{"meta":{"title":"活着就是为了摸鱼🐟！！！","subtitle":"","description":"一个不起眼的小博客","author":"一个小垃圾","url":"http://example.com","root":"/"},"pages":[{"title":"所有标签","date":"2022-06-25T09:44:36.000Z","updated":"2022-06-25T10:10:32.117Z","comments":true,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""},{"title":"archives","date":"2022-06-25T09:46:11.000Z","updated":"2022-06-25T10:00:28.430Z","comments":true,"path":"archives/index.html","permalink":"http://example.com/archives/index.html","excerpt":"","text":""},{"title":"关于我是谁","date":"2022-06-25T09:46:19.000Z","updated":"2022-06-26T00:50:58.784Z","comments":true,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":""},{"title":"所有分类","date":"2022-06-25T09:45:03.000Z","updated":"2022-06-25T10:09:55.599Z","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"(每日LeetCode)1797. 设计一个验证系统","slug":"每日LeetCode/2023-2/1797 设计一个验证系统","date":"2023-02-09T02:09:00.000Z","updated":"2023-02-09T13:05:44.993Z","comments":true,"path":"2023/02/09/每日LeetCode/2023-2/1797 设计一个验证系统/","link":"","permalink":"http://example.com/2023/02/09/%E6%AF%8F%E6%97%A5LeetCode/2023-2/1797%20%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E9%AA%8C%E8%AF%81%E7%B3%BB%E7%BB%9F/","excerpt":"","text":"题目：你需要设计一个包含验证码的验证系统。每一次验证中，用户会收到一个新的验证码，这个验证码在 currentTime 时刻之后 timeToLive 秒过期。如果验证码被更新了，那么它会在 currentTime （可能与之前的 currentTime 不同）时刻延长 timeToLive 秒。 请你实现 AuthenticationManager 类： AuthenticationManager(int timeToLive) 构造 AuthenticationManager 并设置 timeToLive 参数。 generate(string tokenId, int currentTime) 给定 tokenId ，在当前时间 currentTime 生成一个新的验证码。 renew(string tokenId, int currentTime) 将给定 tokenId 且 未过期 的验证码在 currentTime 时刻更新。如果给定 tokenId 对应的验证码不存在或已过期，请你忽略该操作，不会有任何更新操作发生。 countUnexpiredTokens(int currentTime) 请返回在给定 currentTime 时刻，未过期 的验证码数目。如果一个验证码在时刻 t 过期，且另一个操作恰好在时刻 t 发生（renew 或者 countUnexpiredTokens 操作），过期事件 优先于 其他操作。 示例： 输入：[“AuthenticationManager”, “renew”, “generate”, “countUnexpiredTokens”, “generate”, “renew”, “renew”, “countUnexpiredTokens”][[5], [“aaa”, 1], [“aaa”, 2], [6], [“bbb”, 7], [“aaa”, 8], [“bbb”, 10], [15]]输出：[null, null, null, 1, null, null, null, 0] 解释：AuthenticationManager authenticationManager &#x3D; new AuthenticationManager(5); &#x2F;&#x2F; 构造 AuthenticationManager ，设置 timeToLive &#x3D; 5 秒。authenticationManager.renew(“aaa”, 1); &#x2F;&#x2F; 时刻 1 时，没有验证码的 tokenId 为 “aaa” ，没有验证码被更新。authenticationManager.generate(“aaa”, 2); &#x2F;&#x2F; 时刻 2 时，生成一个 tokenId 为 “aaa” 的新验证码。authenticationManager.countUnexpiredTokens(6); &#x2F;&#x2F; 时刻 6 时，只有 tokenId 为 “aaa” 的验证码未过期，所以返回 1 。authenticationManager.generate(“bbb”, 7); &#x2F;&#x2F; 时刻 7 时，生成一个 tokenId 为 “bbb” 的新验证码。authenticationManager.renew(“aaa”, 8); &#x2F;&#x2F; tokenId 为 “aaa” 的验证码在时刻 7 过期，且 8 &gt;&#x3D; 7 ，所以时刻 8 的renew 操作被忽略，没有验证码被更新。authenticationManager.renew(“bbb”, 10); &#x2F;&#x2F; tokenId 为 “bbb” 的验证码在时刻 10 没有过期，所以 renew 操作会执行，该 token 将在时刻 15 过期。authenticationManager.countUnexpiredTokens(15); &#x2F;&#x2F; tokenId 为 “bbb” 的验证码在时刻 15 过期，tokenId 为 “aaa” 的验证码在时刻 7 过期，所有验证码均已过期，所以返回 0 。 代码(cpp)：哈希表12345678910111213141516171819202122232425262728293031class AuthenticationManager &#123;private: //&lt;tokenId, expiryTime&gt; unordered_map&lt;string, int&gt; map; int timeToLive;public: //初始化，设置有效期 AuthenticationManager(int timeToLive) &#123; this-&gt;timeToLive = timeToLive; &#125; //设置token以及过期时间 void generate(string tokenId, int currentTime) &#123; map[tokenId] = currentTime + this-&gt;timeToLive; &#125; //将未过期的token刷新 void renew(string tokenId, int currentTime) &#123; if(map.find(tokenId) != map.end() &amp;&amp; map[tokenId] &gt; currentTime) &#123; map[tokenId] = currentTime + this-&gt;timeToLive; &#125; &#125; //计算当前时间未过期的token数量 int countUnexpiredTokens(int currentTime) &#123; int count = 0; for(auto&amp; [_, expiryTime] : map) &#123; count += expiryTime &gt; currentTime ? 1 : 0; &#125; return count; &#125;&#125;;","categories":[{"name":"每日LeetCode","slug":"每日LeetCode","permalink":"http://example.com/categories/%E6%AF%8F%E6%97%A5LeetCode/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"}]},{"title":"(每日LeetCode)1233. 删除子文件夹","slug":"每日LeetCode/2023-2/1233 删除子文件夹","date":"2023-02-08T04:07:00.000Z","updated":"2023-02-09T13:05:36.192Z","comments":true,"path":"2023/02/08/每日LeetCode/2023-2/1233 删除子文件夹/","link":"","permalink":"http://example.com/2023/02/08/%E6%AF%8F%E6%97%A5LeetCode/2023-2/1233%20%E5%88%A0%E9%99%A4%E5%AD%90%E6%96%87%E4%BB%B6%E5%A4%B9/","excerpt":"","text":"题目：你是一位系统管理员，手里有一份文件夹列表 folder，你的任务是要删除该列表中的所有 子文件夹，并以 任意顺序 返回剩下的文件夹。 如果文件夹 folder[i] 位于另一个文件夹 folder[j] 下，那么 folder[i] 就是 folder[j] 的 子文件夹 。 文件夹的「路径」是由一个或多个按以下格式串联形成的字符串：’&#x2F;‘ 后跟一个或者多个小写英文字母。 例如，”&#x2F;leetcode” 和 “&#x2F;leetcode&#x2F;problems” 都是有效的路径，而空字符串和 “&#x2F;“ 不是。 示例： 输入：folder &#x3D; [“&#x2F;a”,”&#x2F;a&#x2F;b”,”&#x2F;c&#x2F;d”,”&#x2F;c&#x2F;d&#x2F;e”,”&#x2F;c&#x2F;f”]输出：[“&#x2F;a”,”&#x2F;c&#x2F;d”,”&#x2F;c&#x2F;f”]解释：”&#x2F;a&#x2F;b&#x2F;“ 是 “&#x2F;a” 的子文件夹，而 “&#x2F;c&#x2F;d&#x2F;e” 是 “&#x2F;c&#x2F;d” 的子文件夹。 代码(cpp)：1234567891011121314151617181920212223242526272829class Solution &#123;public: vector&lt;string&gt; removeSubfolders(vector&lt;string&gt;&amp; folder) &#123; sort(folder.begin(), folder.end()); vector&lt;string&gt; ans; string temp = &quot; &quot;; for(auto&amp; str : folder) &#123; //获取temp的位置 int pos = str.find(temp); //不在开头或者不存在，说明是一个新的文件夹 if(pos != 0) &#123; temp = str; ans.emplace_back(str); &#125; //判断同级文件夹中是否存在相同的前缀文件 // /a/b和/a/bb else &#123; if(str[temp.size()] != &#x27;/&#x27;) &#123; temp = str; ans.emplace_back(str); &#125; &#125; &#125; return ans; &#125;&#125;; 复杂度分析： 时间复杂度：O(n) 空间复杂度：O(n)","categories":[{"name":"每日LeetCode","slug":"每日LeetCode","permalink":"http://example.com/categories/%E6%AF%8F%E6%97%A5LeetCode/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"}]},{"title":"","slug":"Java/JUC","date":"2023-02-07T02:54:07.540Z","updated":"2023-02-07T07:33:58.260Z","comments":true,"path":"2023/02/07/Java/JUC/","link":"","permalink":"http://example.com/2023/02/07/Java/JUC/","excerpt":"","text":"1.基本概念1.1 进程与线程进程 程序由指令和数据组成，但这些指令要运行，数据要读写，就必须将指令加载至CPU，数据加载至内存。 在指令运行过程中还需要用到磁盘、网络等设备。进程就是用来加载指令、管理内存、管理I&#x2F;O的 当一个程序被运行，从磁盘加载这个程序的代码至内存，这时就开启了一个进程。 进程就可以视为程序的一个实例。大部分程序可以同时运行多个实例进程(例如记事本、画图、浏览器等），也有的程序只能启动一个实例进程（例如网易云音乐、360安全卫士等） 线程 一个进程之内可以分为一到多个线程。 一个线程就是一个指令流，将指令流中的一条条指令以一定的顺序交给CPU执行 Java中，线程作为最小调度单位，进程作为资源分配的最小单位。在windows中进程是不活动的，只是作为线程的容器 1.2 并行与并发并发 单核cpu下，线程实际还是串行执行的。操作系统中有一个组件叫做任务调度器，将cpu的时间片（windows 下时间片最小约为15毫秒）分给不同的线程使用，只是由于cpu在线程间（时间片很短）的切换线程非常快，人类感觉是同时运行的。 总结为一句话就是：微观串行，宏观并行，一般会将这种线程轮流使用cpu的做法称为并发(concurrent) 并行 多核cpu下，每个核(core)都可以调度运行线程，这时候线程可以是并行的。 总的来说， 并发(concurrent)：是一个人同一时间应对多件事情的能力 并行(parallel)：是一群人各自同时做多件事情的能力 1.3 异步与同步从方法调用的角度来讲， 如果需要等待结果返回，才能继续运行就是同步 不需要等待结果返回，就能继续运行就是异步 注意：同步在多线程中还有另外一层意思，是让多个线程步调一致 注意事项： 单核cpu下，多线程不能实际提高程序运行效率，只是为了能够在不同的任务之间切换，不同线程轮流使用cpu，不至于一个线程总占用cpu，别的线程没法干活 多核cpu可以并行跑多个线程，但能否提高程序运行效率还是要分情况的 有些任务，经过精心设计，将任务拆分，并行执行，当然可以提高程序的运行效率。但不是所有计算任务都能拆分 也不是所有任务都需要拆分，任务的目的如果不同，谈拆分和效率没啥意义 I&#x2F;O操作不占用cpu，只是我们一般拷贝文件使用的是阻塞I&#x2F;O，这时相当于线程虽然不用cpu，但需要一直等待I&#x2F;O结束，没能充分利用线程。所以才有后面的非阻塞I&#x2F;O和异步I&#x2F;O优化 2.Java线程2.1 创建线程2.1.1 Thread1234567891011public static void test01() &#123; //创建线程对象，可以添加线程名称也可以不写 Thread thread = new Thread(&quot;t1&quot;) &#123; @Override public void run() &#123; //执行任务 &#125; &#125;; thread.start();&#125; 2.1.2 使用Runnable配合Thread把线程和任务（要执行的代码）分开 Thread：代表线程 Runnable：可运行的任务（线程要执行的代码） 12345678910111213public static void test02() &#123; //创建任务 Runnable runnable = new Runnable() &#123; @Override public void run() &#123; //执行任务 &#125; &#125;; //将任务放入新的线程中 Thread thread = new Thread(runnable); //执行任务 thread.start();&#125; 使用Lambda表达式可以简化： 12345678public static void test03() &#123; //参数1：要执行的任务，参数2：线程名称 Thread thread = new Thread(() -&gt; &#123; //执行任务 &#125;, &quot;t1&quot;); thread.start();&#125; 2.1.3 Runnable与Thread的关系Thread对象中的run()方法： 12345678private Runnable target;@Overridepublic void run() &#123; if (target != null) &#123; target.run(); &#125;&#125; 单独使用Thread： 相当于重写了run()方法， 是把线程和任务合并在了一起 使用Runnable配合Thread： 相当于把Runnable的任务传入target中，调用run()方法会进行判断如果target不为空，则执行任务 是把线程和任务分开了 用Runnable 更容易与线程池等高级API 配合 用Runnable 让任务类脱离了Thread继承体系，更灵活","categories":[],"tags":[]},{"title":"(每日LeetCode)1604. 警告一小时内使用相同员工卡大于等于三次的人","slug":"每日LeetCode/2023-2/1604 警告一小时内使用相同员工卡大于等于三次的人","date":"2023-02-07T02:52:00.000Z","updated":"2023-02-09T13:05:40.633Z","comments":true,"path":"2023/02/07/每日LeetCode/2023-2/1604 警告一小时内使用相同员工卡大于等于三次的人/","link":"","permalink":"http://example.com/2023/02/07/%E6%AF%8F%E6%97%A5LeetCode/2023-2/1604%20%E8%AD%A6%E5%91%8A%E4%B8%80%E5%B0%8F%E6%97%B6%E5%86%85%E4%BD%BF%E7%94%A8%E7%9B%B8%E5%90%8C%E5%91%98%E5%B7%A5%E5%8D%A1%E5%A4%A7%E4%BA%8E%E7%AD%89%E4%BA%8E%E4%B8%89%E6%AC%A1%E7%9A%84%E4%BA%BA/","excerpt":"","text":"题目：力扣公司的员工都使用员工卡来开办公室的门。每当一个员工使用一次他的员工卡，安保系统会记录下员工的名字和使用时间。如果一个员工在一小时时间内使用员工卡的次数大于等于三次，这个系统会自动发布一个 警告 。 给你字符串数组 keyName 和 keyTime ，其中 [keyName[i], keyTime[i]] 对应一个人的名字和他在 某一天 内使用员工卡的时间。 使用时间的格式是 24小时制 ，形如 “HH:MM” ，比方说 “23:51” 和 “09:49” 。 请你返回去重后的收到系统警告的员工名字，将它们按 字典序升序 排序后返回。 请注意 “10:00” - “11:00” 视为一个小时时间范围内，而 “23:51” - “00:10” 不被视为一小时内，因为系统记录的是某一天内的使用情况。 示例： 输入：keyName &#x3D; [“daniel”,”daniel”,”daniel”,”luis”,”luis”,”luis”,”luis”], keyTime &#x3D; [“10:00”,”10:40”,”11:00”,”09:00”,”11:00”,”13:00”,”15:00”]输出：[“daniel”]解释：”daniel” 在一小时内使用了 3 次员工卡（”10:00”，”10:40”，”11:00”）。 代码(cpp)：哈希+排序12345678910111213141516171819202122232425262728293031class Solution &#123;public: vector&lt;string&gt; alertNames(vector&lt;string&gt;&amp; keyName, vector&lt;string&gt;&amp; keyTime) &#123; map&lt;string, vector&lt;int&gt;&gt; map; //遍历，将时间转换为分钟，便于计算以及排序!!! for(int i = 0; i &lt; keyName.size(); i++) &#123; string time = keyTime[i]; int hour = (time[0] -&#x27;0&#x27;)*10 + (time[1] - &#x27;0&#x27;); int minute = (time[3] -&#x27;0&#x27;)*10 + (time[4] - &#x27;0&#x27;); map[keyName[i]].emplace_back(hour*60 + minute); &#125; vector&lt;string&gt; ans; for(auto&amp; [k, v] : map) &#123; sort(v.begin(), v.end()); int left = 0; int right = 2; while(right &lt; v.size()) &#123; if(v[right++] - v[left++] &lt;= 60) &#123; ans.emplace_back(k); break; &#125; &#125; &#125; sort(ans.begin(), ans.end()); return ans; &#125;&#125;; 复杂度分析： 时间复杂度：O(nlogn)，其中 n 是数组 keyName 和 keyTime 的长度 然后判断每个员工是否收到系统警告，需要进行排序和遍历的操作，最坏情况下，排序的时间复杂度是O(nlogn)，遍历的时间复杂度是 O(n)，因此时间复杂度是 O(nlogn)。 空间复杂度：O(n)","categories":[{"name":"每日LeetCode","slug":"每日LeetCode","permalink":"http://example.com/categories/%E6%AF%8F%E6%97%A5LeetCode/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"}]},{"title":"(每日LeetCode)2331. 计算布尔二叉树的值","slug":"每日LeetCode/2023-2/2331 计算布尔二叉树的值","date":"2023-02-06T03:06:00.000Z","updated":"2023-02-09T13:05:56.189Z","comments":true,"path":"2023/02/06/每日LeetCode/2023-2/2331 计算布尔二叉树的值/","link":"","permalink":"http://example.com/2023/02/06/%E6%AF%8F%E6%97%A5LeetCode/2023-2/2331%20%E8%AE%A1%E7%AE%97%E5%B8%83%E5%B0%94%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%80%BC/","excerpt":"","text":"题目：给你一棵 完整二叉树 的根，这棵树有以下特征： 叶子节点 要么值为 0 要么值为 1 ，其中 0 表示 False ，1 表示 True 。非叶子节点 要么值为 2 要么值为 3 ，其中 2 表示逻辑或 OR ，3 表示逻辑与 AND 。计算 一个节点的值方式如下： 如果节点是个叶子节点，那么节点的 值 为它本身，即 True 或者 False 。否则，计算 两个孩子的节点值，然后将该节点的运算符对两个孩子值进行 运算 。返回根节点 root 的布尔运算值。 完整二叉树 是每个节点有 0 个或者 2 个孩子的二叉树。 叶子节点 是没有孩子的节点。 示例： 输入：root &#x3D; [2,1,3,null,null,0,1]输出：true解释：上图展示了计算过程。AND 与运算节点的值为 False AND True &#x3D; False 。OR 运算节点的值为 True OR False &#x3D; True 。根节点的值为 True ，所以我们返回 true 。 代码(cpp)：1234567891011121314151617181920class Solution &#123;public: bool evaluateTree(TreeNode* root) &#123; int choice = root-&gt;val; if(choice == 0 || choice == 1) return choice; bool left = evaluateTree(root-&gt;left); bool right = evaluateTree(root-&gt;right); if(choice == 2) return left || right; if(choice == 3) return left &amp;&amp; right; return false; &#125;&#125;; 复杂度分析： 时间复杂度：O(n)，其中 n 表示树中节点的数目。对于每个节点我们只需遍历一次即可，因此时间复杂度为 O(n)。 空间复杂度：O(n)，其中 n 表示树中节点的数目。按照题目要求，含有 n 个节点的完整二叉树的深度最多为 n&#x2F;2，最少为 O(logn)，因此递归的最大深度为 n&#x2F;2，因此空间复杂度为 O(n)。","categories":[{"name":"每日LeetCode","slug":"每日LeetCode","permalink":"http://example.com/categories/%E6%AF%8F%E6%97%A5LeetCode/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"}]},{"title":"(每日LeetCode)1798. 你能构造出连续值的最大数目","slug":"每日LeetCode/2023-2/1798 你能构造出连续值的最大数目","date":"2023-02-04T00:41:00.000Z","updated":"2023-02-09T13:05:48.833Z","comments":true,"path":"2023/02/04/每日LeetCode/2023-2/1798 你能构造出连续值的最大数目/","link":"","permalink":"http://example.com/2023/02/04/%E6%AF%8F%E6%97%A5LeetCode/2023-2/1798%20%E4%BD%A0%E8%83%BD%E6%9E%84%E9%80%A0%E5%87%BA%E8%BF%9E%E7%BB%AD%E5%80%BC%E7%9A%84%E6%9C%80%E5%A4%A7%E6%95%B0%E7%9B%AE/","excerpt":"","text":"题目： 给你一个长度为 n 的整数数组 coins ，它代表你拥有的 n 个硬币。第 i 个硬币的值为 coins[i] 。如果你从这些硬币中选出一部分硬币，它们的和为 x ，那么称，你可以 构造 出 x 。 请返回从 0 开始（包括 0 ），你最多能 构造 出多少个连续整数。 你可能有多个相同值的硬币。 示例： 输入：coins &#x3D; [1,1,1,4]输出：8解释：你可以得到以下这些值： 0：什么都不取 [] 1：取 [1] 2：取 [1,1] 3：取 [1,1,1] 4：取 [4] 5：取 [4,1] 6：取 [4,1,1] 7：取 [4,1,1,1] 从 0 开始，你可以构造出 8 个连续整数。 思路： 大佬的思路~~ 有序是一个强大的性质，如果对数组排序不影响答案的话，可以尝试将数组排序后，再重新思考，看看能否发现新的思路。 代码(cpp)： 123456789101112131415class Solution &#123;public: int getMaximumConsecutive(vector&lt;int&gt;&amp; coins) &#123; sort(coins.begin(), coins.end()); int ans = 1; for(auto&amp; coin :coins) &#123; if (coin &gt; ans) break; ans += coin; &#125; return ans; &#125;&#125;; 复杂度分析： 时间复杂度：O(nlogn) 空间复杂度：O(1)","categories":[{"name":"每日LeetCode","slug":"每日LeetCode","permalink":"http://example.com/categories/%E6%AF%8F%E6%97%A5LeetCode/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"}]},{"title":"Java8的学习笔记","slug":"Java/Java8","date":"2023-02-04T00:36:43.704Z","updated":"2023-02-06T13:49:21.010Z","comments":true,"path":"2023/02/04/Java/Java8/","link":"","permalink":"http://example.com/2023/02/04/Java/Java8/","excerpt":"","text":"1.Lambda表达式1.1 体验Lambda表达式12345678910111213public static void main(String[] args) &#123; new Thread(new Runnable() &#123; @Override public void run() &#123; System.out.println(&quot;新线程开始执行&quot;); &#125; &#125;).start(); //体验Lambda表达式 new Thread(() -&gt; &#123; System.out.println(&quot;Lambda表达式开始执行&quot;); &#125;).start();&#125; Lambda表达式优点：简化匿名内部类，使代码更加精简 1.2 Lambda的标准格式123(参数类型 参数名) -&gt; &#123; 代码体;&#125; 格式说明： (参数类型 参数名)：参数列表 代码体;：方法体 -&gt;：分隔参数列表和方法体 Lambda只能有且仅有一个抽象方法的接口，不然会报错，不支持多个抽象方法的接口 1.3 Lambda的使用创建接口： 123public interface Person &#123; String eat(String food);&#125; 执行： 12345678910111213public class Test02 &#123; public static void main(String[] args) &#123; toEat((String food) -&gt; &#123; System.out.println(&quot;开始吃&quot; + food); return &quot;吃了&quot; + food; &#125;); &#125; public static void toEat(Person person) &#123; String result = person.eat(&quot;西瓜&quot;); System.out.println(&quot;result = &quot; + result); &#125;&#125; 结果： 开始吃西瓜result &#x3D; 吃了西瓜 执行排序以及遍历： 1234567891011121314151617181920212223242526272829public static void main(String[] args) &#123; List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); list.add(2); list.add(5); list.add(1); list.add(3); /*list.sort(new Comparator&lt;Integer&gt;() &#123; @Override public int compare(Integer o1, Integer o2) &#123; return o1 - o2; &#125; &#125;); list.forEach(new Consumer&lt;Integer&gt;() &#123; @Override public void accept(Integer integer) &#123; System.out.println(&quot;integer = &quot; + integer); &#125; &#125;);*/ list.sort((Integer a, Integer b) -&gt; &#123; return a - b; &#125;); list.forEach((Integer val) -&gt; &#123; System.out.println(&quot;val = &quot; + val); &#125;);&#125; 结果： val &#x3D; 1val &#x3D; 2val &#x3D; 3val &#x3D; 5 1.4 Lambda的实现原理创建接口： 123public interface Car &#123; void driver();&#125; 使用匿名内部类： 1234567891011121314public class Test04 &#123; public static void main(String[] args) &#123; driver(new Car() &#123; @Override public void driver() &#123; System.out.println(&quot;汽车开始行驶&quot;); &#125; &#125;); &#125; public static void driver(Car car) &#123; car.driver(); &#125;&#125; 原理：匿名内部类在编译后会形成一个新的类带有$，实现Car接口的抽象方法 改为使用Lambda表达式： 1234567891011public class Test04 &#123; public static void main(String[] args) &#123; driver(() -&gt; &#123; System.out.println(&quot;汽车开始行驶&quot;); &#125;); &#125; public static void driver(Car car) &#123; car.driver(); &#125;&#125; 原理： Lambda表达式会在类中生成一个私有静态方法 还会形成一个匿名内部类，实现接口的抽象方法 会在接口的抽象方法里调用Lambda表达式的私有静态方法 1.5 Lambda的省略格式123(int a) -&gt; &#123; return new Object();&#125; 在Lambda标准格式的基础上，使用省路写法的规则为： 小括号内参数的类型可以省略 123(a) -&gt; &#123; return new Object();&#125; 如果小括号内有且仅有一个参数，则小括号可以省略 123a -&gt; &#123; return new Object();&#125; 如果大括号内有且仅有一个语句，可以同时省略大括号、return关键字及语句分号 1a -&gt; new Object() 练习： 1234567891011public static void main(String[] args) &#123; List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); list.add(2); list.add(5); list.add(1); list.add(3); list.sort((a, b) -&gt; a - b); list.forEach(val -&gt; System.out.println(&quot;val = &quot; + val));&#125; 1.6 Lambda的使用前提Lambda的语法非常简洁，但是Lambda表达式不是随便使用的，使用时有几个条件要特别注意： 方法的参数或局部变量类型必须为接口才能使用Lambda 接口中有且仅有一个抽象方法 只有一个抽象方法的接口称为函数式接口，我们就能使用Lambda 123456@FunctionalInterface //检测这个接口是不是只有一个抽象方法,即函数式接口interface Flyable &#123; //接口中有且仅有一任抽象方法 public abstract void eat(); //public abstract void eat1(); // 报错&#125; 2.接口2.1 接口的默认方法与静态方法JDK 8以前的接口： 1234interface 接口名 &#123; 静态常量; 抽象方法;&#125; JDK 8对接口的增强，接口还可以有默认方法和静态方法： 123456interface 接口名 &#123; 静态常量; 抽象方法; 默认方法; 静态方法;&#125; 默认方法的定义： 12345interface 接口名 &#123; default 返回值类型 方法名([参数类型 参数]) &#123; 代码; &#125;&#125; 练习： 123456789interface A &#123; default void test() &#123; System.out.println(&quot;我是默认方法&quot;); &#125;&#125;class B implements A &#123; //可重写默认方法&#125; 注意：接口中的默认方法实现类不必重写，可以直接使用，实现类也可以根据需要重写。这样就方便接口的扩展。 静态方法的定义： 12345interface 接口名 &#123; default 返回值类型 方法名([参数类型 参数]) &#123; 代码; &#125;&#125; 练习： 12345678910111213141516171819interface A &#123; static void test() &#123; System.out.println(&quot;我是静态方法&quot;); &#125;&#125;class B implements A &#123; //不可重写静态方法&#125;public class Test01 &#123; public static void main(String[] args) &#123; A.test(); A a = new B(); //a.test(); //报错 //B.test(); //报错 &#125;&#125; 注意：静态方法不能被重写，只有由接口名调用 默认方法与静态方法的区别： 默认方法通过实例调用，静态方法通过接口名调用。 默认方法可以被继承，实现类可以直接使用接口默认方法，也可以重写接口默认方法。 静态方法不能被继承，实现类不能重写接口静态方法，只能使用接口名调用。 2.2 常用内置函数式接口我们知道使用Lambda表达式的前提是需要有函数式接口。 而Lambda使用时不关心接口名，抽象方法名，只关心抽象方法的参数列表和返回值类型。 因此为了让我们便用Lambda方使，JDK提供了大量常用的函数式接口。 它们主要在java.util.function包中。下面是最常用的几个接口： Supplier接口 Consumer接口 Function接口 Predicate接口 2.2.1 Supplier接口1234@FunctionalInterfacepublic interface Supplier&lt;T&gt; &#123; public abstract T get();&#125; 使用Lambda表达式返回数组元素最大值： 123456789101112131415public class Test02 &#123; public static void main(String[] args) &#123; Integer integer = getMax(() -&gt; &#123; int[] arr = &#123;2, 3, 4, 1&#125;; Arrays.sort(arr); return arr[arr.length - 1]; &#125;); System.out.println(&quot;integer = &quot; + integer); &#125; public static &lt;T&gt; T getMax(Supplier&lt;T&gt; supplier) &#123; return supplier.get(); &#125;&#125; 2.2.2 Consumer接口1234@FunctionalInterfacepublic interface Consumer&lt;T&gt; &#123; public abstract void accept(T t);&#125; 使用Lambda表达式将一个字符串的大写转换成小写： 123456789public class Test03 &#123; public static void main(String[] args) &#123; change(&quot;AAA&quot;, str -&gt; System.out.println(str.toLowerCase())); &#125; public static void change(String str, Consumer&lt;String&gt; consumer) &#123; consumer.accept(str); &#125;&#125; andThen()方法： 使用Lambda表达式将一个字符串的大写转换成小写，再将字符串的小写转换成大写： 123456789101112131415public class Test03 &#123; public static void main(String[] args) &#123; printToLower(&quot;AAA&quot;, str -&gt; System.out.println(str.toLowerCase()), str -&gt; System.out.println(str.toUpperCase())); &#125; public static void printToLower( String str, Consumer&lt;String&gt; c1, Consumer&lt;String&gt; c2) &#123; //先执行c1再执行c2 c1.andThen(c2).accept(str); &#125;&#125; 2.2.3 Function接口1234@FunctionalInterfacepublic interface Function&lt;T,R&gt; &#123; public abstract R apply(T t);&#125; 使用Lambda表达式将字符串转成数字： 1234567891011public class Test04 &#123; public static void main(String[] args) &#123; Integer integer = str2Int(&quot;11&quot;, str -&gt; Integer.parseInt(str)); System.out.println(&quot;integer = &quot; + integer); &#125; public static Integer str2Int(String str, Function&lt;String, Integer&gt; function) &#123; return function.apply(str); &#125;&#125; andThen()方法： 使用Lambda表达式将字符串转成数字，第二个操作将这个数字乘以5： 1234567891011public class Test05 &#123; public static void main(String[] args) &#123; boolean isLong = isLongName(&quot;迪丽热巴&quot;, str -&gt; str.length() &gt; 3 ); System.out.println(&quot;isLong = &quot; + isLong); &#125; public static boolean isLongName(String name, Predicate&lt;String&gt; predicate) &#123; return predicate.test(name); &#125;&#125; 2.2.4 Predicate接口1234@FunctionalInterfacepublic interface Predicate&lt;T&gt; &#123; boolean test(T t);&#125; 使用Lambda判断一个人名如果超过3个字就认为是很长的名字： 12345678910111213public class Test05 &#123; public static void main(String[] args) &#123; boolean isLong = isLongName(&quot;迪丽热巴&quot;, str -&gt; &#123; return str.length() &gt; 3; &#125;); System.out.println(&quot;isLong = &quot; + isLong); &#125; public static boolean isLongName(String name, Predicate&lt;String&gt; predicate) &#123; return predicate.test(name); &#125;&#125; and()方法： 使用Lambda表达式判断一个字特串中即包含’W’,也包含’H’： 12345678910111213141516public class Test05 &#123; public static void main(String[] args) &#123; boolean isContain = isContainsHAndW(&quot;Hello World&quot;, str -&gt; str.contains(&quot;H&quot;), str -&gt; str.contains(&quot;W&quot;)); System.out.println(&quot;isContain = &quot; + isContain); &#125; public static boolean isContainsHAndW( String str, Predicate&lt;String&gt; p1, Predicate&lt;String&gt; p2) &#123; return p1.and(p2).test(str); &#125;&#125; and()方法，相当于”&amp;”；还有一个or()方法，相当于”|” 3.引用3.1 方法引用使用Lambda表达式求一个数组的和： 1234567891011121314151617181920212223242526public class Test01 &#123; public static void main(String[] args) &#123; List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); list.add(2); list.add(5); list.add(1); list.add(3); Integer result = getSum(list, nums -&gt; &#123; Integer sum = 0; for (Integer num : nums) &#123; sum += num; &#125; return sum; &#125;); System.out.println(&quot;result = &quot; + result); &#125; public static Integer getSum( List&lt;Integer&gt; list, Function&lt;List&lt;Integer&gt;, Integer&gt; function) &#123; return function.apply(list); &#125;&#125; 方法引用的格式： 符号表示：:: 符号说明：双雪号为方法号引用运算符，而它所在的表达式被称为方法引用。 应用场景：如果Lambda所要实现的方案，已经有其他方法存在相同方案，那么则可以使用方法引用。 改用方法引用： 12345678910111213141516171819202122232425262728public class Test01 &#123; public static void main(String[] args) &#123; List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); list.add(2); list.add(5); list.add(1); list.add(3); //方法引用 Integer result = getSum(list, Test01::getSum); System.out.println(&quot;result = &quot; + result); &#125; public static Integer getSum(List&lt;Integer&gt; list) &#123; Integer sum = 0; for (Integer integer : list) &#123; sum += integer; &#125; return sum; &#125; public static Integer getSum( List&lt;Integer&gt; list, Function&lt;List&lt;Integer&gt;, Integer&gt; function) &#123; return function.apply(list); &#125;&#125; 让这个指定的方法去重写接口的抽象方法，到时候调用接口的抽象方法就是调用传递过去的这个方法 常见引用方式： 方法引用在JDK 8中用方式相当活，有以下几种形式： instanceName::methodName：对象::方法名 ClassName::saticName：类名::静态方法 ClassName::methodName：类名::普通方法 Class::new：类名::new 调用的构造器 TypeName[]::new：String[]::new 调用数组的构造器 4.Stream流Stream流式思想类似于工厂车间的生产流水线，Stream流不是一种数据结构，不保存数据，而是对数据进行加工处理。 Stream可以看作是流水线上的一个工序。在流水线上，通过多个工序让一个原材料加工成一个商品。 Stream API能让我们快速完成许多复杂的操作，如筛选、切片、映射、查找、去除重复、统计、匹配和归约. 基本使用： 拿到所有姓张的 拿到名字长度为3个字的 打印这些数据 1234567891011public class Test01 &#123; public static void main(String[] args) &#123; List&lt;String&gt; list = new ArrayList&lt;&gt;(); Collections.addAll(list, &quot;张无忌&quot;, &quot;周芷若&quot;, &quot;赵敏&quot;, &quot;张强&quot;, &quot;张三丰&quot;); list.stream() .filter(name -&gt; name.startsWith(&quot;张&quot;)) .filter(name -&gt; name.length() == 3) .forEach(name -&gt; System.out.println(&quot;name = &quot; + name)); &#125;&#125; 4.1 获取Stream流的两种方式 根据Collection获取流： 12345678910111213141516public static void main(String[] args) &#123; List&lt;String&gt; list = new ArrayList&lt;&gt;(); Stream&lt;String&gt; streamList = list.stream(); Set&lt;String&gt; set = new HashSet&lt;&gt;(); Stream&lt;String&gt; streamSet = set.stream(); //Map无法直接使用stream() Map&lt;String, String&gt; map = new HashMap&lt;&gt;(); //Map转换成Set&lt;Entry&lt;String, String&gt;&gt; Stream&lt;Map.Entry&lt;String, String&gt;&gt; streamMap1 = map.entrySet().stream(); //Map转换成Set&lt;String&gt; Stream&lt;String&gt; streamMap2 = map.keySet().stream(); //Map转换成Collection&lt;String&gt; Stream&lt;String&gt; streamMap3 = map.values().stream();&#125; Stream中的静态方法of()获取流： 1234567891011public static void main(String[] args) &#123; Stream&lt;String&gt; stream = Stream.of(&quot;aa&quot;, &quot;bb&quot;, &quot;cc&quot;); Integer[] arr = &#123;1, 3, 2&#125;; Stream&lt;Integer&gt; streamArr = Stream.of(arr); ///基本数据类型的数组不可以，会将整个数组看做一个元素进行操作 /*int[] arr = &#123;1, 3, 2&#125;; Stream&lt;int[]&gt; streamArr = Stream.of(arr);*/&#125; 4.2 Stream的常用方法Stream流模型的操作很丰富，这里介绍一些常用的API。这些方法可以被分成两种： 方法名 作用 种类 long count() 统计个数 终结 void forEach() 逐个处理 终结 Stream fiter() 过滤 函数拼接 Stream limit() 取用前几个 函数拼接 Stream skip() 跳过前几个 函数拼接 Stream map() 映射 函数拼接 Stream concat() 组合 函数拼接 终结方法：返回值类型不再是Stream类型的方法，不再支持销式调用。本小节中，终结方法包括count和forEach方法。 非终结方法：返回值送型仍然是Stream送型的方法，支持链式调用。（除了终结方法外，其余方法均为非终结方法 注意： Stream只能操作一次 Stream方法返回的是新的流 Stream不调用终结方法，中间的操作不会执行 4.2.1 forEach方法遍历元素并打印： 12345678public static void forEach() &#123; List&lt;String&gt; list = new ArrayList&lt;&gt;(); Collections.addAll(list, &quot;迪丽热巴&quot;, &quot;宋远桥&quot;, &quot;苏星河&quot;,&quot;老子&quot;,&quot;庄子&quot;,&quot;孙子&quot;); //Lambda表达式 list.stream().forEach(str -&gt; System.out.println(str)); //方法引用 list.stream().forEach(System.out::println);&#125; 4.2.2 count方法计算元素个数： 1234567public static void count() &#123; List&lt;String&gt; list = new ArrayList&lt;&gt;(); Collections.addAll(list, &quot;迪丽热巴&quot;, &quot;宋远桥&quot;, &quot;苏星河&quot;,&quot;老子&quot;,&quot;庄子&quot;,&quot;孙子&quot;); long count = list.stream().count(); System.out.println(&quot;count = &quot; + count);&#125; 4.2.3 filter方法获取名字为3个字的人名： 12345678public static void filter() &#123; List&lt;String&gt; list = new ArrayList&lt;&gt;(); Collections.addAll(list, &quot;迪丽热巴&quot;, &quot;宋远桥&quot;, &quot;苏星河&quot;,&quot;老子&quot;,&quot;庄子&quot;,&quot;孙子&quot;); list.stream() .filter(name -&gt; name.length() == 3) .forEach(System.out::println);&#125; 4.2.4 limit方法截取前三个人： 12345678public static void limit() &#123; List&lt;String&gt; list = new ArrayList&lt;&gt;(); Collections.addAll(list, &quot;迪丽热巴&quot;, &quot;宋远桥&quot;, &quot;苏星河&quot;,&quot;老子&quot;,&quot;庄子&quot;,&quot;孙子&quot;); list.stream() .limit(3) .forEach(System.out::println);&#125; 4.2.5 skip方法跳过前三个人： 12345678public static void skip() &#123; List&lt;String&gt; list = new ArrayList&lt;&gt;(); Collections.addAll(list, &quot;迪丽热巴&quot;, &quot;宋远桥&quot;, &quot;苏星河&quot;,&quot;老子&quot;,&quot;庄子&quot;,&quot;孙子&quot;); list.stream() .skip(3) .forEach(System.out::println);&#125; 4.2.6 map方法String类型转换成Integer类型： 12345678public static void map() &#123; //初始化String类型的Stream Stream&lt;String&gt; stringStream = Stream.of(&quot;11&quot;,&quot;22&quot;,&quot;33&quot;); //转换成Integer类型，将元素+10的结果打印 stringStream .map(Integer::parseInt) .forEach(s -&gt; System.out.println(s+10));&#125; 4.2.7 sorted方法按照降序排列： 12345678public static void sorted() &#123; Stream&lt;Integer&gt; stream = Stream.of(33,22,11,55); //默认按照升序排列 //stream.sorted().forEach(System.out::println); //按照降序排列 stream.sorted((a, b) -&gt; b-a) .forEach(System.out::println);&#125; 4.2.8 distinct方法去除重复元素： 123456public static void distinct() &#123; Stream&lt;Integer&gt; stream = Stream.of(33, 22, 11, 55, 22, 33, 55); stream.distinct() .forEach(System.out::println);&#125; 实现自定义对象去重： 需要重写Person类的equals()方法和hashCode()方法： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public class Person &#123; private String name; private Integer age; public Person() &#123; &#125; public Person(String name, Integer age) &#123; this.name = name; this.age = age; &#125; @Override public boolean equals(Object o) &#123; if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; Person person = (Person) o; return Objects.equals(name, person.name) &amp;&amp; Objects.equals(age, person.age); &#125; @Override public int hashCode() &#123; return Objects.hash(name, age); &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public Integer getAge() &#123; return age; &#125; public void setAge(Integer age) &#123; this.age = age; &#125; @Override public String toString() &#123; return &quot;Person&#123;&quot; + &quot;name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &quot;, age=&quot; + age + &#x27;&#125;&#x27;; &#125;&#125; 自定义对象去重： 12345678910public static void distinct() &#123; Stream&lt;Person&gt; stream = Stream.of( new Person(&quot;大黄&quot;, 20), new Person(&quot;大黄&quot;, 20), new Person(&quot;大黑&quot;, 18), new Person(&quot;大黑&quot;, 18)); stream.distinct() .forEach(System.out::println);&#125; 4.2.9 match方法集合中的元素的匹配条件： 123456789public static void match() &#123; Stream&lt;Integer&gt; stream = Stream.of(5, 3, 6, 1); //boolean result = stream.allMatch(e -&gt; e &gt; 0);//allMatch:元素是否全部满足条件 //boolean result = stream.anyMatch(e -&gt; e &gt; 5);//anyMatch:元表是否任意有一个满足条件 boolean result = stream.noneMatch(e -&gt; e &lt; 0);//noneMatch:是否全部不满足条件 System.out.println(&quot;result = &quot; + result);&#125; 4.2.10 find方法寻找集合中的第一个元素： 1234567public static void find() &#123; Stream&lt;Integer&gt; stream = Stream.of(33,11,22,5); Optional&lt;Integer&gt; first = stream.findFirst(); //Optional&lt;Integer&gt; first = stream.findAny(); //与findFirst()相同 System.out.println(&quot;first.get() = &quot; + first.get());&#125; 4.2.11 max和min方法分别获取最大值、最小值： 123456789public static void minAndMax() &#123; //按照某种排序(升序或者降序)后，获取集合最后一个元素 Optional&lt;Integer&gt; max = Stream.of(5,3,6,1).max((o1, o2) -&gt; o1 - o2); System.out.println(&quot;max.get() = &quot; + max.get()); //按照某种排序(升序或者降序)后，获取集合第一个元素 Optional&lt;Integer&gt; min = Stream.of(5,3,6,1).min((o1, o2) -&gt; o1 - o2); System.out.println(&quot;min.get() = &quot; + min.get());&#125; 4.2.12 reduce方法获取集合的总和： 12345678910public static void reduce() &#123; Stream&lt;Integer&gt; stream = Stream.of(4, 5, 3, 9); //Lambda表达式 //Integer reduce = stream.reduce(0, (sum, num) -&gt; sum + num); //方法引用 Integer reduce = stream.reduce(0, Integer::sum); System.out.println(&quot;reduce = &quot; + reduce);&#125; 4.2.13 map和reduce组合使用求年龄总和： 1234567891011121314public static void reduceAndMap() &#123; Stream&lt;Person&gt; stream = Stream.of( new Person(&quot;刘德许&quot;, 58), new Person(&quot;张学友&quot;, 56), new Person(&quot;郭富城&quot;, 54), new Person(&quot;黎明&quot;, 52)); Integer reduce = stream //.map(person -&gt; person.getAge()) //Lambda表达式 .map(Person::getAge) //方法引用 .reduce(0, Integer::sum); System.out.println(&quot;reduce = &quot; + reduce);&#125; 4.2.14 mapTolnt方法如果需要将Stream&lt;Integer&gt;中的Integer类型数据转成int类型，可以使用mapToInt方法： 12345678910public static void map2Int() &#123; Stream&lt;Integer&gt; stream = Stream.of(4, 5, 3, 9); //转换成基本类型int //IntStream intStream = stream.mapToInt(a -&gt; a.intValue()); //Lambda表达式 IntStream intStream = stream.mapToInt(Integer::intValue); //方法引用 //遍历打印 intStream.forEach(System.out::println);&#125; 4.2.15 concat方法如果有两个流，希望合并成为一个流，那么可以使用Stream接口的静态方法concat： 12345678public static void concat() &#123; Stream&lt;String&gt; stream1 = Stream.of(&quot;大黄&quot;); Stream&lt;String&gt; stream2 = Stream.of(&quot;大黑&quot;); Stream&lt;String&gt; concat = Stream.concat(stream1, stream2); concat.forEach(System.out::println);&#125; 4.2.16 综合案例 第一个队伍只要名字为3个字的成员姓名； 第一个队伍筛选之后只要前3个人； 第二个队伍只要姓张的成员姓名； 第二个队伍筛选之后不要前2个人； 将两个队伍合并为一个队伍； 根据姓名创建Person对象； 打印整个队伍的Person对象信息。 1234567891011121314151617181920public static void main(String[] args) &#123; //第一个队伍 List&lt;String&gt; list1 = new ArrayList&lt;&gt;(7); Collections.addAll(list1, &quot;迪丽热巴&quot;, &quot;宋远桥&quot;, &quot;苏星河&quot;, &quot;老子&quot;, &quot;庄子&quot;, &quot;孙子&quot;, &quot;洪七公&quot;); //第二个队伍 List&lt;String&gt; list2 = new ArrayList&lt;&gt;(7); Collections.addAll(list2, &quot;古力娜扎&quot;, &quot;张无忌&quot;, &quot;张三丰&quot;, &quot;赵丽颗&quot;, &quot;张二狗&quot;, &quot;张天爱&quot;, &quot;张三&quot;); Stream&lt;String&gt; stream1 = list1.stream() .filter(name -&gt; name.length() == 3) .limit(3); Stream&lt;String&gt; stream2 = list2.stream() .filter(name -&gt; name.contains(&quot;张&quot;)) .skip(2); Stream.concat(stream1, stream2) .map(name -&gt; new Person(name, 18)) .forEach(System.out::println);&#125; 4.3 collect方法4.3.1 保存到集合中123456789101112131415161718public static void save2Collection() &#123; Stream&lt;String&gt; stream1 = Stream.of(&quot;aa&quot;, &quot;bb&quot;, &quot;cc&quot;); List&lt;String&gt; list = stream1.collect(Collectors.toList()); Stream&lt;String&gt; stream2 = Stream.of(&quot;aa&quot;, &quot;bb&quot;, &quot;cc&quot;); Set&lt;String&gt; set = stream2.collect(Collectors.toSet()); Stream&lt;String&gt; stream3 = Stream.of(&quot;aa&quot;, &quot;bb&quot;, &quot;cc&quot;); //收集到指定集合ArrayList中 ArrayList&lt;String&gt; collect = stream3 .collect(Collectors.toCollection(ArrayList::new)); Stream&lt;String&gt; stream4 = Stream.of(&quot;aa&quot;, &quot;bb&quot;, &quot;cc&quot;, &quot;aa&quot;, &quot;bb&quot;, &quot;cc&quot;); //收集到指定集合hashSet中，并且会去除重复元素 HashSet&lt;String&gt; hashSet = stream4 .collect(Collectors.toCollection(HashSet::new));&#125; 4.3.2 保存到数组中12345678public static void save2Array() &#123; Stream&lt;String&gt; stream = Stream.of(&quot;aa&quot;, &quot;bb&quot;, &quot;cc&quot;); //需要手动转换到相应的数据类型 //String[] array = (String[]) stream.toArray(); String[] array = stream.toArray(String[]::new);&#125; 4.3.2 聚合计算123456789101112131415161718192021222324252627282930public static void main(String[] args) &#123; Stream&lt;Student&gt; stream = Stream.of( new Student(&quot;大黄&quot;, 20, 88), new Student(&quot;大黑&quot;, 18, 90), new Student(&quot;大白&quot;, 22, 75), new Student(&quot;大红&quot;, 25, 78) ); //获取最大得分 /*Optional&lt;Student&gt; max = stream .collect(Collectors.maxBy((s1, s2) -&gt; s1.getScore() - s2.getScore())); System.out.println(&quot;max.get() = &quot; + max.get());*/ //获取最小得分 /*Optional&lt;Student&gt; min = stream .collect(Collectors.minBy((s1, s2) -&gt; s1.getScore() - s2.getScore())); System.out.println(&quot;min.get() = &quot; + min.get());*/ //得分总和 /*Integer sum = stream.collect(Collectors.summingInt(Student::getScore)); System.out.println(&quot;sum = &quot; + sum);*/ //得分平均 /*Double avg = stream.collect(Collectors.averagingInt(Student::getScore)); System.out.println(&quot;avg = &quot; + avg);*/ //统计数量 Long count = stream.collect(Collectors.counting()); System.out.println(&quot;count = &quot; + count);&#125; 4.3.3 分组通过年龄分组： 123456789101112public static void main(String[] args) &#123; Stream&lt;Student&gt; stream = Stream.of( new Student(&quot;大黄&quot;, 20, 88), new Student(&quot;大黑&quot;, 18, 90), new Student(&quot;大白&quot;, 20, 75), new Student(&quot;大红&quot;, 18, 78) ); //通过年龄分组 Map&lt;Integer, List&lt;Student&gt;&gt; groupByAge = stream.collect(Collectors.groupingBy(Student::getAge)); groupByAge.forEach((age, studentList) -&gt; System.out.println(age + &quot; = &quot; + studentList));&#125; 4.3.4 多级分组先通过年龄分组，之后再通过得分分组： 123456789101112131415161718192021public static void main(String[] args) &#123; Stream&lt;Student&gt; stream = Stream.of( new Student(&quot;大黄&quot;, 20, 88), new Student(&quot;大黑&quot;, 18, 55), new Student(&quot;大白&quot;, 20, 59), new Student(&quot;大红&quot;, 18, 40) ); //先通过年龄分组，之后再通过得分分组 Map&lt;Integer, Map&lt;String, List&lt;Student&gt;&gt;&gt; map = stream .collect(Collectors.groupingBy( Student::getAge, Collectors.groupingBy((student) -&gt; student.getScore() &gt;= 60 ? &quot;及格&quot; : &quot;不及格&quot; ))); map.forEach((age, groupByScore) -&gt; &#123; groupByScore.forEach((isPass, studentList) -&gt; System.out.println(age + &quot; : &quot; + isPass + &quot; : &quot; + studentList)); &#125;);&#125; 4.3.5 分区通过Student是否及格，分区： 1234567891011121314public static void main(String[] args) &#123; Stream&lt;Student&gt; stream = Stream.of( new Student(&quot;大黄&quot;, 20, 88), new Student(&quot;大黑&quot;, 18, 55), new Student(&quot;大白&quot;, 20, 59), new Student(&quot;大红&quot;, 18, 40) ); Map&lt;Boolean, List&lt;Student&gt;&gt; collect = stream.collect(Collectors .partitioningBy(student -&gt; student.getScore() &gt;= 60)); collect.forEach((bool, studentList) -&gt; System.out.println(bool + &quot; = &quot; + studentList));&#125; 4.3.6 拼接通过,将Student的名字拼接： 1234567891011121314public static void main(String[] args) &#123; Stream&lt;Student&gt; stream = Stream.of( new Student(&quot;大黄&quot;, 20, 88), new Student(&quot;大黑&quot;, 18, 55), new Student(&quot;大白&quot;, 20, 59), new Student(&quot;大红&quot;, 18, 40) ); String join = stream .map(Student::getName) .collect(Collectors.joining(&quot;,&quot;)); System.out.println(&quot;join = &quot; + join);&#125; 增加前缀 start:和后缀 :end： 1234567891011121314public static void main(String[] args) &#123; Stream&lt;Student&gt; stream = Stream.of( new Student(&quot;大黄&quot;, 20, 88), new Student(&quot;大黑&quot;, 18, 55), new Student(&quot;大白&quot;, 20, 59), new Student(&quot;大红&quot;, 18, 40) ); String join = stream .map(Student::getName) .collect(Collectors.joining(&quot;,&quot;, &quot;start:&quot;, &quot;:end&quot;)); System.out.println(&quot;join = &quot; + join);&#125; 4.4 并行的Stream流4.4.1 获取并行Stream流集合转为并行Stream流： 123456789public static void main(String[] args) &#123; List&lt;String&gt; list1 = new ArrayList&lt;&gt;(); //方式一: Stream&lt;String&gt; stringStream = list1.parallelStream(); List&lt;String&gt; list2 = new ArrayList&lt;&gt;(); //方式二: Stream&lt;String&gt; parallel = list2.stream().parallel();&#125; 并行Stream测试： 123456public static void main(String[] args) &#123; Stream&lt;Integer&gt; stream = Stream.of(5, 1, 3, 4, 2); stream.parallel().forEach(num -&gt; System.out.println(Thread.currentThread() + &quot; num = &quot; + num));&#125; 串行Stream是单线程，效率没有多线程的并行Stream高 Stream并行处理的过程会分而治之，也就是将一个大任务切分成多个小任务，这表示每个任务都是一个操作 4.4.2 并行Stream线程安全问题ArrayList集合是线程不安全的， 在并行Stream中，对ArrayList的操作加同步锁： 1234567891011121314public static void arrayList() &#123; List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); Object o = new Object(); IntStream.rangeClosed(1,1000) //生成1~1000的流 .parallel().forEach(num -&gt; &#123; synchronized (o) &#123; list.add(num); &#125; &#125;); System.out.println(&quot;list.size() = &quot; + list.size());&#125; 使用线程安全的Vector集合： 12345678public static void vector() &#123; List&lt;Integer&gt; vector = new Vector&lt;&gt;(); IntStream.rangeClosed(1,1000) //生成1~1000的流 .parallel().forEach(vector::add); System.out.println(&quot;vector.size() = &quot; + vector.size());&#125; 使用synchronizedList，构造一个线程安全的 List 对象： 12345678910public static void synchronizedList() &#123; List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); List&lt;Integer&gt; synchronizedList = Collections.synchronizedList(list); IntStream.rangeClosed(1,1000) //生成1~1000的流 .parallel().forEach(synchronizedList::add); System.out.println(&quot;synchronizedList.size() = &quot; + synchronizedList.size());&#125; 使用collect方法： 12345678public static void collect() &#123; List&lt;Integer&gt; list = IntStream.rangeClosed(1, 1000) .parallel() //并行Stream .boxed() //将基本类型转为包装类 .collect(Collectors.toList()); //基本类型无法放入list中 System.out.println(&quot;list.size() = &quot; + list.size());&#125; 4.4.3 并行Stream的原理parallelStream使用的是Fork&#x2F;Join框架，Fork&#x2F;Join框架自JDK1.7引入，Fork&#x2F;Join框架可以将一个大任务所分为很多小任到来异步执行。 主要包含三个模块： 线程池：ForkJoinPool 任务对象：ForkJoinTask 执行任务的线程：ForkJoinWorkerThread Fork&#x2F;Join框架原理： 分治法： 分而治之，将大任务分为多个小任务，小任务又分为更小的任务，直到符合某种条件后停止。再将多个小结果分别结合成大结果，最后汇聚成总结果 工作窃取算法： Fork&#x2F;Join最核心的地方就是利用了现代硬件设备多核，在一个操作时候会有空闲的cpu,那么如何利用好这个空闲的cpu就成了提高性能的关键，工作窃取(work-stealing)算法就是整Fork&#x2F;Join框架的核心理念 Fork&#x2F;Join工作窃取(work-stealing)算法是指某个线程从其他队列里窃取任务来执行， 5.Optional类Optional是一个没有子类的工具类，Optional是一个可以为null的容器对象 它的作用主要就是为了解决避免Null检查，防止NullPointerException 5.1 Optional的基本用法 方法 效果 Optional of( T value ) 只能传入值，不能传入null 静态方法 Optional ofNullable( T value ) 既可以传入值，又可以传入null 静态方法 Optional empty() 返回一个无值(null)的Optional 静态方法 boolean isPresent() 判断是否有具体值，有值返回true，null返回flase 实例方法 T get() 获取值，为null则报错 实例方法 T orElse( T other ) 获取值，为null则返回other的值 实例方法 5.2 Optional的高级用法123456789101112131415public static void main(String[] args) &#123; Optional&lt;String&gt; optional = Optional.of(&quot;凤姐&quot;); Optional&lt;String&gt; empty = Optional.empty(); //如果有值，则调用Lambda表达式 optional.ifPresent(value -&gt; System.out.println(&quot;有值: value = &quot; + value)); //如果有值，则调用第一个参数的Lambda表达式 //如果没有值，则调用第二个参数的Lambda表达式 //注意：此方法为JDK9中新增的方法 optional.ifPresentOrElse( value -&gt; System.out.println(&quot;有值: value = &quot; + value), () -&gt; System.out.println(&quot;没有值&quot;));&#125; 6.新日期时间API旧版日期时间API存在的问题： 设计很差：在面java.util和java.sql的包中都有日期类，java.util.Date同时包含日期和时间，而java.sql.Date仅包含日期。此外用于格式化和解析的类在java.text包中定义 非线程安全：java.util.Date是非线程安全的，所有的日期类都是可变的，这是java日期类最大的问题之一 时区处理麻烦：日期类并不提供国际化，没有时区支持，因java引入了java.util.Calendari和java.util.TimeZone类，但他们同样存在上述所有的问题 新日期时间API介绍： JDK8中增加了一套全新的日期时间API，这套API设计合理，是线程安全的。新的日期及时间API位于java.time包中，下面些关键类。 LocalDate：表示日期，包含年月日，格式为 2023-02-06 LocalTime：表示时间，包含时分秒，格式为18:58:54.158549300 LocalDateTime：表示日期时间，包含年月日，时分秒，格式为 2023-02-06T18:58:54.158 DateTimeFormatter：日期时间格式化类 Instant：时间戳，表示一个特定的时间瞬间 Duration：用于计算2个时间(LocalTime，时分秒)的距高 Period：用于计算2个日期(LocalDate，年月日)的距离 ZonedDateTime：包含时区的时间 6.1 LocalDate12345678910111213public static void localDate() &#123; //指定年月日 LocalDate date = LocalDate.of(2023, 2, 6); System.out.println(&quot;date = &quot; + date); //获取今天的年月日 LocalDate now = LocalDate.now(); System.out.println(&quot;现在日期 = &quot; + now); System.out.println(&quot;今年 = &quot; + now.getYear()); System.out.println(&quot;今月 = &quot; + now.getMonthValue()); System.out.println(&quot;今日 = &quot; + now.getDayOfMonth());&#125; 6.2 LocalTime12345678910111213public static void localTime() &#123; //指定20点30分30秒 LocalTime time = LocalTime.of(20, 30, 30); System.out.println(&quot;time = &quot; + time); //获取现在的时间 LocalTime now = LocalTime.now(); System.out.println(&quot;现在时间 = &quot; + now); System.out.println(now.getHour() + &quot;时&quot;); System.out.println(now.getMinute() + &quot;分&quot;); System.out.println(now.getSecond() + &quot;秒&quot;);&#125; 6.3 LocalDateTime123456789101112131415161718192021222324252627public static void localDateTime() &#123; //指定2023-02-06 00:00 LocalDateTime dateTime = LocalDateTime.of(2023, 2, 6, 0, 0); System.out.println(&quot;dateTime = &quot; + dateTime); //获取现在的日期时间，同理也可以获取相应的年月日时分秒 LocalDateTime now = LocalDateTime.now(); System.out.println(&quot;now = &quot; + now); //修改日期后会返回一个新的日期对象，不会修改之前的日期对象 //修改年份 LocalDateTime otherDateTime = now.withYear(2025); //增加2年 LocalDateTime dateTime1 = now.plusYears(2); //减去2年 LocalDateTime dateTime2 = now.minusYears(2); //now时间是否在dateTime1之后 System.out.println(now.isAfter(dateTime1)); //now时间是否在dateTime2之前 System.out.println(now.isBefore(dateTime2)); //now时间是否等于dateTime1 System.out.println(now.isEqual(dateTime1));&#125; 6.4 时间的格式化与解析12345678910111213public static void main(String[] args) &#123; LocalDateTime now = LocalDateTime.now(); //指定格式，一定要注意大小写！！ DateTimeFormatter formatter = DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd HH:mm:ss&quot;); //格式化 String format = now.format(formatter); System.out.println(&quot;format = &quot; + format); //解析 LocalDateTime dateTime = LocalDateTime.parse(format, formatter); System.out.println(&quot;dateTime = &quot; + dateTime);&#125; 6.5 Instantinstant时间戳&#x2F;时间线，内部保存了从1970年1月1日00：00：00以来的秒和纳秒 123456789101112public static void main(String[] args) &#123; Instant now = Instant.now(); System.out.println(&quot;now = &quot; + now); //2023-02-06T11:56:18.123353300Z System.out.println(now.plusSeconds(20)); //加20秒 System.out.println(now.minusSeconds(20)); //减去20秒 System.out.println(now.getEpochSecond()); //得到秒 System.out.println(now.getNano()); //得到纳秒 System.out.println(System.currentTimeMillis()); //时间戳&#125; 6.6 计算日期时间差Duration&#x2F;Period类：计算日期时间差。 Duration：用于计算2个时间(LocalTime,时分秒)的距离 Period：用于计算2个日期(LocalDate,年月日)的距离 12345678910111213141516171819public static void duration() &#123; LocalTime now = LocalTime.now(); LocalTime time = LocalTime.of(12, 30, 30); Duration duration = Duration.between(now, time); System.out.println(&quot;相差天数 = &quot; + duration.toDays()); System.out.println(&quot;相差小时 = &quot; + duration.toHours()); System.out.println(&quot;相差分钟 = &quot; + duration.toMinutes());&#125;public static void period() &#123; LocalDate now = LocalDate.now(); LocalDate date = LocalDate.of(2020, 8, 8); Period period = Period.between(date,now); System.out.println(&quot;相差的年 = &quot; + period.getYears()); System.out.println(&quot;相差的月 = &quot; + period.getMonths()); System.out.println(&quot;相差的日 = &quot; + period.getDays());&#125; 6.7 时间矫正器有时我们可能需要获取例如：将日期调整到下一个月的第一天等操作。可以通过时间校正器来进行。 TemporalAdjuster：时间校正器 TemporalAdjusters：该类通过静态方法提供了大量的常用TemporalAdjuster的实现 设置为下个月的第一天： 12345678910111213141516public static void main(String[] args) &#123; LocalDateTime now = LocalDateTime.now(); //方式一:Lambda表达式 LocalDateTime firstDayOfNextMonth = now.with(temporal -&gt; &#123; LocalDateTime dateTime = (LocalDateTime) temporal; //设置为下个月的第一天 return dateTime.plusMonths(1).withDayOfMonth(1); &#125;); System.out.println(&quot;firstDayOfNextMonth = &quot; + firstDayOfNextMonth); //方式二:使用TemporalAdjusters工具类 LocalDateTime firstDayOfNextMonth1 = now .with(TemporalAdjusters.firstDayOfNextMonth()); System.out.println(&quot;firstDayOfNextMonth1 = &quot; + firstDayOfNextMonth1);&#125; 6.8 日期时间的时区Java8中加入了对时区的支持，LocalDate、LocalTime、LocalDateTime是不带时区的，带时区的日期时间类分别为：ZonedDate、ZonedTime、ZonedDateTime 其中每个时区都对应看ID，ID的格式为”区域&#x2F;城市”，例如：Asia&#x2F;Shanghai等。 Zoneld：该类中包含了所有的时区信息。 12345678910111213141516public static void main(String[] args) &#123; //获取所有时区的ID //ZoneId.getAvailableZoneIds().forEach(System.out::println); //创建世界标准时间 ZonedDateTime standard = ZonedDateTime.now(Clock.systemUTC()); System.out.println(&quot;standard = &quot; + standard); //获取当地带有时区的时间 ZonedDateTime now = ZonedDateTime.now(); System.out.println(&quot;now = &quot; + now); //使用指定时区创建时间 ZonedDateTime AmericaDateTime = ZonedDateTime.now(ZoneId.of(&quot;America/Vancouver&quot;)); System.out.println(&quot;AmericaDateTime = &quot; + AmericaDateTime);&#125; 7.注解7.1 重复注解自从Java 5中引入注解以来，注解开始变得非常流行，并在各个框架和项目中被广泛使用。不过注解有一个很大的限制是：在同一个地方不能多次使用同一个注解，JDK 8引入了重复注解的概念，允许在同一个地方多次使用同一个注解。在JDK8中使用@Repeatable注解定义重复注解 重复注解使用步骤： 定义重复的注解容器注解 12345//重复注解容器@Retention(RetentionPolicy.RUNTIME) //vm运行期间也会保留注解，可以使用反射机制读取注解的信息@interface MyTests &#123; MyTest[] value();&#125; 定义一个可以重复的注解 123456//可重复的注解@Retention(RetentionPolicy.RUNTIME)@Repeatable(MyTests.class)@interface MyTest &#123; String value();&#125; 配置多个重复的注解 123456789@MyTest(&quot;test1&quot;)@MyTest(&quot;test2&quot;)class Test &#123; @MyTest(&quot;test3&quot;) @MyTest(&quot;test4&quot;) public void test() &#123; &#125;&#125; 解析重复注解： 123456789101112131415161718192021public class Test01&#123; public static void main(String[] args) throws NoSuchMethodException &#123; //获取类上的重复注解 //getAnnotationsByType()为获取重复注解的方法 MyTest[] annotationsByType = Test.class .getAnnotationsByType(MyTest.class); for (MyTest myTest : annotationsByType) &#123; System.out.println(&quot;myTest = &quot; + myTest); &#125; //获取类中方法上的重复注解 MyTest[] myTests = Test.class.getMethod(&quot;test&quot;) .getAnnotationsByType(MyTest.class); for (MyTest myTest : myTests) &#123; System.out.println(&quot;myTest = &quot; + myTest); &#125; &#125;&#125; 7.2 类型注解JDK 8为@Target元注解新增了两种类型：TYPE_PARAMETER、TYPE_USE, TYPE_PARAMETER：表示该注解能写在类型参故的声明语句中。 类型参数声明，如：&lt;T&gt;、&lt;T extends Person&gt; TYPE_USE：表示注解可以再任何用到类型的地方使用 1234567891011121314151617public class Test02 &lt;@TypeParam T&gt; &#123; private @NotNull int num = 10; public &lt;@TypeParam E extends Integer&gt; void test(@NotNull int num) &#123; @NotNull Integer a = 10; &#125;&#125;@Target(ElementType.TYPE_PARAMETER)@interface TypeParam &#123;&#125;@Target(ElementType.TYPE_USE)@interface NotNull &#123;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"http://example.com/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"},{"name":"基础","slug":"基础","permalink":"http://example.com/tags/%E5%9F%BA%E7%A1%80/"}]},{"title":"(每日LeetCode)1145. 二叉树着色游戏","slug":"每日LeetCode/2023-2/1145 二叉树着色游戏","date":"2023-02-03T03:39:00.000Z","updated":"2023-02-09T13:05:31.013Z","comments":true,"path":"2023/02/03/每日LeetCode/2023-2/1145 二叉树着色游戏/","link":"","permalink":"http://example.com/2023/02/03/%E6%AF%8F%E6%97%A5LeetCode/2023-2/1145%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9D%80%E8%89%B2%E6%B8%B8%E6%88%8F/","excerpt":"","text":"题目：有两位极客玩家参与了一场「二叉树着色」的游戏。游戏中，给出二叉树的根节点 root，树上总共有 n 个节点，且 n 为奇数，其中每个节点上的值从 1 到 n 各不相同。 最开始时： 「一号」玩家从 [1, n] 中取一个值 x（1 &lt;&#x3D; x &lt;&#x3D; n）；「二号」玩家也从 [1, n] 中取一个值 y（1 &lt;&#x3D; y &lt;&#x3D; n）且 y !&#x3D; x。「一号」玩家给值为 x 的节点染上红色，而「二号」玩家给值为 y 的节点染上蓝色。 之后两位玩家轮流进行操作，「一号」玩家先手。每一回合，玩家选择一个被他染过色的节点，将所选节点一个 未着色 的邻节点（即左右子节点、或父节点）进行染色（「一号」玩家染红色，「二号」玩家染蓝色）。 如果（且仅在此种情况下）当前玩家无法找到这样的节点来染色时，其回合就会被跳过。 若两个玩家都没有可以染色的节点时，游戏结束。着色节点最多的那位玩家获得胜利 ✌️。 现在，假设你是「二号」玩家，根据所给出的输入，假如存在一个 y 值可以确保你赢得这场游戏，则返回 true ；若无法获胜，就请返回 false 。 示例： 输入：root &#x3D; [1,2,3,4,5,6,7,8,9,10,11], n &#x3D; 11, x &#x3D; 3输出：true解释：第二个玩家可以选择值为 2 的节点。 思路：DFS无非存在两种情况： 把红色结点的父节点染成蓝色 无需计算蓝色的总数，只需要先获取红色的总数即可 红色总数：包括红色主结点及一下的子节点总数 蓝色总数：countBlue = n - countRed 把红色结点的子节点染成蓝色 先获取蓝色的总数，无需计算红色的总数 蓝色总数：countBlue = max(红色的左结点蓝色的总数, 红色的右结点蓝色的总数) 红色总数：countRed = n - countBlue 上述情况中，只要存在一种可以使countBlue &gt; countRed，则返回true 否则，返回false 代码(cpp)：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667class Solution &#123;public: bool btreeGameWinningMove(TreeNode* root, int n, int x) &#123; int countRed = 0; int countBlue = 0; //找到val为x的结点 auto xNode = getNodeByVal(root, x); //获取xNode结点下的总结点数 countRed = getCount(xNode); //给red的父节点染成蓝色的情况 if(n - countRed &gt; countRed) return true; //获取xNode结点的 左右子节点 中 的 总结点数最大的结点数 countBlue = max(getCount(xNode-&gt;left), getCount(xNode-&gt;right)); //给red的某个子节点染成蓝色的情况 return countBlue &gt; n-countBlue; &#125; TreeNode* getNodeByVal(TreeNode* root, int x) &#123; if(root == nullptr) return nullptr; queue&lt;TreeNode*&gt; queue; queue.emplace(root); while(!queue.empty())&#123; auto node = queue.front(); if(node-&gt;val == x) return node; queue.pop(); if(node-&gt;left != nullptr) queue.emplace(node-&gt;left); if(node-&gt;right != nullptr) queue.emplace(node-&gt;right); &#125; return nullptr; &#125; int getCount(TreeNode* root) &#123; if(root == nullptr) return 0; queue&lt;TreeNode*&gt; queue; queue.emplace(root); int count = 0; while(!queue.empty())&#123; auto node = queue.front(); queue.pop(); count++; if(node-&gt;left != nullptr) queue.emplace(node-&gt;left); if(node-&gt;right != nullptr) queue.emplace(node-&gt;right); &#125; return count; &#125;&#125;;","categories":[{"name":"每日LeetCode","slug":"每日LeetCode","permalink":"http://example.com/categories/%E6%AF%8F%E6%97%A5LeetCode/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"}]},{"title":"(每日LeetCode)2325. 解密消息","slug":"每日LeetCode/2023-2/2325 解密消息","date":"2023-02-01T02:25:00.000Z","updated":"2023-02-09T13:05:52.263Z","comments":true,"path":"2023/02/01/每日LeetCode/2023-2/2325 解密消息/","link":"","permalink":"http://example.com/2023/02/01/%E6%AF%8F%E6%97%A5LeetCode/2023-2/2325%20%E8%A7%A3%E5%AF%86%E6%B6%88%E6%81%AF/","excerpt":"","text":"题目：给你字符串 key 和 message ，分别表示一个加密密钥和一段加密消息。解密 message 的步骤如下： 使用 key 中 26 个英文小写字母第一次出现的顺序作为替换表中的字母 顺序 。将替换表与普通英文字母表对齐，形成对照表。按照对照表 替换 message 中的每个字母。空格 ‘ ‘ 保持不变。 例如，key &#x3D; “happy boy”（实际的加密密钥会包含字母表中每个字母 至少一次），据此，可以得到部分对照表（’h’ -&gt; ‘a’、’a’ -&gt; ‘b’、’p’ -&gt; ‘c’、’y’ -&gt; ‘d’、’b’ -&gt; 示例： 输入：key &#x3D; “the quick brown fox jumps over the lazy dog”, message &#x3D; “vkbs bs t suepuv”输出：”this is a secret”解释：对照表如上图所示。提取 “the quick brown fox jumps over the lazy dog” 中每个字母的首次出现可以得到替换表。 代码(cpp)：123456789101112131415161718192021222324252627class Solution &#123;public: string decodeMessage(string key, string message) &#123; vector&lt;char&gt; map(26); int pos = &#x27;a&#x27;; for(auto&amp; k : key)&#123; if(k == &#x27; &#x27;) continue; int temp = k - &#x27;a&#x27;; if(map[temp] == 0)&#123; map[temp] = pos++; &#125; &#125; string ans = &quot;&quot;; for(auto&amp; m : message)&#123; if(m == &#x27; &#x27;) ans.push_back(m); else ans.push_back(map[m-&#x27;a&#x27;]); &#125; return ans; &#125;&#125;; 复杂度分析： 时间复杂度：O(n+m)，其中 m和n 分别是字符串 key 和 message 的长度 空间复杂度：O(C)","categories":[{"name":"每日LeetCode","slug":"每日LeetCode","permalink":"http://example.com/categories/%E6%AF%8F%E6%97%A5LeetCode/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"}]},{"title":"(每日LeetCode)2319. 判断矩阵是否是一个 X 矩阵","slug":"每日LeetCode/2023-1/2319 判断矩阵是否是一个 X 矩阵","date":"2023-01-31T02:46:00.000Z","updated":"2023-01-31T02:47:08.823Z","comments":true,"path":"2023/01/31/每日LeetCode/2023-1/2319 判断矩阵是否是一个 X 矩阵/","link":"","permalink":"http://example.com/2023/01/31/%E6%AF%8F%E6%97%A5LeetCode/2023-1/2319%20%E5%88%A4%E6%96%AD%E7%9F%A9%E9%98%B5%E6%98%AF%E5%90%A6%E6%98%AF%E4%B8%80%E4%B8%AA%20X%20%E7%9F%A9%E9%98%B5/","excerpt":"","text":"题目：如果一个正方形矩阵满足下述 全部 条件，则称之为一个 X 矩阵 ： 矩阵对角线上的所有元素都 不是 0 矩阵中所有其他元素都是 0 给你一个大小为 n x n 的二维整数数组 grid ，表示一个正方形矩阵。如果 grid 是一个 X 矩阵 ，返回 true ； 否则，返回 false 。 示例： 输入：grid &#x3D; [[2,0,0,1],[0,3,1,0],[0,5,2,0],[4,0,0,2]]输出：true解释：矩阵如上图所示。X 矩阵应该满足：绿色元素（对角线上）都不是 0 ，红色元素都是 0 。因此，grid 是一个 X 矩阵。 代码(cpp)：123456789101112131415161718192021class Solution &#123;public: bool checkXMatrix(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123; int n = grid.size(); for(int i = 0; i &lt; n; i++)&#123; for(int j = 0; j &lt; n; j++)&#123; if(i == j || i == n-1-j)&#123; if(grid[i][j] == 0) return false; &#125; else&#123; if(grid[i][j] != 0) return false; &#125; &#125; &#125; return true; &#125;&#125;; 复杂度分析： 时间复杂度：O(n^2) 空间复杂度：O(1)","categories":[{"name":"每日LeetCode","slug":"每日LeetCode","permalink":"http://example.com/categories/%E6%AF%8F%E6%97%A5LeetCode/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"}]},{"title":"(每日LeetCode)1669. 合并两个链表","slug":"每日LeetCode/2023-1/1669 合并两个链表","date":"2023-01-30T03:00:00.000Z","updated":"2023-01-30T03:00:13.520Z","comments":true,"path":"2023/01/30/每日LeetCode/2023-1/1669 合并两个链表/","link":"","permalink":"http://example.com/2023/01/30/%E6%AF%8F%E6%97%A5LeetCode/2023-1/1669%20%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E9%93%BE%E8%A1%A8/","excerpt":"","text":"题目：给你两个链表 list1 和 list2 ，它们包含的元素分别为 n 个和 m 个。 请你将 list1 中下标从 a 到 b 的全部节点都删除，并将list2 接在被删除节点的位置。 下图中蓝色边和节点展示了操作后的结果： 请你返回结果链表的头指针。 示例： 输入：list1 &#x3D; [0,1,2,3,4,5], a &#x3D; 3, b &#x3D; 4, list2 &#x3D; [1000000,1000001,1000002]输出：[0,1,2,1000000,1000001,1000002,5]解释：我们删除 list1 中下标为 3 和 4 的两个节点，并将 list2 接在该位置。上图中蓝色的边和节点为答案链表。 代码(cpp)：123456789101112131415161718192021222324252627282930313233class Solution &#123;public: ListNode* mergeInBetween(ListNode* list1, int a, int b, ListNode* list2) &#123; auto ptr = list1; int pos = 0; ListNode* headPtr = nullptr; ListNode* tailPtr = nullptr; //分别获取到a-1指针和b+1指针 while(ptr != nullptr)&#123; if(pos == a-1)&#123; headPtr = ptr; &#125; if(pos == b+1)&#123; tailPtr = ptr; break; &#125; ptr = ptr-&gt;next; pos++; &#125; //将list1的a-1指针指向list2的头节点 headPtr-&gt;next = list2; //获取到到list2的尾节点指针 ptr = list2; while(ptr-&gt;next != nullptr)&#123; ptr = ptr-&gt;next; &#125; //将list2的尾节点指向list1的b+1结点 ptr-&gt;next = tailPtr; return list1; &#125;&#125;; 复杂度分析： 时间复杂度：O(n + m) 空间复杂度：O(1)","categories":[{"name":"每日LeetCode","slug":"每日LeetCode","permalink":"http://example.com/categories/%E6%AF%8F%E6%97%A5LeetCode/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"}]},{"title":"(每日LeetCode)2315. 统计星号","slug":"每日LeetCode/2023-1/2315 统计星号","date":"2023-01-29T03:03:00.000Z","updated":"2023-01-29T03:03:04.472Z","comments":true,"path":"2023/01/29/每日LeetCode/2023-1/2315 统计星号/","link":"","permalink":"http://example.com/2023/01/29/%E6%AF%8F%E6%97%A5LeetCode/2023-1/2315%20%E7%BB%9F%E8%AE%A1%E6%98%9F%E5%8F%B7/","excerpt":"","text":"题目：给你一个字符串 s ，每 两个 连续竖线 ‘|’ 为 一对 。换言之，第一个和第二个 ‘|’ 为一对，第三个和第四个 ‘|’ 为一对，以此类推。 请你返回 不在 竖线对之间，s 中 ‘*’ 的数目。 注意，每个竖线 ‘|’ 都会 恰好 属于一个对。 示例： 输入：s &#x3D; “l|eet|c**o|*de|”输出：2解释：不在竖线对之间的字符加粗加斜体后，得到字符串：”l|eet|c**o|*de|” 。第一和第二条竖线 ‘|’ 之间的字符不计入答案。同时，第三条和第四条竖线 ‘|’ 之间的字符也不计入答案。不在竖线对之间总共有 2 个星号，所以我们返回 2 。 代码(cpp)：12345678910111213141516171819class Solution &#123;public: int countAsterisks(string s) &#123; int count = 0; int ans = 0; for(auto&amp; c : s)&#123; if(c == &#x27;|&#x27;)&#123; count++; continue; &#125; if(count%2 == 0 &amp;&amp; c == &#x27;*&#x27;)&#123; ans++; &#125; &#125; return ans; &#125;&#125;; 复杂度分析： 时间复杂度：O(n) 空间复杂度：O(1)","categories":[{"name":"每日LeetCode","slug":"每日LeetCode","permalink":"http://example.com/categories/%E6%AF%8F%E6%97%A5LeetCode/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"}]},{"title":"(每日LeetCode)2309. 兼具大小写的最好英文字母","slug":"每日LeetCode/2023-1/2309 兼具大小写的最好英文字母","date":"2023-01-27T12:19:00.000Z","updated":"2023-01-27T12:19:39.742Z","comments":true,"path":"2023/01/27/每日LeetCode/2023-1/2309 兼具大小写的最好英文字母/","link":"","permalink":"http://example.com/2023/01/27/%E6%AF%8F%E6%97%A5LeetCode/2023-1/2309%20%E5%85%BC%E5%85%B7%E5%A4%A7%E5%B0%8F%E5%86%99%E7%9A%84%E6%9C%80%E5%A5%BD%E8%8B%B1%E6%96%87%E5%AD%97%E6%AF%8D/","excerpt":"","text":"题目：给你一个由英文字母组成的字符串 s ，请你找出并返回 s 中的 最好 英文字母。返回的字母必须为大写形式。如果不存在满足条件的字母，则返回一个空字符串。 最好 英文字母的大写和小写形式必须 都 在 s 中出现。 英文字母 b 比另一个英文字母 a 更好 的前提是：英文字母表中，b 在 a 之 后 出现。 示例： 输入：s &#x3D; “arRAzFif”输出：”R”解释：字母 ‘R’ 是大写和小写形式都出现的最好英文字母。注意 ‘A’ 和 ‘F’ 的大写和小写形式也都出现了，但是 ‘R’ 比 ‘F’ 和 ‘A’ 更好。 代码(cpp)：哈希表+位运算1234567891011121314151617181920212223class Solution &#123;public: string greatestLetter(string s) &#123; vector&lt;int&gt; count(26); string ans = &quot;&quot;; for(auto&amp; c : s)&#123; //islower()：判断是否为小写字母 if(islower(c)) count[c-&#x27;a&#x27;] |= 1; else count[c-&#x27;A&#x27;] |= 2; &#125; for(int i = 25; i &gt;= 0; i--)&#123; if(count[i] == 3)&#123; ans.push_back(&#x27;A&#x27;+i); return ans; &#125; &#125; return ans; &#125;&#125;; 复杂度分析： 时间复杂度：O(n+C)，n为s字符串的长度，C为26个字母集 空间复杂度：O(C)","categories":[{"name":"每日LeetCode","slug":"每日LeetCode","permalink":"http://example.com/categories/%E6%AF%8F%E6%97%A5LeetCode/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"}]},{"title":"(每日LeetCode)1663. 具有给定数值的最小字符串","slug":"每日LeetCode/2023-1/1663 具有给定数值的最小字符串","date":"2023-01-26T02:59:00.000Z","updated":"2023-01-26T02:59:53.418Z","comments":true,"path":"2023/01/26/每日LeetCode/2023-1/1663 具有给定数值的最小字符串/","link":"","permalink":"http://example.com/2023/01/26/%E6%AF%8F%E6%97%A5LeetCode/2023-1/1663%20%E5%85%B7%E6%9C%89%E7%BB%99%E5%AE%9A%E6%95%B0%E5%80%BC%E7%9A%84%E6%9C%80%E5%B0%8F%E5%AD%97%E7%AC%A6%E4%B8%B2/","excerpt":"","text":"题目：小写字符 的 数值 是它在字母表中的位置（从 1 开始），因此 a 的数值为 1 ，b 的数值为 2 ，c 的数值为 3 ，以此类推。 字符串由若干小写字符组成，字符串的数值 为各字符的数值之和。例如，字符串 “abe” 的数值等于 1 + 2 + 5 &#x3D; 8 。 给你两个整数 n 和 k 。返回 长度 等于 n 且 数值 等于 k 的 字典序最小 的字符串。 注意，如果字符串 x 在字典排序中位于 y 之前，就认为 x 字典序比 y 小，有以下两种情况： x 是 y 的一个前缀；如果 i 是 x[i] !&#x3D; y[i] 的第一个位置，且 x[i] 在字母表中的位置比 y[i] 靠前。 示例： 输入：n &#x3D; 3, k &#x3D; 27输出：”aay”解释：字符串的数值为 1 + 1 + 25 &#x3D; 27，它是数值满足要求且长度等于 3 字典序最小的字符串。 代码(cpp)：贪心1234567891011121314151617181920class Solution &#123;public: string getSmallestString(int n, int k) &#123; //初始化string字符串全为&#x27;a&#x27; string ans(n, &#x27;a&#x27;); k -= n; //从后往前遍历，优先添加后面的字符 for(int i = n-1; i &gt;= 0; i--)&#123; if(k &lt; 25)&#123; ans[i] += k; break; &#125; else&#123; ans[i] += 25; k -= 25; &#125; &#125; return ans; &#125;&#125;; 复杂度分析： 时间复杂度：O(n) 空间复杂度：O(1)","categories":[{"name":"每日LeetCode","slug":"每日LeetCode","permalink":"http://example.com/categories/%E6%AF%8F%E6%97%A5LeetCode/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"}]},{"title":"(每日LeetCode)1828. 统计一个圆中点的数目","slug":"每日LeetCode/2023-1/1828 统计一个圆中点的数目","date":"2023-01-24T01:45:00.000Z","updated":"2023-01-24T01:48:48.001Z","comments":true,"path":"2023/01/24/每日LeetCode/2023-1/1828 统计一个圆中点的数目/","link":"","permalink":"http://example.com/2023/01/24/%E6%AF%8F%E6%97%A5LeetCode/2023-1/1828%20%E7%BB%9F%E8%AE%A1%E4%B8%80%E4%B8%AA%E5%9C%86%E4%B8%AD%E7%82%B9%E7%9A%84%E6%95%B0%E7%9B%AE/","excerpt":"","text":"题目：给你一个数组 points ，其中 points[i] &#x3D; [xi, yi] ，表示第 i 个点在二维平面上的坐标。多个点可能会有 相同 的坐标。 同时给你一个数组 queries ，其中 queries[j] &#x3D; [xj, yj, rj] ，表示一个圆心在 (xj, yj) 且半径为 rj 的圆。 对于每一个查询 queries[j] ，计算在第 j 个圆 内 点的数目。如果一个点在圆的 边界上 ，我们同样认为它在圆 内 。 请你返回一个数组 answer ，其中 answer[j]是第 j 个查询的答案。 示例： 输入：points &#x3D; [[1,3],[3,3],[5,3],[2,2]], queries &#x3D; [[2,3,1],[4,3,1],[1,1,2]]输出：[3,2,2]解释：所有的点和圆如上图所示。queries[0] 是绿色的圆，queries[1] 是红色的圆，queries[2] 是蓝色的圆。 思路：判断圆心到点points的距离是否小于等于半径 $\\sqrt{(x^2_1-x^2_2)+(y^2_1-y^2_2)} &lt;&#x3D; R$ 代码(cpp)：12345678910111213141516171819class Solution &#123;public: vector&lt;int&gt; countPoints(vector&lt;vector&lt;int&gt;&gt;&amp; points, vector&lt;vector&lt;int&gt;&gt;&amp; queries) &#123; int n = queries.size(); int m = points.size(); vector&lt;int&gt; ans(n); for(int i = 0; i &lt; n; i++)&#123; for(int j = 0; j &lt; m; j++)&#123; int temp = pow(queries[i][0]-points[j][0], 2) + pow(queries[i][1]-points[j][1], 2); if(pow(temp, 0.5) &lt;= queries[i][2])&#123; ans[i]++; &#125; &#125; &#125; return ans; &#125;&#125;; 复杂度分析： 时间复杂度：O(n^2) 空间复杂度：O(n)","categories":[{"name":"每日LeetCode","slug":"每日LeetCode","permalink":"http://example.com/categories/%E6%AF%8F%E6%97%A5LeetCode/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"}]},{"title":"(每日LeetCode)2303. 计算应缴税款总额","slug":"每日LeetCode/2023-1/2303 计算应缴税款总额","date":"2023-01-23T02:57:00.000Z","updated":"2023-01-23T02:57:17.908Z","comments":true,"path":"2023/01/23/每日LeetCode/2023-1/2303 计算应缴税款总额/","link":"","permalink":"http://example.com/2023/01/23/%E6%AF%8F%E6%97%A5LeetCode/2023-1/2303%20%E8%AE%A1%E7%AE%97%E5%BA%94%E7%BC%B4%E7%A8%8E%E6%AC%BE%E6%80%BB%E9%A2%9D/","excerpt":"","text":"题目：给你一个下标从 0 开始的二维整数数组 brackets ，其中 brackets[i] &#x3D; [upperi, percenti] ，表示第 i 个税级的上限是 upperi ，征收的税率为 percenti 。税级按上限 从低到高排序（在满足 0 &lt; i &lt; brackets.length 的前提下，upperi-1 &lt; upperi）。 税款计算方式如下： 不超过 upper0 的收入按税率 percent0 缴纳接着 upper1 - upper0 的部分按税率 percent1 缴纳然后 upper2 - upper1 的部分按税率 percent2 缴纳以此类推给你一个整数 income 表示你的总收入。返回你需要缴纳的税款总额。与标准答案误差不超 10-5 的结果将被视作正确答案。 示例： 输入：brackets &#x3D; [[3,50],[7,10],[12,25]], income &#x3D; 10输出：2.65000解释：前 $3 的税率为 50% 。需要支付税款 $3 * 50% = $1.50 。 接下来 $7 - $3 = $4 的税率为 10% 。需要支付税款 $4 * 10% = $0.40 。 最后 $10 - $7 = $3 的税率为 25% 。需要支付税款 $3 * 25% = $0.75 。 需要支付的税款总计 $1.50 + $0.40 + $0.75 = $2.65 。 代码(cpp)：123456789101112131415161718class Solution &#123;public: double calculateTax(vector&lt;vector&lt;int&gt;&gt;&amp; brackets, int income) &#123; if(income == 0) return 0; int ans = 0; int pre = 0; for(int i = 0; i &lt; brackets.size(); i++)&#123; if(pre &gt; income) break; ans += (min(income, brackets[i][0])-pre)*brackets[i][1]; pre = brackets[i][0]; &#125; return double(ans)*0.01; &#125;&#125;; 复杂度分析： 时间复杂度：O(n) 空间复杂度：O(1)","categories":[{"name":"每日LeetCode","slug":"每日LeetCode","permalink":"http://example.com/categories/%E6%AF%8F%E6%97%A5LeetCode/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"}]},{"title":"(每日LeetCode)1817. 查找用户活跃分钟数","slug":"每日LeetCode/2023-1/1817 查找用户活跃分钟数","date":"2023-01-20T02:36:00.000Z","updated":"2023-01-20T02:36:33.815Z","comments":true,"path":"2023/01/20/每日LeetCode/2023-1/1817 查找用户活跃分钟数/","link":"","permalink":"http://example.com/2023/01/20/%E6%AF%8F%E6%97%A5LeetCode/2023-1/1817%20%E6%9F%A5%E6%89%BE%E7%94%A8%E6%88%B7%E6%B4%BB%E8%B7%83%E5%88%86%E9%92%9F%E6%95%B0/","excerpt":"","text":"题目：给你用户在 LeetCode 的操作日志，和一个整数 k 。日志用一个二维整数数组 logs 表示，其中每个 logs[i] &#x3D; [IDi, timei] 表示 ID 为 IDi 的用户在 timei 分钟时执行了某个操作。 多个用户 可以同时执行操作，单个用户可以在同一分钟内执行 多个操作 。 指定用户的 用户活跃分钟数（user active minutes，UAM） 定义为用户对 LeetCode 执行操作的 唯一分钟数 。 即使一分钟内执行多个操作，也只能按一分钟计数。 请你统计用户活跃分钟数的分布情况，统计结果是一个长度为 k 且 下标从 1 开始计数 的数组 answer ，对于每个 j（1 &lt;&#x3D; j &lt;&#x3D; k），answer[j] 表示 用户活跃分钟数 等于 j 的用户数。 返回上面描述的答案数组 answer 。 示例： 输入：logs &#x3D; [[1,1],[2,2],[2,3]], k &#x3D; 4输出：[1,1,0,0]解释：ID&#x3D;1 的用户仅在分钟 1 执行单个操作。因此，该用户的用户活跃分钟数为 1ID&#x3D;2 的用户执行操作的分钟分别是：2 和 3 。因此，该用户的用户活跃分钟数为 21 个用户的用户活跃分钟数是 1 ，1 个用户的用户活跃分钟数是 2因此，answer[1] &#x3D; 1 ，answer[2] &#x3D; 1 ，其余的值都是 0 代码(cpp)：哈希+set去重1234567891011121314151617class Solution &#123;public: vector&lt;int&gt; findingUsersActiveMinutes(vector&lt;vector&lt;int&gt;&gt;&amp; logs, int k) &#123; unordered_map&lt;int, set&lt;int&gt;&gt; map; for(auto&amp; log : logs)&#123; map[log[0]].emplace(log[1]); &#125; vector&lt;int&gt; ans(k); for(auto&amp; [_, set] : map)&#123; ans[set.size()-1]++; &#125; return ans; &#125;&#125;; 复杂度分析： 时间复杂度：O(n+k)，其中 n 是数组 logs 的长度，k 是给定的整数。 空间复杂度：O(n)。","categories":[{"name":"每日LeetCode","slug":"每日LeetCode","permalink":"http://example.com/categories/%E6%AF%8F%E6%97%A5LeetCode/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"}]},{"title":"(每日LeetCode)2299. 强密码检验器 II","slug":"每日LeetCode/2023-1/2299 强密码检验器 II","date":"2023-01-19T07:30:00.000Z","updated":"2023-01-19T07:30:32.044Z","comments":true,"path":"2023/01/19/每日LeetCode/2023-1/2299 强密码检验器 II/","link":"","permalink":"http://example.com/2023/01/19/%E6%AF%8F%E6%97%A5LeetCode/2023-1/2299%20%E5%BC%BA%E5%AF%86%E7%A0%81%E6%A3%80%E9%AA%8C%E5%99%A8%20II/","excerpt":"","text":"题目：如果一个密码满足以下所有条件，我们称它是一个 强 密码： 它有至少 8 个字符。至少包含 一个小写英文 字母。至少包含 一个大写英文 字母。至少包含 一个数字 。至少包含 一个特殊字符 。特殊字符为：”!@#$%^&amp;*()-+” 中的一个。它 不 包含 2 个连续相同的字符（比方说 “aab” 不符合该条件，但是 “aba” 符合该条件）。给你一个字符串 password ，如果它是一个 强 密码，返回 true，否则返回 false 。 示例： 输入：password &#x3D; “IloveLe3tcode!”输出：true解释：密码满足所有的要求，所以我们返回 true 。 代码(cpp)：位运算1234567891011121314151617181920212223242526272829class Solution &#123;public: bool strongPasswordCheckerII(string password) &#123; //密码长度至少为8 if(password.size() &lt; 8) return false; int ans = 0; char pri = &#x27; &#x27;; for(auto&amp; c : password)&#123; //不能出现连续相同的字符 if(c == pri) return false; else pri = c; //检查包含的字符 if(c &gt;= &#x27;a&#x27; &amp;&amp; c &lt;= &#x27;z&#x27;) ans |= 1; else if(c &gt;= &#x27;A&#x27; &amp;&amp; c &lt;= &#x27;Z&#x27;) ans |= 2; else if(c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;) ans |= 4; else ans |= 8; &#125; return ans == 15; &#125;&#125;; 复杂度分析： 时间复杂度：O(n)，其中 n 为密码的长度。 空间复杂度：O(1)。","categories":[{"name":"每日LeetCode","slug":"每日LeetCode","permalink":"http://example.com/categories/%E6%AF%8F%E6%97%A5LeetCode/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"}]},{"title":"(每日LeetCode)1814. 统计一个数组中好对子的数目","slug":"每日LeetCode/2023-1/1814 统计一个数组中好对子的数目","date":"2023-01-17T02:51:00.000Z","updated":"2023-01-17T02:51:40.201Z","comments":true,"path":"2023/01/17/每日LeetCode/2023-1/1814 统计一个数组中好对子的数目/","link":"","permalink":"http://example.com/2023/01/17/%E6%AF%8F%E6%97%A5LeetCode/2023-1/1814%20%E7%BB%9F%E8%AE%A1%E4%B8%80%E4%B8%AA%E6%95%B0%E7%BB%84%E4%B8%AD%E5%A5%BD%E5%AF%B9%E5%AD%90%E7%9A%84%E6%95%B0%E7%9B%AE/","excerpt":"","text":"题目：给你一个数组 nums ，数组中只包含非负整数。定义 rev(x) 的值为将整数 x 各个数字位反转得到的结果。比方说 rev(123) &#x3D; 321 ， rev(120) &#x3D; 21 。我们称满足下面条件的下标对 (i, j) 是 好的 ： 0 &lt;&#x3D; i &lt; j &lt; nums.lengthnums[i] + rev(nums[j]) &#x3D;&#x3D; nums[j] + rev(nums[i])请你返回好下标对的数目。由于结果可能会很大，请将结果对 109 + 7 取余 后返回。 示例： 输入：nums &#x3D; [42,11,1,97]输出：2解释：两个坐标对为： (0,3)：42 + rev(97) &#x3D; 42 + 79 &#x3D; 121, 97 + rev(42) &#x3D; 97 + 24 &#x3D; 121 。 (1,2)：11 + rev(1) &#x3D; 11 + 1 &#x3D; 12, 1 + rev(11) &#x3D; 1 + 11 &#x3D; 12 。 思路：哈希表nums[i] + rev(nums[j]) == nums[j] + rev(nums[i]) 可以推导出： nums[i] - rev(nums[i]) == nums[j] - rev(nums[j]) 所以，只要有nums[i] - rev(nums[i])相等的，那就是一对好对子 利用哈希表记录结果都为nums[i] - rev(nums[i])的个数 并且可能会存在有多个结果相同的坐标 代码(cpp)：123456789101112131415161718192021222324class Solution &#123;public: int rev(int num)&#123; int res = 0; while(num)&#123; res = res*10 + num%10; num /= 10; &#125; return res; &#125; int countNicePairs(vector&lt;int&gt;&amp; nums) &#123; int mod = 1e9+7; long ans = 0; unordered_map&lt;int, int&gt; map; for(auto&amp; num : nums)&#123; int revNum = rev(num); ans = (ans+map[num-revNum]) % mod; map[num-revNum]++; &#125; return ans; &#125;&#125;; 复杂度分析： 时间复杂度：O(n) 空间复杂度：O(n)","categories":[{"name":"每日LeetCode","slug":"每日LeetCode","permalink":"http://example.com/categories/%E6%AF%8F%E6%97%A5LeetCode/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"}]},{"title":"(每日LeetCode)1813. 句子相似性 III","slug":"每日LeetCode/2023-1/1813 句子相似性 III","date":"2023-01-16T03:54:00.000Z","updated":"2023-01-16T03:55:02.070Z","comments":true,"path":"2023/01/16/每日LeetCode/2023-1/1813 句子相似性 III/","link":"","permalink":"http://example.com/2023/01/16/%E6%AF%8F%E6%97%A5LeetCode/2023-1/1813%20%E5%8F%A5%E5%AD%90%E7%9B%B8%E4%BC%BC%E6%80%A7%20III/","excerpt":"","text":"题目：一个句子是由一些单词与它们之间的单个空格组成，且句子的开头和结尾没有多余空格。比方说，”Hello World” ，”HELLO” ，”hello world hello world” 都是句子。每个单词都 只 包含大写和小写英文字母。 如果两个句子 sentence1 和 sentence2 ，可以通过往其中一个句子插入一个任意的句子（可以是空句子）而得到另一个句子，那么我们称这两个句子是 相似的 。比方说，sentence1 &#x3D; “Hello my name is Jane” 且 sentence2 &#x3D; “Hello Jane” ，我们可以往 sentence2 中 “Hello” 和 “Jane” 之间插入 “my name is” 得到 sentence1 。 给你两个句子 sentence1 和 sentence2 ，如果 sentence1 和 sentence2 是相似的，请你返回 true ，否则返回 false 。 示例：示例1： 输入：sentence1 &#x3D; “My name is Haley”, sentence2 &#x3D; “My Haley”输出：true解释：可以往 sentence2 中 “My” 和 “Haley” 之间插入 “name is” ，得到 sentence1 。 示例2： 输入：sentence1 &#x3D; “of”, sentence2 &#x3D; “A lot of words”输出：false解释：没法往这两个句子中的一个句子只插入一个句子就得到另一个句子。 代码(cpp)：双指针123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657class Solution &#123;public: //第一种方法stringstream vector&lt;string&gt; split(string&amp; s) &#123; vector&lt;string&gt; words; stringstream ss; ss &lt;&lt; s; string str; while (ss &gt;&gt; str) words.emplace_back(str); return words; &#125; //第二种方法isstringstream /*vector&lt;string&gt; split2(string s)&#123; vector&lt;string&gt; words; istringstream iss(s); string str; while (iss &gt;&gt; str) words.emplace_back(str); return words; &#125;*/ //第三种方法遍历 /*vector&lt;string&gt; split3(string&amp; s)&#123; vector&lt;string&gt; wordList; for(int i = 0; i &lt; s.size(); i++)&#123; if(s[i] != &#x27; &#x27;)&#123; string temp = &quot;&quot;; while(i &lt; s.size() &amp;&amp; s[i] != &#x27; &#x27;) temp.push_back(s[i++]); wordList.emplace_back(temp); &#125; &#125; return wordList; &#125;*/ bool areSentencesSimilar(string sentence1, string sentence2) &#123; //将第一个参数指定为长度最短的 if (sentence1.size() &gt; sentence2.size()) return areSentencesSimilar(sentence2, sentence1); vector&lt;string&gt; words1 = split(sentence1); vector&lt;string&gt; words2 = split(sentence2); int shortSize = words1.size(); int longSize = words2.size(); int left = 0; int right = 0; //先从左边遍历 while(left &lt; shortSize &amp;&amp; words1[left] == words2[left]) left++; //再从右边遍历 while(right &lt; shortSize-left &amp;&amp; words1[(shortSize-1)-right] == words2[(longSize-1)-right]) right++; return left+right == shortSize; &#125;&#125;; 复杂度分析： 时间复杂度：O(m+n)，其中 m 是 sentence1 的长度，n 是 sentence2的长度。 空间复杂度：O(m+n)","categories":[{"name":"每日LeetCode","slug":"每日LeetCode","permalink":"http://example.com/categories/%E6%AF%8F%E6%97%A5LeetCode/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"}]},{"title":"(每日LeetCode)2293. 极大极小游戏","slug":"每日LeetCode/2023-1/2293 极大极小游戏","date":"2023-01-15T02:37:00.000Z","updated":"2023-01-15T02:37:41.125Z","comments":true,"path":"2023/01/15/每日LeetCode/2023-1/2293 极大极小游戏/","link":"","permalink":"http://example.com/2023/01/15/%E6%AF%8F%E6%97%A5LeetCode/2023-1/2293%20%E6%9E%81%E5%A4%A7%E6%9E%81%E5%B0%8F%E6%B8%B8%E6%88%8F/","excerpt":"","text":"题目：给你一个下标从 0 开始的整数数组 nums ，其长度是 2 的幂。 对 nums 执行下述算法： 设 n 等于 nums 的长度，如果 n &#x3D;&#x3D; 1 ，终止 算法过程。否则，创建 一个新的整数数组 newNums ，新数组长度为 n &#x2F; 2 ，下标从 0 开始。对于满足 0 &lt;&#x3D; i &lt; n &#x2F; 2 的每个 偶数 下标 i ，将 newNums[i] 赋值 为 min(nums[2 * i], nums[2 * i + 1]) 。对于满足 0 &lt;&#x3D; i &lt; n &#x2F; 2 的每个 奇数 下标 i ，将 newNums[i] 赋值 为 max(nums[2 * i], nums[2 * i + 1]) 。用 newNums 替换 nums 。从步骤 1 开始 重复 整个过程。执行算法后，返回 nums 中剩下的那个数字。 示例： 输入：nums &#x3D; [1,3,5,2,4,8,2,2]输出：1解释：重复执行算法会得到下述数组。第一轮：nums &#x3D; [1,5,4,2]第二轮：nums &#x3D; [1,4]第三轮：nums &#x3D; [1]1 是最后剩下的那个数字，返回 1 。 代码(cpp)：BFS123456789101112131415161718192021222324class Solution &#123;public: int minMaxGame(vector&lt;int&gt;&amp; nums) &#123; while(nums.size() &gt; 1)&#123; vector&lt;int&gt; temp; bool flag = true; for(int i = 0; i &lt; nums.size(); i+=2)&#123; int num = 0; if(flag)&#123; num = min(nums[i], nums[i+1]); flag = false; &#125; else&#123; num = max(nums[i], nums[i+1]); flag = true; &#125; temp.emplace_back(num); &#125; nums = move(temp); &#125; return nums[0]; &#125;&#125;; 复杂度分析： 时间复杂度：O(n)，其中 n 是数组 nums 的长度。第一次循环的时间复杂度为 O(n)，下一次循环时问题规模减半，所以总体复杂度为 O(n)+O(n&#x2F;2)+O( n&#x2F;4)+⋯+O(1)&#x3D;O(n)。 空间复杂度：O(n)，其中 n 是数组 nums 的长度。","categories":[{"name":"每日LeetCode","slug":"每日LeetCode","permalink":"http://example.com/categories/%E6%AF%8F%E6%97%A5LeetCode/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"}]},{"title":"(每日LeetCode)1807. 替换字符串中的括号内容","slug":"每日LeetCode/2023-1/1807 替换字符串中的括号内容","date":"2023-01-12T02:36:00.000Z","updated":"2023-01-12T02:36:29.627Z","comments":true,"path":"2023/01/12/每日LeetCode/2023-1/1807 替换字符串中的括号内容/","link":"","permalink":"http://example.com/2023/01/12/%E6%AF%8F%E6%97%A5LeetCode/2023-1/1807%20%E6%9B%BF%E6%8D%A2%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E6%8B%AC%E5%8F%B7%E5%86%85%E5%AE%B9/","excerpt":"","text":"题目：给你一个字符串 s ，它包含一些括号对，每个括号中包含一个 非空 的键。 比方说，字符串 “(name)is(age)yearsold” 中，有 两个 括号对，分别包含键 “name” 和 “age” 。你知道许多键对应的值，这些关系由二维字符串数组 knowledge 表示，其中 knowledge[i] &#x3D; [keyi, valuei] ，表示键 keyi 对应的值为 valuei 。 你需要替换 所有 的括号对。当你替换一个括号对，且它包含的键为 keyi 时，你需要： 将 keyi 和括号用对应的值 valuei 替换。如果从 knowledge 中无法得知某个键对应的值，你需要将 keyi 和括号用问号 “?” 替换（不需要引号）。knowledge 中每个键最多只会出现一次。s 中不会有嵌套的括号。 请你返回替换 所有 括号对后的结果字符串。 示例：示例1： 输入：s &#x3D; “(name)is(age)yearsold”, knowledge &#x3D; [[“name”,”bob”],[“age”,”two”]]输出：”bobistwoyearsold”解释：键 “name” 对应的值为 “bob” ，所以将 “(name)” 替换为 “bob” 。键 “age” 对应的值为 “two” ，所以将 “(age)” 替换为 “two” 。 示例2： 输入：s &#x3D; “hi(name)”, knowledge &#x3D; [[“a”,”b”]]输出：”hi?”解释：由于不知道键 “name” 对应的值，所以用 “?” 替换 “(name)” 。 代码(cpp)：1234567891011121314151617181920212223242526272829303132class Solution &#123;public: string evaluate(string s, vector&lt;vector&lt;string&gt;&gt;&amp; knowledge) &#123; unordered_map&lt;string, string&gt; map; //建立哈希表 for(auto&amp; kv : knowledge)&#123; map[kv[0]] = kv[1]; &#125; string ans = &quot;&quot;; for(int i = 0; i &lt; s.size(); i++)&#123; string temp = &quot;&quot;; //如果没有到&#x27;(&#x27;，加把字符加入到ans中 if(s[i] != &#x27;(&#x27;) ans.push_back(s[i]); else&#123; i++; //获得括号中的字符串 while(i &lt; s.size() &amp;&amp; s[i] != &#x27;)&#x27;) temp.push_back(s[i++]); //哈希表中是否存在匹配的 string str = map[temp]; if(str.empty()) ans.push_back(&#x27;?&#x27;); else ans.append(str); &#125; &#125; return ans; &#125;&#125;; 复杂度分析： 时间复杂度：O(n+k)，其中 n 是字符串 s 的长度，k 是字符串数组 knowledge 中所有字符串的长度之和 空间复杂度：O(n+k)","categories":[{"name":"每日LeetCode","slug":"每日LeetCode","permalink":"http://example.com/categories/%E6%AF%8F%E6%97%A5LeetCode/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"}]},{"title":"(每日LeetCode)2283. 判断一个数的数字计数是否等于数位的值","slug":"每日LeetCode/2023-1/2283 判断一个数的数字计数是否等于数位的值","date":"2023-01-11T01:54:00.000Z","updated":"2023-01-11T01:54:59.571Z","comments":true,"path":"2023/01/11/每日LeetCode/2023-1/2283 判断一个数的数字计数是否等于数位的值/","link":"","permalink":"http://example.com/2023/01/11/%E6%AF%8F%E6%97%A5LeetCode/2023-1/2283%20%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E6%95%B0%E7%9A%84%E6%95%B0%E5%AD%97%E8%AE%A1%E6%95%B0%E6%98%AF%E5%90%A6%E7%AD%89%E4%BA%8E%E6%95%B0%E4%BD%8D%E7%9A%84%E5%80%BC/","excerpt":"","text":"题目：给你一个下标从 0 开始长度为 n 的字符串 num ，它只包含数字。 如果对于 每个 0 &lt;&#x3D; i &lt; n 的下标 i ，都满足数位 i 在 num 中出现了 num[i]次，那么请你返回 true ，否则返回 false 。 示例： 输入：num &#x3D; “030”输出：false解释：num[0] &#x3D; ‘0’ 。数字 0 应该出现 0 次，但是在 num 中出现了一次。num[1] &#x3D; ‘3’ 。数字 1 应该出现 3 次，但是在 num 中出现了零次。num[2] &#x3D; ‘0’ 。数字 2 在 num 中出现了 0 次。下标 0 和 1 都违反了题目要求，所以返回 false 。 代码(cpp)：12345678910111213141516class Solution &#123;public: bool digitCount(string num) &#123; vector&lt;int&gt; map(10); for(auto&amp; n : num)&#123; map[n-&#x27;0&#x27;]++; &#125; for(int i = 0; i &lt; num.size(); i++)&#123; if(map[i] != num[i]-&#x27;0&#x27;)&#123; return false; &#125; &#125; return true; &#125;&#125;; 复杂度分析： 时间复杂度：O(n) 空间复杂度：O(10)","categories":[{"name":"每日LeetCode","slug":"每日LeetCode","permalink":"http://example.com/categories/%E6%AF%8F%E6%97%A5LeetCode/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"}]},{"title":"(每日LeetCode)1806. 还原排列的最少操作步数","slug":"每日LeetCode/2023-1/1806 还原排列的最少操作步数","date":"2023-01-09T02:11:00.000Z","updated":"2023-01-09T02:12:01.265Z","comments":true,"path":"2023/01/09/每日LeetCode/2023-1/1806 还原排列的最少操作步数/","link":"","permalink":"http://example.com/2023/01/09/%E6%AF%8F%E6%97%A5LeetCode/2023-1/1806%20%E8%BF%98%E5%8E%9F%E6%8E%92%E5%88%97%E7%9A%84%E6%9C%80%E5%B0%91%E6%93%8D%E4%BD%9C%E6%AD%A5%E6%95%B0/","excerpt":"","text":"题目：给你一个偶数 n ，已知存在一个长度为 n 的排列 perm ，其中 perm[i] &#x3D;&#x3D; i（下标 从 0 开始 计数）。 一步操作中，你将创建一个新数组 arr ，对于每个 i ： 如果 i % 2 &#x3D;&#x3D; 0 ，那么 arr[i] &#x3D; perm[i &#x2F; 2] 如果 i % 2 &#x3D;&#x3D; 1 ，那么 arr[i] &#x3D; perm[n &#x2F; 2 + (i - 1) &#x2F; 2] 然后将 arr 赋值给 perm 。 要想使 perm 回到排列初始值，至少需要执行多少步操作？返回最小的 非零 操作步数。 示例： 输入：n &#x3D; 4输出：2解释：最初，perm &#x3D; [0,1,2,3]第 1 步操作后，perm &#x3D; [0,2,1,3]第 2 步操作后，perm &#x3D; [0,1,2,3]所以，仅需执行 2 步操作 代码(cpp)：12345678910111213141516171819202122232425262728293031class Solution &#123;public: int reinitializePermutation(int n) &#123; vector&lt;int&gt; perm(n); vector&lt;int&gt; collation(n); for(int i = 0; i &lt; n; i++)&#123; perm[i] = i; collation[i] = i; &#125; int ans = 0; while(true)&#123; //如果要调用move构造，那么一定要传一个临时变量 vector&lt;int&gt; arr(n); for(int i = 0; i &lt; n; i++)&#123; if(i%2 == 0) arr[i] = perm[i/2]; else arr[i] = perm[n/2+(i-1)/2]; &#125; ans++;//次数加1 perm = move(arr); //如果不相等，重复上面操作直到相等，返回操作次数 if(perm == collation)&#123; break; &#125; &#125; return ans; &#125;&#125;; 复杂度分析： 时间复杂度：O(n^2)，其中 n 表示给定的元素。根据方法二的推论可以知道最多需要经过 nn 次变换即可回到初始状态，每次变换需要的时间复杂度为 O(n)，因此总的时间复杂度为 O(n^2)。 空间复杂度：O(n)，其中 n 表示给定的元素。我们需要存储每次变换中的过程变量，需要的空间为 O(n)。","categories":[{"name":"每日LeetCode","slug":"每日LeetCode","permalink":"http://example.com/categories/%E6%AF%8F%E6%97%A5LeetCode/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"}]},{"title":"(每日LeetCode)2185. 统计包含给定前缀的字符串","slug":"每日LeetCode/2023-1/2185 统计包含给定前缀的字符串","date":"2023-01-08T02:39:00.000Z","updated":"2023-01-08T02:39:21.315Z","comments":true,"path":"2023/01/08/每日LeetCode/2023-1/2185 统计包含给定前缀的字符串/","link":"","permalink":"http://example.com/2023/01/08/%E6%AF%8F%E6%97%A5LeetCode/2023-1/2185%20%E7%BB%9F%E8%AE%A1%E5%8C%85%E5%90%AB%E7%BB%99%E5%AE%9A%E5%89%8D%E7%BC%80%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2/","excerpt":"","text":"题目：给你一个字符串数组 words 和一个字符串 pref 。 返回 words 中以 pref 作为 前缀 的字符串的数目。 字符串 s 的 前缀 就是 s 的任一前导连续字符串。 示例： 输入：words &#x3D; [“pay”,”attention”,”practice”,”attend”], pref &#x3D; “at”输出：2解释：以 “at” 作为前缀的字符串有两个，分别是：”attention” 和 “attend” 。 代码(cpp)：1234567891011121314151617class Solution &#123;public: int prefixCount(vector&lt;string&gt;&amp; words, string pref) &#123; int ans = words.size(); for(auto&amp; word : words)&#123; for(int i = 0; i &lt; pref.size(); i++)&#123; if(word[i] != pref[i])&#123; ans--; break; &#125; &#125; &#125; return ans; &#125;&#125;; 复杂度分析： 时间复杂度：O(n*m)，n为words的长度，m为pref的长度 空间复杂度：O(1)","categories":[{"name":"每日LeetCode","slug":"每日LeetCode","permalink":"http://example.com/categories/%E6%AF%8F%E6%97%A5LeetCode/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"}]},{"title":"(每日LeetCode)1658. 将 x 减到 0 的最小操作数","slug":"每日LeetCode/2023-1/1658 将 x 减到 0 的最小操作数","date":"2023-01-07T03:52:00.000Z","updated":"2023-01-07T03:52:51.119Z","comments":true,"path":"2023/01/07/每日LeetCode/2023-1/1658 将 x 减到 0 的最小操作数/","link":"","permalink":"http://example.com/2023/01/07/%E6%AF%8F%E6%97%A5LeetCode/2023-1/1658%20%E5%B0%86%20x%20%E5%87%8F%E5%88%B0%200%20%E7%9A%84%E6%9C%80%E5%B0%8F%E6%93%8D%E4%BD%9C%E6%95%B0/","excerpt":"","text":"题目：给你一个整数数组 nums 和一个整数 x 。每一次操作时，你应当移除数组 nums 最左边或最右边的元素，然后从 x 中减去该元素的值。请注意，需要 修改 数组以供接下来的操作使用。 如果可以将 x 恰好 减到 0 ，返回 最小操作数 ；否则，返回 -1 。 示例： 输入：nums &#x3D; [1,1,4,2,3], x &#x3D; 5输出：2解释：最佳解决方案是移除后两个元素，将 x 减到 0 。 思路：滑动窗口计算出nums数组的总和sum，数组nums的元素个数为n 初始化指针left &#x3D; -1, right &#x3D; 0 初始化左边的总和lSum为0(left为-1，没有元素)，右边的总和rSum为sum(right为0开始，n-0即为sum) 以nums = [2,1,4,1,3], x = 5示例： 只要lSum+rSum &gt; x，就需要rSum减去nums[right]，right指针+1移动到下一位置，依次往复 直到lSum+rSum &gt; x条件不成立： 存在lSum+rSum == x的情况，得到操作次数((left+1)+(n-right)) 存在lSum+rSum &lt; x的情况，就说明右边的总和不能恰好等于x，就需要加上左边的元素 过程： 起始：left &#x3D; -1，lSum &#x3D; 0； rSum &#x3D; sum &#x3D; 11，right &#x3D; 0 left &#x3D; -1，lSum &#x3D; 0； rSum &#x3D; 11-nums[right] &#x3D; 9，right &#x3D; 1 left &#x3D; -1，lSum &#x3D; 0； rSum &#x3D; 9-nums[right] &#x3D; 8，right &#x3D; 2 left &#x3D; -1，lSum &#x3D; 0； rSum &#x3D; 8-nums[right] &#x3D; 4，right &#x3D; 3 此时存在lSum+rSum &lt; x的情况，left &#x3D; left+1 &#x3D; 0，lSum &#x3D; 0+nums[left] &#x3D; 2 此时状态：left &#x3D; 0，lSum &#x3D; 2； rSum &#x3D; 4，right &#x3D; 3 left &#x3D; 0，lSum &#x3D; 2； rSum &#x3D; 4-nums[right] &#x3D; 3，right &#x3D; 4 此时存在lSum+rSum == x的情况，获得操作次数ans &#x3D; (left+1)+(n-right) &#x3D; 2 代码(cpp)：123456789101112131415161718192021222324252627282930class Solution &#123;public: int minOperations(vector&lt;int&gt;&amp; nums, int x) &#123; int n = nums.size(); int sum = accumulate(nums.begin(), nums.end(), 0); if(sum &lt; x) return -1; int lSum = 0; int rSum = sum; int right = 0; int ans = n+1; for(int left = -1; left &lt; n; left++)&#123; if(left != -1) lSum += nums[left]; while(right &lt; n &amp;&amp; lSum + rSum &gt; x) rSum -= nums[right++]; if(lSum + rSum == x) ans = min(ans, (left + 1) + (n - right)); &#125; if(ans &gt; n) ans = -1; return ans; &#125;&#125;; 复杂度分析： 时间复杂度：O(n) 空间复杂度：O(1)","categories":[{"name":"每日LeetCode","slug":"每日LeetCode","permalink":"http://example.com/categories/%E6%AF%8F%E6%97%A5LeetCode/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"}]},{"title":"(每日LeetCode)2180. 统计各位数字之和为偶数的整数个数","slug":"每日LeetCode/2023-1/2180 统计各位数字之和为偶数的整数个数","date":"2023-01-06T03:41:00.000Z","updated":"2023-01-06T03:41:44.363Z","comments":true,"path":"2023/01/06/每日LeetCode/2023-1/2180 统计各位数字之和为偶数的整数个数/","link":"","permalink":"http://example.com/2023/01/06/%E6%AF%8F%E6%97%A5LeetCode/2023-1/2180%20%E7%BB%9F%E8%AE%A1%E5%90%84%E4%BD%8D%E6%95%B0%E5%AD%97%E4%B9%8B%E5%92%8C%E4%B8%BA%E5%81%B6%E6%95%B0%E7%9A%84%E6%95%B4%E6%95%B0%E4%B8%AA%E6%95%B0/","excerpt":"","text":"题目：给你一个正整数 num ，请你统计并返回 小于或等于 num 且各位数字之和为 偶数 的正整数的数目。 正整数的 各位数字之和 是其所有位上的对应数字相加的结果。 示例： 输入：num &#x3D; 30输出：14解释：只有 14 个整数满足小于等于 30 且各位数字之和为偶数，分别是：2、4、6、8、11、13、15、17、19、20、22、24、26 和 28 。 例如13，各位上之和为：1+3 &#x3D; 4，结果为偶数 代码(cpp)：1234567891011121314151617181920class Solution &#123;public: int countEven(int num) &#123; int ans = 0; for(int i = 2; i &lt;= num; i++)&#123; int sum = 0; int temp = i; while(temp)&#123; sum += temp%10; temp /= 10; &#125; if(sum%2 == 0)&#123; ans++; &#125; &#125; return ans; &#125;&#125;; 复杂度分析： 时间复杂度：O(num×lognum)。我们总共需要枚举 num 个正整数，而判断每个正整数的各位数字之和是否为偶数需要 O(lognum) 的时间复杂度。 空间复杂度：O(1)","categories":[{"name":"每日LeetCode","slug":"每日LeetCode","permalink":"http://example.com/categories/%E6%AF%8F%E6%97%A5LeetCode/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"}]},{"title":"(每日LeetCode)2042. 检查句子中的数字是否递增","slug":"每日LeetCode/2023-1/2042 检查句子中的数字是否递增","date":"2023-01-03T04:46:00.000Z","updated":"2023-01-03T04:49:54.836Z","comments":true,"path":"2023/01/03/每日LeetCode/2023-1/2042 检查句子中的数字是否递增/","link":"","permalink":"http://example.com/2023/01/03/%E6%AF%8F%E6%97%A5LeetCode/2023-1/2042%20%E6%A3%80%E6%9F%A5%E5%8F%A5%E5%AD%90%E4%B8%AD%E7%9A%84%E6%95%B0%E5%AD%97%E6%98%AF%E5%90%A6%E9%80%92%E5%A2%9E/","excerpt":"","text":"题目：句子是由若干 token 组成的一个列表，token 间用 单个 空格分隔，句子没有前导或尾随空格。每个 token 要么是一个由数字 0-9 组成的不含前导零的 正整数 ，要么是一个由小写英文字母组成的 单词 。 示例，”a puppy has 2 eyes 4 legs” 是一个由 7 个 token 组成的句子：”2” 和 “4” 是数字，其他像 “puppy” 这样的 tokens 属于单词。给你一个表示句子的字符串 s ，你需要检查 s 中的 全部 数字是否从左到右严格递增（即，除了最后一个数字，s 中的 每个 数字都严格小于它 右侧 的数字）。 如果满足题目要求，返回 true ，否则，返回 false 。 示例： 输入：s &#x3D; “1 box has 3 blue 4 red 6 green and 12 yellow marbles”输出：true解释：句子中的数字是：1, 3, 4, 6, 12 。这些数字是按从左到右严格递增的 1 &lt; 3 &lt; 4 &lt; 6 &lt; 12 。 代码(cpp)：123456789101112131415161718192021222324252627class Solution &#123;public: bool areNumbersAscending(string s) &#123; int pre = -1; int pos = 0; while(pos &lt; s.size())&#123; if(isdigit(s[pos]))&#123; int num = 0; while(pos &lt; s.size() &amp;&amp; isdigit(s[pos]))&#123; num = num*10 + s[pos]-&#x27;0&#x27;; pos++; &#125; if(num &gt; pre)&#123; pre = num; num = 0; &#125; else&#123; return 0; &#125; &#125; pos++; &#125; return 1; &#125;&#125;; 复杂度分析： 时间复杂度：O(n) 空间复杂度：O(1)","categories":[{"name":"每日LeetCode","slug":"每日LeetCode","permalink":"http://example.com/categories/%E6%AF%8F%E6%97%A5LeetCode/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"}]},{"title":"(每日LeetCode)2351. 第一个出现两次的字母","slug":"每日LeetCode/2023-1/2351 第一个出现两次的字母","date":"2023-01-01T02:42:00.000Z","updated":"2023-01-01T02:42:37.305Z","comments":true,"path":"2023/01/01/每日LeetCode/2023-1/2351 第一个出现两次的字母/","link":"","permalink":"http://example.com/2023/01/01/%E6%AF%8F%E6%97%A5LeetCode/2023-1/2351%20%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%87%BA%E7%8E%B0%E4%B8%A4%E6%AC%A1%E7%9A%84%E5%AD%97%E6%AF%8D/","excerpt":"","text":"题目：给你一个由小写英文字母组成的字符串 s ，请你找出并返回第一个出现 两次 的字母。 注意： 如果 a 的 第二次 出现比 b 的 第二次 出现在字符串中的位置更靠前，则认为字母 a 在字母 b 之前出现两次。s 包含至少一个出现两次的字母。 示例： 输入：s &#x3D; “abccbaacz”输出：”c”解释：字母 ‘a’ 在下标 0 、5 和 6 处出现。字母 ‘b’ 在下标 1 和 4 处出现。字母 ‘c’ 在下标 2 、3 和 7 处出现。字母 ‘z’ 在下标 8 处出现。字母 ‘c’ 是第一个出现两次的字母，因为在所有字母中，’c’ 第二次出现的下标是最小的。 代码(cpp)：哈希表12345678910111213class Solution &#123;public: char repeatedCharacter(string s) &#123; vector&lt;int&gt; map(26); for(auto&amp; c : s)&#123; if(++map[c-&#x27;a&#x27;] == 2)&#123; return c; &#125; &#125; return &#x27;?&#x27;; &#125;&#125;; 复杂度分析： 时间复杂度：O(n) 空间复杂度：O(26)","categories":[{"name":"每日LeetCode","slug":"每日LeetCode","permalink":"http://example.com/categories/%E6%AF%8F%E6%97%A5LeetCode/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"}]},{"title":"(每日LeetCode)2037. 使每位学生都有座位的最少移动次数","slug":"每日LeetCode/2022-12/2037 使每位学生都有座位的最少移动次数","date":"2022-12-31T01:38:00.000Z","updated":"2022-12-31T01:38:26.755Z","comments":true,"path":"2022/12/31/每日LeetCode/2022-12/2037 使每位学生都有座位的最少移动次数/","link":"","permalink":"http://example.com/2022/12/31/%E6%AF%8F%E6%97%A5LeetCode/2022-12/2037%20%E4%BD%BF%E6%AF%8F%E4%BD%8D%E5%AD%A6%E7%94%9F%E9%83%BD%E6%9C%89%E5%BA%A7%E4%BD%8D%E7%9A%84%E6%9C%80%E5%B0%91%E7%A7%BB%E5%8A%A8%E6%AC%A1%E6%95%B0/","excerpt":"","text":"题目：一个房间里有 n 个座位和 n 名学生，房间用一个数轴表示。给你一个长度为 n 的数组 seats ，其中 seats[i] 是第 i 个座位的位置。同时给你一个长度为 n 的数组 students ，其中 students[j] 是第 j 位学生的位置。 你可以执行以下操作任意次： 增加或者减少第 i 位学生的位置，每次变化量为 1 （也就是将第 i 位学生从位置 x 移动到 x + 1 或者 x - 1）请你返回使所有学生都有座位坐的 最少移动次数 ，并确保没有两位学生的座位相同。 请注意，初始时有可能有多个座位或者多位学生在 同一 位置。 示例： 输入：seats &#x3D; [3,1,5], students &#x3D; [2,7,4]输出：4解释：学生移动方式如下： 第一位学生从位置 2 移动到位置 1 ，移动 1 次。 第二位学生从位置 7 移动到位置 5 ，移动 2 次。 第三位学生从位置 4 移动到位置 3 ，移动 1 次。 总共 1 + 2 + 1 &#x3D; 4 次移动。 思路：排序因为座位seats和学生students都是相同长度n，所以一定是一一对应的 将seats和students分别排序，seats[i]和studentsp[i]之间的移动距离一定是最近的 代码(cpp)：1234567891011121314class Solution &#123;public: int minMovesToSeat(vector&lt;int&gt;&amp; seats, vector&lt;int&gt;&amp; students) &#123; sort(seats.begin(), seats.end()); sort(students.begin(), students.end()); int ans = 0; for(int i = 0; i &lt; students.size(); i++)&#123; ans += abs(seats[i]-students[i]); &#125; return ans; &#125;&#125;; 复杂度分析： 时间复杂度：O(n) 空间复杂度：O(1)","categories":[{"name":"每日LeetCode","slug":"每日LeetCode","permalink":"http://example.com/categories/%E6%AF%8F%E6%97%A5LeetCode/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"}]},{"title":"(每日LeetCode)2032. 至少在两个数组中出现的值","slug":"每日LeetCode/2022-12/2032 至少在两个数组中出现的值","date":"2022-12-29T02:54:00.000Z","updated":"2022-12-29T02:55:11.113Z","comments":true,"path":"2022/12/29/每日LeetCode/2022-12/2032 至少在两个数组中出现的值/","link":"","permalink":"http://example.com/2022/12/29/%E6%AF%8F%E6%97%A5LeetCode/2022-12/2032%20%E8%87%B3%E5%B0%91%E5%9C%A8%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E4%B8%AD%E5%87%BA%E7%8E%B0%E7%9A%84%E5%80%BC/","excerpt":"","text":"题目：给你三个整数数组 nums1、nums2 和 nums3 ，请你构造并返回一个 元素各不相同的 数组，且由 至少 在 两个 数组中出现的所有值组成。数组中的元素可以按 任意 顺序排列。 示例： 输入：nums1 &#x3D; [1,1,3,2], nums2 &#x3D; [2,3], nums3 &#x3D; [3]输出：[3,2]解释：至少在两个数组中出现的所有值为： – 3 ，在全部三个数组中都出现过。 – 2 ，在数组 nums1 和 nums2 中出现过。 代码(cpp)：哈希表+二进制1234567891011121314151617181920212223242526class Solution &#123;public: vector&lt;int&gt; twoOutOfThree(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2, vector&lt;int&gt;&amp; nums3) &#123; unordered_map&lt;int, int&gt; map; for(auto&amp; num : nums1)&#123; map[num] |= 1; &#125; for(auto&amp; num : nums2)&#123; map[num] |= 2; &#125; for(auto&amp; num : nums3)&#123; map[num] |= 4; &#125; vector&lt;int&gt; ans; for(auto&amp; [num, count] : map)&#123; //111 101 110 011四种可能 if(count == 3 || count &gt; 4)&#123; ans.emplace_back(num); &#125; &#125; return ans; &#125;&#125;; 复杂度分析： 时间复杂度：O(nums1+nums2+nums3) 空间复杂度：O(nums1+nums2+nums3)","categories":[{"name":"每日LeetCode","slug":"每日LeetCode","permalink":"http://example.com/categories/%E6%AF%8F%E6%97%A5LeetCode/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"}]},{"title":"(每日LeetCode)1750. 删除字符串两端相同字符后的最短长度","slug":"每日LeetCode/2022-12/1750 删除字符串两端相同字符后的最短长度","date":"2022-12-28T02:58:00.000Z","updated":"2022-12-28T02:58:16.230Z","comments":true,"path":"2022/12/28/每日LeetCode/2022-12/1750 删除字符串两端相同字符后的最短长度/","link":"","permalink":"http://example.com/2022/12/28/%E6%AF%8F%E6%97%A5LeetCode/2022-12/1750%20%E5%88%A0%E9%99%A4%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%A4%E7%AB%AF%E7%9B%B8%E5%90%8C%E5%AD%97%E7%AC%A6%E5%90%8E%E7%9A%84%E6%9C%80%E7%9F%AD%E9%95%BF%E5%BA%A6/","excerpt":"","text":"题目：给你一个只包含字符 ‘a’，’b’ 和 ‘c’ 的字符串 s ，你可以执行下面这个操作（5 个步骤）任意次： 选择字符串 s 一个 非空 的前缀，这个前缀的所有字符都相同。选择字符串 s 一个 非空 的后缀，这个后缀的所有字符都相同。前缀和后缀在字符串中任意位置都不能有交集。前缀和后缀包含的所有字符都要相同。同时删除前缀和后缀。请你返回对字符串 s 执行上面操作任意次以后（可能 0 次），能得到的 最短长度 。 示例： 输入：s &#x3D; “aabccabba”输出：3解释：最优操作序列为： 选择前缀 “aa” 和后缀 “a” 并删除它们，得到 s &#x3D; “bccabb” 。 选择前缀 “b” 和后缀 “bb” 并删除它们，得到 s &#x3D; “cca” 。 代码(cpp)：双指针12345678910111213141516171819class Solution &#123;public: int minimumLength(string s) &#123; int left = 0; int right = s.size()-1; //如果前缀和后缀相同 while(left &lt; right &amp;&amp; s[left] == s[right])&#123; auto temp = s[left]; //寻找和前缀相同并且连续的字符 while(left &lt;= right &amp;&amp; s[left] == temp) left++; //寻找和后缀相同并且连续的字符 while(left &lt;= right &amp;&amp; s[right] == temp) right--; &#125; return right-left+1; &#125;&#125;; 复杂度分析： 时间复杂度：O(n) 空间复杂度：O(1)","categories":[{"name":"每日LeetCode","slug":"每日LeetCode","permalink":"http://example.com/categories/%E6%AF%8F%E6%97%A5LeetCode/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"}]},{"title":"(每日LeetCode)2027. 转换字符串的最少操作次数","slug":"每日LeetCode/2022-12/2027 转换字符串的最少操作次数","date":"2022-12-27T00:38:00.000Z","updated":"2022-12-27T00:38:52.483Z","comments":true,"path":"2022/12/27/每日LeetCode/2022-12/2027 转换字符串的最少操作次数/","link":"","permalink":"http://example.com/2022/12/27/%E6%AF%8F%E6%97%A5LeetCode/2022-12/2027%20%E8%BD%AC%E6%8D%A2%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%9C%80%E5%B0%91%E6%93%8D%E4%BD%9C%E6%AC%A1%E6%95%B0/","excerpt":"","text":"题目：给你一个字符串 s ，由 n 个字符组成，每个字符不是 ‘X’ 就是 ‘O’ 。 一次 操作 定义为从 s 中选出 三个连续字符 并将选中的每个字符都转换为 ‘O’ 。注意，如果字符已经是 ‘O’ ，只需要保持 不变 。 返回将 s 中所有字符均转换为 ‘O’ 需要执行的 最少 操作次数。 示例： 输入：s &#x3D; “XXOX”输出：2解释：XXOX -&gt; OOOX -&gt; OOOO第一次操作，选择前 3 个字符，并将这些字符转换为 ‘O’ 。然后，选中后 3 个字符，并执行转换。最终得到的字符串全由字符 ‘O’ 组成。 代码(cpp)：1234567891011121314class Solution &#123;public: int minimumMoves(string s) &#123; int ans = 0; for(int i = 0; i &lt; s.size(); i++)&#123; if(s[i] == &#x27;X&#x27;)&#123; ans++; i += 2; &#125; &#125; return ans; &#125;&#125;; 复杂度分析： 时间复杂度：O(n) 空间复杂度：O(1)","categories":[{"name":"每日LeetCode","slug":"每日LeetCode","permalink":"http://example.com/categories/%E6%AF%8F%E6%97%A5LeetCode/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"}]},{"title":"(每日LeetCode)1759. 统计同构子字符串的数目","slug":"每日LeetCode/2022-12/1759 统计同构子字符串的数目","date":"2022-12-26T02:26:00.000Z","updated":"2022-12-26T02:26:35.703Z","comments":true,"path":"2022/12/26/每日LeetCode/2022-12/1759 统计同构子字符串的数目/","link":"","permalink":"http://example.com/2022/12/26/%E6%AF%8F%E6%97%A5LeetCode/2022-12/1759%20%E7%BB%9F%E8%AE%A1%E5%90%8C%E6%9E%84%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%95%B0%E7%9B%AE/","excerpt":"","text":"题目：给你一个字符串 s ，返回 s 中 同构子字符串 的数目。由于答案可能很大，只需返回对 109 + 7 取余 后的结果。 同构字符串 的定义为：如果一个字符串中的所有字符都相同，那么该字符串就是同构字符串。 子字符串 是字符串中的一个连续字符序列。 示例： 输入：s &#x3D; “abbcccaa”输出：13解释：同构子字符串如下所列：“a” 出现 3 次。“aa” 出现 1 次。“b” 出现 2 次。“bb” 出现 1 次。“c” 出现 3 次。“cc” 出现 2 次。“ccc” 出现 1 次。3 + 1 + 2 + 1 + 3 + 2 + 1 &#x3D; 13 思路：双指针遍历获得的每个字符串相同的子串的字符个数 通过公式：$m×(m+1)&#x2F;2$，计算出现的次数 代码(cpp)：123456789101112131415161718class Solution &#123;public: int countHomogenous(string s) &#123; long mod = 1e9 + 7; long ans = 0; int left = 0; for(int i = 0; i &lt; s.size()+1; i++)&#123; if(i == s.size() || s[left] != s[i])&#123; long temp = i-left; ans = (ans + (temp+1)*temp/2) % mod; left = i; &#125; &#125; return ans ; &#125;&#125;; 复杂度分析： 时间复杂度：O(n) 空间复杂度：O(1)","categories":[{"name":"每日LeetCode","slug":"每日LeetCode","permalink":"http://example.com/categories/%E6%AF%8F%E6%97%A5LeetCode/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"}]},{"title":"(每日LeetCode)1753. 移除石子的最大得分","slug":"每日LeetCode/2022-12/1753 移除石子的最大得分","date":"2022-12-21T04:29:00.000Z","updated":"2022-12-21T04:29:26.553Z","comments":true,"path":"2022/12/21/每日LeetCode/2022-12/1753 移除石子的最大得分/","link":"","permalink":"http://example.com/2022/12/21/%E6%AF%8F%E6%97%A5LeetCode/2022-12/1753%20%E7%A7%BB%E9%99%A4%E7%9F%B3%E5%AD%90%E7%9A%84%E6%9C%80%E5%A4%A7%E5%BE%97%E5%88%86/","excerpt":"","text":"题目：你正在玩一个单人游戏，面前放置着大小分别为 a、b 和 c 的 三堆 石子。 每回合你都要从两个 不同的非空堆 中取出一颗石子，并在得分上加 1 分。当存在 两个或更多 的空堆时，游戏停止。 给你三个整数 a 、b 和 c ，返回可以得到的 最大分数 。 示例： 输入：a &#x3D; 4, b &#x3D; 4, c &#x3D; 6输出：7解释：石子起始状态是 (4, 4, 6) ，最优的一组操作是： 从第一和第二堆取，石子状态现在是 (3, 3, 6) 从第一和第三堆取，石子状态现在是 (2, 3, 5) 从第一和第三堆取，石子状态现在是 (1, 3, 4) 从第一和第三堆取，石子状态现在是 (0, 3, 3) 从第二和第三堆取，石子状态现在是 (0, 2, 2) 从第二和第三堆取，石子状态现在是 (0, 1, 1) 从第二和第三堆取，石子状态现在是 (0, 0, 0) 总分：7 分 。 代码(cpp)：贪心1234567891011121314151617class Solution &#123;public: int maximumScore(int a, int b, int c) &#123; int ans = 0; vector&lt;int&gt; v&#123;a, b, c&#125;; sort(v.begin(), v.end()); //每次选择最大的两个堆取 while(v[1] != 0)&#123; ans++; v[1]--; v[2]--; sort(v.begin(), v.end()); &#125; return ans; &#125;&#125;; 复杂度分析： 时间复杂度：O(n) 空间复杂度：O(1)","categories":[{"name":"每日LeetCode","slug":"每日LeetCode","permalink":"http://example.com/categories/%E6%AF%8F%E6%97%A5LeetCode/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"}]},{"title":"(每日LeetCode)1785. 构成特定和需要添加的最少元素","slug":"每日LeetCode/2022-12/1785 构成特定和需要添加的最少元素","date":"2022-12-16T06:22:00.000Z","updated":"2022-12-16T06:23:01.643Z","comments":true,"path":"2022/12/16/每日LeetCode/2022-12/1785 构成特定和需要添加的最少元素/","link":"","permalink":"http://example.com/2022/12/16/%E6%AF%8F%E6%97%A5LeetCode/2022-12/1785%20%E6%9E%84%E6%88%90%E7%89%B9%E5%AE%9A%E5%92%8C%E9%9C%80%E8%A6%81%E6%B7%BB%E5%8A%A0%E7%9A%84%E6%9C%80%E5%B0%91%E5%85%83%E7%B4%A0/","excerpt":"","text":"题目：给你一个整数数组 nums ，和两个整数 limit 与 goal 。数组 nums 有一条重要属性：abs(nums[i]) &lt;= limit 。 返回使数组元素总和等于 goal 所需要向数组中添加的 最少元素数量 ，添加元素 不应改变 数组中 abs(nums[i]) &lt;= limit 这一属性。 注意，如果 x &gt;= 0 ，那么 abs(x) 等于 x ；否则，等于 -x 。 示例： 输入：nums &#x3D; [1,-1,1], limit &#x3D; 3, goal &#x3D; -4输出：2解释：可以将 -2 和 -3 添加到数组中，数组的元素总和变为 1 - 1 + 1 - 2 - 3 &#x3D; -4 。 代码(cpp)：1234567891011121314class Solution &#123;public: int minElements(vector&lt;int&gt;&amp; nums, int limit, int goal) &#123; long sum = 0; for(auto&amp; num : nums)&#123; sum += num; &#125; long temp = abs(sum-goal); if(temp%limit == 0)&#123; return abs(sum-goal)/limit; &#125; return abs(sum-goal)/limit + 1; &#125;&#125;; 复杂度分析： 时间复杂度：O(n) 空间复杂度：O(1)","categories":[{"name":"每日LeetCode","slug":"每日LeetCode","permalink":"http://example.com/categories/%E6%AF%8F%E6%97%A5LeetCode/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"}]},{"title":"(每日LeetCode)1945. 字符串转化后的各位数字之和","slug":"每日LeetCode/2022-12/1945 字符串转化后的各位数字之和","date":"2022-12-15T07:49:00.000Z","updated":"2022-12-15T07:50:01.296Z","comments":true,"path":"2022/12/15/每日LeetCode/2022-12/1945 字符串转化后的各位数字之和/","link":"","permalink":"http://example.com/2022/12/15/%E6%AF%8F%E6%97%A5LeetCode/2022-12/1945%20%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E5%8C%96%E5%90%8E%E7%9A%84%E5%90%84%E4%BD%8D%E6%95%B0%E5%AD%97%E4%B9%8B%E5%92%8C/","excerpt":"","text":"题目：给你一个由小写字母组成的字符串 s ，以及一个整数 k 。 首先，用字母在字母表中的位置替换该字母，将 s 转化 为一个整数（也就是，&#39;a&#39; 用 1 替换，&#39;b&#39; 用 2 替换，… &#39;z&#39; 用 26 替换）。接着，将整数 转换 为其 各位数字之和 。共重复 转换 操作 k 次 。 例如，如果 s = &quot;zbax&quot; 且 k = 2 ，那么执行下述步骤后得到的结果是整数 8 ： 转化：&quot;zbax&quot; ➝ &quot;(26)(2)(1)(24)&quot; ➝ &quot;262124&quot; ➝ 262124 转换 #1：262124 ➝ 2 + 6 + 2 + 1 + 2 + 4 ➝ 17 转换 #2：17 ➝ 1 + 7 ➝ 8 返回执行上述操作后得到的结果整数。 示例： 输入：s &#x3D; “leetcode”, k &#x3D; 2输出：6解释：操作如下： 转化：”leetcode” ➝ “(12)(5)(5)(20)(3)(15)(4)(5)” ➝ “12552031545” ➝ 12552031545 转换 #1：12552031545 ➝ 1 + 2 + 5 + 5 + 2 + 0 + 3 + 1 + 5 + 4 + 5 ➝ 33 转换 #2：33 ➝ 3 + 3 ➝ 6 因此，结果整数为 6 。 代码(cpp)：123456789101112131415161718192021222324class Solution &#123;public: int getLucky(string s, int k) &#123; int ans = 0; for(auto&amp; c : s)&#123; int temp = c-&#x27;a&#x27;+1; while(temp)&#123; ans += temp%10; temp /= 10; &#125; &#125; for(int i = 0; i &lt; k-1; i++)&#123; int temp = ans; ans = 0; while(temp)&#123; ans += temp%10; temp /= 10; &#125; &#125; return ans; &#125;&#125;; 复杂度分析： 时间复杂度：O(n) 空间复杂度：O(n)","categories":[{"name":"每日LeetCode","slug":"每日LeetCode","permalink":"http://example.com/categories/%E6%AF%8F%E6%97%A5LeetCode/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"}]},{"title":"(每日LeetCode)2011. 执行操作后的变量值","slug":"每日LeetCode/2022-12/2011 执行操作后的变量值","date":"2022-12-15T07:49:00.000Z","updated":"2022-12-23T01:48:14.895Z","comments":true,"path":"2022/12/15/每日LeetCode/2022-12/2011 执行操作后的变量值/","link":"","permalink":"http://example.com/2022/12/15/%E6%AF%8F%E6%97%A5LeetCode/2022-12/2011%20%E6%89%A7%E8%A1%8C%E6%93%8D%E4%BD%9C%E5%90%8E%E7%9A%84%E5%8F%98%E9%87%8F%E5%80%BC/","excerpt":"","text":"题目：存在一种仅支持 4 种操作和 1 个变量 X 的编程语言： ++X 和 X++ 使变量 X 的值 加 1 --X 和 X-- 使变量 X 的值 减 1 最初，X 的值是 0 给你一个字符串数组 operations ，这是由操作组成的一个列表，返回执行所有操作后， X 的 最终值 。 示例： 输入：operations &#x3D; [“–X”,”X++”,”X++”]输出：1解释：操作按下述步骤执行：最初，X &#x3D; 0–X：X 减 1 ，X &#x3D; 0 - 1 &#x3D; -1X++：X 加 1 ，X &#x3D; -1 + 1 &#x3D; 0X++：X 加 1 ，X &#x3D; 0 + 1 &#x3D; 1 代码(cpp)：1234567891011121314class Solution &#123;public: int finalValueAfterOperations(vector&lt;string&gt;&amp; operations) &#123; int x = 0; for(auto&amp; operation : operations)&#123; if(operation[1] == &#x27;+&#x27;) x++; else x--; &#125; return x; &#125;&#125;; 复杂度分析： 时间复杂度：O(n) 空间复杂度：O(1)","categories":[{"name":"每日LeetCode","slug":"每日LeetCode","permalink":"http://example.com/categories/%E6%AF%8F%E6%97%A5LeetCode/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"}]},{"title":"(每日LeetCode)1971. 寻找图中是否存在路径","slug":"每日LeetCode/2022-12/1971 寻找图中是否存在路径","date":"2022-12-15T07:49:00.000Z","updated":"2022-12-19T01:02:49.835Z","comments":true,"path":"2022/12/15/每日LeetCode/2022-12/1971 寻找图中是否存在路径/","link":"","permalink":"http://example.com/2022/12/15/%E6%AF%8F%E6%97%A5LeetCode/2022-12/1971%20%E5%AF%BB%E6%89%BE%E5%9B%BE%E4%B8%AD%E6%98%AF%E5%90%A6%E5%AD%98%E5%9C%A8%E8%B7%AF%E5%BE%84/","excerpt":"","text":"题目：有一个具有 n 个顶点的 双向 图，其中每个顶点标记从 0 到 n - 1（包含 0 和 n - 1）。图中的边用一个二维整数数组 edges 表示，其中 edges[i] = [ui, vi] 表示顶点 ui 和顶点 vi 之间的双向边。 每个顶点对由 最多一条 边连接，并且没有顶点存在与自身相连的边。 请你确定是否存在从顶点 source 开始，到顶点 destination 结束的 有效路径 。 给你数组 edges 和整数 n、source 和 destination，如果从 source 到 destination 存在 有效路径 ，则返回 true，否则返回 false 。 示例： 输入：n &#x3D; 6, edges &#x3D; [[0,1],[0,2],[3,5],[5,4],[4,3]], source &#x3D; 0, destination &#x3D; 5输出：false解释：不存在由顶点 0 到顶点 5 的路径. 代码(cpp)：BFS1234567891011121314151617181920212223242526272829303132333435class Solution &#123;public: bool validPath(int n, vector&lt;vector&lt;int&gt;&gt;&amp; edges, int source, int destination) &#123; if(source == destination)&#123; return true; &#125; vector&lt;vector&lt;int&gt;&gt; dp(n); for(int i = 0; i &lt; edges.size(); i++)&#123; dp[edges[i][0]].emplace_back(edges[i][1]); dp[edges[i][1]].emplace_back(edges[i][0]); &#125; queue&lt;int&gt; queue; queue.emplace(source); vector&lt;bool&gt; flag(n, false); while(!queue.empty())&#123; auto cur = queue.front(); queue.pop(); for(int i = 0; i &lt; dp[cur].size(); i++)&#123; int temp = dp[cur][i]; if(temp == destination)&#123; return true; &#125; if(!flag[temp])&#123; queue.emplace(temp); flag[temp] = true; &#125; &#125; &#125; return false; &#125;&#125;; 复杂度分析： 时间复杂度：O(n+m)，其中 n 表示图中顶点的数目，m 表示图中边的数目 空间复杂度：O(n+m)","categories":[{"name":"每日LeetCode","slug":"每日LeetCode","permalink":"http://example.com/categories/%E6%AF%8F%E6%97%A5LeetCode/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"}]},{"title":"(每日LeetCode)1832. 判断句子是否为全字母句","slug":"每日LeetCode/2022-12/1832 判断句子是否为全字母句","date":"2022-12-13T02:53:00.000Z","updated":"2022-12-13T02:54:02.205Z","comments":true,"path":"2022/12/13/每日LeetCode/2022-12/1832 判断句子是否为全字母句/","link":"","permalink":"http://example.com/2022/12/13/%E6%AF%8F%E6%97%A5LeetCode/2022-12/1832%20%E5%88%A4%E6%96%AD%E5%8F%A5%E5%AD%90%E6%98%AF%E5%90%A6%E4%B8%BA%E5%85%A8%E5%AD%97%E6%AF%8D%E5%8F%A5/","excerpt":"","text":"题目：全字母句 指包含英语字母表中每个字母至少一次的句子。 给你一个仅由小写英文字母组成的字符串 sentence ，请你判断 sentence 是否为 全字母句 。 如果是，返回 true ；否则，返回 false 。 示例： 输入：sentence &#x3D; “thequickbrownfoxjumpsoverthelazydog”输出：true解释：sentence 包含英语字母表中每个字母至少一次。 代码(cpp)：12345678910111213141516class Solution &#123;public: bool checkIfPangram(string sentence) &#123; if(sentence.size() &lt; 26) return false; vector&lt;int&gt; map(26); int count = 0; for(int i = 0; i &lt;sentence.size(); i++)&#123; if(map[sentence[i]-&#x27;a&#x27;]++ == 0) count++; &#125; return count == 26; &#125;&#125;; 复杂度分析： 时间复杂度：O(n) 空间复杂度：O(C)，C为26字母","categories":[{"name":"每日LeetCode","slug":"每日LeetCode","permalink":"http://example.com/categories/%E6%AF%8F%E6%97%A5LeetCode/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"}]},{"title":"(每日LeetCode)1781. 所有子字符串美丽值之和","slug":"每日LeetCode/2022-12/1781 所有子字符串美丽值之和","date":"2022-12-12T02:40:00.000Z","updated":"2022-12-12T02:40:11.784Z","comments":true,"path":"2022/12/12/每日LeetCode/2022-12/1781 所有子字符串美丽值之和/","link":"","permalink":"http://example.com/2022/12/12/%E6%AF%8F%E6%97%A5LeetCode/2022-12/1781%20%E6%89%80%E6%9C%89%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%BE%8E%E4%B8%BD%E5%80%BC%E4%B9%8B%E5%92%8C/","excerpt":"","text":"题目：一个字符串的 美丽值 定义为：出现频率最高字符与出现频率最低字符的出现次数之差。 比方说，&quot;abaacc&quot; 的美丽值为 3 - 1 = 2 。 给你一个字符串 s ，请你返回它所有子字符串的 美丽值 之和。 示例： 输入：s &#x3D; “aabcb”输出：5解释：美丽值不为零的字符串包括 [“aab”,”aabc”,”aabcb”,”abcb”,”bcb”] ，每一个字符串的美丽值都为 1 。 思路：获得s字符串所有的组合 利用哈希表记录字母出现的次数，依次计算相应的美丽值，返回总和 代码(cpp)：12345678910111213141516171819202122232425class Solution &#123;public: int beautySum(string s) &#123; int ans = 0; for(int i = 0; i &lt; s.size(); i++)&#123; //定义字符串的开头 vector&lt;int&gt; map(26); for(int j = i; j &lt; s.size(); j++)&#123; //每一次遍历就是一次字符串的尾部 map[s[j]-&#x27;a&#x27;]++; int maxNum = 0; int minNum = INT_MAX; for(auto&amp; m : map)&#123; //获取当前字符串中字母的出现最大、最小次数 if(m == 0) continue; maxNum = max(maxNum, m); minNum = min(minNum, m); &#125; ans += maxNum-minNum; &#125; &#125; return ans; &#125;&#125;; 复杂度分析： 时间复杂度：O(C*n^2^)，其中 C 是 s 的元素种类，n 是 s 的长度。 空间复杂度：O(C)","categories":[{"name":"每日LeetCode","slug":"每日LeetCode","permalink":"http://example.com/categories/%E6%AF%8F%E6%97%A5LeetCode/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"}]},{"title":"(每日LeetCode)1827. 最少操作使数组递增","slug":"每日LeetCode/2022-12/1827 最少操作使数组递增","date":"2022-12-11T01:44:00.000Z","updated":"2022-12-11T01:44:51.454Z","comments":true,"path":"2022/12/11/每日LeetCode/2022-12/1827 最少操作使数组递增/","link":"","permalink":"http://example.com/2022/12/11/%E6%AF%8F%E6%97%A5LeetCode/2022-12/1827%20%E6%9C%80%E5%B0%91%E6%93%8D%E4%BD%9C%E4%BD%BF%E6%95%B0%E7%BB%84%E9%80%92%E5%A2%9E/","excerpt":"","text":"题目：给你一个整数数组 nums （下标从 0 开始）。每一次操作中，你可以选择数组中一个元素，并将它增加 1 。 比方说，如果 nums &#x3D; [1,2,3] ，你可以选择增加 nums[1] 得到 nums &#x3D; [1,3,3] 。请你返回使 nums 严格递增 的 最少 操作次数。 我们称数组 nums 是 严格递增的 ，当它满足对于所有的 0 &lt;&#x3D; i &lt; nums.length - 1 都有 nums[i] &lt; nums[i+1] 。一个长度为 1 的数组是严格递增的一种特殊情况。 示例： 输入：nums &#x3D; [1,1,1]输出：3解释：你可以进行如下操作： 增加 nums[2] ，数组变为 [1,1,2] 。 增加 nums[1] ，数组变为 [1,2,2] 。 增加 nums[2] ，数组变为 [1,2,3] 。 代码(cpp)：1234567891011121314151617class Solution &#123;public: int minOperations(vector&lt;int&gt;&amp; nums) &#123; if(nums.size() == 1) return 0; int ans = 0; for(int i = 1; i &lt; nums.size(); i++)&#123; if(nums[i] &lt;= nums[i-1])&#123; ans += nums[i-1] - nums[i] + 1; nums[i] = nums[i-1] + 1; &#125; &#125; return ans; &#125;&#125;; 复杂度分析： 时间复杂度：O(n) 空间复杂度：O(1)","categories":[{"name":"每日LeetCode","slug":"每日LeetCode","permalink":"http://example.com/categories/%E6%AF%8F%E6%97%A5LeetCode/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"}]},{"title":"(每日LeetCode)1780. 判断一个数字是否可以表示成三的幂的和","slug":"每日LeetCode/2022-12/1780 判断一个数字是否可以表示成三的幂的和","date":"2022-12-09T01:53:00.000Z","updated":"2022-12-09T01:53:16.295Z","comments":true,"path":"2022/12/09/每日LeetCode/2022-12/1780 判断一个数字是否可以表示成三的幂的和/","link":"","permalink":"http://example.com/2022/12/09/%E6%AF%8F%E6%97%A5LeetCode/2022-12/1780%20%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E6%95%B0%E5%AD%97%E6%98%AF%E5%90%A6%E5%8F%AF%E4%BB%A5%E8%A1%A8%E7%A4%BA%E6%88%90%E4%B8%89%E7%9A%84%E5%B9%82%E7%9A%84%E5%92%8C/","excerpt":"","text":"题目：给你一个整数 n ，如果你可以将 n 表示成若干个不同的三的幂之和，请你返回 true ，否则请返回 false 。 对于一个整数 y ，如果存在整数 x 满足 y &#x3D;&#x3D; 3x ，我们称这个整数 y 是三的幂。 示例： 输入：n &#x3D; 91输出：true解释：91 &#x3D; 3^0^ + 3^2^ + 3^4^ 代码(cpp)：三进制模拟123456789101112class Solution &#123;public: bool checkPowersOfThree(int n) &#123; while(n)&#123; if(n % 3 == 2) //只能存在一种3的幂之和，不能为两个 return false; n /= 3; &#125; return true; &#125;&#125;; 复杂度分析： 时间复杂度：O(logn) 空间复杂度：O(1)","categories":[{"name":"每日LeetCode","slug":"每日LeetCode","permalink":"http://example.com/categories/%E6%AF%8F%E6%97%A5LeetCode/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"}]},{"title":"(每日LeetCode)1812. 判断国际象棋棋盘中一个格子的颜色","slug":"每日LeetCode/2022-12/1812 判断国际象棋棋盘中一个格子的颜色","date":"2022-12-08T00:19:00.000Z","updated":"2022-12-08T00:19:37.526Z","comments":true,"path":"2022/12/08/每日LeetCode/2022-12/1812 判断国际象棋棋盘中一个格子的颜色/","link":"","permalink":"http://example.com/2022/12/08/%E6%AF%8F%E6%97%A5LeetCode/2022-12/1812%20%E5%88%A4%E6%96%AD%E5%9B%BD%E9%99%85%E8%B1%A1%E6%A3%8B%E6%A3%8B%E7%9B%98%E4%B8%AD%E4%B8%80%E4%B8%AA%E6%A0%BC%E5%AD%90%E7%9A%84%E9%A2%9C%E8%89%B2/","excerpt":"","text":"题目：给你一个坐标 coordinates ，它是一个字符串，表示国际象棋棋盘中一个格子的坐标。下图是国际象棋棋盘示意图。 示例： 输入：coordinates &#x3D; “a1”输出：false解释：如上图棋盘所示，”a1” 坐标的格子是黑色的，所以返回 false 。 代码(cpp)：123456class Solution &#123;public: bool squareIsWhite(string coordinates) &#123; return (coordinates[0]+coordinates[1])%2 != 0; &#125;&#125;; 复杂度分析： 时间复杂度：O(1) 空间复杂度：O(1)","categories":[{"name":"每日LeetCode","slug":"每日LeetCode","permalink":"http://example.com/categories/%E6%AF%8F%E6%97%A5LeetCode/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"}]},{"title":"(每日LeetCode)1775. 通过最少操作次数使数组的和相等","slug":"每日LeetCode/2022-12/1775 通过最少操作次数使数组的和相等","date":"2022-12-07T01:33:00.000Z","updated":"2022-12-07T01:34:28.828Z","comments":true,"path":"2022/12/07/每日LeetCode/2022-12/1775 通过最少操作次数使数组的和相等/","link":"","permalink":"http://example.com/2022/12/07/%E6%AF%8F%E6%97%A5LeetCode/2022-12/1775%20%E9%80%9A%E8%BF%87%E6%9C%80%E5%B0%91%E6%93%8D%E4%BD%9C%E6%AC%A1%E6%95%B0%E4%BD%BF%E6%95%B0%E7%BB%84%E7%9A%84%E5%92%8C%E7%9B%B8%E7%AD%89/","excerpt":"","text":"题目：给你两个长度可能不等的整数数组 nums1 和 nums2 。两个数组中的所有值都在 1 到 6 之间（包含 1 和 6）。 每次操作中，你可以选择 任意 数组中的任意一个整数，将它变成 1 到 6 之间 任意 的值（包含 1 和 6）。 请你返回使 nums1 中所有数的和与 nums2 中所有数的和相等的最少操作次数。如果无法使两个数组的和相等，请返回 -1 。 示例： 输入：nums1 &#x3D; [1,2,3,4,5,6], nums2 &#x3D; [1,1,2,2,2,2]输出：3解释：你可以通过 3 次操作使 nums1 中所有数的和与 nums2 中所有数的和相等。以下数组下标都从 0 开始。 将 nums2[0] 变为 6 。 nums1 &#x3D; [1,2,3,4,5,6], nums2 &#x3D; [6,1,2,2,2,2] 。 将 nums1[5] 变为 1 。 nums1 &#x3D; [1,2,3,4,5,1], nums2 &#x3D; [6,1,2,2,2,2] 。 将 nums1[2] 变为 2 。 nums1 &#x3D; [1,2,2,4,5,1], nums2 &#x3D; [6,1,2,2,2,2] 。 思路：贪心分别获取nums1,nums2的总和，选择出最大值max，最小值min 将nums1,nums2排序后， 属于最大值max的数组，从后往前遍历 属于最小值min的数组，从前往后遍历 如果min的数组中的当前元素可以增加量 大于 max的数组中的当前元素可以减小量 min加上增加量 同理，如果小于 max减去减小量 直到 min &gt;&#x3D; max 为止，返回次数 或者增加量、减小量为0时，因为无法在增加或者减小了，返回-1 代码(cpp)：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051class Solution &#123;public: int update(vector&lt;int&gt;&amp; maxNums, vector&lt;int&gt;&amp; minNums, int max, int min)&#123; int maxRight = maxNums.size()-1; int minLeft = 0; int count = 0; while(max &gt; min)&#123; int maxTemp = 0; int minTemp = 0; if(minLeft &lt; minNums.size()) minTemp = 6 - minNums[minLeft]; if(maxRight &gt;= 0) maxTemp = maxNums[maxRight] - 1; if(maxTemp == 0 &amp;&amp; minTemp == 0) return -1; if(maxTemp &gt; minTemp)&#123; max -= maxTemp; maxRight--; &#125; else &#123; min += minTemp; minLeft++; &#125; count++; &#125; return count; &#125; int minOperations(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123; sort(nums1.begin(), nums1.end()); sort(nums2.begin(), nums2.end()); int num1Sum = accumulate(nums1.begin(), nums1.end(), 0); int num2Sum = accumulate(nums2.begin(), nums2.end(), 0); int ans = -1; if(num1Sum &gt; num2Sum)&#123; ans = update(nums1, nums2, num1Sum, num2Sum); &#125; else &#123; ans = update(nums2, nums1, num2Sum, num1Sum); &#125; return ans; &#125;&#125;; 复杂度分析： 时间复杂度：O(nums1+nums2) 空间复杂度：O(1)","categories":[{"name":"每日LeetCode","slug":"每日LeetCode","permalink":"http://example.com/categories/%E6%AF%8F%E6%97%A5LeetCode/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"}]},{"title":"(每日LeetCode)1805. 字符串中不同整数的数目","slug":"每日LeetCode/2022-12/1805 字符串中不同整数的数目","date":"2022-12-06T01:33:00.000Z","updated":"2022-12-06T01:33:52.869Z","comments":true,"path":"2022/12/06/每日LeetCode/2022-12/1805 字符串中不同整数的数目/","link":"","permalink":"http://example.com/2022/12/06/%E6%AF%8F%E6%97%A5LeetCode/2022-12/1805%20%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E4%B8%8D%E5%90%8C%E6%95%B4%E6%95%B0%E7%9A%84%E6%95%B0%E7%9B%AE/","excerpt":"","text":"题目： 给你一个字符串 word ，该字符串由数字和小写英文字母组成。 请你用空格替换每个不是数字的字符。例如，”a123bc34d8ef34” 将会变成 “ 123 34 8 34” 。注意，剩下的这些整数为（相邻彼此至少有一个空格隔开）：”123”、”34”、”8” 和 “34” 。 返回对 word 完成替换后形成的 不同 整数的数目。 只有当两个整数的 不含前导零 的十进制表示不同， 才认为这两个整数也不同。 示例： 输入：word &#x3D; “a123bc34d8ef34”输出：3解释：不同的整数有 “123”、”34” 和 “8” 。注意，”34” 只计数一次。 代码(CPP)： 123456789101112131415161718192021222324252627class Solution &#123;public: unordered_set&lt;string&gt; set; int numDifferentIntegers(string word) &#123; for(int i = 0; i &lt; word.size(); i++)&#123; if(isdigit(word[i]))&#123; //得到数字的第一位的位置 int begin = i; //得到数字的后一位的位置 while(i &lt; word.size() &amp;&amp; isdigit(word[i]))&#123; i++; &#125; int end = i; //除去开头的0 while(begin &lt; end-1 &amp;&amp; word[begin] == &#x27;0&#x27;)&#123; begin++; &#125; string str = word.substr(begin, end-begin); set.insert(str); &#125; &#125; return set.size(); &#125;&#125;; 复杂度分析： 时间复杂度：O(n) 空间复杂度：O(n)","categories":[{"name":"每日LeetCode","slug":"每日LeetCode","permalink":"http://example.com/categories/%E6%AF%8F%E6%97%A5LeetCode/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"}]},{"title":"(每日LeetCode)1758. 生成交替二进制字符串的最少操作数","slug":"每日LeetCode/2022-11/1758 生成交替二进制字符串的最少操作数","date":"2022-11-29T00:45:00.000Z","updated":"2022-11-29T00:47:06.297Z","comments":true,"path":"2022/11/29/每日LeetCode/2022-11/1758 生成交替二进制字符串的最少操作数/","link":"","permalink":"http://example.com/2022/11/29/%E6%AF%8F%E6%97%A5LeetCode/2022-11/1758%20%E7%94%9F%E6%88%90%E4%BA%A4%E6%9B%BF%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%9C%80%E5%B0%91%E6%93%8D%E4%BD%9C%E6%95%B0/","excerpt":"","text":"题目：给你一个仅由字符 ‘0’ 和 ‘1’ 组成的字符串 s 。一步操作中，你可以将任一 ‘0’ 变成 ‘1’ ，或者将 ‘1’ 变成 ‘0’ 。 交替字符串 定义为：如果字符串中不存在相邻两个字符相等的情况，那么该字符串就是交替字符串。例如，字符串 “010” 是交替字符串，而字符串 “0100” 不是。 返回使 s 变成 交替字符串 所需的 最少 操作数。 示例： 输入：s &#x3D; “0100”输出：1解释：如果将最后一个字符变为 ‘1’ ，s 就变成 “0101” ，即符合交替字符串定义。 思路：模拟一共两种方式：”01”和”10” 用这两种方式遍历s，来得到最小替换次数 代码：(CPP)1234567891011121314151617181920class Solution &#123;public: int minOperations(string s) &#123; int ans1 = 0; //&quot;01&quot; int ans2 = 0; //&quot;10&quot; for(int i = 0; i &lt; s.size(); i++)&#123; if(i % 2 == 0) if(s[i] == &#x27;1&#x27;) ans1++; else ans2++; else if(s[i] == &#x27;0&#x27;) ans1++; else ans2++; &#125; return min(ans1, ans2); &#125;&#125;; 复杂度分析： 时间复杂度：O(n) 空间复杂度：O(1)","categories":[{"name":"每日LeetCode","slug":"每日LeetCode","permalink":"http://example.com/categories/%E6%AF%8F%E6%97%A5LeetCode/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"}]},{"title":"(每日LeetCode)1732. 找到最高海拔","slug":"每日LeetCode/2022-11/1732 找到最高海拔","date":"2022-11-19T02:39:00.000Z","updated":"2022-11-19T02:39:20.387Z","comments":true,"path":"2022/11/19/每日LeetCode/2022-11/1732 找到最高海拔/","link":"","permalink":"http://example.com/2022/11/19/%E6%AF%8F%E6%97%A5LeetCode/2022-11/1732%20%E6%89%BE%E5%88%B0%E6%9C%80%E9%AB%98%E6%B5%B7%E6%8B%94/","excerpt":"","text":"题目：有一个自行车手打算进行一场公路骑行，这条路线总共由 n + 1 个不同海拔的点组成。自行车手从海拔为 0 的点 0 开始骑行。 给你一个长度为 n 的整数数组 gain ，其中 gain[i] 是点 i 和点 i + 1 的 净海拔高度差（0 &lt;&#x3D; i &lt; n）。请你返回 最高点的海拔 。 示例： 输入：gain &#x3D; [-5,1,5,0,-7]输出：1解释：海拔高度依次为 [0,-5,-4,1,1,-6] 。最高海拔为 1 。 代码(cpp)：123456789101112class Solution &#123;public: int largestAltitude(vector&lt;int&gt;&amp; gain) &#123; int pri = 0; int ans = 0; for(auto&amp; g : gain)&#123; pri += g; ans = max(ans, pri); &#125; return ans; &#125;&#125;; 复杂度分析： 时间复杂度：O(n) 空间复杂度：O(1)","categories":[{"name":"每日LeetCode","slug":"每日LeetCode","permalink":"http://example.com/categories/%E6%AF%8F%E6%97%A5LeetCode/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"}]},{"title":"(每日LeetCode)775. 全局倒置与局部倒置","slug":"每日LeetCode/2022-11/775 全局倒置与局部倒置","date":"2022-11-16T04:47:00.000Z","updated":"2022-11-16T04:47:55.506Z","comments":true,"path":"2022/11/16/每日LeetCode/2022-11/775 全局倒置与局部倒置/","link":"","permalink":"http://example.com/2022/11/16/%E6%AF%8F%E6%97%A5LeetCode/2022-11/775%20%E5%85%A8%E5%B1%80%E5%80%92%E7%BD%AE%E4%B8%8E%E5%B1%80%E9%83%A8%E5%80%92%E7%BD%AE/","excerpt":"","text":"题目：给你一个长度为 n 的整数数组 nums ，表示由范围 [0, n - 1] 内所有整数组成的一个排列。 全局倒置 的数目等于满足下述条件不同下标对 (i, j) 的数目： 0 &lt;= i &lt; j &lt; n nums[i] &gt; nums[j] 局部倒置 的数目等于满足下述条件的下标 i 的数目： 0 &lt;= i &lt; n - 1 nums[i] &gt; nums[i + 1] 当数组 nums 中 全局倒置 的数量等于 局部倒置 的数量时，返回 true ；否则，返回 false 。 示例： 输入：nums &#x3D; [1,2,0]输出：false解释：有 2 个全局倒置，和 1 个局部倒置。 思路：局部倒置一定是全局倒置，全局倒置不一定是局部倒置。 所以只要存在一个非局部倒置的全局倒置，那就不相等，返回false 不存在这样的全局倒置，返回true 代码(cpp)：12345678910111213class Solution &#123;public: bool isIdealPermutation(vector&lt;int&gt;&amp; nums) &#123; int temp = nums[0]; for(int i = 2; i &lt; nums.size(); i++)&#123; if(temp &gt; nums[i]) return false; //如果有比temp还大的数字，替换。因为更大的数字有更大的可能找到小的数字 temp = max(temp, nums[i-1]); &#125; return true; &#125;&#125;; 复杂度分析： 时间复杂度：O(n) 空间复杂度：O(1)","categories":[{"name":"每日LeetCode","slug":"每日LeetCode","permalink":"http://example.com/categories/%E6%AF%8F%E6%97%A5LeetCode/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"}]},{"title":"(每日LeetCode)1710. 卡车上的最大单元数","slug":"每日LeetCode/2022-11/1710 卡车上的最大单元数","date":"2022-11-15T01:29:00.000Z","updated":"2022-11-15T01:29:22.141Z","comments":true,"path":"2022/11/15/每日LeetCode/2022-11/1710 卡车上的最大单元数/","link":"","permalink":"http://example.com/2022/11/15/%E6%AF%8F%E6%97%A5LeetCode/2022-11/1710%20%E5%8D%A1%E8%BD%A6%E4%B8%8A%E7%9A%84%E6%9C%80%E5%A4%A7%E5%8D%95%E5%85%83%E6%95%B0/","excerpt":"","text":"题目：请你将一些箱子装在 一辆卡车 上。给你一个二维数组 boxTypes ，其中 boxTypes[i] &#x3D; [numberOfBoxesi, numberOfUnitsPerBoxi] ： numberOfBoxesi 是类型 i 的箱子的数量。 numberOfUnitsPerBoxi 是类型 i 每个箱子可以装载的单元数量。 整数 truckSize 表示卡车上可以装载 箱子 的 最大数量 。只要箱子数量不超过 truckSize ，你就可以选择任意箱子装到卡车上。 返回卡车可以装载 单元 的 最大 总数。 示例： 输入：boxTypes &#x3D; [[1,3],[2,2],[3,1]], truckSize &#x3D; 4输出：8解释：箱子的情况如下： 1 个第一类的箱子，里面含 3 个单元。 2 个第二类的箱子，每个里面含 2 个单元。 3 个第三类的箱子，每个里面含 1 个单元。 可以选择第一类和第二类的所有箱子，以及第三类的一个箱子。单元总数 &#x3D; (1 * 3) + (2 * 2) + (1 * 1) &#x3D; 8 代码(cpp)：贪心1234567891011121314151617181920class Solution &#123;public: int maximumUnits(vector&lt;vector&lt;int&gt;&gt;&amp; boxTypes, int truckSize) &#123; sort(boxTypes.begin(), boxTypes.end(),[](auto&amp; x, auto&amp; y)&#123; return x[1] &gt; y[1]; &#125;); int ans = 0; for(int i = 0; i &lt; boxTypes.size(); i++)&#123; if(truckSize - boxTypes[i][0] &lt;= 0)&#123; ans += truckSize*boxTypes[i][1]; break; &#125; else &#123; truckSize -= boxTypes[i][0]; ans += boxTypes[i][0]*boxTypes[i][1]; &#125; &#125; return ans; &#125;&#125;; 复杂度分析： 时间复杂度：O(n) 空间复杂度：O(1)","categories":[{"name":"每日LeetCode","slug":"每日LeetCode","permalink":"http://example.com/categories/%E6%AF%8F%E6%97%A5LeetCode/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"}]},{"title":"","slug":"Java/JVM","date":"2022-11-14T13:49:11.748Z","updated":"2023-01-25T13:24:45.456Z","comments":true,"path":"2022/11/14/Java/JVM/","link":"","permalink":"http://example.com/2022/11/14/Java/JVM/","excerpt":"","text":"1.内存结构1.1 程序计数器Program Counter Register程序计数器(寄存器) 作用：记录下一条jvm指令的执行地址 特点： 线程是私有的(在多线程中，每个线程都一个程序计数器) 程序计数器不会存在内存溢出 1.2 虚拟机栈栈和栈帧 栈：线程运行需要的内存空间 栈帧：每个方法运行需要的内存 方法运行时需要的内存：参数、局部变量、返回地址 定义 Java Virtual Machine Stacks(Java虚拟机栈) 每个线程运行时所需的内存，称之为虚拟机栈 每个栈由多个栈帧(Frame)组成，对应着每次方法调用时所占用的内存 每个线程只能有一个活动栈帧，对应着当前正在执行的那个方法 栈的演示 1234567891011121314public class Demo&#123; public static void main(String[] args) throw InterruptedException&#123; method1(); &#125; private static void method1()&#123; method2(1, 2); &#125; private static void method1(int a, int b)&#123; int c = a + b; return c; &#125;&#125; 运行顺序： 执行main主方法，将main主方法入栈。 此时活动栈帧为main 调用method1方法，将method1方法申请一块内存，入栈。开始执行method1方法。 此时活动栈帧为method1 调用method2方法，将method2方法申请一块内存(参数，局部变量，返回地址)，入栈。 此时活动栈帧为method2 method2方法执行完毕，释放内存，出栈。开始执行method1方法 此时活动栈帧为method1 method1方法执行完毕，释放内存，出栈。开始执行main主方法 此时活动栈帧为main main主方法执行完毕，释放内存，出栈。 执行结束。 相关问题 垃圾回收是否涉及到栈内存？ 不会，方法执行完毕后，会自动释放内存 栈内存分配越大越好吗？ -Xss[size]：linux系统默认为1024KB 分配1mb栈内存： 12-Xss1m-Xss1024k 不是，分配内存越大，线程数越少 方法内的局部变量是否线程安全？ 线程是否安全看变量是否共享，每个局部变量都在各自的栈帧中，线程不共享 类中的static成员变量在方法区是共享的，导致线程不安全","categories":[],"tags":[]},{"title":"(每日LeetCode)1684. 统计一致字符串的数目","slug":"每日LeetCode/2022-11/791 自定义字符串排序","date":"2022-11-13T02:08:00.000Z","updated":"2022-11-13T02:08:57.570Z","comments":true,"path":"2022/11/13/每日LeetCode/2022-11/791 自定义字符串排序/","link":"","permalink":"http://example.com/2022/11/13/%E6%AF%8F%E6%97%A5LeetCode/2022-11/791%20%E8%87%AA%E5%AE%9A%E4%B9%89%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8E%92%E5%BA%8F/","excerpt":"","text":"题目：给定两个字符串 order 和 s 。order 的所有单词都是 唯一 的，并且以前按照一些自定义的顺序排序。 对 s 的字符进行置换，使其与排序的 order 相匹配。更具体地说，如果在 order 中的字符 x 出现字符 y 之前，那么在排列后的字符串中， x 也应该出现在 y 之前。 返回 满足这个性质的 s 的任意排列 。 示例： 输入: order &#x3D; “cba”, s &#x3D; “abcd”输出: “cbad”解释:“a”、“b”、“c”是按顺序出现的，所以“a”、“b”、“c”的顺序应该是“c”、“b”、“a”。因为“d”不是按顺序出现的，所以它可以在返回的字符串中的任何位置。“dcba”、“cdba”、“cbda”也是有效的输出。 代码(cpp)：哈希表1234567891011121314151617181920212223class Solution &#123;public: string customSortString(string order, string s) &#123; vector&lt;int&gt; map(26); for(auto&amp; c : s)&#123; map[c-&#x27;a&#x27;]++; &#125; string ans = &quot;&quot;; for(auto&amp; o : order)&#123; while(map[o-&#x27;a&#x27;] &gt; 0)&#123; ans.push_back(o); map[o-&#x27;a&#x27;]--; &#125; &#125; for(int i = 0; i &lt; 26; i++)&#123; while(map[i] &gt; 0)&#123; ans.push_back(&#x27;a&#x27;+i); map[i]--; &#125; &#125; return ans; &#125;&#125;; 复杂度分析： 时间复杂度：O(n) 空间复杂度：O(n)","categories":[{"name":"每日LeetCode","slug":"每日LeetCode","permalink":"http://example.com/categories/%E6%AF%8F%E6%97%A5LeetCode/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"}]},{"title":"(每日LeetCode)790. 多米诺和托米诺平铺","slug":"每日LeetCode/2022-11/790 多米诺和托米诺平铺","date":"2022-11-12T04:18:00.000Z","updated":"2022-11-12T04:18:09.204Z","comments":true,"path":"2022/11/12/每日LeetCode/2022-11/790 多米诺和托米诺平铺/","link":"","permalink":"http://example.com/2022/11/12/%E6%AF%8F%E6%97%A5LeetCode/2022-11/790%20%E5%A4%9A%E7%B1%B3%E8%AF%BA%E5%92%8C%E6%89%98%E7%B1%B3%E8%AF%BA%E5%B9%B3%E9%93%BA/","excerpt":"","text":"题目：有两种形状的瓷砖：一种是 2 x 1 的多米诺形，另一种是形如 “L” 的托米诺形。两种形状都可以旋转。\\ 给定整数 n ，返回可以平铺 2 x n 的面板的方法的数量。返回对 109 + 7 取模 的值。 平铺指的是每个正方形都必须有瓷砖覆盖。两个平铺不同，当且仅当面板上有四个方向上的相邻单元中的两个，使得恰好有一个平铺有一个瓷砖占据两个正方形。 示例： 输入: n &#x3D; 3输出: 5解释: 五种不同的方法如上所示。 思路： 代码 (cpp)：123456789101112131415161718class Solution &#123; const int MOD = 1e9 + 7;public: int numTilings(int n) &#123; if (n == 1) return 1; long f[n + 1]; f[0] = f[1] = 1; f[2] = 2; for (int i = 3; i &lt;= n; ++i)&#123; f[i] = (f[i - 1] * 2 + f[i - 3]) % MOD; &#125; return f[n]; &#125;&#125;; 复杂度分析： 时间复杂度：O(n) 空间复杂度：O(n)","categories":[{"name":"每日LeetCode","slug":"每日LeetCode","permalink":"http://example.com/categories/%E6%AF%8F%E6%97%A5LeetCode/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"}]},{"title":"(每日LeetCode)1704. 判断字符串的两半是否相似","slug":"每日LeetCode/2022-11/1704 判断字符串的两半是否相似","date":"2022-11-11T01:56:00.000Z","updated":"2022-11-11T02:02:01.031Z","comments":true,"path":"2022/11/11/每日LeetCode/2022-11/1704 判断字符串的两半是否相似/","link":"","permalink":"http://example.com/2022/11/11/%E6%AF%8F%E6%97%A5LeetCode/2022-11/1704%20%E5%88%A4%E6%96%AD%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E4%B8%A4%E5%8D%8A%E6%98%AF%E5%90%A6%E7%9B%B8%E4%BC%BC/","excerpt":"","text":"题目：给你一个偶数长度的字符串 s 。将其拆分成长度相同的两半，前一半为 a ，后一半为 b 。 两个字符串 相似 的前提是它们都含有相同数目的元音（’a’，’e’，’i’，’o’，’u’，’A’，’E’，’I’，’O’，’U’）。注意，s 可能同时含有大写和小写字母。 如果 a 和 b 相似，返回 true ；否则，返回 false 。 示例： 输入：s &#x3D; “textbook”输出：false解释：a &#x3D; “text” 且 b &#x3D; “book” 。a 中有 1 个元音，b 中有 2 个元音。因此，a 和 b 不相似。注意，元音 o 在 b 中出现两次，记为 2 个。 代码(cpp)：123456789101112131415161718192021class Solution &#123;public: bool halvesAreAlike(string s) &#123; string vowel = &quot;aeiouAEIOU&quot;; unordered_map&lt;char, int&gt; map; for(auto&amp; v : vowel)&#123; map[v]++; &#125; int size = s.size()/2; int left = 0; int right = 0; for(int i = 0; i &lt; size; i++)&#123; if(map[s[i]] == 1) left++; if(map[s[size+i]] == 1) right++; &#125; return left == right; &#125;&#125;; 复杂度分析： 时间复杂度：O(n) 空间复杂度：O(1)","categories":[{"name":"每日LeetCode","slug":"每日LeetCode","permalink":"http://example.com/categories/%E6%AF%8F%E6%97%A5LeetCode/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"}]},{"title":"(每日LeetCode)864. 获取所有钥匙的最短路径","slug":"每日LeetCode/2022-11/864 获取所有钥匙的最短路径","date":"2022-11-10T09:18:00.000Z","updated":"2022-11-10T09:18:29.200Z","comments":true,"path":"2022/11/10/每日LeetCode/2022-11/864 获取所有钥匙的最短路径/","link":"","permalink":"http://example.com/2022/11/10/%E6%AF%8F%E6%97%A5LeetCode/2022-11/864%20%E8%8E%B7%E5%8F%96%E6%89%80%E6%9C%89%E9%92%A5%E5%8C%99%E7%9A%84%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/","excerpt":"","text":"题目：给定一个二维网格 grid ，其中： ‘.’ 代表一个空房间 ‘#’ 代表一堵 ‘@’ 是起点 小写字母代表钥匙 大写字母代表锁 我们从起点开始出发，一次移动是指向四个基本方向之一行走一个单位空间。我们不能在网格外面行走，也无法穿过一堵墙。如果途经一个钥匙，我们就把它捡起来。除非我们手里有对应的钥匙，否则无法通过锁。 假设 k 为 钥匙&#x2F;锁 的个数，且满足 1 &lt;&#x3D; k &lt;&#x3D; 6，字母表中的前 k 个字母在网格中都有自己对应的一个小写和一个大写字母。换言之，每个锁有唯一对应的钥匙，每个钥匙也有唯一对应的锁。另外，代表钥匙和锁的字母互为大小写并按字母顺序排列。 返回获取所有钥匙所需要的移动的最少次数。如果无法获取所有钥匙，返回 -1 。 示例： 输入：grid &#x3D; [“@.a.#”,”###.#”,”b.A.B”]输出：8解释：目标是获得所有钥匙，而不是打开所有锁。 代码(cpp)：BFS123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566class Solution &#123;public: int shortestPathAllKeys(vector&lt;string&gt;&amp; grid) &#123; int first, end; //记录起始地点 int all_k = 0; //记录钥匙的总数 int dir[4][2] = &#123;&#123;1,0&#125;,&#123;-1,0&#125;,&#123;0,1&#125;,&#123;0,-1&#125;&#125;; int m = grid.size(); int n = grid[0].size(); for(int i = 0; i &lt; m; i++)&#123; for(int j = 0; j &lt; n; j++)&#123; char c = grid[i][j]; if(c == &#x27;@&#x27;)&#123; //获取起始地点的位置 first = i; end = j; &#125; if(islower(c)) //如果为小写则钥匙总数加1 all_k++; &#125; &#125; //记录已经遍历过的状态[x][y][k] vector&lt;vector&lt;vector&lt;bool&gt;&gt;&gt; flag(m, vector&lt;vector&lt;bool&gt;&gt;(n, vector&lt;bool&gt;(1 &lt;&lt; all_k))); flag[first][end][0] = true; //将起始地点标记 queue&lt;tuple&lt;int, int, int&gt;&gt; queue; queue.emplace(first, end, 0); int ans = 1; //BFS while(!queue.empty())&#123; int size = queue.size(); for(int i = 0; i &lt; size; i++)&#123; auto [temp_x, temp_y, temp_k] = queue.front(); queue.pop(); //遍历4个方向 for (int j = 0; j &lt; 4; j++) &#123; int x = temp_x + dir[j][0]; int y = temp_y + dir[j][1]; //如果超出范围，则跳过 if (x &lt; 0 || y &lt; 0 || x &gt;= m || y &gt;= n) continue; char c = grid[x][y]; //如果为&#x27;#&#x27;或者已有的钥匙无法打开门，则跳过 if (c == &#x27;#&#x27; || (isupper(c) &amp;&amp; (temp_k &gt;&gt; (c - &#x27;A&#x27;) &amp; 1) == 0)) continue; int k = temp_k; //如果遇到钥匙，则捡起，并判断是否已经找到全部的钥匙 if (islower(c)) &#123; k |= 1 &lt;&lt; (c - &#x27;a&#x27;); //如果已经找到全部钥匙，则返回 if(k == (1&lt;&lt;all_k)-1) return ans; &#125; //如果此位置没有被标记，则加入到队列中 if (!flag[x][y][k]) &#123; flag[x][y][k] = true; queue.emplace(x, y, k); &#125; &#125; &#125; //步数+1 ans++; &#125; return -1; &#125;&#125;; 复杂度分析： 时间复杂度：O(mn⋅2^k^)，其中 m 和 n 是网格的行数和列数，k 是网格中钥匙的数量。 空间复杂度：O(mn⋅2^k^)。","categories":[{"name":"每日LeetCode","slug":"每日LeetCode","permalink":"http://example.com/categories/%E6%AF%8F%E6%97%A5LeetCode/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"}]},{"title":"(每日LeetCode)1684. 统计一致字符串的数目","slug":"每日LeetCode/2022-11/1684 统计一致字符串的数目","date":"2022-11-08T01:04:00.000Z","updated":"2022-11-08T01:04:10.994Z","comments":true,"path":"2022/11/08/每日LeetCode/2022-11/1684 统计一致字符串的数目/","link":"","permalink":"http://example.com/2022/11/08/%E6%AF%8F%E6%97%A5LeetCode/2022-11/1684%20%E7%BB%9F%E8%AE%A1%E4%B8%80%E8%87%B4%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%95%B0%E7%9B%AE/","excerpt":"","text":"题目：给你一个由不同字符组成的字符串 allowed 和一个字符串数组 words 。如果一个字符串的每一个字符都在 allowed 中，就称这个字符串是 一致字符串 。 请你返回 words 数组中 一致字符串 的数目。 示例： 输入：allowed &#x3D; “cad”, words &#x3D; [“cc”,”acd”,”b”,”ba”,”bac”,”bad”,”ac”,”d”]输出：4解释：字符串 “cc”，”acd”，”ac” 和 “d” 是一致字符串。 代码(cpp)：12345678910111213141516171819202122232425class Solution &#123;public: int countConsistentStrings(string allowed, vector&lt;string&gt;&amp; words) &#123; vector&lt;bool&gt; map(26, false); for(auto&amp; a : allowed)&#123; map[a-&#x27;a&#x27;] = true; &#125; int ans = 0; bool flag = true; for(string&amp; word : words)&#123; for(char&amp; w : word)&#123; if(!map[w-&#x27;a&#x27;])&#123; flag = false; break; &#125; flag = true; &#125; if(flag)&#123; ans++; &#125; &#125; return ans; &#125;&#125;; 复杂度分析： 时间复杂度：O(n + m)，其中 n 是字符串 allowed 的长度，m是字符串 words[i] 的长度。 空间复杂度：O(C)。C&lt;&#x3D;26","categories":[{"name":"每日LeetCode","slug":"每日LeetCode","permalink":"http://example.com/categories/%E6%AF%8F%E6%97%A5LeetCode/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"}]},{"title":"(每日LeetCode)816. 模糊坐标","slug":"每日LeetCode/2022-11/816 模糊坐标","date":"2022-11-07T04:55:00.000Z","updated":"2022-11-07T04:55:23.906Z","comments":true,"path":"2022/11/07/每日LeetCode/2022-11/816 模糊坐标/","link":"","permalink":"http://example.com/2022/11/07/%E6%AF%8F%E6%97%A5LeetCode/2022-11/816%20%E6%A8%A1%E7%B3%8A%E5%9D%90%E6%A0%87/","excerpt":"","text":"题目：我们有一些二维坐标，如 “(1, 3)” 或 “(2, 0.5)”，然后我们移除所有逗号，小数点和空格，得到一个字符串S。返回所有可能的原始字符串到一个列表中。 原始的坐标表示法不会存在多余的零，所以不会出现类似于”00”, “0.0”, “0.00”, “1.0”, “001”, “00.01”或一些其他更小的数来表示坐标。此外，一个小数点前至少存在一个数，所以也不会出现“.1”形式的数字。 最后返回的列表可以是任意顺序的。而且注意返回的两个数字中间（逗号之后）都有一个空格。 示例： 示例 2:输入: “(00011)”输出: [“(0.001, 1)”, “(0, 0.011)”]解释:0.0, 00, 0001 或 00.01 是不被允许的。 代码(cpp)：模拟123456789101112131415161718192021222324252627282930313233343536class Solution &#123;public: vector&lt;string&gt; getPoint(string num)&#123; vector&lt;string&gt; temp; for(int i = 1; i &lt;= num.size(); i++)&#123; string integer = num.substr(0, i); string decimal = num.substr(i); if(integer != &quot;0&quot; &amp;&amp; integer[0] == &#x27;0&#x27;) continue; if(!decimal.empty() &amp;&amp; decimal.back() == &#x27;0&#x27;)&#123; continue; &#125; if(decimal.empty()) temp.emplace_back(integer); else&#123; temp.emplace_back(integer+&#x27;.&#x27;+decimal); &#125; &#125; return temp; &#125; vector&lt;string&gt; ambiguousCoordinates(string s) &#123; vector&lt;string&gt; ans; s = s.substr(1,s.size() -2); string temp; for(int i = 1; i &lt; s.size(); i++)&#123; for(auto&amp; x : getPoint(s.substr(0, i)))&#123; for(auto&amp; y : getPoint(s.substr(i)))&#123; ans.emplace_back(&quot;(&quot;+x+&quot;, &quot;+y+&quot;)&quot;); &#125; &#125; &#125; return ans; &#125;&#125;; 复杂度分析： 时间复杂度：O(n^3^) 空间复杂度：O(n^3^)","categories":[{"name":"每日LeetCode","slug":"每日LeetCode","permalink":"http://example.com/categories/%E6%AF%8F%E6%97%A5LeetCode/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"}]},{"title":"(每日LeetCode)1678. 设计 Goal 解析器","slug":"每日LeetCode/2022-11/1678 设计 Goal 解析器","date":"2022-11-06T03:51:00.000Z","updated":"2022-11-06T03:51:45.481Z","comments":true,"path":"2022/11/06/每日LeetCode/2022-11/1678 设计 Goal 解析器/","link":"","permalink":"http://example.com/2022/11/06/%E6%AF%8F%E6%97%A5LeetCode/2022-11/1678%20%E8%AE%BE%E8%AE%A1%20Goal%20%E8%A7%A3%E6%9E%90%E5%99%A8/","excerpt":"","text":"题目：请你设计一个可以解释字符串 command 的 Goal 解析器 。command 由 “G”、”()” 和&#x2F;或 “(al)” 按某种顺序组成。Goal 解析器会将 “G” 解释为字符串 “G”、”()” 解释为字符串 “o” ，”(al)” 解释为字符串 “al” 。然后，按原顺序将经解释得到的字符串连接成一个字符串。 给你字符串 command ，返回 Goal 解析器 对 command 的解释结果。 示例： 输入：command &#x3D; “G()(al)”输出：”Goal”解释：Goal 解析器解释命令的步骤如下所示：G -&gt; G() -&gt; o(al) -&gt; al最后连接得到的结果是 “Goal” 代码(cpp)：123456789101112131415161718class Solution &#123;public: string interpret(string command) &#123; string ans = &quot;&quot;; for(int i = 0; i &lt; command.size(); i++)&#123; if(command[i] == &#x27;G&#x27;) ans.push_back(&#x27;G&#x27;); if(command[i] == &#x27;)&#x27;) ans.push_back(&#x27;o&#x27;); if(command[i] == &#x27;a&#x27;)&#123; ans.append(&quot;al&quot;); i += 2; &#125; &#125; return ans; &#125;&#125;; 复杂度分析： 时间复杂度：O(n) 空间复杂度：O(n)","categories":[{"name":"每日LeetCode","slug":"每日LeetCode","permalink":"http://example.com/categories/%E6%AF%8F%E6%97%A5LeetCode/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"}]},{"title":"(每日LeetCode)1106. 解析布尔表达式","slug":"每日LeetCode/2022-11/1106 解析布尔表达式","date":"2022-11-05T14:37:00.000Z","updated":"2022-11-05T14:39:05.916Z","comments":true,"path":"2022/11/05/每日LeetCode/2022-11/1106 解析布尔表达式/","link":"","permalink":"http://example.com/2022/11/05/%E6%AF%8F%E6%97%A5LeetCode/2022-11/1106%20%E8%A7%A3%E6%9E%90%E5%B8%83%E5%B0%94%E8%A1%A8%E8%BE%BE%E5%BC%8F/","excerpt":"","text":"题目：给你一个以字符串形式表述的 布尔表达式（boolean） expression，返回该式的运算结果。 有效的表达式需遵循以下约定： &quot;t&quot;，运算结果为 True &quot;f&quot;，运算结果为 False &quot;!(expr)&quot;，运算过程为对内部表达式 expr 进行逻辑 非的运算（NOT） &quot;&amp;(expr1,expr2,...)&quot;，运算过程为对 2 个或以上内部表达式 expr1, expr2, … 进行逻辑 与的运算(AND) &quot;|(expr1,expr2,...)&quot;，运算过程为对 2 个或以上内部表达式 expr1, expr2, … 进行逻辑 或的运算(OR) 示例： 输入：expression &#x3D; “|(&amp;(t,f,t),!(t))”输出：false 代码(cpp)：栈12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152class Solution &#123;public: bool parseBoolExpr(string expression) &#123; stack&lt;char&gt; stk; for(auto&amp; ch : expression)&#123; if(ch == &#x27;,&#x27;) //跳过&#x27;,&#x27; continue; if(ch != &#x27;)&#x27;) //将&#x27;!&#x27;&#x27;、&#x27;|&#x27;、&#x27;&amp;&#x27;压栈 stk.emplace(ch); else&#123; //如果为&#x27;)&#x27; //统计括号中true和false的个数 int t = 0; int f = 0; while(stk.top() != &#x27;(&#x27;)&#123; //如果不为&#x27;(&#x27; auto temp = stk.top(); stk.pop(); if(temp == &#x27;t&#x27;) t++; else f++; &#125; stk.pop(); //将&#x27;(&#x27;出栈 auto optator = stk.top(); //获取运算符 stk.pop(); //运算符操作，并将结果入栈 switch(optator)&#123; case &#x27;!&#x27;: if(f == 0) stk.emplace(&#x27;f&#x27;); else stk.emplace(&#x27;t&#x27;); break; case &#x27;|&#x27;: if(t &gt; 0) stk.emplace(&#x27;t&#x27;); else stk.emplace(&#x27;f&#x27;); break; case &#x27;&amp;&#x27;: if(f == 0) stk.emplace(&#x27;t&#x27;); else stk.emplace(&#x27;f&#x27;); break; &#125; &#125; &#125; return stk.top() == &#x27;t&#x27;; &#125;&#125;; 复杂度分析： 时间复杂度：O(n) 空间复杂度：O(n)","categories":[{"name":"每日LeetCode","slug":"每日LeetCode","permalink":"http://example.com/categories/%E6%AF%8F%E6%97%A5LeetCode/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"}]},{"title":"(每日LeetCode)754. 到达终点数字","slug":"每日LeetCode/2022-11/754 到达终点数字","date":"2022-11-04T07:06:00.000Z","updated":"2022-11-04T07:06:45.667Z","comments":true,"path":"2022/11/04/每日LeetCode/2022-11/754 到达终点数字/","link":"","permalink":"http://example.com/2022/11/04/%E6%AF%8F%E6%97%A5LeetCode/2022-11/754%20%E5%88%B0%E8%BE%BE%E7%BB%88%E7%82%B9%E6%95%B0%E5%AD%97/","excerpt":"","text":"题目： 在一根无限长的数轴上，你站在0的位置。终点在target的位置。 你可以做一些数量的移动 numMoves : 每次你可以选择向左或向右移动。第 i 次移动（从 i &#x3D;&#x3D; 1 开始，到 i &#x3D;&#x3D; numMoves ），在选择的方向上走 i 步。给定整数 target ，返回 到达目标所需的 最小 移动次数(即最小 numMoves ) 。 示例： 输入: target &#x3D; 2输出: 3解释:第一次移动，从 0 到 1 。第二次移动，从 1 到 -1 。第三次移动，从 -1 到 2 。 代码(cpp)： 12345678910111213141516class Solution &#123;public: int reachNumber(int target) &#123; target = abs(target); int k = 0; while(target &gt; 0)&#123; k++; target -= k; &#125; if(target%2 == 0) return k; else return k + 1 + k%2; &#125;&#125;;","categories":[{"name":"每日LeetCode","slug":"每日LeetCode","permalink":"http://example.com/categories/%E6%AF%8F%E6%97%A5LeetCode/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"}]},{"title":"(每日LeetCode)1668. 最大重复子字符串","slug":"每日LeetCode/2022-11/1668 最大重复子字符串","date":"2022-11-03T00:53:00.000Z","updated":"2022-11-03T00:56:39.408Z","comments":true,"path":"2022/11/03/每日LeetCode/2022-11/1668 最大重复子字符串/","link":"","permalink":"http://example.com/2022/11/03/%E6%AF%8F%E6%97%A5LeetCode/2022-11/1668%20%E6%9C%80%E5%A4%A7%E9%87%8D%E5%A4%8D%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2/","excerpt":"","text":"题目： 给你一个字符串 sequence ，如果字符串 word 连续重复 k 次形成的字符串是 sequence 的一个子字符串，那么单词 word 的 重复值为 k 。单词 word 的 最大重复值 是单词 word 在 sequence 中最大的重复值。如果 word 不是 sequence 的子串，那么重复值 k 为 0 。 给你一个字符串 sequence 和 word ，请你返回 最大重复值 k 。 示例： 输入：sequence &#x3D; “ababc”, word &#x3D; “ab”输出：2解释：”abab” 是 “ababc” 的子字符串。 思路：KMP 先用KMP找到重复一次的字串，如果存在就找重复两次的字串，依次递加 代码(cpp)： 12345678910111213class Solution &#123;public: int maxRepeating(string sequence, string word) &#123; int ans = 0; string temp = word; while(sequence.find(word) != string::npos)&#123; word.append(temp); ans++; &#125; return ans; &#125;&#125;;","categories":[{"name":"每日LeetCode","slug":"每日LeetCode","permalink":"http://example.com/categories/%E6%AF%8F%E6%97%A5LeetCode/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"}]},{"title":"(每日LeetCode)1662. 检查两个字符串数组是否相等","slug":"每日LeetCode/2022-11/1662 检查两个字符串数组是否相等","date":"2022-11-01T01:44:00.000Z","updated":"2022-11-01T01:45:07.339Z","comments":true,"path":"2022/11/01/每日LeetCode/2022-11/1662 检查两个字符串数组是否相等/","link":"","permalink":"http://example.com/2022/11/01/%E6%AF%8F%E6%97%A5LeetCode/2022-11/1662%20%E6%A3%80%E6%9F%A5%E4%B8%A4%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%95%B0%E7%BB%84%E6%98%AF%E5%90%A6%E7%9B%B8%E7%AD%89/","excerpt":"","text":"题目：给你两个字符串数组 word1 和 word2 。如果两个数组表示的字符串相同，返回 true ；否则，返回 false 。 数组表示的字符串 是由数组中的所有元素 按顺序 连接形成的字符串。 示例： 输入：word1 &#x3D; [“ab”, “c”], word2 &#x3D; [“a”, “bc”]输出：true解释：word1 表示的字符串为 “ab” + “c” -&gt; “abc”word2 表示的字符串为 “a” + “bc” -&gt; “abc”两个字符串相同，返回 true 代码(cpp)：123456789101112131415161718192021222324class Solution &#123;public: bool arrayStringsAreEqual(vector&lt;string&gt;&amp; word1, vector&lt;string&gt;&amp; word2) &#123; string str1 = &quot;&quot;; for(int i = 0; i &lt; word1.size(); i++)&#123; str1.append(word1[i]); &#125; string str2 = &quot;&quot;; for(int i = 0; i &lt; word2.size(); i++)&#123; str2.append(word2[i]); &#125; if(str1.size() != str2.size()) return false; for(int i = 0; i &lt; str1.size(); i++)&#123; if(str1[i] != str2[i]) return false; &#125; return true; &#125;&#125;;","categories":[{"name":"每日LeetCode","slug":"每日LeetCode","permalink":"http://example.com/categories/%E6%AF%8F%E6%97%A5LeetCode/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"}]},{"title":"(每日LeetCode)784. 字母大小写全排列","slug":"每日LeetCode/2022-10/784 字母大小写全排列","date":"2022-10-30T01:31:00.000Z","updated":"2022-10-30T01:33:02.455Z","comments":true,"path":"2022/10/30/每日LeetCode/2022-10/784 字母大小写全排列/","link":"","permalink":"http://example.com/2022/10/30/%E6%AF%8F%E6%97%A5LeetCode/2022-10/784%20%E5%AD%97%E6%AF%8D%E5%A4%A7%E5%B0%8F%E5%86%99%E5%85%A8%E6%8E%92%E5%88%97/","excerpt":"","text":"题目：给定一个字符串 s ，通过将字符串 s 中的每个字母转变大小写，我们可以获得一个新的字符串。 返回 所有可能得到的字符串集合 。以 任意顺序 返回输出。 示例： 输入：s &#x3D; “a1b2”输出：[“a1b2”, “a1B2”, “A1b2”, “A1B2”] 思路：DFS获取到字符串s中每个字母的位置，并且如果是大写字母的话，改为小写字母，统一为小写字母 利用dfs，得到所有可能的字符串 代码(cpp)：1234567891011121314151617181920212223242526272829class Solution &#123;public: vector&lt;string&gt; ans; void dfs(string s, vector&lt;int&gt;&amp; index, int pos)&#123; for(int i = pos; i &lt; index.size(); i++)&#123; string temp = s; temp[index[i]] -= 32; ans.emplace_back(temp); dfs(temp, index, i+1); &#125; &#125; vector&lt;string&gt; letterCasePermutation(string s) &#123; vector&lt;int&gt; index; for(int i = 0; i &lt; s.size(); i++)&#123; if(!isdigit(s[i])) index.emplace_back(i); if(s[i] &gt;= 65 &amp;&amp; s[i] &lt;= 90) s[i] += 32; &#125; ans.emplace_back(s); dfs(s, index, 0); return ans; &#125;&#125;;","categories":[{"name":"每日LeetCode","slug":"每日LeetCode","permalink":"http://example.com/categories/%E6%AF%8F%E6%97%A5LeetCode/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"}]},{"title":"(每日LeetCode)1773. 统计匹配检索规则的物品数量","slug":"每日LeetCode/2022-10/1773 统计匹配检索规则的物品数量","date":"2022-10-29T03:27:00.000Z","updated":"2022-10-29T03:27:54.356Z","comments":true,"path":"2022/10/29/每日LeetCode/2022-10/1773 统计匹配检索规则的物品数量/","link":"","permalink":"http://example.com/2022/10/29/%E6%AF%8F%E6%97%A5LeetCode/2022-10/1773%20%E7%BB%9F%E8%AE%A1%E5%8C%B9%E9%85%8D%E6%A3%80%E7%B4%A2%E8%A7%84%E5%88%99%E7%9A%84%E7%89%A9%E5%93%81%E6%95%B0%E9%87%8F/","excerpt":"","text":"题目：给你一个数组 items ，其中 items[i] &#x3D; [typei, colori, namei] ，描述第 i 件物品的类型、颜色以及名称。 另给你一条由两个字符串 ruleKey 和 ruleValue 表示的检索规则。 如果第 i 件物品能满足下述条件之一，则认为该物品与给定的检索规则 匹配 ： ruleKey &#x3D;&#x3D; “type” 且 ruleValue &#x3D;&#x3D; typei 。ruleKey &#x3D;&#x3D; “color” 且 ruleValue &#x3D;&#x3D; colori 。ruleKey &#x3D;&#x3D; “name” 且 ruleValue &#x3D;&#x3D; namei 。统计并返回 匹配检索规则的物品数量 。 示例： 输入：items &#x3D; [[“phone”,”blue”,”pixel”],[“computer”,”silver”,”phone”],[“phone”,”gold”,”iphone”]], ruleKey &#x3D; “type”, ruleValue &#x3D; “phone”输出：2解释：只有两件物品匹配检索规则，这两件物品分别是 [“phone”,”blue”,”pixel”] 和 [“phone”,”gold”,”iphone”] 。注意，[“computer”,”silver”,”phone”] 未匹配检索规则。 代码(cpp)：123456789101112131415161718192021class Solution &#123;public: int countMatches(vector&lt;vector&lt;string&gt;&gt;&amp; items, string ruleKey, string ruleValue) &#123; int pos; if(ruleKey == &quot;type&quot;) pos = 0; else if(ruleKey == &quot;color&quot;) pos = 1; else pos = 2; int ans = 0; for(int i = 0; i &lt; items.size(); i++)&#123; if(items[i][pos] == ruleValue)&#123; ans++; &#125; &#125; return ans; &#125;&#125;; 复杂度分析： 时间复杂度：O(n) 空间复杂度：O(1)","categories":[{"name":"每日LeetCode","slug":"每日LeetCode","permalink":"http://example.com/categories/%E6%AF%8F%E6%97%A5LeetCode/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"}]},{"title":"(每日LeetCode)907. 子数组的最小值之和","slug":"每日LeetCode/2022-10/907 子数组的最小值之和","date":"2022-10-28T02:26:00.000Z","updated":"2022-10-28T02:46:05.486Z","comments":true,"path":"2022/10/28/每日LeetCode/2022-10/907 子数组的最小值之和/","link":"","permalink":"http://example.com/2022/10/28/%E6%AF%8F%E6%97%A5LeetCode/2022-10/907%20%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E5%80%BC%E4%B9%8B%E5%92%8C/","excerpt":"","text":"题目：给定一个整数数组 arr，找到 min(b) 的总和，其中 b 的范围为 arr 的每个（连续）子数组。 由于答案可能很大，因此 返回答案模 10^9 + 7 。 示例： 输入：arr &#x3D; [3,1,2,4]输出：17解释：子数组为 [3]，[1]，[2]，[4]，[3,1]，[1,2]，[2,4]，[3,1,2]，[1,2,4]，[3,1,2,4]。最小值为 3，1，2，4，1，1，2，1，1，1，和为 17。 思路：单调栈举例：arr = [11,81,94,43,3] 对于11，左边没有更小值，右边更小值为3，那么，只能以11为起点，终点可以选11，81，94，43，共4个数组，对答案的贡献就是4*11=44 对于81，左边更小值为11，右边更小值为43，那么，可以以81为起点，81，94为终点，共两个数组， 对答案的贡献为2*81=162 对于94，左边更小值为81，右边更小值为43，只能以自身为起点终点，共一个数组， 贡献94 对于43，左边更小值为11，右边更小值为3，可以以81，94，43为起点，43为终点，共三个数组， 对答案的贡献为3*43=129 对于3，左边没有更小值，右边没有更小值，可以以11，81，94，43，3为起点，3为终点，共五个数组， 对答案的贡献为5*3=15 最终结果就是累加起来，44+162+94+129+15=444 更一般来说，如果当前位置坐标为i，左边更小值位置为left，右边为right，则贡献就是(i-left)*(right-i)*arr[i]。特别地，如果左边没有更小值，left=-1，如果右边没有更小值，right=size。 作者：heren1229链接：https://leetcode.cn/problems/sum-of-subarray-minimums/solution/dan-diao-zhan-by-heren1229-j8nz/来源：力扣（LeetCode）著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 代码(cpp)：1234567891011121314151617181920class Solution &#123;public: int sumSubarrayMins(vector&lt;int&gt;&amp; arr) &#123; long ans = 0; arr.emplace_back(-1); stack&lt;int&gt; stk; stk.emplace(-1); long mod = 1e9+7; for(int i = 0; i &lt; arr.size(); i++)&#123; while(stk.size() &gt; 1 &amp;&amp; arr[stk.top()] &gt;= arr[i])&#123; int t = stk.top(); stk.pop(); ans += (long)arr[t]*(i-t)*(t-stk.top()); &#125; stk.emplace(i); &#125; return ans%mod; &#125;&#125;; 复杂度分析： 时间复杂度：O(n)，其中 n 为 arr 的长度。在 arr[i] 的视角看，i 在二重循环中最多入栈出栈各一次，因此整个二重循环的时间复杂度为 O(n)。 空间复杂度：O(n)。最坏情况下，栈里面有 O(n) 个元素。","categories":[{"name":"每日LeetCode","slug":"每日LeetCode","permalink":"http://example.com/categories/%E6%AF%8F%E6%97%A5LeetCode/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"}]},{"title":"(每日LeetCode)1822. 数组元素积的符号","slug":"每日LeetCode/2022-10/1822 数组元素积的符号","date":"2022-10-27T01:16:00.000Z","updated":"2022-10-27T01:16:30.028Z","comments":true,"path":"2022/10/27/每日LeetCode/2022-10/1822 数组元素积的符号/","link":"","permalink":"http://example.com/2022/10/27/%E6%AF%8F%E6%97%A5LeetCode/2022-10/1822%20%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0%E7%A7%AF%E7%9A%84%E7%AC%A6%E5%8F%B7/","excerpt":"","text":"题目：已知函数 signFunc(x) 将会根据 x 的正负返回特定值： 如果 x 是正数，返回 1 。如果 x 是负数，返回 -1 。如果 x 是等于 0 ，返回 0 。给你一个整数数组 nums 。令 product 为数组 nums 中所有元素值的乘积。 返回 signFunc(product) 。 示例： 输入：nums &#x3D; [-1,-2,-3,-4,3,2,1]输出：1解释：数组中所有值的乘积是 144 ，且 signFunc(144) &#x3D; 1 代码(cpp)：12345678910111213141516171819202122class Solution &#123;public: int arraySign(vector&lt;int&gt;&amp; nums) &#123; int count = 0; for(auto&amp; num : nums)&#123; if(num == 0)&#123; count = -1; break; &#125; if(num &lt; 0)&#123; count++; &#125; &#125; if(count%2 == 0) return 1; else if(count == -1) return 0; else return -1; &#125;&#125;; 复杂度分析： 时间复杂度：O(n) 空间复杂度：O(1)","categories":[{"name":"每日LeetCode","slug":"每日LeetCode","permalink":"http://example.com/categories/%E6%AF%8F%E6%97%A5LeetCode/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"}]},{"title":"(每日LeetCode)934. 最短的桥","slug":"每日LeetCode/2022-10/934 最短的桥","date":"2022-10-25T07:51:00.000Z","updated":"2022-10-25T07:51:48.426Z","comments":true,"path":"2022/10/25/每日LeetCode/2022-10/934 最短的桥/","link":"","permalink":"http://example.com/2022/10/25/%E6%AF%8F%E6%97%A5LeetCode/2022-10/934%20%E6%9C%80%E7%9F%AD%E7%9A%84%E6%A1%A5/","excerpt":"","text":"题目：给你一个大小为 n x n 的二元矩阵 grid ，其中 1 表示陆地，0 表示水域。 岛 是由四面相连的 1 形成的一个最大组，即不会与非组内的任何其他 1 相连。grid 中 恰好存在两座岛 。 你可以将任意数量的 0 变为 1 ，以使两座岛连接起来，变成 一座岛 。 返回必须翻转的 0 的最小数目。 示例： 输入：grid &#x3D; [[0,1,0],[0,0,0],[0,0,1]]输出：2 思路：BFS可以确定的是grid数组中只有两个岛屿(1表示岛，0表示海) 可以遍历岛其中一个岛后，由此岛利用BFS，得到另一个岛之间所需搭桥数 以示例为例： 0 1 0 0 0 0 0 0 1 先找到第一个岛屿，并(利用BFS)将其整个岛都标记为-1： 0 -1 0 0 0 0 0 0 1 利用BFS搜索另一个岛： 第一次，ans &#x3D; 0时： -1 -1 -1 0 -1 0 0 0 1 第二次，ans &#x3D; 1时： -1 -1 -1 -1 -1 -1 0 -1 1 第三次，ans &#x3D; 2 时，找到另一个岛屿，返回结果： -1 -1 -1 -1 -1 -1 0 -1 1 代码(cpp)：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879class Solution &#123;public: int shortestBridge(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123; int size = grid.size(); int dir[4][2]&#123;&#123;0,1&#125;,&#123;1,0&#125;,&#123;-1,0&#125;,&#123;0,-1&#125;&#125;; queue&lt;pair&lt;int, int&gt;&gt; qu1; queue&lt;pair&lt;int, int&gt;&gt; qu2; //获取到第一个岛屿的位置 for(int i = 0; i &lt; size; i++)&#123; for(int j = 0; j &lt; size; j++)&#123; if(grid[i][j] == 1)&#123; grid[i][j] = -1; //标记-1 qu1.emplace(i, j); //入队 break; &#125; &#125; if(!qu1.empty())&#123; break; &#125; &#125; //遍历数组，将于第一个岛屿相连的岛屿保存入队到qu2中，并标记-1 while(!qu1.empty())&#123; auto [x, y] = qu1.front(); qu2.emplace(x, y); //将相连的岛屿入队到qu2中 qu1.pop(); //遍历该岛屿的4个方向 for(int i = 0; i &lt; 4; i++)&#123; int new_x = x + dir[i][0]; int new_y = y + dir[i][1]; //边界判断 if(new_x &lt; 0 || new_y &lt; 0 || new_x &gt;= size || new_y &gt;= size)&#123; continue; &#125; //如果是岛屿 if(grid[new_x][new_y] == 1)&#123; qu1.emplace(new_x, new_y); //入队 grid[new_x][new_y] = -1; //标记为-1 &#125; &#125; &#125; int ans = 0; while(!qu2.empty())&#123; //如果桥数为ans时，两个岛屿是否可以相连 int n = qu2.size(); for(int i = 0; i &lt; n; i++)&#123; auto [x, y] = qu2.front(); qu2.pop(); //遍历该岛屿的4个方向 for(int i = 0; i &lt; 4; i++)&#123; int new_x = x + dir[i][0]; int new_y = y + dir[i][1]; //边界判断 if(new_x &lt; 0 || new_y &lt; 0 || new_x &gt;= size || new_y &gt;= size)&#123; continue; &#125; //如果已经被标记 if(grid[new_x][new_y] == -1)&#123; continue; &#125; //如果为1到了岛屿 if(grid[new_x][new_y] == 1)&#123; return ans; //返回桥数 &#125; //如果为0，是海 if(grid[new_x][new_y] == 0)&#123; qu2.emplace(new_x, new_y); //入队 grid[new_x][new_y] = -1; //标记为-1 &#125; &#125; &#125; //桥数+1 ans++; &#125; return -1; &#125;&#125;; 复杂度分析： 时间复杂度: O(n^2)O(n2) 空间复杂度: O(n^2)O(n2)","categories":[{"name":"每日LeetCode","slug":"每日LeetCode","permalink":"http://example.com/categories/%E6%AF%8F%E6%97%A5LeetCode/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"}]},{"title":"(每日LeetCode)1768. 交替合并字符串","slug":"每日LeetCode/2022-10/1768 交替合并字符串","date":"2022-10-23T00:53:00.000Z","updated":"2022-10-23T00:53:58.926Z","comments":true,"path":"2022/10/23/每日LeetCode/2022-10/1768 交替合并字符串/","link":"","permalink":"http://example.com/2022/10/23/%E6%AF%8F%E6%97%A5LeetCode/2022-10/1768%20%E4%BA%A4%E6%9B%BF%E5%90%88%E5%B9%B6%E5%AD%97%E7%AC%A6%E4%B8%B2/","excerpt":"","text":"题目：给你两个字符串 word1 和 word2 。请你从 word1 开始，通过交替添加字母来合并字符串。如果一个字符串比另一个字符串长，就将多出来的字母追加到合并后字符串的末尾。 返回 合并后的字符串 。 示例： 输入：word1 &#x3D; “abc”, word2 &#x3D; “pqr”输出：”apbqcr”解释：字符串合并情况如下所示：word1： a b cword2： p q r合并后： a p b q c r 代码(cpp)：1234567891011121314151617181920212223class Solution &#123;public: string mergeAlternately(string word1, string word2) &#123; string ans = &quot;&quot;; int size = min(word1.size(), word2.size()); for(int i = 0; i &lt; size; i++)&#123; ans.push_back(word1[i]); ans.push_back(word2[i]); &#125; while(size &lt; word1.size())&#123; ans.push_back(word1[size++]); &#125; while(size &lt; word2.size())&#123; ans.push_back(word2[size++]); &#125; return ans; &#125;&#125;; 复杂度分析： 时间复杂度：O(m+n) 空间复杂度：O(m+n)","categories":[{"name":"每日LeetCode","slug":"每日LeetCode","permalink":"http://example.com/categories/%E6%AF%8F%E6%97%A5LeetCode/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"}]},{"title":"(每日LeetCode)901. 股票价格跨度","slug":"每日LeetCode/2022-10/901 股票价格跨度","date":"2022-10-21T01:33:00.000Z","updated":"2022-10-21T01:33:44.095Z","comments":true,"path":"2022/10/21/每日LeetCode/2022-10/901 股票价格跨度/","link":"","permalink":"http://example.com/2022/10/21/%E6%AF%8F%E6%97%A5LeetCode/2022-10/901%20%E8%82%A1%E7%A5%A8%E4%BB%B7%E6%A0%BC%E8%B7%A8%E5%BA%A6/","excerpt":"","text":"题目：编写一个 StockSpanner 类，它收集某些股票的每日报价，并返回该股票当日价格的跨度。 今天股票价格的跨度被定义为股票价格小于或等于今天价格的最大连续日数（从今天开始往回数，包括今天）。 例如，如果未来7天股票的价格是 [100, 80, 60, 70, 60, 75, 85]，那么股票跨度将是 [1, 1, 1, 2, 1, 4, 6]。 示例： 输入：[“StockSpanner”,”next”,”next”,”next”,”next”,”next”,”next”,”next”], [[],[100],[80],[60],[70],[60],[75],[85]]输出：[null,1,1,1,2,1,4,6]解释：首先，初始化 S &#x3D; StockSpanner()，然后：S.next(100) 被调用并返回 1，S.next(80) 被调用并返回 1，S.next(60) 被调用并返回 1，S.next(70) 被调用并返回 2，S.next(60) 被调用并返回 1，S.next(75) 被调用并返回 4，S.next(85) 被调用并返回 6。 注意 (例如) S.next(75) 返回 4，因为截至今天的最后 4 个价格(包括今天的价格 75) 小于或等于今天的价格。 代码(cpp)：123456789101112131415161718192021class StockSpanner &#123;public: StockSpanner() &#123; this-&gt;stk.emplace(-1, INT_MAX); this-&gt;idx = -1; &#125; int next(int price) &#123; idx++; while (price &gt;= stk.top().second) &#123; stk.pop(); &#125; int ret = idx - stk.top().first; stk.emplace(idx, price); return ret; &#125;private: stack&lt;pair&lt;int, int&gt;&gt; stk; int idx;&#125;; 复杂度分析： 时间复杂度：O(n)，其中 n 为调用 next 函数的次数，每个 price 值最多都会入栈出栈各 11 次。 空间复杂度：O(n)，栈中最多有 n 个元素。","categories":[{"name":"每日LeetCode","slug":"每日LeetCode","permalink":"http://example.com/categories/%E6%AF%8F%E6%97%A5LeetCode/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"}]},{"title":"(每日LeetCode)1700. 无法吃午餐的学生数量","slug":"每日LeetCode/2022-10/1700 无法吃午餐的学生数量","date":"2022-10-19T05:57:00.000Z","updated":"2022-10-21T00:31:01.699Z","comments":true,"path":"2022/10/19/每日LeetCode/2022-10/1700 无法吃午餐的学生数量/","link":"","permalink":"http://example.com/2022/10/19/%E6%AF%8F%E6%97%A5LeetCode/2022-10/1700%20%E6%97%A0%E6%B3%95%E5%90%83%E5%8D%88%E9%A4%90%E7%9A%84%E5%AD%A6%E7%94%9F%E6%95%B0%E9%87%8F/","excerpt":"","text":"题目：学校的自助午餐提供圆形和方形的三明治，分别用数字 0 和 1 表示。所有学生站在一个队列里，每个学生要么喜欢圆形的要么喜欢方形的。餐厅里三明治的数量与学生的数量相同。所有三明治都放在一个 栈 里，每一轮： 如果队列最前面的学生 喜欢 栈顶的三明治，那么会 拿走它 并离开队列。否则，这名学生会 放弃这个三明治 并回到队列的尾部。这个过程会一直持续到队列里所有学生都不喜欢栈顶的三明治为止。 给你两个整数数组 students 和 sandwiches ，其中 sandwiches[i] 是栈里面第 i 个三明治的类型（i &#x3D; 0 是栈的顶部）， students[j] 是初始队列里第 j 名学生对三明治的喜好（j &#x3D; 0 是队列的最开始位置）。请你返回无法吃午餐的学生数量。 示例： 输入：students &#x3D; [1,1,0,0], sandwiches &#x3D; [0,1,0,1]输出：0解释： 最前面的学生放弃最顶上的三明治，并回到队列的末尾，学生队列变为 students &#x3D; [1,0,0,1]。 最前面的学生放弃最顶上的三明治，并回到队列的末尾，学生队列变为 students &#x3D; [0,0,1,1]。 最前面的学生拿走最顶上的三明治，剩余学生队列为 students &#x3D; [0,1,1]，三明治栈为 sandwiches &#x3D; [1,0,1]。 最前面的学生放弃最顶上的三明治，并回到队列的末尾，学生队列变为 students &#x3D; [1,1,0]。 最前面的学生拿走最顶上的三明治，剩余学生队列为 students &#x3D; [1,0]，三明治栈为 sandwiches &#x3D; [0,1]。 最前面的学生放弃最顶上的三明治，并回到队列的末尾，学生队列变为 students &#x3D; [0,1]。 最前面的学生拿走最顶上的三明治，剩余学生队列为 students &#x3D; [1]，三明治栈为 sandwiches &#x3D; [1]。 最前面的学生拿走最顶上的三明治，剩余学生队列为 students &#x3D; []，三明治栈为 sandwiches &#x3D; []。所以所有学生都有三明治吃。 代码(cpp)：12345678910111213141516class Solution &#123;public: int countStudents(vector&lt;int&gt;&amp; students, vector&lt;int&gt;&amp; sandwiches) &#123; vector&lt;int&gt; v(2); for(int i = 0; i &lt; students.size(); i++)&#123; v[students[i]]++; &#125; for(int i = 0; i &lt; sandwiches.size(); i++)&#123; if(--v[sandwiches[i]] == -1) return sandwiches.size()-i; &#125; return 0; &#125;&#125;; 复杂度分析：时间复杂度：O(n) 空间复杂度：O(1)","categories":[{"name":"每日LeetCode","slug":"每日LeetCode","permalink":"http://example.com/categories/%E6%AF%8F%E6%97%A5LeetCode/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"}]},{"title":"(每日LeetCode)902. 最大为 N 的数字组合","slug":"每日LeetCode/2022-10/902 最大为 N 的数字组合","date":"2022-10-18T02:19:00.000Z","updated":"2022-10-18T02:19:10.377Z","comments":true,"path":"2022/10/18/每日LeetCode/2022-10/902 最大为 N 的数字组合/","link":"","permalink":"http://example.com/2022/10/18/%E6%AF%8F%E6%97%A5LeetCode/2022-10/902%20%E6%9C%80%E5%A4%A7%E4%B8%BA%20N%20%E7%9A%84%E6%95%B0%E5%AD%97%E7%BB%84%E5%90%88/","excerpt":"","text":"题目： 给定一个按 非递减顺序 排列的数字数组 digits 。你可以用任意次数 digits[i] 来写的数字。例如，如果 digits &#x3D; [‘1’,’3’,’5’]，我们可以写数字，如 ‘13’, ‘551’, 和 ‘1351315’。 返回 可以生成的小于或等于给定整数 n 的正整数的个数 。 示例： 输入：digits &#x3D; [“1”,”3”,”5”,”7”], n &#x3D; 100输出：20解释：可写出的 20 个数字是：1, 3, 5, 7, 11, 13, 15, 17, 31, 33, 35, 37, 51, 53, 55, 57, 71, 73, 75, 77. 代码(cpp)：时间超时摆烂~~ 123456789101112131415161718class Solution &#123;public: int atMostNGivenDigitSet(vector&lt;string&gt;&amp; digits, int n) &#123; return dfs(digits, n, &quot;&quot;); &#125; int dfs(vector&lt;string&gt;&amp; digits, int n, string num)&#123; int ans = 0; for(int i = 0; i &lt; digits.size(); i++)&#123; string temp = num; temp.append(digits[i]); if(stoll(temp) &gt; n) break; ans += dfs(digits, n, temp)+1; &#125; return ans; &#125;&#125;;","categories":[{"name":"每日LeetCode","slug":"每日LeetCode","permalink":"http://example.com/categories/%E6%AF%8F%E6%97%A5LeetCode/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"}]},{"title":"(每日LeetCode)904. 水果成篮","slug":"每日LeetCode/2022-10/904 水果成篮","date":"2022-10-17T09:46:00.000Z","updated":"2022-10-21T00:29:07.356Z","comments":true,"path":"2022/10/17/每日LeetCode/2022-10/904 水果成篮/","link":"","permalink":"http://example.com/2022/10/17/%E6%AF%8F%E6%97%A5LeetCode/2022-10/904%20%E6%B0%B4%E6%9E%9C%E6%88%90%E7%AF%AE/","excerpt":"","text":"题目：你正在探访一家农场，农场从左到右种植了一排果树。这些树用一个整数数组 fruits 表示，其中 fruits[i] 是第 i 棵树上的水果 种类 。 你想要尽可能多地收集水果。然而，农场的主人设定了一些严格的规矩，你必须按照要求采摘水果： 你只有 两个 篮子，并且每个篮子只能装 单一类型 的水果。每个篮子能够装的水果总量没有限制。 你可以选择任意一棵树开始采摘，你必须从 每棵 树（包括开始采摘的树）上 恰好摘一个水果 。采摘的水果应当符合篮子中的水果类型。每采摘一次，你将会向右移动到下一棵树，并继续采摘。 一旦你走到某棵树前，但水果不符合篮子的水果类型，那么就必须停止采摘。 给你一个整数数组 fruits ，返回你可以收集的水果的 最大 数目。 示例： 输入：fruits &#x3D; [3,3,3,1,2,1,1,2,3,3,4]输出：5解释：可以采摘 [1,2,1,1,2] 这五棵树。 代码(cpp)：1234567891011121314151617181920class Solution &#123;public: int totalFruit(vector&lt;int&gt;&amp; fruits) &#123; unordered_map&lt;int, int&gt; map; int ans = 0; for(int left = 0, right = 0; left &lt; fruits.size(); left++)&#123; map[fruits[left]]++; while(map.size() &gt; 2)&#123; auto temp = fruits[right++]; if(--map[temp] == 0) map.erase(temp); &#125; ans = max(ans, left - right + 1); &#125; return ans; &#125;&#125;; 复杂度分析： 时间复杂度 O(n) 空间复杂度 O(1)","categories":[{"name":"每日LeetCode","slug":"每日LeetCode","permalink":"http://example.com/categories/%E6%AF%8F%E6%97%A5LeetCode/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"}]},{"title":"(每日LeetCode)1441. 用栈操作构建数组","slug":"每日LeetCode/2022-10/1441 用栈操作构建数组","date":"2022-10-15T01:49:00.000Z","updated":"2022-10-15T01:49:31.820Z","comments":true,"path":"2022/10/15/每日LeetCode/2022-10/1441 用栈操作构建数组/","link":"","permalink":"http://example.com/2022/10/15/%E6%AF%8F%E6%97%A5LeetCode/2022-10/1441%20%E7%94%A8%E6%A0%88%E6%93%8D%E4%BD%9C%E6%9E%84%E5%BB%BA%E6%95%B0%E7%BB%84/","excerpt":"","text":"题目：给你一个数组 target 和一个整数 n。每次迭代，需要从 list &#x3D; { 1 , 2 , 3 …, n } 中依次读取一个数字。 请使用下述操作来构建目标数组 target ： “Push”：从 list 中读取一个新元素， 并将其推入数组中。 “Pop”：删除数组中的最后一个元素。 如果目标数组构建完成，就停止读取更多元素。 题目数据保证目标数组严格递增，并且只包含 1 到 n 之间的数字。 请返回构建目标数组所用的操作序列。如果存在多个可行方案，返回任一即可。 示例： 输入：target &#x3D; [1,3], n &#x3D; 3输出：[“Push”,”Push”,”Pop”,”Push”]解释：读取 1 并自动推入数组 -&gt; [1]读取 2 并自动推入数组，然后删除它 -&gt; [1]读取 3 并自动推入数组 -&gt; [1,3] 代码(cpp)：12345678910111213141516171819class Solution &#123;public: vector&lt;string&gt; buildArray(vector&lt;int&gt;&amp; target, int n) &#123; vector&lt;string&gt; ans; int pos = 0; for(int i = 1; i &lt;= n; i++)&#123; if(pos == target.size()) break; ans.emplace_back(&quot;Push&quot;); if(target[pos] != i) ans.emplace_back(&quot;Pop&quot;); else&#123; pos++; &#125; &#125; return ans; &#125;&#125;; 时间复杂度： 时间复杂度：O(n) 空间复杂度：O(1)","categories":[{"name":"每日LeetCode","slug":"每日LeetCode","permalink":"http://example.com/categories/%E6%AF%8F%E6%97%A5LeetCode/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"}]},{"title":"(每日LeetCode)769. 最多能完成排序的块","slug":"每日LeetCode/2022-10/769 最多能完成排序的块","date":"2022-10-13T05:57:00.000Z","updated":"2022-10-13T05:57:33.016Z","comments":true,"path":"2022/10/13/每日LeetCode/2022-10/769 最多能完成排序的块/","link":"","permalink":"http://example.com/2022/10/13/%E6%AF%8F%E6%97%A5LeetCode/2022-10/769%20%E6%9C%80%E5%A4%9A%E8%83%BD%E5%AE%8C%E6%88%90%E6%8E%92%E5%BA%8F%E7%9A%84%E5%9D%97/","excerpt":"","text":"题目：给定一个长度为 n 的整数数组 arr ，它表示在 [0, n - 1] 范围内的整数的排列。 我们将 arr 分割成若干 块 (即分区)，并对每个块单独排序。将它们连接起来后，使得连接的结果和按升序排序后的原数组相同。 返回数组能分成的最多块数量。 示例： 输入: arr &#x3D; [4,3,2,1,0]输出: 1解释:将数组分成2块或者更多块，都无法得到所需的结果。例如，分成 [4, 3], [2, 1, 0] 的结果是 [3, 4, 0, 1, 2]，这不是有序的数组。 代码(cpp)：123456789101112131415class Solution &#123;public: int maxChunksToSorted(vector&lt;int&gt;&amp; arr) &#123; int ans = 0; int temp = -1; for(int i = 0; i &lt; arr.size(); i++)&#123; temp = max(temp, arr[i]); if(temp == i)&#123; ans++; &#125; &#125; return ans; &#125;&#125;; 复杂度分析： 时间复杂度：O(n)，其中 n 是数组 arr 的长度。 空间复杂度：O(1)。","categories":[{"name":"每日LeetCode","slug":"每日LeetCode","permalink":"http://example.com/categories/%E6%AF%8F%E6%97%A5LeetCode/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"}]},{"title":"(每日LeetCode)817. 链表组件","slug":"每日LeetCode/2022-10/817 链表组件","date":"2022-10-12T01:18:00.000Z","updated":"2022-10-12T01:18:30.033Z","comments":true,"path":"2022/10/12/每日LeetCode/2022-10/817 链表组件/","link":"","permalink":"http://example.com/2022/10/12/%E6%AF%8F%E6%97%A5LeetCode/2022-10/817%20%E9%93%BE%E8%A1%A8%E7%BB%84%E4%BB%B6/","excerpt":"","text":"题目：给定链表头结点 head，该链表上的每个结点都有一个 唯一的整型值 。同时给定列表 nums，该列表是上述链表中整型值的一个子集。 返回列表 nums 中组件的个数，这里对组件的定义为：链表中一段最长连续结点的值（该值必须在列表 nums 中）构成的集合。 示例： 输入: head &#x3D; [0,1,2,3,4], nums &#x3D; [0,3,1,4]输出: 2解释: 链表中，0 和 1 是相连接的，3 和 4 是相连接的，所以 [0, 1] 和 [3, 4] 是两个组件，故返回 2。 代码(cpp)：12345678910111213141516171819202122232425262728class Solution &#123;public: int numComponents(ListNode* head, vector&lt;int&gt;&amp; nums) &#123; unordered_map&lt;int, int&gt; map; for(auto&amp; num : nums) map[num]++; int ans = 0; int count = 0; while(head != nullptr)&#123; if(map.find(head-&gt;val) == map.end())&#123; if(count != 0)&#123; ans++; count = 0; &#125; &#125; else count++; head = head-&gt;next; &#125; if(count != 0) ans++; return ans; &#125;&#125;; 复杂度分析： 时间复杂度：O(n)，需要遍历一遍链表。 空间复杂度：O(m)，其中 m 是数组 nums 的长度，需要一个哈希集合来存储 nums 的元素。","categories":[{"name":"每日LeetCode","slug":"每日LeetCode","permalink":"http://example.com/categories/%E6%AF%8F%E6%97%A5LeetCode/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"}]},{"title":"(每日LeetCode)1790. 仅执行一次字符串交换能否使两个字符串相等","slug":"每日LeetCode/2022-10/1790 仅执行一次字符串交换能否使两个字符串相等","date":"2022-10-11T03:25:00.000Z","updated":"2022-10-11T03:25:21.452Z","comments":true,"path":"2022/10/11/每日LeetCode/2022-10/1790 仅执行一次字符串交换能否使两个字符串相等/","link":"","permalink":"http://example.com/2022/10/11/%E6%AF%8F%E6%97%A5LeetCode/2022-10/1790%20%E4%BB%85%E6%89%A7%E8%A1%8C%E4%B8%80%E6%AC%A1%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%BA%A4%E6%8D%A2%E8%83%BD%E5%90%A6%E4%BD%BF%E4%B8%A4%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E7%AD%89/","excerpt":"","text":"题目：给你长度相等的两个字符串 s1 和 s2 。一次 字符串交换 操作的步骤如下：选出某个字符串中的两个下标（不必不同），并交换这两个下标所对应的字符。 如果对 其中一个字符串 执行 最多一次字符串交换 就可以使两个字符串相等，返回 true ；否则，返回 false 。 示例： 输入：s1 &#x3D; “bank”, s2 &#x3D; “kanb”输出：true解释：例如，交换 s2 中的第一个和最后一个字符可以得到 “bank” 代码(cpp)：123456789101112131415161718192021class Solution &#123;public: bool areAlmostEqual(string s1, string s2) &#123; int index = -1; for(int i = 0; i &lt; s1.size(); i++)&#123; if(s1[i] == s2[i]) continue; else if(index == -1) index = i; else if(index == -2) return false; else&#123; if(s1[i] != s2[index] || s2[i] != s1[index]) return false; index = -2; &#125; &#125; return index &lt; 0; &#125;&#125;; 复杂度分析： 时间复杂度: O(n) 空间复杂度: O(1)","categories":[{"name":"每日LeetCode","slug":"每日LeetCode","permalink":"http://example.com/categories/%E6%AF%8F%E6%97%A5LeetCode/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"}]},{"title":"汇编的学习笔记","slug":"计算机4件套/汇编","date":"2022-10-09T13:04:32.410Z","updated":"2023-02-09T13:12:02.410Z","comments":true,"path":"2022/10/09/计算机4件套/汇编/","link":"","permalink":"http://example.com/2022/10/09/%E8%AE%A1%E7%AE%97%E6%9C%BA4%E4%BB%B6%E5%A5%97/%E6%B1%87%E7%BC%96/","excerpt":"","text":"1.访问寄存器和内存寄存器及数据存储CPU的组成： 运算器进行信息处理 寄存器进行信息存储 控制器协调各种器件进行工作 在8086CPU中有14个寄存器： 通用寄存器：AX、BX、CX、DX 变址寄存器：SI、DI 指针寄存器：SP、BP 指令指针寄存器：IP 段寄存器：CS、SS、DS、ES 标志寄存器：PSW 并且所有寄存器都是16位的，可以存放两个字节 以通用寄存器AX为例： 一个16位寄存器存储一个16位的数据 最大值位2^16 - 1，转换位16进制为FFFFH 注意： 二进制后缀为B 八进制后缀为E 十进制后缀为D 十六进制后缀为H 例如： 在AX中存储18D，转换为十六进制就为12H，转换为二进制就为10010B 在AX中存储20000D，转换为十六进制就为4E20H，转换为二进制就为0100111000100000B 8086上一代的CPU中的寄存器都是8位的，如何保证程序的兼容性？ 可以将通用寄存器均分为两个独立的8位寄存器使用 AX可以分为AH和AL AX为0~15位可以细分为AH为8~15位以及AL位0~7位 例如： 寄存器 寄存器中的数据 所表示的值 AX 0100111000100000 20000(4E20H) AH 01001110 78(4EH) AL 00100000 32(20H) 同样： BX可以细分为BH和BL CX可以细分为CH和CL DX可以细分为DH和DL 8086是16位CPU 8086的字长为16bit 一个字可以存在一个16位寄存器中： 这个字的高位字节存在这个寄存器的高8位寄存器8~15 这个字的低位字节存在这个寄存器的低8位寄存器0~7 mov和add指令 汇编指令 控制CPU完成的操作 高级语言描述 mov ax, 18 将18送入AX AX &#x3D; 18 mov ah, 78 将78送入AH AH &#x3D; 78 add ax, 8 将寄存器AX中的数值加8 AX +&#x3D; 8 mov ax, bx 将寄存器BX的数据送入寄存器AX AX &#x3D; BX add ax, bx 将AX， BX中的内容相加，将结果存入AX中 AX +&#x3D; BX 注意：汇编指令不区分大小写 确定物理地址的方法 CPU访问内存单元时要给出内存单元的地址。 所有的内存单元构成的存储空间是一个一维的线性空间。 每一个内存单元在这个空间中都有唯一的地址，这个唯一的地址称为物理地切 事实 8086有20位地址总线，可传送20位地址，寻址能力为1M。 8086是16位结构的CPU 运算器一次最多可以处理16位的数据，寄存器的最大宽度为16位。 在8086内部处理的、传输、暂存的地址也是16位，寻址能力也只有64KB！ 8086如何在寻址空间上的矛盾？ 可以通过地址加法器用两个16位地址(段地址、偏移地址)合成一个20位的物理地址 地址加法器合成物理地址的方法 物理地址 = 段地址*16 + 偏移地址 就是将(16进制的)段地址左移一位，加上偏移地址 例如： ​ 段地址： 12300 +偏移地址： 00C8 -—————————– 物理地址： 123CB 内存的分段表示法8086CPU使用物理地址 = 段地址*16 + 偏移地址的方法给出内存单元的物理地址 内存并没有分段，段的划分来自于CPU！ 内存分段方案： 起始地址(基础地址)：10000H 段地址：1000H 10000H~100FFH单元组成一个段 大小：100H(因为10000H~100FFH之间有100H) 起始地址(基础地址)：分别为10000H和10080H 段地址：分别为1000H和1008H 10000H~1007FH单元组成一个段以及10080H~100FFH单元组成一个段 大小均为：80H(因为10000H~1007FH以及10080H~100FFH之间都有80H) 段地址*16必然是16倍数，所以一个段的起始地址也一定是16的倍数 偏移地址为16位，16位地址的寻址能力为64K，所以一个段的长度最大为64K 偏移地址16位，变化范围为0~FFFFH 给定段地址2000H，用偏移地址寻址的范围是：20000H~2FFFFH，共64K 物理地址 段地址 偏移地址 21F60H 2000H 1F60H 2100H 0F60H 21F0H 0060H 21F6H 0000H 1F00H 2F60H 注意：存储单元地址表示：段地址:偏移地址 有专用的寄存器存放段地址： 4个段寄存器： CS：代码段寄存器 DS：数据段寄存器 SS：栈段寄存器 ES：附加段寄存器 DeBug的使用Debug是Dos系统中的著名的调试程序， 也可以运行在windows系统实模式下。使用Debug程序，可以查看CPU各种寄存器中的内容、内存的情况，并旦在机器指令级跟踪程序的运行！ 注意：汇编时默认是十进制,debug工具中默认的是十六进制 在DOS提提示符下输入命令：debug Debug能做的： r：查看、改变CPU寄存器的内容 1r [寄存器] 回车 [要修改的内容] d：查看内存中的内容 e：改变内存中的内容 u：将内存中的机器指令翻译成汇编指令 a：以汇编指令在内容中写入机器指令 t：执行机器指令 q：退出Debug CS、IP与代码段 CS：代码段寄存器 IP：指令指针寄存器 CS:IP：CPU将内存中CS:IP指向的内容当作指令执行 8086PC读取和执行指令演示： 8086PC工作过程的简要描述： 从CS:IP指向内存单元读取指令，读取的指令进入指令缓冲器； IP&#x3D;IP + 所读取指令的长度，从而指向下一条指令； 执行指令。转到步骤1，重复这个过程。 DeBug的指令读取和执行演示： 1234mov ax, 0123Hmov bx, 0003Hmov ax, bxadd ax, bx a [地址]：写入汇编指令 u [地址]：查看代码 t ：执行CS:IP处的代码(IP指向下一条指令地址，重复输入t指令) 所以，内存中D8 23 01 BB 03 00 89 D8 01 DB这一串数据，是作为一般数据还是用作指令？ CPU将CS:IP指向的内存单元中的内容看作指令 jmp指令执行何处的指令，取决于CS:IP 所以，我们可以通过改变CS、IP中的内容，来控制CPU要执行的目标指令 那如何改变CS、IP的值呢？ 方式一： DeBug中可以使用r命令改变寄存器中的值 12rcsrip 但是DeBug是调试手段，并非程序方式！ 方式二： 用指令修改 12mov cs, 2000Hmov ip, 0H 这是错误的:x:，8086CPU不提供CS和IP修改的指令 方式三： 转移指令jmp 同时修改CS、IP的内容：jmp 段地址:偏移地址 例如： 1jmp 2AE3:3 仅修改IP的内容：jmp 某一合法寄存器 例如： 1jmp ax ;类似于 mox ip, ax 从20000H开始，执行的序列是： mov ax, 6622H jmp 1000:3 mov ax, 0000 mov bx, ax jmp bx mov ax, 0123H 转到第3步，开始循环！ 内存中字的存储对8086CPU，16位作为一个字 16位的字存储在一个16位的寄存器中，如何存储？ 高8位放高字节，低8位放低字节 16位的字在内存中需要2个连续字节存储，怎么存放？ 低位字节存放低地址单元，高位字节存放高地址单元 例如： 20000D(4E20H)存放0、1两个单元 18D(0012H)存放在2、3单元 字单元：由两个地址连续的内存单元组成，存放一个字型数据(16位) 原理：在一个字单元中，低地址单元存放低位字节，高地址单元存放高位字节 地址 0 20H 1 4EH 2 12H 3 00H 4 5 在起始地址为0的(最小的)单元中，存放的(由下往上读)是4E20H 在起始地址为2的单元中，存放的是0012H 问题： 0地址单元中存放的字节型数据是20H 0地址单元中存放的字型数据是4E20H 2地址单元中存放的字节型数据是12H 2地址单元中存放的字型数据是0012H DS和[]实现字的传送CPU要读取一个内存单元的时候，必须要先给出这个内存单元的地址 在8086PC中，内存地址由段地址和偏移地址组成(段地址:偏移地址) DS和[address]配合： 用DS寄存器存放要访问的数据的段地址 偏移地址用[]形式直接给出 123mov bx, 1000Hmov ds, bxmov al, [0] ;将10000H(1000:0)的数据读到al中 123mov bx, 1000Hmov ds, bxmov [0], al ;将al的数据写到10000H(1000:0)中 将段地址送入DS的两种方式 方式一：:x: 1mov ds, 1000H ;8086CPU不支持将数据直接送入Ds 方式二：:white_check_mark: 12mov bx, 1000H ;先将数据放入通用寄存器中mov ds, bx ;通过通用寄存器送入DS中 内存： 地址 数据 10000H 23 10001H 11 10002H 22 10003H 66 指令： 1234567mov ax, 1000H ;1mov ds, ax ;2mov ax, [0] ;3mov bx, [2] ;4mov cx, [1] ;5add bx, [1] ;6add cx, [2] ;7 AX &#x3D; 1000H DS &#x3D; AX ; DS &#x3D; 1000H AX &#x3D; 1123 BX &#x3D; 6622 CX &#x3D; 2211 BX +&#x3D; 2211 ; BX &#x3D; 8833 CX +&#x3D; 6622 ; CX &#x3D; 8833 DS与数据段对于8086PC机，可以根据需要将一组内存单元定义为一个段 物理地址 &#x3D; 段地址*16 + 偏移地址 将一组长度为N(N &lt;&#x3D; 64K)、地址连续、起始地址为16的倍数的内存单元当作专门存储数据的内存空间，从而定义了一个数据段 例如：用123B0H~123B9H的空间来存放数据 段地址：123BH 起始偏移地址：0000H 长度：10字节 段地址：1230H 起始偏移地址：00B0H 长度：10字节 处理方法：DS:[address] 用DS存放数据段的段地址 用相关指令(mov、add、sub…)访问数据段中的具体单元，单元地址由[address]指出 累加数据段中的前3个单元中的数据： 123456mov ax, 123BHmov ds, axmov al, 0add al, [0]add al, [1]add al, [2] 累加数据段中的前3个字型中的数据： 123456mov ax, 123BHmov ds, axmov ax, 0add ax, [0]add ax, [1]add ax, [2] 总结： 字在内存中存储时 ，要用两个地址连续的内存单元来存放，字的低位字节存放在低地址单元中，高位字节存放再高地址单元中。&amp;#x20; 用mov指令要访问内存单元，可以在mov指令中只给出单元的偏移地址，此时，段地址默认在Ds奇存器中。&amp;#x20; laddressj表示一个偏移地址为address的内存单元。&amp;#x20; 在内存和寄存器之间传送字型数据时，高地址单元和高8位寄存器、低地址单元和低8位奇存器相对应。&amp;#x20; mov、add、sub是具有两个操作对象的指令，访问内存中的数据段 （对照：jmp是具有一个操作对象的指令，对应内存中的代码段）。&amp;#x20; 可以根据自己的推测，在Debug中实验指令的新格式。 栈及栈操作的实现CPU提供的栈机制： 现如今的CPU中都有栈的设计 8086CPU提供相关的指令，支持用栈的方式访问内存空间 基于8086CPU的编程，可以将一段内存当作栈来使用。&amp;#x20; PUSH(入栈)和POP(出栈)指令&amp;#x20; push ax ：将ax中的数据送入栈中&amp;#x20; pop ax：从栈顶取出数据送入ax(以字为单位对栈进行操作) 问题： CPU如何知道一段内存空间被当作栈使用？ 执行push和pop的时候，如何知道哪个单元是栈顶单元？ 8086CPU中，有两个与栈相关的寄存器： 栈段寄存器SS：存放栈顶的段地址 栈顶指针寄存器SP：存放栈顶的偏移地址 任何时刻，SS:SP指向栈顶元素 栈的操作： 12345678910mov ax, 1000Hmov ss, axmov sp, 0010H ;(栈顶)SS:SP为10010H(1000:0010),此时栈为空mov ax, 001AHmov bx, 001BHpush ax. ;此时栈顶地址为1000EHpush bx ;此时栈顶地址为1000CHpop ax ;此时栈顶地址为1000EHpop bx ;此时栈顶地址为10010H，此时栈为空;并且此时ax与bx的数据发生了交换 push指令和pop指令的执行过程： push ax SP -&#x3D; 2 将ax中的内容送入SS:SP指向的内存单元，SS:SP此时指向新的栈顶 pop ax 将SS:SP指向的内存单元处的数据送入ax中&amp;#x20; SP +&#x3D; 2，SS:SP指向当前栈顶下面的单元，以当前栈顶下面的单元为新的栈顶 栈顶超界问题： 如果能够保证在入栈、出栈时，栈顶不会超出栈空间？ 8086CPU不保证对栈顶操作不会越界 8086CPU只知道栈顶在何处(SS:SP所指示的)，不知道程序安排的栈空间有多大 所以靠自己 总结： push、pop 实质上就是一种内存传送指令，可以在寄存器和内存之间传送数据，与mov指令不同的是，push和pop指令访问的内存单元的地址不是在指令中给出的，而是由SS:SP指出的。 执行push和pop指令时，SP中的内容自动改变。 8086CPU提供的栈操作机制：&amp;#x20; 在SS，SP中存放栈顶的段地址和偏移地址，入栈和出栈指 令根据SS:SP指示的地址，按照栈的方式访问内存单元。&amp;#x20; push指令的执行步骤： SP -&#x3D; 2 向SS:SP指向的字单元中送入数据。 pop指令的执行步骤： 从SS:SP指向的字单元中读取数据； SP +&#x3D; 2 2.汇编语言程序用汇编语言写源程序汇编语言编写程序的工作过程： 程序员-&gt;汇编程序-&gt;编译器-&gt;机器码-&gt;计算机执行 伪指令： 没有对应的机器码的指令，最终不会被CPU所执行 伪指令是由编译器来执行的指令，编译器根据伪指令来进行相关的编译工作 12345assume cs:codesgcode segment;汇编指令…codesg endsend 汇编指令： 对应有机器码的指令，可以被编译为机器指令，最终被CPU执行 1234567mov ax, 0123Hmov bx, 0456Hadd ax, bxadd ax, axmov ax, 4C00hint 21h 汇编程序：包含汇编指令和伪指令的文本 1234567891011assume cs:codesgcode segment mov ax, 0123H mov bx, 0456H add ax, bx add ax, ax mov ax, 4C00h int 21h codesg endsend 其中，下面的部分程序为程序返回(return 0;) 程序结束运行后，将CPU的控制权交还给使它得以运行的程序(常为DOS系统) 12mov ax, 4C00hint 21h 解释： 段定义： 一个汇编程序是由多个段组成的，这些段被用来存放代码、数据或或当作栈空间来使用。&amp;#x20; 一个有意义的汇编程序中至少要有一个段，这个段用来存放代码。&amp;#x20; 定义程序中的段：每个段都需要有段名&amp;#x20; 段名 segment：段的开始&amp;#x20; … 段名 ends：一段的结束 end(不是ends) 汇编程序的结束标记。若程序结尾处不加end，编译器在编译程序 时，无法知道程序在何处结束 assume(假设) 含义是假设某一段寄存器和程序中的某一个用 segment … ends 定义的段相关联 assume cs:codesg指CS寄存器与codesg关联，将定义的codesg当作程序的代码段使用。 如何写出一个程序？ 定义一个段&amp;#x20; 实现处理任务&amp;#x20; 指出程序在何结束&amp;#x20; 段与段寄存器关联&amp;#x20; 加上程序返回的代码 举例：求2^3 12345678910assume cs:abcabc segment mov ax,2 add ax,ax add ax,ax mov ax,4c00h int 21habc endsend 由源程序到程序运行过程： 源程序文件.asm—编译—&gt;目标文件.obj—连接—&gt;可执行文件.exe—&gt;运行程序 编译： 1masm XXX.asm 会出现： Object filename[XXX.OBJ]: 目标文件(*.OBJ)了是我们对一个源程序进行编译要得到的最终结果。 Source Listing [NUL.LST]: 列表文件(*.LST)是编译器将源程序编译为目标文件的过程中产生的中间结果。 Cross-reference [NUL.CRT]: 交叉引用文件(*.CRF)同列表文件一样，是编译器将源程序编译为目标文件过程中产生的中问结果。 连接： 1link XXX.obj 会出现： Run File [XXX.EXE]: 可执行文件(.EXE)是我们对一个程序进行连接要得到的最终结果。 List File [NUL.MAP]: 映像文件(.MAP)是连接程序将目标文件连接为可执行文件过程中产生的中间结果。 Libraries [.LIB]: 库文件(.LIB)里包含了一些可以调用的子程序，如果我们的程序中调用了某一个库文件中的子程序，就需要在连接的时候，将这个库文件和我们的目标文件连接到一起，生成可执行文件。 运行： 1XXX.exe 用Debug跟踪程序的执行1debug XXX.exe 命令： r命令：查看所有寄存器 u命令：查看程序被装在哪个位置 t命令：执行一行汇编指令 p命令：类似于t命令，但遇子程序、中断等时，直接执行，然后显示结果 g命令：从指定地址开始运行程序，直到遇到断点或程序正常结束 q命令：退出debug 小结： 程序加载后，DS中存放着程序所在内存区的段地址，这个内存区的偏移地址为0，则程序所在的内存区的地址为：DS:0 这个内存区的前256个字节(100H)存PSP(程序段前缀)，DOS用来和程序进行通信。 从256字节处向后的空间存放的是程序，CS的值为DS+10H。 程序加载后，CX中存放代码的长度(字节)。 程序执行处于开发周期的运行方式： 运行Debug时，command程序加载Debug.exe。debug 将程序加载入内存，程序运行结束后要返回到Debug中，使用Q命令退出Debug，将返回到command中。 […]和(…)一个内存单元的描述： 内存单元的地址 段地址 偏移地址 内存单元的长度(类型) []:汇编语法规定表示一个内存单元 ():(为方便学习作出的约定)表示一个内存单元或寄存器中的内容 ()中只能是物理地址或寄存器 描述对象 描述方法 ax中的内容为0010H (ax)&#x3D;0010H 2000:1000处的内容为0010H (21000H)&#x3D;0010H mov ax,[2]的功能 (ax)&#x3D;((ds)*16+2) add ax,2 的功能 ((ds)*16+2)&#x3D;(ax) mov [2],ax的功能 ((ds)*16+2)&#x3D;(ax) add ax,bx的功能 (ax)&#x3D;(ax)+(bx) push ax的功能 (sp)&#x3D;(sp)-2((ss)*16+(sp))&#x3D;(ax) pop ax 的功能 (sp)&#x3D;(sp)+2(ax)&#x3D;((ss)*16+(sp)) Loop指令功能：实现循环 1234567891011 assume cs:codecode segment mov ax, 2 mov cx, 11s: add ax, ax loop s mov ax, 4c00h int 21hcode endsend 数据不加H，默认为十进制 数据不能以字母开头，如果数据为ffffh需要在前面加上0为：0ffffh CPU执行loop指令要进行的操作 (cx)&#x3D;(cx)-1 判断cx中的值 为零，则向下执行 不为零，转至标号处执行程序 注意：cx中要提前存放循环次数(如果设置为10，那么循环次数就为10次)，(cx)影响着loop指令的执行 段前缀的使用Debug中，mov al, [0]的功能是将DS:0的存储的单元的值专递给AL 但是已经编译好的程序中，Dubug后，使用u命令查看代码，mov al, [0]变成了将常量0传给ALmov al, 00 解决办法： 在[idata]前显式写上段寄存器 123mov ax, 2000Hmov ds, axmov al, ds:[0] 这些出现在访问内存单元的指令中，用于显式地指明内存单元的段地址的“ds:”、“cs:”、“ss:”或“es:” ，在汇编语言中称为段前缀。 访问连续的内存单元 计算ffff:0~ffff:b字节单元中的数据和，结果存储在dx中 12345678910111213141516171819assume sc:codecode segment mov ax, 0ffffh mov ds, ax ;段地址 mov dx, 0 ;结果 mov bx, 0 ;偏移地址 mov cx, 12 ;循环次数s: mov al, ds:[bx] ;获取某一内存单元数据 mov ah, 0 ;将高8位置为0 add dx, ax ;累加 inc bx ;地址+1 loop s mov ax, 4c00h int 21hcode endsend 将内存ffff:0~ffff:b中的内存拷贝到0:200～0:20单元中 1234567891011121314151617181920assume cs:codecode segment mov bx, 0 ;偏移地址 mov cx, 12 ;循环次数s: mov ax, 0ffffh mov ds, ax ;将ffffh段地址送入ds mov dl, ds:[bx] ;将ffff:[bx]内存单元数据保存到dl mov ax, 0020h mov ds, ax ;将ds的段地址改为0020h mov [bx], dl ;将dl的数据送入0020:[bx]中 inc bx ;地址+1 loop s mov ax, 4c00h int 21hcode endsend 在代码段中使用数据在程序中直接写地址是危险的，因为在计算机中每一段内存干什么的都是明确的 在程序的段中存放数据，运行时由操作系统分配空间。&amp;#x20; 段的类别 ：数据贸、代码段、 栈段&amp;#x20; 各种段中均可以有数据可以在单个的段中安置，也可以将数据、代码、栈放入不同的段中。 编程计算以下8个数据的和，结果存在ax寄存器中&amp;#x20; 0123H,0456H,0789H,0abcH,0defH,0fedH,0cbaH,0987H 12345678910111213141516assume cs:codecode segment dw 0123H,0456H,0789H,0abcH,0defH,0fedH,0cbaH,0987H mov bx, 0 ;偏移地址 mov ax, 0 mov cx, 8 ;循环次数s: add ax, cs:[bx] ;累加 add bx, 2 ;地址+2，要取的是字而非字节 loop s mov ax, 4c00h int 21hcode endsend dw：定义一个字 db：定义一个字节 dd：定义一个双字 但是这个代码有问题！！ Dubug后，偏移地址IP是从0000开始的，但是从0000开始的是数据，只有到0010才是真正的代码 所以，要让数据从CS:0000开始，让代码从CS:0010开始 改进： 12345678910111213141516assume cs:codecode segment dw 0123H,0456H,0789H,0abcH,0defH,0fedH,0cbaH,0987H start: mov bx, 0 ;偏移地址 mov ax, 0 mov cx, 8 ;循环次数s: add ax, cs:[bx] ;累加 add bx, 2 ;地址+2，要取的是字而非字节 loop s mov ax, 4c00h int 21hcode endsend start 与上面的区别就是多了两个 start(可以自定义，也可以为begin) 开头的start:：定义一个标号，指示代码开始的位置，程序加载后，CS:IP执行要执行的第一条指令的start处 结尾的end start：end的作用处理通知编译器程序结束外，还可以通知编译器程序入口在哪里 相当于C中的main函数，来指定IP的偏移 这就有了程序的一般框架： 1234567assume cs:codecode segment 数据begin: 代码code endsend begin 在代码段中使用栈完成下面的程序，利用栈，将程序中定义的数据逆序存放 12345678910111213141516171819202122232425assume cs:codecode segment dw 0123H,0456H,0789H,0abcH,0defH,0fedH,0cbaH,0987H dw 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0start: mov ax, cs mov ss, ax ;设置栈的段地址 mov sp, 30h ;设置栈的偏移地址(起始地址) mov bx, 0 ;设置数据段的起始地址 mov cx, 8 ;循环次数s: push cs:[bx] ;压栈 add bx, 2 ;移动到下一个字的内存地址，地址+2 loop s mov bx, 0 ;设置数据段的起始地址 mov cx, 8 ;循环次数u: pop cs:[bx] ;出栈，并直接给数据段赋值 add bx, 2 ;移动到下一个字的内存地址，地址+2 loop u mov ax, 4c00h int 21hcode endsend start 将数据、代码、栈放入不同段数据、栈和代码都在一个段。 程序显得混乱， 编程和阅读时都要注意何处是数据，何处是栈， 何处是代码， 只应用于要处理 的数据很少，用到的栈空间也小， 加上没有多长的代码 将数据、栈和代码放在不同段中： 12345678910111213141516171819202122232425262728293031323334assume cs:code, ds:data, ss:stackdata segment dw 0123H,0456H,0789H,0abcH,0defH,0fedH,0cbaH,0987Hdata endsstack segment dw 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0stack endscode segmentstart: ;初始化段寄存器 mov ax, stack mov ss, ax ;ss放入栈段 mov sp, 20h ;设置栈顶 mov ax, data mov ds, ax ;ds放入数据段 ;入栈 mov bx, 0 ;数据的起始地址 mov cx, 8 ;循环次数s: push [bx] add bx, 2 ;地址+2，字型 loop s ;出栈 mov bx, 0 mov cx, 8u: pop [bx] add bx, 2 loop u mov ax, 4c00h int 21hcode endsend start 3.内存寻址方式处理字符问题汇编程序中，用&#39;……&#39;的方式指明数据是以字符的形式给出的，编译器将把它们转化为相对应的ASCII码 大写 二进制 小写 二进制 A 01000001 a 01100001 B 01000010 b 01100010 C 01000011 c 01100011 D 01000100 d 01100100 由表可知：小写字母的ASCII码值比大写字母的ASCII码值大20H 大小写转换问题： 第一个字符串：小写字母转换为大写字母 第二个字符串：大写字母转换为小写字母 1234567891011121314151617181920212223242526272829303132assume cs:code, ds:datadata segment db ‘BaSiC’ db ‘iNfOrMaTiOn’data endscode segmentstart: mov ax, data mov ds, ax mov bx, 0 ;数据段段起始地址 mov cx, 5 ;循环次数s: mov al, [bx] ;获取到当前地址的字符 and al, 11011111B ;and运算，变为大写 mov [bx], al ;送入当前地址 inc bx loop s mov bx, 5 ;数据段起始地址 mov cx, 11 ;循环次数u: mov al, [bx] ;获取到当前地址到字符 or al, 00100000B ;or运算，变为小写 mov [bx], al ;送入当前地址 inc bx loop u mov ax, 4c00h int 21hcode endsend start [bx+idata]方式寻址[bx+idata]表示一个内存单元，它的偏移地址为(bx)+idata mov ax, [bx+200]的含义： 将一个内存单元的内容送入ax 这个内存单元的长度为2字节(字单元)，存放一个字 内存单元的段地址在ds中，偏移地址为200+bx中的数值 数学化的描述为：(ax)&#x3D;((ds)*16+200+(bx)) 其他写法： mov ax, [200+bx] mov ax, 200[bx] mov ax, [bx].200 用[bx+idata]的方式进行数组的处理 问题：大小写转换问题 第一个字符串：小写字母转换为大写字母 第二个字符串：大写字母转换为小写字母 123456789101112131415161718192021222324252627assume cs:code, ds:datadata segment db ‘BaSiC’ db ‘MinIX’data endscode segmentstart: mov ax, data mov ds, ax ;同时操作两个字符串 mov bx, 0 ;数据段段起始地址 mov cx, 5 ;循环次数s: mov al, [bx] ;获取到当前地址的字符 and al, 11011111B ;and运算，变为大写 mov [bx], al ;送入当前地址 mov al, [bx+5] ;获取到当前地址到字符 or al, 00100000B ;or运算，变为小写 mov [bx+5], al ;送入当前地址 inc bx loop s mov ax, 4c00h int 21hcode endsend start 等价于C： 123456789101112131415char a[5] = &quot;BaSiC&quot;;char b[5] = &quot;MinIx&quot;;int main()&#123; int i = 0; while(i &lt; 5) &#123; a[i] = a[i] &amp; 0xDF; b[i] = b[i] | 0x20; i++l &#125; return 0;&#125; SI和DI寄存器SI和DI是8086CPU中和BX功能相近的寄存器 BX：通过寄存器，在计算存储器地址时，常作为基地址寄存器用 SI：source index， 源变址寄存器 DI：destination index，目标变址寄存器 区别：SI和DI不能够分成两个8位寄存器来使用 DI和SI也可以实现相同的功能： 12345678mov bx, 0mov ax, [bx]mov si, 0mov ax, [si]mov di, 0mov ax, [di] 12345678mov bx, 0mov ax, [bx+123]mov si, 0mov ax, [si+123]mov di, 0mov ax, [di+123] SI和DI的应用： 问题：用寄存器SI和DI实现将字符串welcome to masm!复制到它后面的数据区中 123456789101112131415161718192021222324assume cs:code, ds:datadata segment db &#x27;welcome to masm!&#x27; db &#x27;................&#x27;data endscode segmentstart: mov ax, data mov ds, ax mov si, 0 mov di, 16 mov cx, 8s: mov ax, [si] mov [di], ax add si, 2 add di, 2 loop s mov ax, 4c00h int 21hcode endsend start [bx+si]和[bx+di]方式寻址[bx+si]表示一个内存单元 偏移地址为(bx)+(si) 指令mov ax, [bx+si]的含义 数学化的描述为：(ax)&#x3D;((ds)*16+(bx)+(si)) 其他写法： mov ax, [bx][si] 感觉像二维数组 [bx+si+idata]和[bx+di+idata]方式寻址mov ax, [bx+si+idata]的含义 数学化的描述：(ax) &#x3D; ((ds)*16+(bx)+(si)+idata) 其他写法： mov ax, [bx+200+si] mov ax, [200+bx+si] mov ax, 200[bx][si] mov ax, [bx].200[si] mov ax, [bx][si].200 不同的寻址方式的灵活应用 形式 名称 意义 示例 [idata] 直接寻址 用于直接定位一个内存单元 mov ax, [200] [bx] 寄存器间接寻址 用于间接定位一个内存单元 mox bx, 0mov ax, [bx+200] [bx+idata] 寄存器相对寻址 可在一个起始地址的基础上用变量间接定位一个内存单元 mov bx, 4mov ax, [bx+200] [bx+si] 基地址变址寻址 mov ax, [bx+si] [bx+si+idata] 相对基地址变址寻址 mov ax, [bx+si+200] 案例： 编程将data段中的每个单词的开头一个字母变成大写字母 12345678910111213141516171819202122232425assume cs:code, ds:datadata segment db &#x27;1.file &#x27; ;每个长度为16 db &#x27;2.edit &#x27; db &#x27;3.search &#x27; db &#x27;4.view &#x27; db &#x27;5.options &#x27; db &#x27;6.help &#x27;data endscode segmentstart: mov ax, data mov ds, ax mov cx, 6 ;设置循环次数 mov bx, 0 ;设置起始地址 s: add al, [bx][2] and al, 11011111B mov [bx][2], al add bx, 16 ;移动到下一个字符串的起始地址 loop scode endsend start 编程将每个单词都改为大写字母 12345678910111213141516171819202122232425262728293031323334353637assume cs:code, ds:data, ss:stackdata segment db &#x27;ibm &#x27; ;每个长度为16 db &#x27;dec &#x27; db &#x27;doc &#x27; db &#x27;vax &#x27;data endsstack segment dw 0,0,0,0,0,0,0,0stack endscode segmentstart: mov ax, data mov ds, ax mov ax, stack mov ss, ax mov cx, 4 ;设置i层的循环次数 mov bx, 0 i: mov si, 0 push cx ;用栈保存i层的循环次数 mov cx, 3 ;设置j层的循环次数 j: add al, [bx][si] and al, 11011111B mov [bx][si], al inc si loop j add bx, 16 pop cx ;从栈拿出i层的循环次数 loop icode endsend start 不同的寻址方式的演示内存的寻址方式： 寻址方式 名称 常用格式举例 [idata] 直接寻址 [idata] [bx][si][di][bp] 寄存器间接寻址 [bx] [bx+idata][si+idata][di+idata][dp+idata] 寄存器相对寻址 用于结构体：[bx].idata用于数组：idata[si]或idata[di]用于二维数组：[bx][idata] [bx+si][bx+di][bp+si][bp+di] 基地址变址寻址 用于二维数组：[bx][si] [bx+si+idata][bx+di+idata][bp+si+idata][bp+di+idata] 相对基址变址寻址 用于表格(结构)中的数组项：[bx].idata[si]用于二维数组：idata[bx][si] 直接寻址过程： 寄存器间接寻址过程： 寄存器相对寻址过程： 用于内存寻址的寄存器错误的指令： 1234567mov ax, [cx]mov ax, [ax]mov ax, [dx]mov ax, [ds]mov ax, [bx+bp]mov ax, [si+di] 正确的指令： 12345678910mov ax, [si]mov ax, [di]mov ax, [bx]mov ax, [bx+si]mov ax, [bx+di]mov ax, [bp]mov ax, [bp+si]mov ax, [bp+di] 只有bx、bp、si、di可以在[]中对内存单元寻址 bx以外的通用寄存器、段寄存器不可以用在[]中 bx和bp的区别： bx默认指ds段 bp默认指ss段 指令 解释 mov ax, [bp] (ax)&#x3D;((ss)*16+(bp))，默认 mov ax, ds:[bp] (ax)&#x3D;((ds)*16+(bp)) mov ax, es:[bp] (ax)&#x3D;((es)*16+(bp)) mov ax, [bx] (ax)&#x3D;((ds)*16+(bx))，默认 mov ax, ss:[bx] (ax)&#x3D;((ss)*16+(bx)) 在哪里？有多长？ 立即数(idata) 对于直接包含在机器指令中的数据，称为立即数(idata)，数据包含在指令中 mov ax, 1的机器码为B80100其中的0100 寄存器 指令要处理的数据在寄存器中，在汇编指令中给出相应的寄存器名 内存：段地址(SA)和偏移地址(EA) 指令要处理的数据内存中，由SA:EA确定内存单元 字word操作 mov ax, 1 字节byte操作 mov al, 1 用word ptr或byte ptr指明 mov word ptr ds:[0], 1 mov byte ptr ds:[0], 1 在没有寄存器参与的内存单元访问指令中，用word ptr或byte ptr显性地指明所要访问的内存单元长度是很有必要的，否则，CPU无法得知要访问的单元是字单元，还是字节单元 寻址方式的综合应用关于姚明2001年的一条记录： 姓名：Yao 生日：’19800912’ 球衣号码：15 场均得分：32 效力球队：SHH 到了2002年，姚明的信息有了变化： 球衣号码变换成了11号 场均得分为13 效力球队：HOU 任务：编程修改内存中的过时数据 2001年数据： si 数据 seg:60 +00 ‘Yao’ +03 ‘19800912’ +0C 15 +0E 32 +10 ‘SHH’ 12345678910111213mov ax, segmov ds, axmov bx, 60hmov word ptr [bx+0ch], 11mov word ptr [bx+0eh], 32mov si, 0mov byte ptr [bx+10h+si], &#x27;H&#x27;inc simov byte ptr [bx+10h+si], &#x27;O&#x27;inc simov byte ptr [bx+10h+si], &#x27;U&#x27; 等价于C： 12345678910111213141516171819202122232425struct Player&#123; char name[3]; char birthday[9]; int num; int score; char team[3];&#125;struct Player yao = &#123;&quot;Yao&quot;, &quot;19800912&quot;, 15, 32, &quot;SHH&quot;&#125;;int main()&#123; yao.num = 11; yao.score = 13; int i = 0; yao.team[i] = &#x27;H&#x27;; i++; yao.team[i] = &#x27;O&#x27;; i++; yao.team[i] = &#x27;U&#x27;; return 0;&#125; 其中结构体yao等价于上面汇编中的bx yao.num = 11; &lt;&#x3D;&gt; mov word ptr [bx].0ch, 11 &lt;&#x3D;&gt; mov word ptr [bx+0ch], 11 yao.team[i] = &#39;H&#39;; &lt;&#x3D;&gt; mov byte ptr [bx].10h[si], &#39;H&#39; &lt;&#x3D;&gt; mov byte ptr [bx+10h+si], &#39;H&#39; 用div指令实现除法 被除数：(默认)放在AX或DX和AX中 除数：8位或16位，在寄存器或内存单元中 指令格式： div [除数] 举例：div 寄存器 或 div 内存单元 被除数 AX DX和AX 除数 8位内存或寄存器 16位内存或寄存器 商 AL AX 余数 AH DX 例如： 示例指令 被除数 除数 商 余数 div bl (ax) (bl) (al) (ah) div byte ptr ds:[0] (ax) ((ds)*16+0) (al) (ah) div byte ptr [bx+si+8] (ax) ((ds)*16+(bx)+(si)+8) (al) (ah) div bx (dx)*10000H+(ax) (bx) (ax) (dx) div word ptr es:[0] (dx)*10000H+(ax) ((es)*16+0) (ax) (dx) div word ptr [bx+si+8] (dx)*10000H+(ax) ((ds)*16+(bx)+(si)+8) (ax) (dx) 注意：提前在默认的寄存器中设置好被除数，且默认寄存器不作别的用处 示例： 编程利用除法指令计算100001&#x2F;100 分析： 100001D &#x3D; 186A1H 被除数转换成16进制为5位，需要进行16位的除法 dx和ax两个寄存器联合存放186A1H 用bx存放除数100D &#x3D; 64H 123456mov dx, 1Hmov ax, 86A1Hmov bx, 64Hdiv bx;ax中存放商;dx中存放余数 编程利用除法指令计算1001&#x2F;100 12345mov ax, 3E9Hmov bx, 64Hdiv bx;al中存放商;ah中存放余数 在内存单元中实现除法 双字型数据的定义： 12345data segment db 1 ;定义字节类型为01H，在data:0处，占1个字节 dw 1 ;定义字类型为0001H，在data:1处，占2个字节 dd 1 ;定义双字类型为00000001H，在data:3处，占4个字节data ends 例子：用div计算data中的第一个数据除以第二个数据，将商存放在第三个数据的存储单元中 1234567891011121314151617data segment dd 100001 dw 100 dw 0data endscode segmentstart: mov ax, data mov ds, ax mov ax, ds:[0] mov dx, ds:[2] div word ptr ds:[4] mov word ptr ds:[6], axcode endsend start 用dup设置内存空间dup和db、dw、dd等数据定义伪指令配合使用，用来进行数据的重复 示例： 指令 功能 相当于 db 3 dup(0) 定义了3个字节，它们的值都是0 db 0,0,0 db 3 dup(0,1,2) 定义了9个字节，有0、1、2重复3次构成 db 0,1,2,0,1,2,0,1,2 db 3 dup(‘abc’,’ABC’) 定义了18个字节，构成’abcABCabcABCabcABC’ db ‘abcABCabcABCabcABC’ 格式： db 重复次数 dup(重复的字节型数据) dw 重复次数 dup(重复的字型数据) dd 重复次数 dup(重复的双字型数据) 4.流程转移与子程序“转移”综述一般情况下指令是顺序地逐条执行的，而在实际中，常需要改变程序的执行流程 1234 mov ax, 0 jmp short, s add ax, 1s: inc ax 转移指令： 可以控制CPU执行内存中某处代码的指令 可以修改IP，或同时修改CS和IP的指令 转移指令的分类 按转移行为 段内转移：只修改IP，如jmp ax 段间转移：同时修改CS和IP，如jmp 1000:0 根据指令对IP修改的范围不同 段内短转移：IP修改范围为-128~127 段内近转移：IP修改范围为-32768~32767 按转移指令 无条件转移指令(如：jmp) 条件转移指令(如：jcxz) 循环指令(如：loop) 过程 中断 操作符offset用offset取得标号的偏移地址 格式：offset 标号 例子： 1234567assume cs:codecode segmentstart: mov ax, offset start ;相当于mov ax, 0s: mov ax, offset s ;相当于mov ax, 3code endsend start 问题：有如下程序段，添加2条指令，使该程序在运行中将s处的一条指令复制到s0处 12345678910111213assume cs:codecode segments: mov ax, bx ;该指令占用2字节 mov si, offset s mov di, offset s0 mov ax, cs[si] ;需要添加的指令1 mov cs[di], ax ;需要添加的指令2s0: nop ;nop的机器码占一个字节，起占位作用 nopcode endsends jmp指令jmp指令的功能 无条件转移，可以只修改IP，也可以同时修改CS和IP jmp指令要给出两种信息： 转移的目的地址 转移的距离 段间转移(远转移)：jmp 2000:1000 段内短转移：jmp short 标号;IP的修改范围为-128~127，8位的位移 段内近转移：jmp near ptr 标号;IP的修改范围为-32768~32767，16位的位移 地址 机器码 指令 076A:0000 B80000 mov ax, 0000 076A:0003 EB03 jmp short s 076A:0005 050100 add ax, 0001 076A:0008 40 s: inc ax 跳转的偏移地址等于(IP)+03 &#x3D; 0008，03为机器码中的03，IP此时为05 jmp short 的机器指令中，包含的是跳转到指令的相对位置，而不是转移的目标地址 两种段内转移 短转移：”jmp short 标号” 功能：(IP)&#x3D;(IP)+8位位移 原理： 8位位移&#x3D;”标号”处的地址-jmp指令后的第一个字节的地址； short指明此处的位移为8位位移； 8位位移的范国为-128~127，用补码表示； 8位位移由编译程序在编译时算出。 近转移：指令”jmp near ptr标号” 功能：(IP)&#x3D;(IP)+16位位移 原理： 16位位移&#x3D;”标号”处的地址-jmp指令后的第一个字节的地址； near ptr指明此处的位移为16位位移，进行的是段内近转移； 16位位移的范国为-32769~32767，用补码表示； 16位位移由编译程序,在编译时算出。 远转移：jmp far ptr 标号 far ptr指明了跳转的目的地址，包含了标号段地址CS和偏移地址IP 转移地址在寄存器中的jmp指令 指令格式：jmp 16位寄存器 功能：IP &#x3D; (16位寄存器) 例子：jmp ax 其他转移指令jcxz指令 格式：jcxz 标号 功能：如果(cx) &#x3D; 0，则跳转到标号处执行，与”jmp short 标号”类似 ​ 当(cx) !&#x3D; 0，什么也不做 loop指令 格式：loop 标号 指令操作： (cx) -&#x3D; (cx) 当(cx) !&#x3D; 0时，则转移到标号处执行 当(cx) &#x3D; 0时，程序向下执行 在它们对应的机器码中不包含转移的目的地址，而包含的是到目的地址的位移。 如果loop s的机器码中包含的是s的地址，则就对程序段在内存中的偏移地址有了严格的限制，易引发错误 当机器码中包含的是转移的位移，无论s处的指令的实际地址是多少，loop指令转移的相对位移是不变的。 这样的设计 ，方便了程序段在内存中的浮动装配 call指令和ret指令 调用子程序：call程序 返回：ret指令 1234567 mov ax, 0 call s mov ax, 4c00h int 21hs: add ax, 1 ret 实质：流程转移指令，它们都修改IP，或同时修改CS和IP 格式：all 标号 CPU执行call指令，进行两步操作 将当前的IP或CS和IP压入栈中 (sp) &#x3D; (sp)-2 ((ss)*16+(sp)) &#x3D; (IP) 转移到标号处执行指令 (IP) &#x3D; (IP) + 16位位移 相当于： 12push IPjmp near ptr 标号 指令call far ptr 标号，实现的是段间转移 CPU执行”call far ptr 标号”时的操作： (sp) &#x3D; (sp) - 2 ((ss)*16+(sp)) &#x3D; (CS) (sp) &#x3D; (sp) - 2 ((ss)*16+(sp)) &#x3D; (IP) (CS) &#x3D; 标号所在的段地址 (IP) &#x3D; 标号所在的偏移地址 相当于： 123push CSpush IPjmp far ptr 标号 还有call 寄存器、call word ptr 内存单元、call dword ptr 内存单元等 返回指令ret和retf： ret指令 retf指令 功能 用栈的数据，修改IP的内容 用栈的数据，修改IP的内容以及CS的内容 相当于 pop IP pop IPpop CS call和ret配合使用： 例子：计算2的N次方，计算前，N由CX提供 1234567891011121314151617181920212223assume cs:code, ss:stackstack segment db 16 dup(0)stack endscode segmentstart: mov ax, stack mov ss, ax mov sp, 16 mov ax, 1 mov cx, 10 call s mov bx, ax mov ax, 4c00h int 21h s: add ax, ax loop s retcode endsend start mul指令格式：mul 寄存器或mul 内存单元 8位乘法 16位乘法 被乘数(默认) AL AX 乘数 8位寄存器或内存字节单元 16位寄存器或内存字单元 结果 AX DX(高位) + AX(低位) 例子 mul bl(ax) = (al)*(bl)mul byte ptr ds:[0](ax) = (al)*((ds)*16+0) mul word ptr [bx+si+8](ax) = (ax)*16+((ds)*16+(bx)+(si)+8)结果的低16位(dx) = (ax)*16+((ds)*16+(bx)+(si)+8)结果的高16位 举例： 计算100*10 1234mov al, 100mov bl, 10mov bl;结果在ax中 计算100*10000 123456mov ax, 10000mov bx, 100mul bx;结果在dx和ax中;(dx)=000FH,(ax)=4240H;即，F4240H=1000000 模块化程序设计用寄存器传递参数 编程任务：计算data段中第一组数据的3次方，结果保存在后面一组dword单元中 1234567891011121314151617181920212223242526272829303132assume cs:codedata segment dw 1,2,3,4,5,6,7,8 dd 0,0,0,0,0,0,0,0data endscode segmentstart: mov ax, data mov ds, ax mov si, 0 mov di, 16 mov cx, 8s: mov bx, [si] call cube mov [di], ax mov [di].2, dx add si, 2 add di, 4 loop s mov ax, 4c00h int 21h cube: mov ax, bx mul bx mul bx retcode endsend start 如果传递的数据有3个及其以上，寄存器不够怎么办？ 用内存单元批量传递参数 例子：将data段中的字符串转为大写 123456789101112131415161718192021222324assume cs:codedata segment db &#x27;conversation&#x27;data endscode segmentstart: mov ax, data mov ds, ax mov si, 0 mov cx, 12 call capital mov ax, 4c00h int 21hcapital: and byte ptr [si], 11011111B inc si loop capital ret code endsend start 用栈传递参数 例子：计算(a-b)^3，a、b为字类型 进入子程序前，参数a、b入栈 调用子程序，将使栈顶存放IP 设，a&#x3D;3，b&#x3D;1 1234567891011121314151617181920212223242526assume cs:codecode segmentstart: mov ax, 1 push ax mov ax, 3 push ax call difcube mov ax, 4c00h int 21h difcube: push bp mov bp, sp mov ax, [bp+4] sub ax, [bp+6] mov bp, ax mul bp mul bp ;计算结果在dx和ax中 pop bp ret 4 ;指令ret n的含义 pop ip add sp, ncode endsends start 寄存器冲突问题编程：将data段中的字符串转化为大写 1234567891011121314151617181920212223242526assume cs:codedata segment db &#x27;conversation&#x27;,0data endscode segmentstart: mov ax, data mov ds, ax mov si, 0 call capital mov ax, 4c00h int 21hcapital: mov ch, 0 mov cl, [si] jcxz ok ;如果cx为0，则跳转到ret and byte ptr [si], 11011111B inc si jmp short capitalok: ret code endsend start 子程序标准框架： 子程序开始：子程序中使用的寄存器入栈 ​ 子程序内容 ​ 子程序使用的寄存器出栈 ​ 返回(ret、retf) 编程：将data段中的多个字符串转化为大写 12345678910111213141516171819202122232425262728293031323334353637assume cs:codedata segment db &#x27;word&#x27;,0 db &#x27;unix&#x27;,0 db &#x27;wind&#x27;,0 db &#x27;good&#x27;,0data endscode segmentstart: mov ax, data mov ds, ax mov si, 0 mov cx, 4 s: call capital loop s mov ax, 4c00h int 21hcapital: push cx push sichange: mov ch, 0 mov cl, [si] jcxz ok ;如果cx为0，则跳转到ret and byte ptr [si], 11011111B inc si jmp short changeok: pop si pop cx ret code endsend start 标志寄存器标志寄存器的结构 flag寄存器是按位起作用的，也就是说，它的每一位都有专门的含义，记录特定的信息。 8086CPU中没有使用flag的1、3、5. 12、13、14、15位，这些位不具有任何含义。 标志寄存器的作用 用来存储相关指令的某些执行结果 用来为CPU执行相关指令提供行为依据 用来控制CPU的相关工作方式 直接访问标志寄存器的方法 pushf：将标志寄存器的值压栈 popf：从栈中弹出数据，送入标志寄存器中 标志 值为1 值为0 意义 Overflow OF OV NV 溢出 Direction DF DN UP 方向 Sign SF NG PL 符号 Zero ZF ZR NZ 零值 Parity PF PE PO 奇偶 Carry CF CY NC 进位 零标志： ZF标记相关指令的计算结果是否为0 ZF&#x3D;1，表示结果是0，1表示逻辑真 ZF&#x3D;0，表示结果不是0，0表示逻辑假 示例： 指令 执行结果 mov ax, 1add ax, 0 ZF&#x3D;0，表示结果是0 mov ax, 1or ax, 0 ZF&#x3D;1，表示结果不是0 在8086CPU的指令集中，有的指令的执行是影响标志寄存器的，比如：add、sub、mul、div、inc、or、and等，它们大都是运算指令，进行逻辑或算术运算； 有的指令的执行对标志寄存器没有影响，比如：mov、push、pop等，它们大都是传送指令。 使用一条指令的时候，要注意这条指令的全部功能，其中包括执行结果对标记寄存器的哪些标志位选成影响。 奇偶标志： PF记录指今执行后，结果的所有二进制位中1的个数： 1的个数为偶数，PF&#x3D;1 1的个数为奇数，PF&#x3D;0 指令 执行结果 mov al, 1add al, 10 结果为0000 1011B &#x3D; 0000 0001B + 0000 1010B其中有3(奇数)个1，则PF&#x3D;0； mov al, 1or al, 2 结果为00000011B &#x3D; 0000 0001B or 0000 0010B其中有2(偶数)个1，则PF&#x3D;1； 符号标志： SF记录指令执行后，将结果视为有符号数 结果为負，SF&#x3D;1 结果为非负，SF &#x3D; 0 示例： 指令 执行结果 mov al, 10000001Badd al, 1 结果ax为10000010B，为负数，则SF&#x3D;1 sub ax, ax 结果ax为0，为非负数，故SF&#x3D;0 进位标志： 在进行无符号数运算的时候，CF记录了运算结果的最高有效位向更高位的进位值，或从更高位的借位值。 CF记录指令执行后： 有进位或借位，CF&#x3D;1 无进位或借位，CF&#x3D;0 示例： 指令 执行结果 mov al, 98Hadd al, al (al)&#x3D;30H，CF&#x3D;1，CF记录了最高有效位向更高位进位值 add al, al (al)&#x3D;60H，CF&#x3D;0，CF记录了最高有效向更高位的进位值 sub al, 98H (al)&#x3D;C8H，CF&#x3D;1，CF记录了向更高位的借位值 溢出标志： 在进行有符号数运算的时候，如结果超过了机器所能表示的范国称为溢出 OF记录有符号数操作指令执行后， 有溢出，OF&#x3D;1 无溢出，OF&#x3D;0 示例： 指令 执行结果 mov al, 98add al, 99 (al) &#x3D; 197，超出了8位有符号数的范围(-128~127)，OF&#x3D;1 mov al, 0F0Hadd al,88H (al) &#x3D; (-16)+(-120) &#x3D; -136，有溢出，OF&#x3D;1 CF和OF的区别： CF是对无符号数运算有意义的进&#x2F; 借位标志位 OF是对有符号数运算有意义的溢出标志位 应用： 指令 执行结果 mov al, 0F0Hadd al, 88H CF&#x3D;1，OF&#x3D;1，当无符号数运算有进位，当有符号数运算有溢出 综合：一条指令会带来多个寄存器的变化 指令 CF OF SF ZF PF sub al, al mov al, 10h add al, 90h mov al, 80h add al, 80h mov al, 0FCh add al, 05h mov al, 7Dh add al, 0Bh 带进(借)位的加减法adc带进位加法指令，它利用了CF位上记录的进位值 格式：adc 操作对象1, 操作对象2 功能：操作对象1-操作对象1+操作对象2+CF&amp;#x20; 例：adc ax,bx 实现的功能是：(ax)&#x3D;(ax)+(bx)+CF 指令 mov al, 98Hadd al, aladc al, 3 mov ax, 1add ax, axadc ax, 3 mov ax, 2mov bx, 1sub bx, axadc ax, 1 结果 (ax)&#x3D;34H (ax)&#x3D;5 (ax)&#x3D;4 解释 adc执行时，相当于计算：(ax)+3&#x3D;CF&#x3D;30H+3+1&#x3D;34H adc执行时，相当于计算：(ax)+3+CF&#x3D;2+3+0&#x3D;5 adc执行时，相当于计算：(ax)+1+CF&#x3D;2+1+1&#x3D;4 大数相加 问题：8086指令提供add指令 ，完成8位或16位如法，有更大的数相加时，如何做？ 例子：编程计算1EF000H+201000H，结果放在ax(高16位)和bx(低16位)中 1234mov ax, 001EH. ;存放高16位mov bx, 0F000H ;存放低16位add bx, 1000H ;将低16位相加adc ax, 0020H ;将高16位相加，以及进位1 例子：编程计算1E F000 1000H+20 1000 1EF0H，结果放在ax(高16位)、bx(次高16位)、cx(低16位)中 12345678mov cx, 1000Hadd cx, 1EF0Hmov bx, 0F000Hadc bx, 1000Hmov ax, 001EHadc ax, 0020H 问题：编写一个子程序，对两个128位数据进行相加。&amp;#x20; 名称：add128&amp;#x20; 功能：两个逆序存放的128位数据进行相加 1234567891011121314151617181920212223242526272829303132333435code segmentstart: mov ax, data mov ds, ax mov si, 0 mov di, 16 mov cx, 8 call add128 mov ax, 4c00h int 21hadd128: push ax push cx push si push dis: sub ax, ax mov ax, [si] adc ax, [di] mov [si], ax inc si inc si inc di inc di loop s pop di pop si pop cx pop ax retcode endsend start sub ax, ax是否可替换为mov ax, 0，或者是否可以不用写？ sub ax, ax可以将CF置为0 两个inc di是否可替换为add di, 2 inc不会导致CF的值变化，add可能会导致进位，使CF变为1 sbb指令 sbb：带借位减法指令 格式：sbb 操作对象1, 操作对象2 功能： 操作对象1&#x3D;操作对象1-操作对象2-CF 与sub区别：利用CF位上记录的借位值&amp;#x20; 比如：sbb ax, bx 实现功能：(ax)&#x3D;(ax)-(bx)-CF 应用：对任意大的数据进行减法运算&amp;#x20; 例如：计算003E 1000H-0020 2000H结果放在ax，bx中 12345mov bx, 1000Hmov ax, 003EHsub bx, 2000Hsbb ax, 0020H cmp和条件转移指令cmp指令 格式：cmp操作对象1,操作对象2 功能：计算操作对象1-操作对象2&amp;#x20; cmp 是比较指令，功能相当于减法指令，只是不保存结果 cmp 指令执行后，将对标志寄存器产生影响。 指令 cmp ax, ax mov ax, 8mov bx, 3cmp ax, bx 功能 做(ax)-(ax)的运算，结果为0，但并不在ax中保存 ，仅影响flag的相关各位。 (ax)&#x3D;8,(bx)&#x3D;3 标志寄存器 ZF&#x3D;1,PF&#x3D;1,SF&#x3D;0,CF&#x3D;0,OF&#x3D;0 ZF&#x3D;0,PF&#x3D;1,SF&#x3D;0,CF&#x3D;0,OF&#x3D;0 指令：cmp ax, bx 比较关系 (ax)?(bx) (ax)-(bx)特点 标志寄存器 等于 (ax)&#x3D;(bx) 0 ZF&#x3D;1 不等于 (ax)!&#x3D;(bx) !&#x3D;0 ZF&#x3D;0 小于 (ax)&lt;(bx) 将产生借位 CF&#x3D;1 大于等于 (ax)&gt;&#x3D;(bx) 不必借位 CF&#x3D;0 大于 (ax)&gt;(bx) 既不用借位，结果不为0 CF&#x3D;0且ZF&#x3D;0 小于等于 (ax)&lt;&#x3D;(bx) 或者借位，或者结果为0 CF&#x3D;1或ZF&#x3D;1 条件转移指令&amp;#x20; 根据单个标志位转移的指令： 指令 含义 测试条件 je&#x2F;jz 相等&#x2F;结果为0 ZF&#x3D;1 jne&#x2F;jnz 不等&#x2F;结果不为0 ZF&#x3D;0 js 结果为负 SF&#x3D;1 jns 结果非负 SF&#x3D;0 jo 结果溢出 OF&#x3D;1 jno 结果溢出 OF&#x3D;0 jp 奇偶位为1 PF&#x3D;1 jnp 奇偶位不为1 PF&#x3D;0 jb&#x2F;jnae&#x2F;jc 低于&#x2F;不高于等于&#x2F;有借位 CF&#x3D;1 jnb&#x2F;jae&#x2F;jnc 不低于&#x2F;高于等于&#x2F;无借位 CF&#x3D;0 根据无符号数比较结果进行转移的指令： 指令 含义 测试条件 jb&#x2F;jnae&#x2F;jc 低于则转移 CF&#x3D;1 jnb&#x2F;jae&#x2F;jnc 不低于则转移 CF&#x3D;0 jna&#x2F;jbe 不高于则转移 CF&#x3D;1或ZF&#x3D;1 ja&#x2F;jnbe 高于则转移 CF&#x3D;0且ZF&#x3D;0 根据有符号数比较结果进行转移的指令： 指令 含义 测试条件 jl&#x2F;jnge 小于则转移 SF&#x3D;1且OF&#x3D;0 jnl&#x2F;jge 不小于转移 SF&#x3D;0且OF&#x3D;0 jle&#x2F;jng 小于等于转移 SF&#x3D;0或OF&#x3D;1 jnle&#x2F;jg 不小于等于则转移 SF&#x3D;1且OF&#x3D;1 参数说明： j-Jmup；e-Equal；n-Not；b-Below；a-Above；L-less； g-Greater；s-Sign；c-carry；p-Parity；o-overflow；z-Zero 条件转移指令的使用 jxxx系列指令和cmp指令配合，构造条件转移指令 不必再考虑cmp指令对相关标志位的影响和jxxx指令对相关标志位的检测 可以直接考處arap和alua看令配合使用时表现出来的迎租合义。 jxxx系列指令和cmp指令配合实现高级语言中if语句的功能 例如：如果(ah)&#x3D;(bh)，则(ah)&#x3D;(ah)+(ah)，否则(ah)&#x3D;(ah)+(bh) 123456 cmp ah, bh je s add ah, bh jmp short oks: add ah, ahok: ret 等价于C： 123456if(a == b)&#123; a += a;&#125;else&#123; a += b;&#125; 例如：如果(ax)&#x3D;0，则(ax)&#x3D;(ax)+1 1234 add ax, 0 jnz s inc axs: ret 等价于C： 123if(a == 0)&#123; a++;&#125; 条件转移指令应用请编程实现如下统计，用ax保存统计结果 统计数值为8的字节的个数 123456789101112131415161718192021assume cs:code, ds:datadata segment db 8,11,8,1,8,5,63,38data endscode segmentstart: mov ax, data mov ds, ax mov ax, 0 mov bx, 0 mov cx, 8 s: cmp byte ptr [bx], 8 jne next ;不为0，ze inc axnext: inc bx loop scode endsend start DF标志和串传送指令编程：将data段中的第一个字符串复制到它后面的空间中 123456789101112131415161718192021222324assume cs:code, ds:data data segment db &#x27;Welcome to masm!&#x27; db 16 dup(0)data endscode segmentstart: mov ax, data mov ds, ax mov si, 0 mov di, 16 mov cx, 8 S: mov ax, [si] mov [di], ax add si, 2 add di, 2 loop s mov ax, 4c00h int 21hcode endsend start DF：方向标志位 功能 在串处理指令中，控制每次操作后si、di的增减 DF&#x3D;0：每次操作后si，di递增 DF&#x3D;1：每次操作后si，di递减 对DF位进行设置的指令： cld指令：将标志寄存器的DF位设为0(clear) std指令：将标志寄存器的DF位设为1(setup) 串传送指令1：morsb 功能：(以字节为单位传送) ((es)*16+(di)) = ((ds)*16+(si)) 如果DF&#x3D;0则：(si)&#x3D;(si)+1 ​ (di)&#x3D;(di)+1 如果DF&#x3D;1则：(si)&#x3D;(si)-1 ​ (di)&#x3D;(di)-1 串传送指令2：movsw 功能：(以字为单位传送) ((es)*16+(di))=((ds)*16+(si) 如果DF&#x3D;0则：(si)&#x3D;(si)+2 ​ (di)&#x3D;(di)+2 如果DF&#x3D;1则：(si)&#x3D;(si)-2 ​ (di)&#x3D;(di)-2 编程：将data段中的第一个字符串复制到它后面的空间中 1234567891011121314151617181920212223assume cs:code, ds:data data segment db &#x27;Welcome to masm!&#x27; db 16 dup(0)data endscode segmentstart: mov ax, data mov ds, ax mov es, ax mov si, 0 mov di, 16 mov cx, 8 cld S: movsw loop s mov ax, 4c00h int 21hcode endsend start rep指令 rep指令常和串传送指令配合使用 功能：根据cx的值，重复执行后面的指令 用法：rep movsb等价于s: movsb loop s ​ rep movsw等价于s: movsw loop s 123456789101112131415161718192021assume cs:code, ds:data data segment db &#x27;Welcome to masm!&#x27; db 16 dup(0)data endscode segmentstart: mov ax, data mov ds, ax mov es, ax mov si, 0 mov di, 16 mov cx, 8 cld rep movsw mov ax, 4c00h int 21hcode endsend start 实例：用串传送指令，将F000H段中的最后的16给字符复制到data段中 12345678910111213141516171819202122assume cs:code, ds:datadata segment db 16 dup(0)data endscode segmentstart: mov ax, data mov es, ax mov ax, 0F000H mov ds, ax mov di, 15 ;数据段的最后一个字符的位置为16 mov si, 0FFFFH ;F000H段最后一个字符的位置为F000:FFFF mov cx, 16 std ;设置为递减(-1) ref movsb mov ax, 4c00h int 21hcode endsend start 5.中断及其应用移位指令 逻辑左移：SHL OPR, CNT 逻辑右移：SHR OPR, CNT 循环左移：ROL OPR, CNT 循环右移：ROR OPR, CNT 算数左移：SAL OPR, CNT 算数右移：SAR OPR, CNT 带进位循环左移：RCL OPR, CNT 带进位循环右移：RCR OPR, CNT 注意：S,SH-Shit；L-Left；R-Right；R,Ro-Rotate；C-Carry SHL OPR, CNT，将OPR逻辑左移CNT位 将寄存器或内存单元中的数据向左移位 将最后移出的一位写入CF中 最低位用0补充 shl指令操作示例： 12345mov al, 01010001Bmov cl, 3 ;移动位数大于1时，必须要使用cl来存放移动位数shl al, cl;结果(al)=10100010B;CF=0 常用方法： 将X逻辑左移一位，相当于执行X&#x3D;X*2 将X逻辑右移一位，相当于执行X&#x3D;X&#x2F;2 操作显存数据屏幕上的内容&#x3D;显存数据 其中，B8000h~BFFFFh，共32K的空间，是80*25 彩色字符模式第0页的显示缓冲区。 显示缓冲区的结构 行数 各行所需字节数 显示缓冲区地址范围 0 160(A0H) B800:0000~B800:009F 1 160(A0H) B800:0000~B800:013F … … … 24 160(A0H) B800:0F00~B800:0F9F 要显示的每个字符所要占2个字节 低字节位：要显示符号的ASCII 高字节位：显示属性字节 7 6 5 4 3 2 1 0 BL R G B I R G B 闪烁 背景 背景 背景 高亮 前景 前景 前景 显示信息最直接的方式： 例子：在屏幕中间显示一段语句，白底蓝字 1234567891011121314151617181920212223242526272829assume cs:code, ds:datadata segment db &#x27;Welcome to masm!&#x27;data endscode segmentstart: mov ax, data mov ds, ax mov ax, 0B800H mov es, ax ;设定显存的段地址 mov si, 0 mov di, 160*12+80-16 ;指定显示的地址为屏幕正中间 mov cx, 16 ;设置循环次数s: mov al, [si] mov es:[di], al ;ACSII inc di mov al, 71H mov es:[di], al ;显示属性 inc di inc si loop s mov ax, 4c00h int 21hcode endsend start 描述内存单元的标号代码段中的标号可以用来标记指令、段的起始地址 代码段中的数据也可以用标号 12345678910111213141516171819assume cs:codecode segment a: db 1,2,3,4,5,6,7,8 b: dw 0start: mov si, offset a mov bx, offset b mov cx, 8s: mov al, cs:[si] mov ah, 0 add cs:[bx], ax inc si loop s mov ax, 4c00h int 21hcode endsend start 去冒号的数据标号 123456789101112131415161718assume cs:codecode segment a db 1,2,3,4,5,6,7,8 ;a代表地址为code:0，长度为字节的内存单元 b dw 0 ;b代表地址为code:8，长度为字的内存单元start: mov al, a[si] ;等价于mov al, cs:0[si] mov al, a[3] ;等价于mov al, cs:0[3] mov al, a[bx+si+3] ;等价于mov al, cs:0[bx+si+3] mov ax, b ;等价于mov ax, cs:[8] mov b, 2 ;等价于mov word ptr cs:[8], 2 inc b ;等价于inc word ptr cs:[8] ;mov al, b ;报错 mov ax, 4c00h int 21hcode endsend start 在code 段中使用的标号a、b后面没有”:”，它们同时描述内存地址和单元长度的标号。 标号a 地址code:0 以后的内存单元都是字节 标号b 地址code:8 以后的内存单元都是字 12345678910111213141516171819202122assume cs:code, ds:datadata segment a db 1,2,3,4,5,6,7,8 b dw 0data endscode segmentstart: mov ax, data mov ds, ax mov si, 0 mov cx, 8s: mov al, a[si] mov ah, 0 mov b, ax inc si loop s mov ax, 4c00h int 21hcode endsend start 扩展用法：将标号当作数据来定义 123456data segment a db 1,2,3,4,5,6,7,8 b dw 0 c dw a,b ;存放每段数据的起始地址(指针数组) ;等价于c dw offset a, offset bdata ends 123456data segment a db 1,2,3,4,5,6,7,8 b dw 0 c dd a,b ;存放每段数据的起始地址(指针数组) ;等价于c dw offset a, seg a, offset b, seg b (seg操作符：取段地址)data ends 数据的直接定址表问题：以十六进制的形式在屏幕中间显示给定的byte型数据 分析：先将一个byte的高4位和低4位分开，显示对应的数码字符 12345678910111213141516171819202122232425262728293031323334353637383940assume cs:codecode segmentstart: mov al, 2Bh ;00101100b call showbyte mov ax, 4c00h int 21h showbyte: jmp short show table db &#x27;0123456789ABCDEF&#x27; ;字符表show: push bx push es push cx mov ah, al mov cl, 4 shr ah, cl ;右移4位，得到2Bh的高4位 00000010b=2h and al, 00001111B ;and运算，得到2Bh的低4位 00001100b=Bh ;用高4位的值(ah)作为相对于table的偏移，取得对应的字符并显示 mov bl, ah mov bh, 0 ;(bx)=2h mov ah, table[bx] ;(ah)存放的&#x27;2&#x27; mov bx, 0B800h mov es, bx ;显存的段地址 mov es:[160*12+40*2], ah ;用低4位的值(al)作为相对于table的偏移，取得对应的字符 mov bl, al mov bh, 0 ;(bx)=Bh mov al, table[bx] ;(al)存放的&#x27;B&#x27; mov es:[160*12+40*2+2], al pop cx pop es pop bx retcode endsend start 优点： 算法清晰和简洁 加快运算速度 使程度易于扩充 代码的直接定址表问题： 实现一个子程序setscreen，为显示输出提供如下功能 清屏 设置颜色 设置背景颜色 向上滚动一行 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118assume cs:codecode segmentstart: mov al, 1 ;功能号 mov ah, 1 ;属性 call setscreen mov 4c00h int 21hsetscreen: jmp short set ;fun1:清屏 fun2:颜色 fun3:背景颜色 fun4:向上滚动一行 table dw fun1, fun2, fun3, fun4set: push bx cmp ah, 3 ja sret ;大于3，则退出 mov bl, ah mov bh, 0 add bx, bx call word ptr table[bx]sret: pop bx retfun1: ;清屏 push bx push cx push es mov bx, 0B800h mov es, bx ;设置显存的段地址 mov bx, 0 mov cx, 2000fun11: mov byte ptr es:[bx], &#x27;&#x27; ;将显存上的字符设为空格符 add bx, 2 ;略过字节属性 loop fun11 pop es pop cx pop bx retfun2: ;设置前景颜色 push bx push cx push es mov bx, 0B800h mov es, bx ;设置显存的段地址 mov bx, 1 mov cx, 2000fun21: and byte ptr es:[bx], 11111000b ;将前景颜色置为黑 or es:[bx], al ;设置前景颜色 add bx, 2 ;略过字符 loop fun21 pop es pop cx pop bx retfun3: ;设置背景颜色 push bx push cx push es mov bx, 0B800h mov es, bx ;设置显存的段地址 mov bx, 1 mov cx, 2000fun31: and byte ptr es:[bx], 10001111b ;将背景颜色置为黑 or es:[bx], al ;设置背景颜色 add bx, 2 ;略过字符 loop fun31 pop es pop cx pop bx retfun4: ;向上滚动一行 push bx push cx push es mov si, 0B800h mov es, si ;设置显存的段地址 mov ds, si mov si, 160 ;ds:si mov di, 0 ;es:di cld mov cx, 24fun41: ;向上移动一行 push cx mov cx, 160 rep movsb pop cx loop fun41 mov cx, 80 mov si, 0fun43: ;将最后一行置为空格符 mov byte ptr es:[160*24+si], &#x27; &#x27; add si, 2 loop fun43 pop es pop cx pop bx retcode endsend start 中断的概念 中断：CPU不在接着(刚执行完的指令)向下执行，而是转去处理中断信息 内中断：由CPU内部发生的事 外中断：由外部设备发生的事 CPU内部产生的中断信息： 除法错误，比如：执行div指令产生的除法溢出 单步执行 执行into指令 执行int指令 8086的中断类型码： 除法错误：0 单步执行：1 执行into指令：4 执行int n指令，立即数n为中断类型码 12345678910111213141516171819assume cs:code, ss:stack, ds:datastack segment db 200h dup(0)stack endsdata segment msg db 13, 10, &#x27;hello world!&#x27;, 10, 13, &#x27;$&#x27;data endscode segmentstart: mov ax, data mov ds, ax lea dx, msg ;lea就是目标地址传送指令：将一个近地址指针写入到指定的寄存器 mov ah, 9 int 21h ;调用中断的9号功能 mov ax, 4c00h int 21hcode endsend start 中断处理程序 CPU收到中断信息怎么办？ 执行中断处理程序 中断处理程序在哪里？ 中断信息和其处理程序的入口地址之间有某种联系，CPU根据中断信息可以找到要执行的处理程序。 中断向量表。 由中断类型码，查表得到中断处理程序的入口地址，从而定位中断处理程序。 8086CPU的中断向量表： (IP)=(N*4)，(CS)=(N*4+2)，N为中断类型码 中断过程： 中断过程由CPU的硬件自动完成 用中断类型码找到中断向量，并用它设置CS和IP 8086CPU的中断过程： 从中断信息中取得中断类型码 (取得中断类型码N) 标志寄存器的值入栈——中断过程中要改变标志寄存器的值，需要先行保护 (pushf) 设置标志寄存器的第8位TF和第9位IF的值为0 (TF&#x3D;0, IF&#x3D;0) CS的内容入栈 (push CS) IP的内容入栈 (push IP) 从中断向量表读取中断处理程序的入口地址，设置IP和CS ((IP)=(N*4)，(CS)=(N*4+2)) 编制中断处理程序CPU随时都可能检测到中断信息 ，所以中断处理程序必须常驻内存(一直存储在内存某段空间之中)。 中断处理程序的入口地址，即中断向量，必须存储在对应的中断向量表表项中(0000:0000~0000:03FF)。 除法错误中断 编与一个0号中断处理程序，它的功能是在屏幕中间显示”overflow!”后，然后返回到操作系统 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748asssume cs:codecode segmentstart: ;安装do0程序 mov ax, cs mov ds, ax mov si, offset do0 ;指向源地址ds:si为cs:do0 mov ax, 0 mov es, ax mov di, 200h ;指向目标地址es:di为0000:0200 mov cx, offset do0end - offset do0 ;循环次数 cld ;正向传输 rep movsb ;从ds:si复制到es:di ;设置中断向量表 mov ax, 0 mov es, ax ;将0号中断要指向的地址更改为指向do0 mov word ptr es:[0*4], 200h ;设置偏移地址 mov word ptr es:[0*4+2], 0 ;设置段地址 mov ax, 4c00h int 21h do0: jmp short do0start db &#x27;overflow!&#x27;do0start: mov ax, cs mov ds, ax mov si, 202h ;设置ds:si为cs:0202,为字符串的起始地址 mov ax, 0B800h mov es, ax mov di, 12*160+36*2 ;设置es:di为B800:07C8，设置在屏幕中间 mov cx, 9 ;设置字符串循环次数s: ;循环复制到显存 mov al, [si] mov es:[di], al inc si add di, 2 loop s mov ax, 4c00h int 21hdo0end:nopcode endsend start 单步中断Dubug中的t命令 程序的正常执行：取指令、改变CS:IP、执行指令、取指令… Debug提供了单步中断的中断处理程序，功能为显示所有寄存器中的内容后等待输入命令。 是什么，让CPU能执行一条指令就停下来？ Debug利用了CPU提供的单步中断的功能 使用t命令时，Debug将TF标志设为1，使CPU工作在单步中断方式下… 自定义单步中断处理程序，还可以实现特殊的功能 两个和中断相关的奇存器标志位： TF-陷阱标志(Trap flag)：用于调试时的单步方式操作。当TF&#x3D;1时，每条指令执行完后产生陷阱，由系统控制计算机；当TF&#x3D;0时，CPU正常工作，不产生陷阱。 IF-中断标志(Interrupt flag)：当IF&#x3D;1时，分许CPU响应可屏蔽中断请求；当IF&#x3D;0时，关闭中断。 CPU在执行完一条指令之后，如果检测到标志寄存器的TF位为1，则产生单步中断(中断类型码为1 ，引发中断过程，执行中断处理程序)。 中断过程： 取得中断类型码1 标志奇在器入栈，TF、IF设置为0 为什么要TF、IF设置为0？ 中断处理程序也由一条条指令组成的。 如果在执行中断处理程序之前，TF&#x3D;1，则CPU在执行完中断处理程序的第一条指令后，又要产生单步中断，转去执行单步中断的中断处理程序的第一条指令 上面的过程将陷入一个永远不能结束的循环CPU永远执行单步中断处理程序的第一夅指令 所以，在进入中断处理程序之前，设置TF&#x3D;0 CS、IP入栈 (IP)=(1*4), (CS)=(1*4+2) 中断不响应的情况 一般情况下，CPU在执行完当前指令后，如果检测到中断信息，就响应中断，引发中断过程。 在有些情况下，CPU 在执行完当前指令后，即便是发生中断，也不会响应。 例：在执行完向ss寄存器(栈基地址)传送数据的指令后，即便是发生中断，CPU也不会响应。 1234mov ax, 1000mov ss, axmov sp, 10mov ax, 0 ;执行t命令后会将mov ss, ax和mov sp,10一口气执行完，到达此行 原因：ss:sp联合指向栈项，而对它们的设置应该连续完成 以保证对栈的正确操作 下面这种写法是错位的！！应该杜绝 1234mov ax, 1000mov ss, axmov ax, 0mov sp, 10 由int指令引发的中断int格式：int n，n为中断类型码 功能：引发中断过程 int指令与call指令相似，都是调用一段程序 执行int n时，pushf、push CS、push IP 编写供应用程序调用的中断例程 编程时，可以用int指令调用子程序 此程序即中断处理程序，简称为中断例程 可以自定义中断例程，实现特定功能 示例：中断7ch的中断例程的编写和安装 写7ch的中断例程，完成特定任务 求一个word型数据的平方 参数(ax)&#x3D;要计算的数据 返回值：dx,ax存放结果的高、低16位 1234567891011121314151617181920212223242526272829303132assume cs:codecode segmentstart: ;安装中断例程 mov ax, cs mov ds, ax mov si, offset do7c mov ax, 0 mov es, ax mov di, 200h mov cx, offset do7cend-offset do7c cld rep movsb ;设置中断向量表 mov ax, 0 mov es, ax mov word ptr es:[7ch*4], 200h mov word ptr es:[7ch*4+2], 0 mov ax, 4c00h int 21h ;中断例程do7c: mul ax ;执行iret时，pop IP、pop CS、popf iret ;中断返回。使程序返回到原来发⽣中断的地⽅。其作⽤是从中断中恢复中断前的状态do7cend:nopcode endsend start 中断处理程序的常规步骤： 保存用到的寄存器 处理中断 恢复用到的寄存器 用iret指令返回 BIOS和DOS中断处理BIOS——基本输入输出系统 BIOS，是在系统板的ROM中存放着一套程应 容量：8KB 地址：从FE000H开始 BIOS中的主要内容 硬件系统的检测和初始化程序 外部中断和内部中断的中断例程 用于对硬件设备进行I&#x2F;O操作的中断例程 其他和硬件系统相关的中断例程 使用BIOS功能调用 ，程序员不用了解硬件操作细节，直接使用指令设置参数，并中断调用BIOS例程，即可完成相关工作！ 使用BIOS功能调用： 方便编程 能出简洁、可读性好、易于移植的程序 BIOS中断调用示例 任务：在屏幕的5行12列显示3个红底高亮闪烁绿色的’a’ 使用BIOS的10h中断 (ah)&#x3D;2时，调用10h中断例程的2号子程序，设置光标位置 (ah)&#x3D;9时，调用第10h中断例程的9号子程序，在光标位置显示字符 12345678910111213141516171819assume cs:codecode segment mov ah, 2 ;设置光标功能2 mov bh, 0 ;第0页 mov dh, 5 ;dh中方行号 mov dl, 12 ;dl中方列号 int 10h mov ah, 9 ;显示字符功能9 mov al, &#x27;a&#x27; ;字符 mov bl, 11001010b ;颜色属性 mov bh, 0 ;第0页 mov cx, 3 ;字符重复个数 int 10h mov ax, 4c00h int 21hcode endsend 其他的BIOS中断: 显示服务(Video Service——INT 10H) 直接磁盘服务(Direct Disk Service——INT 13H) 串行口服务(Serial Port Service——INT 14H) 杂项系统服务(Miscellaneous System Service——INT 15H) 键盘服务(Keyboard Service——INT 16H) 并行口服务(Parallel Port Service——INT 17H) 时钟服务(Clock Service——INT 1AH) 直接系统服务(Direct System Service) DOS中断： INT 20H一终止程序运行 INT 21H一功能调用 INT 22H一终止处理程序的地址 INT 23H—Ctrl+C 处理异常 INT 24H一致命错误处理程亮 INT 25H一读磁盘扇区(忽略逻辑结构) INT 26H一写磁盘扇区(忽略逻辑结构) INT 27H一终止、并驻留在内存 INT 28H—DOS 空闲 INT 2FH一多重中断服务 INT 33H一鼠标功能 BIOS和DOS在所提供的中断 例程中包舍了许多子程序，这些子程序实现了程序员在编程的时常用到的功能。 和硬件设备相关的DOS中断例程中，一般都调用BIOS的中断例程。 int 21h DOS中断例程的应用 4ch号功能：程序返回 功能号在ah，返回结果保存在al 123mov ah, 4chmov al, 0int 21h 09h号功能：在光标位置显示字符串 ds:bx指向要显示的字符串(用’$’结束) 编程在屏幕中显示字符串： 12345678910111213141516assume cs:code, ds:datadata segment masm db &#x27;Welcom to masm!$&#x27;data endscode segmentstart: mov ax, data mov ds, ax mov dx, masm mov ah, 9 int 21h mov ax, 4c00h int 21hcode endsend start BIOS和DOS中断例程的安装过程 CPU一加电，初始化(CS)&#x3D;0FFFFH ,(IP)&#x3D;0，自动从FFFF:0单元开始执行程序。FFFF:0处有一条转跳指令，CPU执行该指令后，转去执行B1OS中的硬件系统检测和初始化程序。 初始化程序将建立BIOS 所支持的中断向量，即将BIOS提供的中断例程的入口地址登记在中断向量表中。 硬件系统检测和初始化完成后，调用int 19h进行操作系统的引导 。从此将计算机交由操作系统控制。 DOS启动后，除完成其它工作外，还将它所提供的中断例程装入内存，并建立相应的中断向量。 端口的读写使用端口访问外设：以发声为例 123456789101112131415161718192021assume cs:codecode segmentstart: mov al, 08h ;设置声音的频率 out 44h, al out 42h, al in al, 61h ;读设备控制器端口原值 mov ah, al ;保存原值 or al, 3 ;打开扬声器和定时器 out 61h, al ;接通扬声器，发声 mov cx, 60000 ;延时delay: nop loop delay mov al, ah ;恢复端口原值 out 61h, al mov ax, 4c00h int 21hcode endsend start CPU的邻居 CPU可以直接读写3个地方的数据 CPU内部的寄存器 内存单元 端口： 各种接口、网卡、显卡等 主板上的接口芯片 其他芯片 各种芯片工作时，都有一些寄存器由CPU读写 从CPU角度，将各寄存器当端口，并统一编址 CPU用统一的方法与各种设备通信 读写内存与寄存器的指令 mov、add、push 读写端口的指令 in：CPU从端口读取数据 out：CPU往端口写入数据 端口的读写 访问端口的方法： in al, 60h：从60h号端口读入一个字节 执行时与总线相关的操作： CPU通过地址线将地址信息60h交出 CPU通过控制线发出端口读命令，选中端口所在的芯片，并通知要从中读取数据 端口所在的芯片将60h端口中的数据通过数据总线送入CPU。 端口的读写过程演示 12in al, 20h ;机器码为E420out 21h, al ;机器码为E621 端口的读写指令示例 对0~255以内的端口进行读写，端口号立即数给出 12in al, 20h ;从20h端口读入一个字节out 21h, al ;往21h端口写入一个字节 对256~65535的端口进行读写时，端口号放在dx中 123mov dx, 3f8h ;将端口号3f8h送入dxin al, dx ;从3f8h端口读入一个字节out dx, al ;向3f8h端口写入一个字节 注意： 在in和out指令中，只能使用ax或al来存放从端口中读入的数据或要发送到端口中的数据。 访问8位端口时用al，访问16位端口时用ax。 操作CMOS RAM芯片CMOS RAM芯片 包含一个实时钟和一个有128个存储单元的RAM存储器。 128个字节的RAM中存储：内部实时钟、系统配置信息、相关的程序(用于开机时配置系统信息) CMOS RAM芯片靠电池供电，关机后其内部的实时钟仍可正常工作，RAM中的信息不丢失。 该芯片内部有两个端口，端口地址为20h和71h，CPU通过这两个端口读写CMOS RAM 70h地址端口，存放要访问的CMOS RAM单元的地址 71h数据端口，存放从选定的单元中读取的数据，或要写入到其中的数据 读取CMOS RAM的两个步骤： 将要读取的单元地址送入70h地址端口 从数据端口71h读出指定单元的内容 提取CMOS RAM中存储的时间信息 当前时间在CMOS RAM中用6个字节存放 内容 秒 分 时 日 月 年 地址 00 01 02 03 04 05 06 07 08 09 注意：这六个信息的长度都为1个字节 例如：今天为10月21日(时间信息用BCD码存放) 2 1 1 0 0010 0001 0001 0000 在屏幕上显示当前月份 12345678910111213141516171819202122assume cs:codecode segmentstart: mov al, 8 out 70h, al ;首先要向地址端口70h写入要访问的单元地址，8单元存放的为月份 in al, 71h ;在从数据端口71h中取得指定单元中的数据中的月份，放到al中 mov ah, al mov cl, 4 shr ah, cl ;获取高4位，月份的十位数 and al, 00001111b ;获取低4位，月份的个位数 add ah, 30h ;获取十位数所对应的ASCII码 add al, 30h ;获取个位数所对应的ASCII码 mov bx, 0B800h mov byte ptr es:[160*12+40*2], ah ;写入屏幕中间 mov byte ptr es:[160*12+40*2+2], al mov ax, 4c00h int 21hcode endsend start 外设连接与中断外中断：由外部设备发生的事件引起的中断 可屏蔽中断： 可屏蔽中断是CPU 可以不响应的外中断。 CPU 是否响应可屏蔽中断，要看标志奇存器的IF位的设置。 当CPU检测到可屏蔽中断信息时： 如果IF&#x3D;1，则CPU在执行完当前指令后响应中断，引发中断过程； 如果IF0&#x3D;0，则不响应可屏蔽中断。 不可屏蔽中断： 不可屏蔽中断是CPU必须响应的外中断 当CPU检测到不可屏蔽中断信息时，则在执行完当前指令后，立即响应，引发中断过程 对于8086CPU不可屏蔽中断的中断类型码固定为2 几乎所有由外设引发的外中断，都是可屏蔽中断，比如键盘输入、打印机请求。 不可屏蔽中断在系统中有必须处理的紧急情况发生时用来通知CPU的中断信息 外中断处理过程 可屏蔽中断所引发的中断过程： 取中断类型码n 注意：可屏蔽中断信息来自于CPU外部，中断类型码是通过数据总线送入CPU 对比内中断：中断类型码是在CPU内部产生的 标志寄存器入栈，IF&#x3D;0，TF&#x3D;0 将IF置0的原因：进入中断处理程序后，禁止其他的可屏蔽中断 如果在中断处理程序中需要处理可屏蔽中断，可以用指令将IF置1 CS、IP入栈 (IP)=(n*4)，CS=(n*4+2) 由此转去执行中断处理程序。 不可屏蔽中断的中断过程： 标志奇存器入栈，IF&#x3D;0， TF&#x3D;0 CS、IP入栈； (IP)&#x3D;(8)，(CS)&#x3D;(0AH). 中断值固定为2，不必取中断码 8086CPU提供的设置IF的指令： sti：用于设置IF&#x3D;1 cli：用于设置 IF&#x3D;0 PC机键盘的处理过程键盘输入的处理过程 键盘输入 键盘上的每一个键相当于一个开关，键盘中有一个芯片对键盎上的每—个键的开关状态进行扫描。 按下一个键时的操作： 开关接通，该芯片就产生一个扫描鸡，扫描码说明了按下的键在键盘上的位置。 扫描码被送入主板上的相关接口芯片的寄存器中，该寄存器的端口地址为60H。 松开按下的键时的操作： 产生一个扫描码，扫描码说明了松开的键在键密上的位置。 松开按键时产生的扫描码也被送入60H 端口中。 扫描码：长度为一个字节的编码 按下一个键时产生的扫描码一一通码，通码的第7位为0 松开一个键时产生的扫描码一一断码，断码的第7位为1 例：G键的通码为22H，断码为a2H g键的通码：0010 0010 g键的断码：1010 0010 公式：通码+80h=断码 引发9号中断 键盘的输入到达60H端口时 ，相关的芯片就会向CPU发出中断类型码为9的可屏蔽中断信息。 CPU检测到该中断信息后 ，如果IF&#x3D;1，则响应中断，引发中断过程，转去执行int 9中断例程。 输入的的字符键值如何保存？ 有BIOS键盘缓冲区 ！ BIOS键盘缓冲区：是系统启动后，BIOS用于存放int 9中断例程所接收的键盘输入的内存区。 Bos键盘缓冲区：可以存储15个键盎输入，一个键盘输入用一个字单元存放，高位字节存放扫描码，低位字节存放字符码 输入了控制键和切换键，如何处理？ 0040:17：键盘状态字节 7 6 5 4 3 2 1 0 Insert CapsLock NumLock ScrollLock Alt Ctrl 左shift 右shift 执行int 9中断例程 B1OS 中提供的处理键盘输入的int 9中断例程的工作 读出60H 端口中的扫描码 根据扫描码分情况对待 如果是字符键的扫描码，将该扣描码和它所对应的字符码(即：ASCI码)送入内存中的BIOS键盎缓冲区； 如果是控制键(比如：Ctrl)和切换键(比如：CapsLock)的扫描码，则将其转变为状态字节(用二进制位记录控制键和切换键状态的字节)写入内存中存储状态字节的单元 对键盘系统进行相关的控制，如向相关芯片发出应答信息 输入’a’的处理过程 定制键盘输入处理键盘输入的处理过程 键盘产生扫描码 扫描码送入60h端口 引发9 号中断 以上都是由硬件系统完成的 CPU执行int 9中断例程 ，处理键盘输入 DOS系统提供int 9中断例程 或者按照开发需求定制处理键盘的输入 编程任务 在屏幕中间依次显示’a’~’z’，并可以让人看清。 在显示的过程中，按下Esc键后，改变显示的颜色。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091assume cs:code, ss:stack, ds:datastack segment db 128 dup(0)stack endsdata segment dw 0, 0data endscode segmentstart: mov ax, stack mov ss, ax mov sp, 128 mov ax, data mov ds, ax ;改中断例程入口地址 mov ax, 0 mov es, ax push es:[9*4] pop ds:[0] push es:[9*4+2] pop ds:[2] mov word ptr es:[9*4], offset int9 mov es:[9*4+2], cs ;在同一位置依次显示字符a~z mov ax, 0B800h mov es, ax mov ah, &#x27;a&#x27;s: mov es:[160*12+40*2], ah call delay inc ah cmp ah, &#x27;z&#x27; jna s ;恢复原来的地址 push ds:[0] pop es:[9*4] push ds:[2] pop es:[9*4+2] mov 4c00h int 21h ;定义延时函数，设置一个循环函数delay: push ax push dx mov dx, 10h mov ax, 0s1: sub ax, 1 sbb dx, 0 cmp ax, 0 jne s1 cmp dx, 0 jne s1 pop dx pop ax ret ;定义中断例程int9: push ax push bx in al, 60h pushf pushf pop bx and bh, 11111100b push bx popf call dword ptr ds:[0] cmp al, 1 jne int9ret mov ax, 0B800h mov es, ax inc byte ptr es:[...]int9ret: pop es pop bx pop ax iretcode endsend start 改写中断例程的方法用中断响应外设以典型输入设计——键盘操作为例： 硬件中断int 16h BIOS中断int 16h DOS中断int 21h 由键盘上按下或松开个键时，如果中断是允许的，就会产生int 9h中断，并转到BIOS的键盘中断处理程序。 G10s中断提供基本的鍵盘操作，功能号(AH)&#x3D;00H、10H从键盘读入字符01H、11H读取键盘状态024、12H读取键盘标志03H设置重复率04H设置键盘点击05H字符及其扫描码进栈在使用功能键和变换键的程序中很重要。 DOs中断提供丰富、便捷的功能调用功能号(AH)&#x3D;01H从键盘输入一个字符并回显06H读键盘字符07H从键盘输入一个字符不回显08H从键盘输入一个字符，不回显，检测CTRL-Break0AH输入字符到指定地址的缓冲区0BH读键盘状态0CH清除键盘缓冲区，并调用一种键盎功能 对键盘输入的处理的int 9h中断和int 16h中断 字符的输入输出问题：设计一个最基本的字符串输入程序，需要具备下面的功能 在输入的同时需要显示这个字符串 一般在输入回车符后，字符串输入结束 能够删除已经输入的字符一一用退格键 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148assume cs:code, ds:datadata segment db 32 dup(?) ;?表示所定义的变量未指定初值,就是说定义的单元不存新数据data endscode segmentstart: mov ax, data mov ds, ax mov si, 0 mov dh, 12 mov dl, 20 call getstr mov ax, 4c00h int 21h;子程序：读取字符 getstr: push axgetstrs: ;读取键盘输入 mov ah, 0 int 16h ;小于20h为非字符 cmp al, 20h jb nochar ;字符al入栈 mov ah, 0 call charstack ;字符显示 mov ah, 2 call charstack jmp getstrs;处理非字符nochar: ;退格键的扫描码 cmp ah, 0eh je backspace ;回车键的扫描码 cmp ah, 1ch je enter jmp getstrs;退格键 backspace: ;字符出栈 mov ah, 1 call charstack ;字符显示 mov ah, 2 call cahrstack jmp getstrs;回车键enter: mov al, 0 ;0字符入栈 mov ah, 0 call cahrstack ;显示字符 mov ah, 2 call cahrstack ;退出getstr子程序 pop ax ret;子程序：字符操作 charstack: jmp short charstart table dw charpush, charpop, charshow top dw 0charstart: push bx push dx push di push es cmp ah, 2 ja sret ;通过ah在table中跳转到对应功能的地址 mov bl, ah mov bh, 0 add bx, bx jmp word ptr table[bx] ;字符入栈 charpush: ;字符入栈 mov bx, top mov [si][bx], al ;字符数+1 inc top jmp sret ;字符出栈 charpop: cmp top, 0 je sret ;字符数-1 dec top ;dec指令：自减 ;获取出栈的字符，保存在al中 mov bx, top mov al, [si][bx] jmp sret ;显示栈中的字符,在(dh)行(di)列显示 charshow: mov bx, 0B800h mov es, bx mov al, 160 mov ah, 0 mul dh mov di, ax add dl, al mov dh, 0 add di, dx ;将已经复制的字符数置为0 mov bx, 0 charshows: cmp bx, top jne noempty mov byte ptr es:[di], &#x27; &#x27; jmp sret noempty: ;复制到的显存中 mov al, [si][bx] mov es:[di], al ;将下一个字符置为空格符 mov btye ptr es:[di+2], &#x27; &#x27; ;已经复制的字符数+1 inc bx ;移动到下一个字符位置 add di, 2 jmp charshowssret: pop es pop di pop dx pop bx retcode endsend start 磁盘读写BIOS提供的磁盘直接服务——int 13h 对磁盘进行读操作 入口参数： (ah)&#x3D;2 (2表示读扇区) (al)&#x3D;读取的扇区数 (ch)&#x3D;磁道号，(cl)&#x3D;扇区号 (dh)&#x3D;磁头号(对于软盘即面号，一个面用一个磁头来读写) (dl)&#x3D;驱动器号：软盘从0号开始，0：软驱A，1：软驱B； ​ 硬盘从80h开始，80h：硬盘C，81h：硬盘D es:bx指向接收从扇区读入数据的内存区 返回参数； 操作成功：(ah)&#x3D;0，(al)&#x3D;读入的扇区数 操作失败：(ah)&#x3D;出错代码 例子：读入c盘0面0道1扇区的内容道内存单元0:200h 12345678910mov ax, 0mov es, axmov bx, 200h ;读入0:200hmov al, 1 ;1个扇区mov ch, 0 ;0磁道mov cl, 1 ;1扇区mov dl, 80h ;C盘mov dh, 0 ;0面mov ah, 2 ;读扇区int 13h DOS中断对磁盘文件的支持——int 21h 部分功能： 目录控制功能 磁盘管理功能 39H：创建目录3AH：删除目录3BH：设置当前目录47H：读取当前目录 0DH：磁盘复位2EH：设置校验标志0EH：选择磁盘36H：读取驱动器分配信息19H：读取当前驱动器54H：读取校验标志1BH,1CH：读取驱动器数据 举例：功能39H 功能描述：用指定的驱动器和路径创建一个新目录 入口参数： AH &#x3D;39H DS:DX&#x3D;指定路径的字符串地址(以0为字符串的结束标志) 出口参数：CF&#x3D;0——创建成功，否则，AX&#x3D;错误号(03H或05H)，其含义见错误代码表 让计算机唱歌与”计算机唱歌”有关的硬件及控制 8253芯片(定时&#x2F;计数器)的设置 12345678mov al, 0b6h ;8253初始化out 43h, al ;43H时8253芯片控制口的端口地址mov dx, 12hmov ax, 34dchdiv word ptr [si] ;计算分频值，赋给ax，[si]中存放声音的频率值out 42h, al ;先送低8位到计数器，42h是8253芯片通道2的端口地址mov al, ahout 42h, al ;后送高8位计数器 设置8255芯片(并行I&#x2F;O)，控制扬声器的开&#x2F;关 1234567in al, 61h ;读取8255 B端口原值mov ah, al ;保存原值or al, 3 ;使低两位置1，以便打开开关out 61h, al ;开扬声器，发声... ;延时，保持时间mov al, ahout 61h, al ;恢复扬声器端口原值 翻译乐谱 音符和发音频率(HZ)的对应关系： 低音符 频率 中音符 频率 高音符 频率 1 138 1 262 1 524 2 147 2 294 2 587 3 165 3 330 3 659 4 175 4 349 4 698 5 196 5 392 5 784 6 220 6 440 6 880 7 247 7 494 7 988 1234567891011121314;新年好&quot;数字化&quot;乐谱data segmentmus_freq dw 262,262,262,196 dw 330,330,330,262 dw 262,330,392,392 dw 349,330,294 dw 294,330,349,349 dw 330,294,330,262 dw 262,330,294,196 dw 247,294,262,-1 mus_time dw 3 dup(12,12,25,25),12,12,50 dw 3 dup(12,12,25,25),12,12,50 data ends 演凑程序 1 0.总结在8086CPU中有14个寄存器： 通用寄存器：AX、BX、CX、DX 变址寄存器：SI、DI 指针寄存器：SP、BP 指令指针寄存器：IP 段寄存器：CS、SS、DS、ES 标志寄存器：PSW 并且所有寄存器都是16位的，可以存放两个字节 段寄存器 CS 代码段寄存器 CS:IP DS 数据段寄存器 SS 堆栈段寄存器 SS:SP ES 附加段寄存器 指针寄存器 SP 堆栈指针 SP指向栈顶，SS:SP BP 基数指针 IP 指令指针 存储下一条指令的偏移地址，CS:IP 变址寄存器 SI 源变址 串操作指令，si和ds联用 DI 目的变址 串操作指令，di和es联用 si和di可以和bx、bp联用。使用bx时段地址在ds中；使用bp时段地址在ss中 si和di在单独使用时，段地址默认在ds中 si和di不能够分成两个8位寄存器来使用 数据传送指令： 指令 mov 移动 posh 压栈 pop 出栈 lds les lahf sahf pushf 将标志寄存器值压栈 popf 将标志寄存器值出栈 算数运算指令： 指令 add adc inc 加1 aaa daa sub sbb dec 减1 neg cmp aas das mul imul amm div idiv aad cbw cwd 逻辑指令： 指令 and 和运算 test or 或运算 xor not shl 左移 shr 右移 sah sar rol ror rcl rcr 串操作指令： 指令 movsb movsw rep jmp loop call ret int","categories":[{"name":"计算机4件套","slug":"计算机4件套","permalink":"http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA4%E4%BB%B6%E5%A5%97/"}],"tags":[{"name":"汇编","slug":"汇编","permalink":"http://example.com/tags/%E6%B1%87%E7%BC%96/"}]},{"title":"(每日LeetCode)856. 括号的分数","slug":"每日LeetCode/2022-10/856 括号的分数","date":"2022-10-09T13:03:00.000Z","updated":"2022-10-09T13:04:02.170Z","comments":true,"path":"2022/10/09/每日LeetCode/2022-10/856 括号的分数/","link":"","permalink":"http://example.com/2022/10/09/%E6%AF%8F%E6%97%A5LeetCode/2022-10/856%20%E6%8B%AC%E5%8F%B7%E7%9A%84%E5%88%86%E6%95%B0/","excerpt":"","text":"题目：给定一个平衡括号字符串 S，按下述规则计算该字符串的分数： () 得 1 分。 AB 得 A + B 分，其中 A 和 B 是平衡括号字符串。 (A) 得 2 * A 分，其中 A 是平衡括号字符串。 示例： 输入： “(()(()))”输出： 6 代码(cpp)：12345678910111213141516171819202122class Solution &#123;public: int scoreOfParentheses(string s) &#123; stack&lt;int&gt; stk; stk.emplace(0); for(int i = 0; i &lt; s.size(); i++)&#123; if(s[i] == &#x27;(&#x27;)&#123; stk.emplace(0); &#125; else&#123; auto t = stk.top(); stk.pop(); stk.top() += max(t*2, 1); &#125; &#125; return stk.top(); &#125;&#125;; 复杂度分析： 时间复杂度：O(n)，其中 n 是字符串的长度。 空间复杂度：O(n)。栈需要 O(n) 的空间。","categories":[{"name":"每日LeetCode","slug":"每日LeetCode","permalink":"http://example.com/categories/%E6%AF%8F%E6%97%A5LeetCode/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"}]},{"title":"MySQL的学习笔记","slug":"Java/MySQL","date":"2022-10-08T07:37:44.332Z","updated":"2023-02-03T03:48:45.726Z","comments":true,"path":"2022/10/08/Java/MySQL/","link":"","permalink":"http://example.com/2022/10/08/Java/MySQL/","excerpt":"","text":"进阶 DDL：数据定义语言 DML：数据操作语言 DQL：数据查询语言 DCL：数据控制语言 1.存储引擎1.1 MySQL体系结构 连接层 最上层是一些客户端和链接服务，主要完成一些类似于连接处理、授权认证、及相关的安全方案。服务器也会为安全接入的每个客户端验证它所具有的操作权限。 服务层 第二层架构主要完成大多数的核心服务功能，如SQL接口，并完成缓存的查询，SQL的分析和优化，部分内置西数的执行。所有跨存储引擎的功能也在这一层实现，如过程、函数等。 引擎层 存储引擎真正的负责了MySQL中数据的存储和提取，服务器通过API和存储引擎进行通信。不同的存储引擎具有不同的功能，这样我们可以根据自己的需要，来选取合适的存储引擎 存储层 主要是将数据存储在文件系统之上，并完成与存储引擎的交互 1.2 存储引擎简介存储引擎就是存储数据、建立索引、更新&#x2F;查询数据等技术的实现方式。存储引擎是基于表的，而不是基于库的，所以存储引擎也可被称为表类型 在创建表时，指定存储引擎 1234CREATE TABLE 表名( 字段 字段类型[COMMENT 字段注释], ......)ENGINE=INNODB[COMMENT 表注释]; 查看当前数据库支持的存储引擎 1SHOW ENGINES; 1.3 存储引擎特点 InnoDB 介绍 InnoDB是一种兼顾高可靠性和高性能的通用存储引擎，在 MySQL5.5 之后，InnoDB是默认的 MySQL 存储引擎 特点 DML操作遵循ACID模型，支持事务 行级锁，提高并发访问性能 支持外键 FOREIGN KEY约束，保证数据的完整性和正确性； 文件 xxx.ibd：xxx代表的是表名，innoDB引擎的每张表都会对应这样一个表空间文件，存储该表的表结构(frm、sdi)、数据和索引。参数：innodb file_per_table MyISAM 介绍 MyISAM是MySQL早期的默认存储引擎。 特点 不支持事务，不支持外键 支持表锁，不支持行锁 访问速度快 文件xxx.sdi：存储表结构信息xxx.MYD：存储数据xxx.MYI：存储索引 Memory 介绍 Memory引擎的表数据时存储在内存中的，由于受到硬件问题、或断电问题的影响，只能将这些表作为临时表或缓存使用 特点 内存存放 hash索引（默认） 文件 xxx.sdi：存储表结构信息 特点 InnoDB MyISAM Memory 存储限制 64TB 有 有 事务安全 支持 - - 锁机制 行锁 表锁 表锁 B+tree索引 支持 支持 支持 Hash索引 - - 支持 全文索引 支持(5.6版本后) 支持 - 空间使用 高 低 N&#x2F;A 内存使用 高 低 中等 批量插入速度 低 高 高 支持外键 支持 - - 1.4 存储引擎的应用场景在选择存储引擎时，应该根据应用系统的特点选择合适的存储引1擎。对于复杂的应用系统，还可以根据实际情况选择多种存储引擎进行组合。 InnoDB： 是MySQL的默认存储引擎，支持事务、外键。如果应用对事务的完整性有比较高的要求，在并发条件下要求数据的一致性，数据操作除了插入和查询之外，还包含很多的更新、脚除操作，那么innoDB存储引擎是比较合适的选择。 MyISAM：(MongoDB取代) 如果应用是以读操作和插入操作为主，只有很少的更新和删除操作，井且对事务的完整性、并发性要求不是很高，那么选择这个存储引擎是非常合适的。 MEMORY：(Redis取代) 将所有数据保存在内存中，访问速度快，通常用于临时表及缓存。MEMORY的缺陷就是对表的大小有限制，太大的表无法缓存在内存中，而且无法保障数据的安全性。 2.索引2.1 概述索引(index)是帮助MySQL **高效获取数据的数据结构(有序)**。在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用(指向)数据， 这样就可以在这些数据结构上实现高级查找算法，这种数据结构就是索引。 优缺点： 优势 劣势 据检索的效率，降低数据库的IO成本 索引列也是要占用空间的。 通过索引列对数据进行排序，降低数据排序的成本，降低CPU的消耗 索引大大提高了查询效率，同时却也降低更新表的速度，如对表进行INSERT、UPDATE、DELETE时，效率降低。 2.2 结构MySQL的索引是在存储引擎层实现的，不同的存储引擎有不同的结构，主要包含以下几种： 索引结构 描述 B+Tree索引 最常见的索引类型，大部分引擎都支持 B+树索引 Hash索引 底层数据结构是用哈希表实现的，只有精确匹配索引列的查询才有效,不支持范围查询 R-Tree(空间索引) 空间索引是MyISAN引擎的一个特殊索引类型，主要用于地理空问数据类型，通常使用较少 Full-Text(全文索引) 是一种通过建立倒排索引,快速匹配文档的方式。类似于Lucene、Solr、ES 索引 InnoDB MyISAM Memory B+Tree索引 :white_check_mark: :white_check_mark: :white_check_mark: Hash索引 :x: :x: :white_check_mark: R-Tree索引 :x: :white_check_mark: :x: Full-Text索引 5.6版本后:white_check_mark: :white_check_mark: :x: 我们平常所说的索引，如果没有特别指明，都是指B+树结构组织的索引。 二叉树： 二叉树缺点：顺序插入时，会形成一个链表，查询性能大大降低。大数据量情况下，层级较深，检索速度慢。 红黑树：大数据量情况下，层级较深，检索速度慢。 B-Tree(多路平衡查找树) 以一颗最大度数为5的(5阶)B-Tree为例： 注意：数的度数指的是一个结点的子节点数 B+Tree 以一颗最大度数为4的(4阶)B-Tree为例： 相对于B-Tree的区别： 所有的数据都会出现在叶子节点 叶子节点形成一个单向链表 而MySQL索引数据结构对经典的B+Tree进行了优化。在原B+Tree的基础上，增加一个指向相邻叶子节点的链表指针，就形成了带有顺序指针的B+Tree，提高区间访问的性能。 Hash 哈希索引就是采用一定的hash算法，将键值换算成新的hash值，映射到对应的槽位上，然后存储在hash表中。 Hash索引特点 Hash索引只能用于对等比较(&#x3D;，in)，不支持范围查询(between，&gt;，＜，…) 无法利用索引完成排序操作 查询效率高，通常只需要一次检索就可以了，效率通常要高于B+tree索引 存储引擎支持 在MySQL中，支持hash索引的是Memory引擎，而InnoDB中具有自适应hash功能，hash索引是存储引擎根据B+Tree索引l在指定条件下自动构建的。 思考： 为什么InnoDB存储引擎选择使用Bttree索引结构？ 相对于二叉树，层级更少，搜索效率高； 对于B-tree，无论是叶子节点还是非叶子节点，都会保存数据，这样导致一页中存储的键值减少，指针跟着减少，要同样保存大量数据，只能增加树的高度，导致性能降低; 相对于Hash索引，B+Tree支持范围匹配及排序操作; 2.3 分类 分类 含义 特点 关键字 主键索引 针对于表中主键创建的索引 默认自动创建，只能有一个 PRIMARY 唯一索引 避免同一个表中某数据列中的值重复 可以有多个 UNIQUE 常规索引 快速定位特定数据 可以有多个 全文索引 全文泰引查找的是文本中的关键词，而不是比较索引中的值 可以有多个 FULLTEXT 在InnoDB存储引擎中，根据索引的存储形式，又可以分为以下两种： 分类 含义 特点 聚集索引(Clustered Index) 将数据存储与索引放到了一块，索引结构的叶子节点保存了行数据 必须有,而且只有一个 二级索引(Secondary Index) 将数据与索引分开存储，索引结构的叶子节点关联的是对应的主键 可以存在多个 聚集索引选取规则： 如果存在主键，主键索引就是聚集索引。 如果不存在主键，将使用第一个唯一(UNIQUE)索引作为聚集索引。 如果表没有主键，或没有合适的唯一索引，则innoDB会自动生成一个rowid作为隐藏的聚集索引。 以select * from user where name=&#39;Arm&#39;为例： 回表查询：先通过二级索引查询到主键id，再通过主键id通过聚集索引查询 思考： 以下SQL语句，那个执行效率高？ select * from user where id=10 select * from user where name=&#39;Arm&#39; 注意：id为主键，name为字段(有索引) 通过id(主键)查询效率高 InnoDB主键索引的B+tree高度为多高呢？ 假设： 一行数据大小为1k，一页中可以存储16行这样的数据。InnoDB的指针占用6个字节的空间，主键即使为bigint， 占用字节数为8。 高度为2：n*8+（n+1)*6=16*1024，算出n约为 11701171* 16=18736 高度为31171* 1171*16=21939856 2.4 语法 创建索引： 1create [UNIQUE|FULLTEXT] index index_name on table_name(index_col_name, …); 参数说明： UNIQUE：唯一索引，该字段不能出现重复数据 FULLTEXT：全文索引 如果不加，则是常规索引 如果一个索引只关联一个字段叫做单列索引 如果一个索引只关联多个字段叫做联合索引 查看索引： 1show index from table_name; 删除索引： 1drop index index_name on table_name; 案例需求： name宇段为姓名字段，该宇段的值可能会重复，为该宇段创建索引。 phone手机号字段的值，是非空，且唯一的，为该宇段创建唯一索引。 为profession、age、status创建联合素引。 为email建立合适的索引来提升查询效率。(常规索引) 1234create index idx_user_name on tb_user(name);create unique index idx_user_phone on tb_user(phone);create index idx_user_pro_age_sta on tb_user(profession, age, status);create index idx_email on tb_user(email); 2.5 SQL性能分析SQL的执行频率 MvSOL 客户媏连接成功后，通过 show [session|global] status 命令可以提供服务器状态信息。通过指令，可以查看当前数据库的INSERT、UPDATE、DELETE、SELECT的访问频次：&amp;#x20; 1show global status like ‘Com_______’; 慢查询日志慢查询日志记录了所有执行时间超过指定参数(long_query_time， 单位：秒，默认10秒)的所有SQL语句的日志。&amp;#x20; MySQL的慢查询日志默认没有开启： 1show variables like ‘show_query_log’; 需要在MySQL的配置文件(&#x2F;etc&#x2F;my.cnf)中配置如下信息： 1234#开启MySQL慢日志查询开关slow_query_log=1#设置慢日志的时间为2秒，SQL语句执行时间超过2秒就会视为慢查询，记录慢查询日志long_query_time=2 配置完毕之后，重新启动MySQL服务器进行测试，查看慢日志文件中记录的信息/var/lib/mysql/locathost-slow.log profile详情show profiles 能够在做SQL优化时帮助我们了解时间都耗费到哪里去了。 通过have_profiling參数，能够看到当前MySQL是否支持profile操作： 1select @@have_profiling; 默认profiling是关闭的，可以通过set语句在session&#x2F;global级别开启profiling： 1set profiling = 1; 查看是否开启profiling： 1select @@profiling; 查看SQL语句耗时情况： 12345678#查看每一条SQL语句的基本情况show profiles;#查看指定query_id的SQL语句的各个阶段的耗时情况show profile for query query_id;#查看指定query_id的SQL语句CPU的使用情况show profile cpu for query query_id; explain执行计划EXPLAIN 或者 DESC 命令获取 MySQL 如何执行 SELECT 语句的信息，包括在 SELECT 语句执行过程中表如何连接和连接的顺序。 语句： 12#直接在select语句之前加上关键字explain/descexplain select 字段列表 from 表名 where 条件; EXPLAIN 执行计划各字段含义： Id select查询的序列号，表示查询中执行select子句或者是操作表的顺序(id相同，执行顺序从上到下；id不同，值越大，越先执行)。 select_type 表示 SELECT 的类型，常见的取值有 SIMPLE（简单表，即不使用表连接或者子查询）、PRIMARY（主查询，即外层的查询）、UNION (UNION 中的第二个或者后面的查询语句）、SUBQUERY (SELECT&#x2F;WHERE之后包含了子查询）等 type 表示连接类型，性能由好到差的连接类型为NULL、system、const、eq_ref、ref、range、index、all 。 possible key 显示可能应用在这张表上的索引，一个或对个 key实际使用的索引，如果为NULL，则没有使用索引。 key_len 表示索引中使用的字节数，该值为索引字段最大可能长度，并非实际使用长度，在不损失精确性的前提下，长度越短越好。 rows MySQL认为必须要执行查询的行数，在innodb引擎的表中，是一个估计值，可能并不总是准确的。 filtered 表示返回结果的行数占需读取行数的百分比，filtered 的值越大越好。 2.6 使用规则验证索引效率未建立索引之前，(大约对1千万的数据量)执行如下SQL语句，查看SQL的耗时： 1select * from tb_sku where sn=&#x27;100000003145001&#x27;; 耗时：大约20s 针对字段创建索引： 1create index idx_sku_sn on tb_sku(sn); 再次执行上面的SQL语句，耗时：大约0.01s 最左前缀法则如果索引了多列(联合索引)，要遵守最左前缀法则。 最左前缀法则指的是查询从索引的最左列开始，并且不跳过索引中的列。 如果从索引的最左列开始**跳跃某一列，索引将部分失效(后面的字段索引失效)**。 已经创建好的联合索引：idx_user_pro_age_sta(依次为profession、age、status) 1explain select * from tb_user where profession=&#x27;软件工程&#x27; and age=31 and status=&#x27;0&#x27;; 使用了联合索引idx_user_pro_age_sta 1explain select * from tb_user where profession=&#x27;软件工程&#x27; and age=31; 依然使用了联合索引idx_user_pro_age_sta 1explain select * from tb_user where profession=&#x27;软件工程&#x27;; 仍然使用了联合索引idx_user_pro_age_sta 1explain select * from tb_user where age=31 and status=&#x27;0&#x27;; 没有使用联合索引，而是使用了全表扫描。 1explain select * from tb_user where status=&#x27;0&#x27;; 依然没有使用联合索引 1explain select * from tb_user where profession=&#x27;软件工程&#x27; and status=&#x27;0&#x27;; 会使用联合索引。profession走了索引，而status没有走索引，索引部分失效 范围查询 联合索引中，出现范围查询&gt;、&lt;，范围查询右侧的列索引失效 1explain select * from tb user where profession = &#x27;软件工程&#x27; and age &gt;30 and status= &#x27;0&#x27;; status索引失效 使用&lt;=、&gt;=，则不会失效： 1explain select * from tb user where profession = &#x27;软件工程&#x27; and age &gt;=30 and status =&#x27;0&#x27;; status索引不会失效 索引失效情况 索引列运算 不要在索引列上进行运算操作，索引将失效 12-- substring():截取字段select * from tb_user where substring(phone,10,2) = &#x27;15&#x27;; idx_user_phone索引失效 字符串不加引号 字符串类型字段使用时，不加引号，索引将失效 1explain select * from tb_user where phone=17799990015 虽然可以查询，但是idx_user_phone索引会失效 1explain select * from tb user where profession = &#x27;软件工程&#x27; and age=30 and status =0: 联合索引中的status失效 模糊查询 如果仅仅是尾部模糊匹配，索引不会失效，如果是头部模糊匹配，索引失效 1explain select * from tb user where profession like &#x27;%工程&#x27; 索引失效 1explain select * from tb user where profession like &#x27;软件%&#x27; 索引生效 or连接的条件 用or分割开的条件，如果or前的条件中的列有索引，而后面的列中没有索引，那么涉及的索引都不会被用到。 12explain select * from tb_user where id = 10 or age = 23;explain select * from tb_user where phone = &#x27;77799990017&#x27; or age = 23; 由于age没有索引，所以即使id、phone有索引，索引也会失效。所以需要针对于age也要建立索引。 数据分布影响 如果MySQL评估使用索引比全表更慢，则不会使用索引 1select * from tb_user where phone &gt;= &#x27;17799990005&#x27;; 不会走索引，因为大部分的数据满足条件 1select * from tb_user where phone &gt;= &#x27;17799990015&#x27;; 会走索引，仅少量数据满足条件 SQL提示profession存在两个索引联合索引idx_user_pro_age_sta、单列索引idx_user_pro 执行下面语句： 1explain select * from tb_user where profession = &#x27;软件工程&#x27;; 用到了联合索引，经过MySQL，选择了联合索引 SQL提示，是优化数据库的一个重要手段，简单来说，就是在SQL语句中加入一些人为的提示来达到优化操作的目的。 use index：使用的索引 1explain select * from tb_user use index(idx_user_pro) where profession = &#x27;软件工程&#x27;; ignore index：忽略使用的索引 1explain select * from tb_user ignore index(idx_user_pro) where profession = &#x27;软件工程&#x27;; force index：强制使用的索引 1explain select * from tb_user force index(idx_user_pro) where profession = &#x27;软件工程&#x27;; 覆盖索引&amp;回表查询尽量使用覆盖索引(查询使用了索引，并且需要返回的列，在该索引中已经全部能够找到)，减少使用select * 以下存在联合索引idx_user_pro_age_sta 12345678910111213141516explain select id, profession from tb_user where profession = &#x27;软件工程&#x27; and age = 31 and status=&#x27;0&#x27;;/*using where; using index*/explain select id, profession, age, status from tb_user where profession = &#x27;软件工程&#x27; and age =31 and status = &#x27;0&#x27;;/*using where; using index*/explain select id, profession, age, status, name from tb_user where profession = &#x27;软件工程&#x27; and age =31 and status =&#x27;0&#x27;;/*using index condition 多加一个name字段*/explain select * from tb_user where profession = &#x27;软件工程&#x27; and age =31 and status = &#x27;0&#x27;;/*using index condition*/ Extra中： using index condition ：查找使用了索引，但是需要回表查询数据 using where; using index ：查找使用了索引，但是需要的数据都在索引列中能找到，所以不需要回表查询数据 一张表，有四个字段(id, username, password, status)，由于数据量大，需要对以下SQL语句进行优化，该如何进行才是最优方案：select id,username,password from tb_user where username = &#39;itcast&quot;; 通过username和password建立一个联合索引，不需要回表查询 前缀索引当字段类型为字符串(varchar, text等)时，有时候需要索引很长的字符串，这会让索引变得很大，查询时，浪费大量的磁盘IO，影响查询效率。此时可以只将字符串的一部分前缀，建立索引，这样可以大大节约索引空间，从而提高索引效率。 语法： create index idx_XXX on table_name(column(n)) 前缀长度： 可以根据索引的选择性来决定，而选择性是指不重复的索引值(基数)和数据表的记录总数的比值，索引选择性越高则查询效率越高，唯一索引的选择性是1，这是最好的索引选择性，性能也是最好的。select count(distinct email)/count(*) from tb_user;select count(distinct substring(email,1,5))/count(*) from tb_user; distinct：去重 count(*)：总行数 substring()：截取字符串函数 单列&amp;联合索引单列索引：即一个索引只包含单个列 联合索引：即一个索引包含多个列 存在单列索引idx_user_phone、idx_user_name 12explain select id, phone, name from tb_user where phone = &#x27;123456789&#x27; and name = &#x27;元哥&#x27;; 只走了idx_user_phone索引 创建联合索引idx_user_phone_name 执行上面的语句后，发现依然只走了idx_user_phone索引，有单列索引干扰 我们可以指定所使用的索引： 123explain select id, phone, name from tb_user use index(idx_user_phone_name)where phone = &#x27;123456789&#x27; and name = &#x27;元哥&#x27;; 走了联合索引idx_user_phone_name 在业务中，如果存在多个查询条件，考虑针对查询字段建立索引时，建议建立联合索引，而非单列索引 2.7 设计原则 针对于数据量较大，且查询比较频繁的表建立索引。 针对于常作为查询条件(where)、排序(order by)、分组(groupby) 操作的字段建立索引。 尽量选择区分度高的列作为索引，尽量建立唯一索引，区分度越高，使用索引的效率越高。 如果是字符串类型的字段，字段的长度较长，可以针对于字段的特点，建立前缀索引。 尽量使用联合索引，减少单列索引，查询时，联合素引很多时候可以覆盖索引，节省存储空问，避免回表，提高查询效率。 要控制索引的数量，索引不是多多益善，索引越多，维护索引结构的代价也就越大，会影响增删改的效率。 如果索引列不能存储NULL值，请在创建表时使用NOT NULL约束它。当优化器知道每列是否包含NULL值时，它可以更好地确定哪个索引最有效地用于查询。 3.SQL优化3.1 插入数据insert优化 批量插入 手动提交事务 主键顺序插入 12345start transaction;insert into tb_test values(1,&#x27;Tom&#x27;),(2,&#x27;Cat&#x27;),(3,&#x27;Jerry&#x27;);insert into tb_test values(4,&#x27;Tom&#x27;),(5,&#x27;Cat&#x27;),(6,&#x27;Jerry&#x27;);insert into th_test values(7,&#x27;Tom&#x27;),(8,&#x27;Cat&#x27;),(9,&#x27;Jerry&#x27;);commit; 大批量插入数据 如果一次性需要插入大批量数据，使用insert语句插入性能较低，此时可以使用MySQL数据库提供的load指令进行插入。 操作如下： 123456#客户端连接服务端时，加上参数 --local-infilemysal --local-infile -u root -p#设置全局参数local_infile为1，开启从本地加载文件导入数据的开关set global local_infile = 1,#执行load指令将准备好的数据，加载到表结构中load data local infile &#x27;/root/sql1.log&#x27; into table `tb_user` fields terminated by &#x27;,&#x27; lines terminated by &#x27;/n&#x27;; 3.2 主键优化数据组织方式在InnoDB存储引擎中，表数据都是根据主键顺常组织存放的，这种存储方式的表称为家引组织表(index organized table IOT)。 页分裂页可以为空，也可以填充一半，也可以填充100%。每个页包含了2~N行数据(如果一行数据多大，会行溢出)，根据主键排列。 主键顺序插入： 依次插入 主键乱序插入： 页合并当删除一行记录时，实际上记录并没有被物理删除，只是记录被标记(flaged)为删除井且它的空间变得允许被其他记录声明使用。 当页中删除的记录达到 MERGE_THRESHOLD(合并页的阈值，默认为页的50%，可以自己设置)，InnoDB会开始寻找最靠近的页(前或后)看看是否可以将两个页合并以优化空间使用。 主键设计原则 满足业务需求的情况下，尽量降低主键的长度。 插入数据时，尽量选择顺序插入，选择使用AUTO_INCREMENT自增主键。 尽量不要使用UUID做主键或者是其他自然主键，如身份证号。 业务操作时，避免对主键的修改。 3.3 order by优化 Using filesort：通过表的索引或全表扫描，读取满足条件的数据行，然后在排序缓冲区sort buffer中完成排序操作，所有不是通过索引直接返回排序结果的排序都叫 FileSort 排序。 Using index ：通过有序索引顺序扫描直接返回有序数据，这种情况即为using index，不需要额外排序，操作效率高。 123456789#没有创建索引时，根据age,phone进行排序explain select id,age,phone from tb _user order by age, phone;#创建索引create index idx_user_age_phone on tb_user(age,phone);#创建索引后，根据age,phone进行升序排序explain select id,age,phone from th _user order by age, phone;#创建索引后，根据age,phone进行降序排序explain select id, age,phone from th_user order by age desc, phone desc; 只有字段全都是升序排列或者全都是降序排列时，idx_user_age_phone索引生效，为Using index 如果一个升序一个降序或者一个降序一个升序，就需要重新创建一个新索引 1234567#没有创建索引时，根据age升序,phone降序进行排序explain select id,age,phone from tb _user order by age asc, phone desc;#创建索引create index idx_user_age_phone_ad on tb_user(age asc,phone desc);#创建索引后，根据age升序,phone降序进行排序，为Using indexexplain select id,age,phone from tb _user order by age asc, phone desc; 总结 根据排序字段建立合适的索引，多字段排序时，也遵循最左前缀法则。 尽量使用覆盖索引。 多字段排序，一个升序一个降序，此时需要注意联合索引在创建时的规则(ASC&#x2F;DESC)。 如果不可避免的出现filesort，大数据量排序时，可以适当增大排序缓冲区大小 sort_ buffer_size(默认256k）。 3.4 group by优化1234567891011121314#执行分组操作，根据profession字段分组explain select profession, count(*) from th_user group by profession;#创建索引Create index id_user_pro_age_sta on tb_user(profession,age,status);#以下均会走索引#执行分组操作，根据profession字段分组explain select profession, count(*) from tb_user group by profession;#执行分组操作，根据profession字段分组explain select profession, count(*) from tb_user group by profession,age;#执行分组操作，根据profession字段分组explain select profession, count(*) from tb_user where profession = &#x27;软件工程&#x27;group by age; 总结 在分组操作时，可以通过索引来提高效率 分组操作时，索引的使用也是满足最左前缀法则的 3.5 limit优化一个常见又非常头疼的问题就是 limit 2000000,10，此时需要MySQL排序前2000010 记录，仅仅返回2000000-2000010的记录，其他记录丢弃，查询排序的代价非常大。 优化思路：一般分页查询时，通过创建 覆盖索引 能够比较好地提高性能，可以通过覆盖索引加子查询形式进行优化。 优化前： 1explain select * from tb_sku order by id limit 2000000,10 优化后： 1explain select t.* from tb_sku t, (select id from tb_sku order by id limit 2000000,10) a where t.id = a.id 3.6 count优化1explain select count(*) from tb_user; MyISAM 引擎把一个表的总行数存在了磁盘上，因此执行 count(*)的时候会直接返回这个数，效率很高 InnoDB 引擎就麻烦了，它执行 count(*)的时候，需要把数据一行一行地从引擎里面读出来，然后累积数 优化思路：自己计数。 count的几种用法count(是一个聚合函数，对于返回的结果集，一行行地判断，如果count 函数的参数不是 NULL，累计值就加1，否则不加，最后返回累计值。 用法：count(*)、count(主键)、count(字段)、count(1) count(主键) InnoDB 引擎会遍历整张表，把每一行的 主键id 值都取出来，返回给服务层。服务层拿到主键后，直接按行进行累加(主键不可能为nul)。 count(字段) 没有not null 约束：InnoDB 引1擎会遍历整张表把每一行的字段值都取出来，返回给服务层，服务层判断是否为null，不为null，计数累加。 有not null 约束：InnoDB 引擎会遍历整张表把每一行的字段值都取出来，返回给服务层，直接按行进行累加。 count(1) InnoDB 引擎遍历整张表，但不取值。服务层对于返回的每一行，放一个数字”1”进去，直接按行进行累加。 count(*) InnoDB引擎并不会把全部字段取出来，而是专门做了优化，不取值，服务层直接按行进行累加。 按照效率排序的话，count(字段) &lt; count(主键id) &lt; count(1) ≈ count(*)，所以尽量使用 *count()**。 3.7 update优化InnoDB的行锁是针对索引加的锁，不是针对记录加的锁 如果该索引失效或者没有索引，则会从行锁升级为表锁。 4.视图视图(view)是一种虛拟存在的表。视图中的数据并不在数据库中实际存在，行和列数据来自定义视图的查询中使用的表，并且是在使用视图时动态生成的。 通俗的讲，视图只保存了查询的SQL逻辑，不保存查询结果。所以我们在创建视图的时候，主要的工作就落在创建这条SQL查询语句上。 4.1 基础语法创建视图： 1create [or replace] view 视图名[(列名列表)] as select语句 查询视图： 查看创建视图语句： 1show create view 视图名称; 查看视图数据： 1select * from 视图名称…; 修改视图： 方式一： 1create [or replace] view 视图名[(列名列表)] as select语句 方式二： 1alter view 视图名[(列名列表)] as select语句 删除视图： 1drop view [if exists] 视图名称 [,视图名称] 4.2 检查选项当使用WITH CHECK OPTION子句创建视图时，MySQL会通过视图检查正在更改的每个行，例如插入，更新，删除，以使其符合视图的定义。MySQL允许基于另一个视图创建视图，它还会检查依赖视图中的规则以保持一致性。为了确定检查的范围，MySQL提供了两个选项：CASCADED和LOCAL,默认值为CASCADED。 CASCADED示例： 第一种情况： 1create view stu_v_1 as select id,name from v1 where id &lt;=20 with cascaded check option 执行插入语句： 1insert into stu_v_1 values(30,&#x27;Tom&#x27;); 会依据条件where id &lt;=10进行检查，如果不符合条件则报错 第二种情况： 修改视图stu_v_1： 1create view stu_v_1 as select id,name from v1 where id &lt;=20 依据stu_v_1视图建立视图stu_v_2： 1create or replace view stu_v_2 as select id,name from stu_v_1 where id &gt;=10 with cascaded check option 执行插入语句： 1insert into stu_v_2 values(30,&#x27;Tom&#x27;); 此插入语句符合视图stu_v_2的条件，但是无论stu_v_1是否有检查选项，都会进行对stu_v_1条件的检查，所以不符合报错 LOCAL示例： 第一种情况与CASCADED相同 第二种情况： 修改视图stu_v_1： 1create view stu_v_1 as select id,name from v1 where id &lt;=20 依据stu_v_1视图建立视图stu_v_2： 1create or replace view stu_v_2 as select id,name from stu_v_1 where id &gt;=10 with local check option 执行插入语句： 1insert into stu_v_2 values(30,&#x27;Tom&#x27;); 此插入语句符合视图stu_v_2的条件，会对stu_v_1进行检查是否有检查选项。如果有，则对stu_v_1进行条件检查；如果没有，则不会对stu_v_1进行检查，所以不会报错 4.3 更新及作用视图的更新： 要使视图可更新，视图中的行与基础表中的行之间必须存在一对一的关系。如果视图包含以下任何一项，则该视图不可更新： 聚合函数或窗口函数(SUM()、MIN()、MAX()、COUNT()等) DISTINCT GROUP BY HAVING UNION或者UNION ALL 视图的作用： 简单： 视图不仅可以简化用户对数据的理解，也可以简化他们的操作。那些被经常使用的查询可以被定义为视图，从而使得用户不必为以后的操作每次指定全部的条件。 安全： 数据库可以授权，但不能授权到数据库特定行和特定的列上。通过视图用户只能查询和修改他们所能见到的数据 数据独立： 视图可帮助用户屏蔽真实表结构变化带来的影响。 5.存储过程存储过程是事先经过编译并存储在数据库中的一段SQL语句的集合，调用存储过程可以简化应用开发人员的很多工作，减少数据在数据库和应用服务器之间的传输，对于提高数据处理的效率是有好处的。 存储过程思想上很简单，就是数据库SQL语言层面的代码封装与重用。 特点： 封装，复用 可以接收参数，也可以返回数据 减少网络交互，效率提升 5.1 基础语法创建： 1234create procedure 存储过程名称([参数列表])begin SQL语句;end; 注意：在命令行中，执行创建存储过程的SQL时，需要通过关键字delimiter指定SQL语句的结束符。 调用： 1call 存储过程名称([参数]) 查看： 查询指定数据库的存储过程及状态信息： 1select * from INFORMATION_SCHEMA.ROUTINES where ROUTINE_SCHEMA=&#x27;XXX&#x27;; 查询某个存储过程的定义： 1show create procedure 存储过程名称; 删除： 1drop procedure [if exists] 存储过程名称; 6.触发器6.1 介绍触发器是与表有关的数据库对象，指在insert&#x2F;update&#x2F;delete之前或之后，触发并执行触发器中定义的SQL语句集合。触发器的这种特性可以协助应用在数据库端确保数据的完整性，日志记录，数据校验等操作。 使用别名OLD和NEW来引用触发器中发生变化的记录内容，这与其他的数据库是相似的。现在触发器还只支持行级触发，不支持语句级触发。 触发器类型 NEW和OLD INSERT型触发器 NEW表示将要或者已经新增的数据 UPDATE型触发器 OLD表示修改之前的数据，NEW表示将要或已经修改后的数据 DELETE型触发器 OLD表示将要或者已经别除的数据 6.2 基础语法创建： 123456CREATE TRIGGER trigger_nameBEFORE/AFTER INSERT/UPDATE/DELETEON tbl_name FOR EACH ROW --行级触发器BEGIN trigger_stmtEND; 查看： 1SHOW TRIGGERS; 删除： 1DROP TRIGGER [schema_name.]trigger_name; --如果没有指定schema_name,默认为当前数据库。 6.3 案例通过触发器将记录tb_user表的数据变更日志插入到日志表user_logs中，包含增加，修改，删除： user_logs表结构： 12345678create table user_logs( id int(11) not null auto increment, operation varchar(20) not null comment &#x27;操作类型insert/update/delete&#x27;, operate_time datetime not null comment &#x27;操作时间&#x27;， operate_id int(11) not null comment &#x27;操作的ID&#x27;, operate_params varchar(500)comment &#x27;操作参数&#x27;, primary key(&#x27;id&#x27;))engine=innodb default charset=utf8; insert类型创建tb_user_insert_trigger触发器： 123456create trigger tb_user_insert_trigger after insert on tb_user for each rowbegin insert into user_logs(id,operation,operate_time,operate_id,operate_params) VALUES (null,&#x27;insert&#x27;,now(),new.id,concat(&#x27;插入的数据内容为：id=&#x27;,new.id, &#x27;,name=&#x27;,new.name, &#x27;,phone=&#x27;,new.phone, &#x27;,email=&#x27;,new.email, &#x27;,profession=&#x27;,new.profession));end; new为插入的数据 concat() 函数用于将多个字符串连接起来，形成一个单一的字符串 update类型创建tb_user_update_trigger触发器： 123456create trigger tb_user_insert_trigger after update on tb_user for each rowbegin insert into user_logs(id,operation,operate_time,operate_id,operate_params) VALUES (null,&#x27;update&#x27;,now(),new.id,concat(&#x27;更新之后的数据内容为：id=&#x27;,old.id, &#x27;,name=&#x27;,old.name, &#x27;,phone=&#x27;,old.phone, &#x27;,email=&#x27;,old.email, &#x27;,profession=&#x27;,old.profession, &#x27;|更新之后的数据内容为：id=&#x27;,new.id, &#x27;,name=&#x27;,new.name, &#x27;,phone=&#x27;,new.phone, &#x27;,email=&#x27;,new.email, &#x27;,profession=&#x27;,new.profession));end; old为更新之前的数据 delete类型创建tb_user_delete_trigger触发器： 123456create trigger tb_user_delete_trigger after delete on tb_user for each rowbegin insert into user_logs(id,operation,operate_time,operate_id,operate_params) VALUES (null,&#x27;update&#x27;,now(),new.id,concat(&#x27;删除的数据内容为：id=&#x27;,old.id, &#x27;,name=&#x27;,old.name, &#x27;,phone=&#x27;,old.phone, &#x27;,email=&#x27;,old.email, &#x27;,profession=&#x27;,old.profession));end; 7.锁7.1 介绍锁是计算机协调多个进程或线程并发访问某一资源的机制。在数据库中，除传统的计算资源(CPU、RAM、I&#x2F;O)的争用以外，数据也是一种供许多用户共享的资源。如何保证数据并发访问的一致性、有效性是所有数据库必须解决的一个问题，锁冲突也是影响数据库并发访问性能的一个重要因素。从这个角度来说，锁对数据库而言显得尤其重要，也更加复杂。 7.2 全局锁全局锁就是对整个数据库实例加锁，加锁后整个实例就处于只读状态，后续的DML(对数据的增删改查)的写语句，DDL(对数据库索引的增删改查)语句，已经更新操作的事务提交语句都将被阻塞。 其典型的使用场景是做全库的逻辑备份，对所有的表进行锁定，从而获取一致性视图，保证数据的完整性 添加全局锁： 1flush tables with read lock; 在非MySQL命令行中输入地址、账号、密码，将数据库存放到指定的文件中： 1mysqldump -h 192.168.200.001 -uroot -p1234 user &gt; D:/user.sql 解除全局锁： 1unlock tables; 特点： 数据库中加全局锁，是一个比较重的操作，存在以下问题： 如果在主库上备份，那么在备份期间都不能执行更新，业务基本上就得停摆。 如果在从库上备份，那么在备份期间从库不能执行主库同步过来的二进制日志(binlog),会导致主从延迟。 在InnoDB引擎中，我们可以在备份时加上参数--single-transaction参数来完成不加锁的一致性数据备份。 1mysqldump --single-transaction -uroot -p123456 db &gt; db.sql 7.3 表级锁表级锁，每次操作锁住整张表。锁定粒度大，发生锁冲突的概率最高，并发度最低。应用在MyISAM、InnoDB、BDB等存储引擎中。 对于表级锁，主要分为以下三类： 表锁 元数据锁(meta data lock,MDL) 意向锁 表锁对于表锁，分为两类： 表共享读锁(read lock)：当前客户端只可以读，不可以写，其他客户端也一样 表独占写锁(write lock)：当前客户端既可以读，又可以写，其他客户端都不可以 语法： 加锁： 1lock tables 表名 read/write; 释放锁： 1unlock tables;/与客户端断开连接 元数据锁MDL加锁过程是系统自动控制，无需显式使用，在访问一张表的时候会自动加上。MDL锁主要作用是维护表元数据的数据一致性，在表上有活动事务的时候，不可以对元数据进行写入操作。为了避免DML与DDL冲突，保证读写的正确性。 在MySQL5.5中引入了MDL,当对一张表进行增删改查的时候，加MDL读锁（共享）；当对表结构进行变更操作的时候，加MDL写锁(排他)。 对应SQL 锁类型 说明 lock tables xxx read&#x2F;write SHARED_READ_ONLY&#x2F;SHARED_NO_READ_WRITE select,select … lock in share mode SHARED_READ 与SHARED_READ、SHARED_WRITE兼容，与EXCLUSIVE互斥 insert,update、delete、select,for update SHARED_WRITE 与SHARED_READ、SHARED_WRITE兼容，与EXCLUSIVE互斥 alter table… EXCLUSIVE 与其他的MDL都互斥 大致就是修改表结构时，无法增删改查；增删查改时，无法修改表结构 意向锁为了避免DML在执行时，加的行锁与表锁的冲突，在InnoDB中引入了意向锁，使得表锁不用检查每行数据是否加锁，使用意向锁来减少表锁的检查。 在加入行锁后，会自动添加意向锁，如果存在意向锁那么添加表锁就会阻塞等待，使得不需要检查是否存在行锁；解除行锁后，自动解除意向锁，就可以上表锁了 意向锁分为： 意向共享锁(IS)：由语句select..lock in share mode添加。 与表锁共享锁(read)兼容，与表锁排它锁(write)互斥。 意向排他锁(lX)：由insert、update、delete、select..for update添加。 与表锁共享锁(read)及排它锁(write)都互斥。意向锁之间不会互斥。 7.4 行级锁行级锁，每次操作锁住对应的行数据。锁定粒度最小，发生锁冲突的概率最低，并发度最高。应用在InnoDB存储引擎中。 InnoDB的数据是基于索引组织的，行锁是通过对索引上的索引项加锁来实现的，而不是对记录加的锁。对于行级锁，主要分为以下三类： 行锁(Record Lock)：锁定单个行记录的锁，防止其他事务对此行进行update和delete。在RC、RR隔离级别下都支持。 间隙锁(Gap Lock)：锁定索引记录间隙（不含该记录），确保索引记录间隙不变，防止其他事务在这个间隙进行insert,产生幻读。在RR隔离级别下都支持。 幻读：事务A修改了表中所有信息，此时事务B插入一条数据，在事务A提交时发现有一条未修改的数据 临键锁(Next-Key Lock)：行锁和间隙锁组合，同时锁住数据，并锁住数据前面的间隙Gap。在RR隔离级别下支持。 行锁InnoDB实现了以下两种类型的行锁： 共享锁(S)：允许一个事务去读一行，阻止其他事务获得相同数据集的排它锁。 排他锁(X)：允许获取排他锁的事务更新数据，阻止其他事务获得相同数据集的共享锁和排他锁。 共享锁与共享锁之间兼容，排他锁与共享锁以及自己都不兼容 SQL 行锁类型 说明 insert 排他锁 自动加锁 update 排他锁 自动加锁 delete 排他锁 自动加锁 select 无 select … lock in share mode 共享锁 手动加锁 select … for update 排他锁 手动加锁 间隙锁&amp;临界锁默认情况下，InnoDB在REPEATABLE READ事务隔离级别运行，InnoDB使用next-key锁(临界锁)进行搜索和索引扫描，以防止幻读。 索引上的等值查询（唯一索引），给不存在的记录加锁时，优化为间隙锁。 表中的数据的id依次为1、3、5 此时一个客户端要查询一个不存在的记录要查询id为4，那么就会加上间隙锁，锁住3和5之间 防止此时另一个客户端插入一个id为4的记录，导致发生幻读 索引上的等值查询(普通索引)，向右遍历时最后一个值不满足查询需求时，next-key lock退化为间隙锁。 索引上的范围查询(唯一索引)，会访问到不满足条件的第一个值为止。 注意：间隙锁唯一目的是防止其他事务插入间隙。间隙锁可以共存，一个事务采用的间隙锁不会阻止另一个事务在同一间隙上采用间隙锁。 8.InnoDB引擎8.1 逻辑存储结构 Tablespace：表空间(ibd文件)，一个ysql实例可以对应多个表空间，用于存储记录、索引等数据。 Segment：段，分为数据段(Leaf node segment)、索引段(Non-leaf node segment)、回滚段(Rollback segment),InnoDB是索引组织表，数据段就是B+树的叶子节点，索引段即为B+树的非叶子节点。段用来管理多个Extent(区)。 Extent：区，表空间的单元结构，每个区的大小为1M。默认情况下，InnoDB存储引擎页大小为16K,即一个区中一共有64个连续的页。 Page：页，是InnoDB存储引擎磁盘管理的最小单元，每个页的大小默认为16KB。为了保证页的连续性，InnoDB存储引擎每次从磁盘申请4-5个区。 Row：行，InnoDB存储引擎数据是按行进行存放的。 8.2 架构MySQL5.5版本开始，默认使用InnoDB存储引擎，它擅长事务处理，具有崩溃恢复特性，在日常开发中使用非常广泛。 下面是InnoDB架构图，左侧为内存结构，右侧为磁盘结构： 内存结构 Buffer Pool：缓冲池是主内存中的一个区域，里面可以缓存磁盘上经常操作的真实数据，在执行增改查操作先操作缓冲池中的数据(若缓冲池没有数据，则从磁盘加载并缓存)，然后再以一定频率刷新到磁盘，从而减少磁盘的I&#x2F;O操作，快处理速度。 缓冲池以Page页为单位，底层采用链表结构管理Page。根据状态，将Page分为三种类型： free page：未发使用。 clean page：被使用page，数据没有被修改过. dirty page：脏页，被使用page， 数据被修改过，也中数据与磁盘的数据产生了不一致。 Change Buffer：更改缓冲区针对于非唯一 二级索引页)，在执行DML语句时，如果这些数据Page没有在Buffer Pool中，不会直接操作磁盘，而会将数据变更存在更改缓冲区Change Buffer中，在未来数据被读取时，再将数据合并恢复到Buffer Pool中，再将合并后的数据刷新到磁盘中。 Change Buffer的意义是什么？ 与聚集索引不同，二级索引通常是非唯一的，并且以相对随机的顺序插入二级索引。同样，删除和更新可能会影响索引树中不相邻的二级索引页，如果每一次都操作磁盘，会造成大量的磁盘I&#x2F;O。有了Change Buffer之后，我们可以在缓冲池中进行合并处理，从而减少磁盘I&#x2F;O。 Adaptive Hash Index：自适应hash索引，用于优化对Buffer Pool数据的查询(只能用于等值匹配)。InnoDB存储引攀会监控对表上各索引页的查询，如果观察到hash索引可以提升速度，则建立hash索引，称之为自适应hash索引。 自适应哈希素引，无需人工干预，是系统根据情况自动完成。 参数：adaptive_hash_index Log Buffer：日志缓冲区，用来保存要写入到磁盘中的log日志数据(redo log、undo log)，默认大小为16MB，日志缓冲区的日志会定期别新到磁盘中。如果需要更新、插入或删除许多行的事务，增加日志缓冲区的大小可以节省磁盘I&#x2F;O。 参数： innodb_log_buffer_size:缓冲区大小 innodb_flush_log_at_trx_commit:日志别新到磁盘时机 磁盘结构 System Tablespace：系统表空间是更改缓冲区的存储区域。如果表是在系统表空间而不是每个表文件或通用表空间中创建的，它也可能包含表和索引数据。(在MySQL5.x版本中还包含InnoDB数据字典、undolog等) 参数：innodb_data_file_path File-Per-Table Tablespaces：每个表的文件表空间包含单个InnoDB表的数据和索引，并存储在文件系统上的单个数据文件中。 参数：innodb_file_per_table General Tablespaces：通用表空间，需要通过CREATE TABLESPACE语法创建通用表空间，在创建表时，可以指定该表空间。 创建表空间： 123CREATE TABLESPACE xxx ADD --指定表空间名称DATAFILE &#x27;file_name&#x27; --指定表空间关联表空间文件ENGINE = engine_name; --指定存储引擎 创建表时指定表空间： 1234CREATE TABLE user( ...)ENGINE = engine_name TABLESPACE ts_Rame; --指定表空间 Undo Tablespaces：辙销表空间，MySQL实例在初始化时会自动创建两个默认的undo表空间(初始大小16M)，用于存储undo log日志。 Temporary Tablespaces：InnoDB使用会话临时表空间和全局临时表空间。存储用户创建的临时表等数据。 Doublewrite Buffer Files：双写缓冲区，innoDB引擎将数据页从Buffer Pool刷新到磁盘前，先将数据页写入双写缓冲区文件中，便于系统异常时恢复数据。 Redo Log：重做日志，是用来实现事务的持久性。 该日志文件由两部分组成：重做日志缓冲(redo log buffer)以及重做日志文件(redo log)，前者是在内存中，后者在磁盘中。当事务提交之后会把所有修改信息都会存到该日志中，用于在刷新脏页到磁盘时，发生错误时，进行数据恢复使用。 后台线程 Master Thread 核心后台线程，负责调度其他线程，还负责将缓冲池中的数据异步刷新到磁盘中，保持数据的一致性，还包括脏页的刷新、合并插入缓存、undo页的回收。 IO Thread 在InnoDB存储引擎中大量使用了AIO来处理I&#x2F;O请求，这样可以极大地提高数据库的性能，而IO Thread主要负责这些I&#x2F;O请求的回调。 线程类型 默认个数 职责 Read thread 4 负责读操作 Write thread 4 负责写操作 Log thread 1 负责将日志缓冲区刷新到磁盘 Insert buffer thread 1 负责将写缓冲区内容刷新到磁盘 Purge Thread 主要用于回收事务已经提交了的undo log,在事务提交之后，undo log可能不用了，就用它来回收。 Page Cleaner Thread 协助Master Thread刷新脏页到磁盘的线程，它可以减轻Master Thread的工作压力，减少阻塞。 8.3 事务原理事务： 事务是一组操作的集合，它是一个不可分割的工作单位，事务会把所有的操作作为一个整体一起向系统提交或撒销操作请求，即这些操作要么同时成功，要么同时失败。 特性： 原子性(Atomicity)：事务是不可分割的最小操作单元，要么全部成功，要么全部失败。 一致性(Consistency)：事务完成时，必须使所有的数据都保持一致状态。 隔离性(lsolation)：数据库系统提供的隔离机制，保证事务在不受外部并发操作影响的独立环境下运行。 特久性(Durability)：事务一旦提交或回滚，它对数据库中的数据的改变就是永久的。 redo log重做日志，记录的是事务提交时数据页的物理修改，是用来实现事务的持久性， 该日志文件由两部分组成：重做日志缓冲(redo log buffer)以及重做日志文件(redo log file)，前者是在内存中，后者在磁盘中。 当事务提交之后会优先把所有修改信息先都存到该日志文件中(如果存入日志文件失败则事务提交也就失败了)，用于在刷新脏页到磁盘，发生错误时，进行数据恢复使用。 并且日志文件会将多条事务排列好顺序刷新到磁盘，避免随机I&#x2F;O，浪费性能 undo log回滚日志，用于记录数据被修改前的信微，作用包含两个：提供回滚和MVCC(多版本并发控制) undo log和redo log记录物理日志不一样，它是逻辑日志。可以认为当delete一条记录时，undo log中会记条对应的insert记录，反之亦然，当update一条记录时，它记录一条对应相反的update记录。当执行rollback时，就可以从undo log中的逻辑记录读家到相应的内容井进行回滚。 Undo log销盟：undo log在事务执行时产生，事务提交时，并不会立即除undo log,因为这些日志可能还用于MVCC Undo log存储：undo log采用段的方式进行管理和记录，存放在前面介绍的rollback segment回滚段中，内部包含1024个undo log segment 8.4 MVCC基本概念 当前读： 读取的是记录的最新版本，读取时还要保证其他并发事务不能修改当前记录，会对读取的记录进行加锁。对于我们日常的操作，如：select...lock in share mode(共享锁)，select..for update、update、insert、delete(排他锁)都是一种当前读。 快照读： 简单的select(不加锁)就是快照读，快照读，读取的是记录数据的可见版本，有可能是历史数据，不加锁，是非阻塞读。 隔离级别： Read Committed(不可重复读)：每次select，都生成一个快照读。 Repeatable Read(可重复读)：开启事务后第一个select语句才是快照读的地方。 Serializable(串行化)：快照读会退化为当前读。 MVCC： 全称Multi-Version Concurrency Control，多版本并发控制。指维护一个数据的多个版本，使得读写操作没有冲突，快照读为MySQL实现MVCC提供了一个非阻塞读功能。MVCC的具体实现，还需要依赖于数据库记录中的三个隐式字段、undo log日志、readView。 隐藏字段记录中会有2个或3个隐藏字段： 隐藏字段 含义 DB_TRX_ID 最近修改事务ID，记录插入这条记录或最后一次修改该记录的事务ID。 DB_ROLL_PTR 回滚指针，指向这条记录的上一个版本，用于配合undo log，指向上一个版本。 DB_ROW_ID 隐藏主键，如果表结构没有指定主键，将会生成该隐藏字段。 undo log版本链回滚日志，在insert、update、deletel的时候产生的便于数据回滚的日志。 当insert的时候，产生的undo log日志只在回滚时需要，在事务提交后，可被立即删除。 而update、delete的时候，产生的undo log日志不仅在回滚时需要，在快照读时也需要，不会立即被删除。 不同事务或相同事务对同一条记录进行修改，会导致该记录的undo log生成一条记录版本链表，链表的头部是最新的旧记录，链表尾部是最早的旧记录。 readviewReadView(读视图)是快照读SQL执行时MVCC提取数据的依据，记录并维护系统当前活跃的事务(未提交的)id。 ReadView中包含了四个核心字段： 字段 含义 m_ids 当前活跃的事务ID集合 min_trx_id 最小活跃事务ID max_trx id 预分配事务ID,当前最大事务ID+1(因为事务ID是自增的) creator_trx_id ReadView创建者的事务ID 版本链数据访问规则： trx_id为记录中的DB_TRX_ID trx_id == creator_trx_id ? 可以访问该版本 成立，说明数据是当前这个事务更改的。 trx_id &lt; min trx_id ? 可以访问该版本 成立，说明数据已经提交了。 trx_id &gt; max_trx_id ? 不可以访问该版本 成立，说明该事务是在ReadView生成后才开启。 min_trx_id &lt;= trx_id &lt;= max_trx_id ? 如果trx_id不在m_ids中是可以访问该版本的 成立，说明数据已经提交 不同的隔离级别，生成ReadView的时机不同： READ COMMITTED：在事务中每一次执行快黑读时生成Readview。 REPEATABLE READ：仅在事务中第一次执行快照读时生成Readview，后续复用该Readview。 RC隔离级别下，在事务中每一次执行快照读时生成ReadView。 执行事务5时的第一条查询语句生成的ReadView： m_ids(活跃事务集合)：{3、4、5} min_trx_id(最小事务id)：3 max_trx id(预分配事务id)：6 creator_trx_id(创建ReadView的事务id)：5 在执行事务5时的第二条查询语句生成的ReadView： m_ids(活跃事务集合)：{4、5} 此时，事务3已经提交事务 min_trx_id(最小事务id)：4 max_trx id(预分配事务id)：6 creator_trx_id(创建ReadView的事务id)：5 这样就可以通过一条记录中的DB_TRX_ID与版本链数据访问规则进行判断，从undo log找出可以访问的版本 RR隔离级别下，仅在事务中第一次执行快照读时生成ReadView，后续复用该ReadView。 同样为这个图： 执行事务5时的第一条查询语句生成的ReadView： m_ids(活跃事务集合)：{3、4、5} min_trx_id(最小事务id)：3 max_trx id(预分配事务id)：6 creator_trx_id(创建ReadView的事务id)：5 在事务5执行第二条查询语句时，会复用之前的Readview 所以在同一次事务中，只会生成一次ReadView","categories":[{"name":"Java","slug":"Java","permalink":"http://example.com/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"},{"name":"数据库","slug":"数据库","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}]},{"title":"(每日LeetCode)870. 优势洗牌","slug":"每日LeetCode/2022-10/870 优势洗牌","date":"2022-10-08T07:37:00.000Z","updated":"2022-10-08T07:37:20.298Z","comments":true,"path":"2022/10/08/每日LeetCode/2022-10/870 优势洗牌/","link":"","permalink":"http://example.com/2022/10/08/%E6%AF%8F%E6%97%A5LeetCode/2022-10/870%20%E4%BC%98%E5%8A%BF%E6%B4%97%E7%89%8C/","excerpt":"","text":"题目：给定两个大小相等的数组 nums1 和 nums2，nums1 相对于 nums2 的优势可以用满足 nums1[i] &gt; nums2[i] 的索引 i 的数目来描述。 返回 nums1 的任意排列，使其相对于 nums2 的优势最大化。 示例： 输入：nums1 &#x3D; [2,7,11,15], nums2 &#x3D; [1,10,4,11]输出：[2,11,7,15] 思路：类似于田忌赛马 将两个数组降序排序，num1中最大的数都比不过num2，那就摆烂，用num1中最小的数 代码(cpp)：1234567891011121314151617181920212223242526272829303132class Solution &#123;public: vector&lt;int&gt; advantageCount(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123; sort(nums1.begin(), nums1.end(), greater&lt;int&gt;()); vector&lt;pair&lt;int, int&gt;&gt; sign(nums2.size()); for(int i = 0; i &lt; nums2.size(); i++)&#123; sign[i] = &#123;nums2[i], i&#125;; &#125; sort(sign.begin(), sign.end(), [](auto&amp; a, auto&amp; b)&#123; return a.first &gt; b.first; &#125; ); vector&lt;int&gt; ans(nums2.size()); int left = 0; int right = nums2.size() - 1; int pos = 0; while(pos &lt; nums2.size())&#123; auto [num, index] = sign[pos++]; if(nums1[left] &gt; num)&#123; ans[index] = nums1[left++]; &#125; else&#123; ans[index] = nums1[right--]; &#125; &#125; return ans; &#125;&#125;; 复杂度分析： 时间复杂度：O(nlogn)，其中 n 是 nums1 的长度。 空间复杂度：O(n)","categories":[{"name":"每日LeetCode","slug":"每日LeetCode","permalink":"http://example.com/categories/%E6%AF%8F%E6%97%A5LeetCode/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"}]},{"title":"(每日LeetCode)1800. 最大升序子数组和","slug":"每日LeetCode/2022-10/1800 最大升序子数组和","date":"2022-10-07T02:47:00.000Z","updated":"2022-10-07T02:47:37.809Z","comments":true,"path":"2022/10/07/每日LeetCode/2022-10/1800 最大升序子数组和/","link":"","permalink":"http://example.com/2022/10/07/%E6%AF%8F%E6%97%A5LeetCode/2022-10/1800%20%E6%9C%80%E5%A4%A7%E5%8D%87%E5%BA%8F%E5%AD%90%E6%95%B0%E7%BB%84%E5%92%8C/","excerpt":"","text":"题目：给你一个正整数组成的数组 nums ，返回 nums 中一个 升序 子数组的最大可能元素和。 子数组是数组中的一个连续数字序列。 已知子数组 [numsl, numsl+1, …, numsr-1, numsr] ，若对所有 i（l &lt;&#x3D; i &lt; r），numsi &lt; numsi+1 都成立，则称这一子数组为 升序 子数组。注意，大小为 1 的子数组也视作 升序 子数组。 示例： 输入：nums &#x3D; [12,17,15,13,10,11,12]输出：33解释：[10,11,12] 是元素和最大的升序子数组，最大元素和为 33 。 代码(cpp)：123456789101112131415class Solution &#123;public: int maxAscendingSum(vector&lt;int&gt;&amp; nums) &#123; int ans = 0; int temp = 0; for(int i = 0; i &lt; nums.size(); i++)&#123; temp += nums[i]; if(i &lt; nums.size() || nums[i] &gt;= nums[i + 1])&#123; ans = max(ans, temp); temp = 0; &#125; &#125; return ans; &#125;&#125;; 复杂度分析： 时间复杂度：O(n) 空间复杂度：O(1)","categories":[{"name":"每日LeetCode","slug":"每日LeetCode","permalink":"http://example.com/categories/%E6%AF%8F%E6%97%A5LeetCode/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"}]},{"title":"(每日LeetCode)811. 子域名访问计数","slug":"每日LeetCode/2022-10/811 子域名访问计数","date":"2022-10-05T03:10:00.000Z","updated":"2022-10-05T03:10:32.577Z","comments":true,"path":"2022/10/05/每日LeetCode/2022-10/811 子域名访问计数/","link":"","permalink":"http://example.com/2022/10/05/%E6%AF%8F%E6%97%A5LeetCode/2022-10/811%20%E5%AD%90%E5%9F%9F%E5%90%8D%E8%AE%BF%E9%97%AE%E8%AE%A1%E6%95%B0/","excerpt":"","text":"题目：网站域名 “discuss.leetcode.com” 由多个子域名组成。顶级域名为 “com” ，二级域名为 “leetcode.com” ，最低一级为 “discuss.leetcode.com” 。当访问域名 “discuss.leetcode.com” 时，同时也会隐式访问其父域名 “leetcode.com” 以及 “com” 。 计数配对域名 是遵循 “rep d1.d2.d3” 或 “rep d1.d2” 格式的一个域名表示，其中 rep 表示访问域名的次数，d1.d2.d3 为域名本身。 例如，”9001 discuss.leetcode.com” 就是一个 计数配对域名 ，表示 discuss.leetcode.com 被访问了 9001 次。给你一个 计数配对域名 组成的数组 cpdomains ，解析得到输入中每个子域名对应的 计数配对域名 ，并以数组形式返回。可以按 任意顺序 返回答案。 示例： 输入：cpdomains &#x3D; [“900 google.mail.com”, “50 yahoo.com”, “1 intel.mail.com”, “5 wiki.org”]输出：[“901 mail.com”,”50 yahoo.com”,”900 google.mail.com”,”5 wiki.org”,”5 org”,”1 intel.mail.com”,”951 com”]解释：按照前文描述，会访问 “google.mail.com” 900 次，”yahoo.com” 50 次，”intel.mail.com” 1 次，”wiki.org” 5 次。而对于父域名，会访问 “mail.com” 900 + 1 &#x3D; 901 次，”com” 900 + 50 + 1 &#x3D; 951 次，和 “org” 5 次。 代码(cpp)：12345678910111213141516171819202122232425262728293031323334353637class Solution &#123;public: vector&lt;string&gt; subdomainVisits(vector&lt;string&gt;&amp; cpdomains) &#123; vector&lt;string&gt; ans; unordered_map&lt;string, int&gt; map; int n = cpdomains.size(); for(int i = 0; i &lt; n; i++)&#123; for(int j = 0; j &lt; cpdomains[i].size(); j++)&#123; if(cpdomains[i][j] == &#x27; &#x27;)&#123; int num = stoi(cpdomains[i].substr(0, j)); string str = cpdomains[i].substr(j + 1); map[str] += num; int pos = 0; while(pos &lt; str.size())&#123; if(str[pos] == &#x27;.&#x27;)&#123; string temp = str.substr(pos + 1); map[temp] += num; &#125; pos++; &#125; break; &#125; &#125; &#125; for(auto&amp; [str, num] : map)&#123; string temp = to_string(num); temp += &#x27; &#x27;; temp += str; ans.emplace_back(temp); &#125; return ans; &#125;&#125;; 复杂度分析： 时间复杂度：O(L)，其中 L 是数组 cpdomains 中的所有字符串长度之和。遍历数组中所有的计数配对域名计算每个子域名的计数需要 O(L) 的时间，遍历哈希表也需要 O(L) 的时间。 空间复杂度：O(L)，其中 L 是数组 cpdomains 中的所有字符串长度之和。哈希表需要 O(L) 的空间。","categories":[{"name":"每日LeetCode","slug":"每日LeetCode","permalink":"http://example.com/categories/%E6%AF%8F%E6%97%A5LeetCode/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"}]},{"title":"(每日LeetCode)921. 使括号有效的最少添加","slug":"每日LeetCode/2022-10/921 使括号有效的最少添加","date":"2022-10-04T15:18:00.000Z","updated":"2022-10-04T15:18:40.853Z","comments":true,"path":"2022/10/04/每日LeetCode/2022-10/921 使括号有效的最少添加/","link":"","permalink":"http://example.com/2022/10/04/%E6%AF%8F%E6%97%A5LeetCode/2022-10/921%20%E4%BD%BF%E6%8B%AC%E5%8F%B7%E6%9C%89%E6%95%88%E7%9A%84%E6%9C%80%E5%B0%91%E6%B7%BB%E5%8A%A0/","excerpt":"","text":"题目：只有满足下面几点之一，括号字符串才是有效的： 它是一个空字符串，或者它可以被写成 AB （A 与 B 连接）, 其中 A 和 B 都是有效字符串，或者它可以被写作 (A)，其中 A 是有效字符串。给定一个括号字符串 s ，移动N次，你就可以在字符串的任何位置插入一个括号。 例如，如果 s &#x3D; “()))” ，你可以插入一个开始括号为 “(()))” 或结束括号为 “())))” 。返回 为使结果字符串 s 有效而必须添加的最少括号数。 示例： 输入：s &#x3D; “())”输出：1 代码(cpp)：1234567891011121314151617class Solution &#123;public: int minAddToMakeValid(string s) &#123; int count = 0; int ans = 0; for(auto&amp; i : s)&#123; if(i == &#x27;(&#x27;) count++; else if(count == 0) ans++; else count--;; &#125; return ans + count; &#125;&#125;; 复杂度分析： 时间复杂度：O(n)，其中 n 是字符串的长度。遍历字符串一次。 空间复杂度：O(1)。只需要维护常量的额外空间。","categories":[{"name":"每日LeetCode","slug":"每日LeetCode","permalink":"http://example.com/categories/%E6%AF%8F%E6%97%A5LeetCode/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"}]},{"title":"(每日LeetCode)777. 在LR字符串中交换相邻字符","slug":"每日LeetCode/2022-10/777 在LR字符串中交换相邻字符","date":"2022-10-02T02:27:00.000Z","updated":"2022-10-02T02:27:39.978Z","comments":true,"path":"2022/10/02/每日LeetCode/2022-10/777 在LR字符串中交换相邻字符/","link":"","permalink":"http://example.com/2022/10/02/%E6%AF%8F%E6%97%A5LeetCode/2022-10/777%20%E5%9C%A8LR%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E4%BA%A4%E6%8D%A2%E7%9B%B8%E9%82%BB%E5%AD%97%E7%AC%A6/","excerpt":"","text":"题目：在一个由 ‘L’ , ‘R’ 和 ‘X’ 三个字符组成的字符串（例如”RXXLRXRXL”）中进行移动操作。一次移动操作指用一个”LX”替换一个”XL”，或者用一个”XR”替换一个”RX”。现给定起始字符串start和结束字符串end，请编写代码，当且仅当存在一系列移动操作使得start可以转换成end时， 返回True。 示例： 输入: start &#x3D; “RXXLRXRXL”, end &#x3D; “XRLXXRRLX”输出: True解释:我们可以通过以下几步将start转换成end:RXXLRXRXL -&gt;XRXLRXRXL -&gt;XRLXRXRXL -&gt;XRLXXRRXL -&gt;XRLXXRRLX 思路：&#39;R&#39;只能向右移动，并且只能移向&#39;X&#39;，&#39;L&#39;只能向左移动，并且只能移向&#39;X&#39;。 如果将start、end中的‘X’全部去掉得到的newStart 和 newEnd相等才有可能转换成功。 如果start中&#39;R&#39;的左边&#39;X&#39;的个数超过在end中对应位置的&#39;R&#39;的左边&#39;X&#39;的个数，则不能转换成功 因为start中的&#39;R&#39;只能向右移动，右边的&#39;X&#39;只能增加不能减少 如果end中&#39;L&#39;的左边&#39;X&#39;的个数超过在start中对应位置的&#39;L&#39;的左边&#39;X&#39;的个数，则不能转换成功 因为start中的&#39;L&#39;只能向左移动，左边的&#39;X&#39;只能减少不能增加 代码(cpp)：双指针 1234567891011121314151617181920212223class Solution &#123;public: bool canTransform(string start, string end) &#123; int n = start.size(); int i = 0, j = 0; while (true) &#123; while (i &lt; n &amp;&amp; start[i] == &#x27;X&#x27;) i++; while (j &lt; n &amp;&amp; end[j] == &#x27;X&#x27;) j++; if (i == n &amp;&amp; j == n) return true; if (i == n || j == n || start[i] != end[j]) return false; if (start[i] == &#x27;L&#x27; &amp;&amp; i &lt; j) return false; if (start[i] == &#x27;R&#x27; &amp;&amp; i &gt; j) return false; i++; j++; &#125; &#125;&#125;; 复杂度分析： 时间复杂度：O(n)，其中 n 是字符串 start 和 end 的长度。需要遍历两个字符串各一次。 空间复杂度：O(1)。只需要使用常量的额外空间。","categories":[{"name":"每日LeetCode","slug":"每日LeetCode","permalink":"http://example.com/categories/%E6%AF%8F%E6%97%A5LeetCode/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"}]},{"title":"(每日LeetCode)1694. 重新格式化电话号码","slug":"每日LeetCode/2022-10/1694 重新格式化电话号码","date":"2022-10-01T12:35:00.000Z","updated":"2022-10-01T12:36:00.091Z","comments":true,"path":"2022/10/01/每日LeetCode/2022-10/1694 重新格式化电话号码/","link":"","permalink":"http://example.com/2022/10/01/%E6%AF%8F%E6%97%A5LeetCode/2022-10/1694%20%E9%87%8D%E6%96%B0%E6%A0%BC%E5%BC%8F%E5%8C%96%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81/","excerpt":"","text":"题目：给你一个字符串形式的电话号码 number 。number 由数字、空格 &#39; &#39;、和破折号 &#39;-&#39; 组成。 请你按下述方式重新格式化电话号码。 首先，删除 所有的空格和破折号。其次，将数组从左到右 每 3 个一组 分块，直到 剩下 4 个或更少数字。剩下的数字将按下述规定再分块： 2 个数字：单个含 2 个数字的块。 3 个数字：单个含 3 个数字的块。 4 个数字：两个分别含 2 个数字的块。 最后用破折号将这些块连接起来。注意，重新格式化过程中 不应该 生成仅含 1 个数字的块，并且 最多 生成两个含 2 个数字的块。 返回格式化后的电话号码。 示例： 输入：number &#x3D; “1-23-45 6”输出：”123-456”解释：数字是 “123456”步骤 1：共有超过 4 个数字，所以先取 3 个数字分为一组。第 1 个块是 “123” 。步骤 2：剩下 3 个数字，将它们放入单个含 3 个数字的块。第 2 个块是 “456” 。连接这些块后得到 “123-456” 。 代码(cpp)：1234567891011121314151617181920212223242526272829303132333435class Solution &#123;public: string reformatNumber(string number) &#123; string num = &quot;&quot;; for(int i = 0; i &lt; number.size(); i++)&#123; if(number[i] == &#x27; &#x27; || number[i] == &#x27;-&#x27;)&#123; continue; &#125; num.push_back(number[i]); &#125; string ans = &quot;&quot;; int size = num.size(); int count = 0; for(int i = 0; i &lt; size; i++)&#123; if(size%3 == 1 &amp;&amp; size -i+1 &lt;= 4)&#123; if(count == 2)&#123; ans.push_back(&#x27;-&#x27;); count = 0; &#125; &#125; if(count == 3)&#123; ans.push_back(&#x27;-&#x27;); count = 0; &#125; ans.push_back(num[i]); count++; &#125; return ans; &#125;&#125;; 复杂度分析： 时间复杂度：O(n) 空间复杂度：O(n)","categories":[{"name":"每日LeetCode","slug":"每日LeetCode","permalink":"http://example.com/categories/%E6%AF%8F%E6%97%A5LeetCode/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"}]},{"title":"(每日LeetCode)面试题 01.08. 零矩阵","slug":"每日LeetCode/2022-9/面试题 01.08 零矩阵","date":"2022-09-30T06:16:00.000Z","updated":"2022-09-30T06:16:35.698Z","comments":true,"path":"2022/09/30/每日LeetCode/2022-9/面试题 01.08 零矩阵/","link":"","permalink":"http://example.com/2022/09/30/%E6%AF%8F%E6%97%A5LeetCode/2022-9/%E9%9D%A2%E8%AF%95%E9%A2%98%2001.08%20%E9%9B%B6%E7%9F%A9%E9%98%B5/","excerpt":"","text":"题目：编写一种算法，若M × N矩阵中某个元素为0，则将其所在的行与列清零。 示例： 输入：[[1,1,1],[1,0,1],[1,1,1]]输出：[[1,0,1],[0,0,0],[1,0,1]] 代码(cpp)：1234567891011121314151617181920212223242526class Solution &#123;public: void setZeroes(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123; int m = matrix.size(); int n = matrix[0].size(); vector&lt;int&gt; x(m); vector&lt;int&gt; y(n); for(int i = 0; i &lt; m; i++)&#123; for(int j = 0; j &lt; n; j++)&#123; if(matrix[i][j] == 0)&#123; x[i] = 1; y[j] = 1; &#125; &#125; &#125; for(int i = 0; i &lt; m; i++)&#123; for(int j = 0; j &lt; n; j++)&#123; if(x[i] == 1 || y[j] == 1)&#123; matrix[i][j] = 0; &#125; &#125; &#125; &#125;&#125;; 复杂度分析： 时间复杂度：O(mn)，其中 m 是矩阵的行数，n 是矩阵的列数。我们至多只需要遍历该矩阵两次。 空间复杂度：O(m+n)，其中 m 是矩阵的行数，n 是矩阵的列数。我们需要分别记录每一行或每一列是否有零出现。","categories":[{"name":"每日LeetCode","slug":"每日LeetCode","permalink":"http://example.com/categories/%E6%AF%8F%E6%97%A5LeetCode/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"}]},{"title":"(每日LeetCode)面试题 01.09. 字符串轮转","slug":"每日LeetCode/2022-9/面试题 01.09 字符串轮转","date":"2022-09-29T11:50:00.000Z","updated":"2022-09-29T11:50:50.639Z","comments":true,"path":"2022/09/29/每日LeetCode/2022-9/面试题 01.09 字符串轮转/","link":"","permalink":"http://example.com/2022/09/29/%E6%AF%8F%E6%97%A5LeetCode/2022-9/%E9%9D%A2%E8%AF%95%E9%A2%98%2001.09%20%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AE%E8%BD%AC/","excerpt":"","text":"题目：字符串轮转。给定两个字符串s1和s2，请编写代码检查s2是否为s1旋转而成（比如，waterbottle是erbottlewat旋转后的字符串）。 示例： 输入：s1 &#x3D; “waterbottle”, s2 &#x3D; “erbottlewat”输出：True 代码(cpp)：模拟 1234567891011121314151617181920class Solution &#123;public: bool isFlipedString(string s1, string s2) &#123; if(s1.size() != s2.size()) return false; if(s1.size() == 0) return true; for(int i = 0; i &lt; s1.size(); i++)&#123; bool flag = true; for(int j = 0; j &lt; s1.size(); j++)&#123; if(s2[(i + j) % s1.size()] != s1[j])&#123; flag = false; break; &#125; &#125; if(flag) return true; &#125; return false; &#125;&#125;; 复杂度分析： 时间复杂度：O(n^2)，其中 n 是字符串 s1的长度。我们需要双重循环来判断。 空间复杂度：O(1)。仅使用常数空间。 代码(cpp)：KMP 123456789101112class Solution &#123;public: bool isFlipedString(string s1, string s2) &#123; if(s1.size() != s2.size()) return false; if(s1.size() == 0) return true; s1 += s1; return s1.find(s2) != string::npos; &#125;&#125;; 复杂度分析： 时间复杂度：O(n)，其中 n 是字符串 s1的长度。KMP 算法搜索子字符串的时间复杂度为 O(n)，其他搜索子字符串的方法会略有差异。 空间复杂度：O(n)，其中 n 是字符串 s1的长度。KMP 算法搜索子字符串的空间复杂度为 O(n)，其他搜索子字符串的方法会略有差异。","categories":[{"name":"每日LeetCode","slug":"每日LeetCode","permalink":"http://example.com/categories/%E6%AF%8F%E6%97%A5LeetCode/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"}]},{"title":"(每日LeetCode)面试题 01.02. 判定是否互为字符重排","slug":"每日LeetCode/2022-9/面试题 01.02 判定是否互为字符重排","date":"2022-09-27T04:43:00.000Z","updated":"2022-09-27T04:43:35.593Z","comments":true,"path":"2022/09/27/每日LeetCode/2022-9/面试题 01.02 判定是否互为字符重排/","link":"","permalink":"http://example.com/2022/09/27/%E6%AF%8F%E6%97%A5LeetCode/2022-9/%E9%9D%A2%E8%AF%95%E9%A2%98%2001.02%20%E5%88%A4%E5%AE%9A%E6%98%AF%E5%90%A6%E4%BA%92%E4%B8%BA%E5%AD%97%E7%AC%A6%E9%87%8D%E6%8E%92/","excerpt":"","text":"题目： 给定两个字符串 s1 和 s2，请编写一个程序，确定其中一个字符串的字符重新排列后，能否变成另一个字符串。 示例： 输入: s1 &#x3D; “abc”, s2 &#x3D; “bca”输出: true 代码(cpp)： 方式一：排序 12345678910111213141516171819class Solution &#123;public: bool CheckPermutation1(string s1, string s2) &#123; if(s1.size() != s2.size())&#123; return false; &#125; sort(s1.begin(), s1.end()); sort(s2.begin(), s2.end()); for(int i = 0; i &lt; s1.size(); i++)&#123; if(s1[i] != s2[i])&#123; return false; &#125; &#125; return true; &#125;&#125;; 方式二：哈希 12345678910111213141516171819202122class Solution &#123;public: bool CheckPermutation(string s1, string s2)&#123; if(s1.size() != s2.size())&#123; return false; &#125; vector&lt;int&gt; map(26, 0); for(auto&amp; s : s1)&#123; map[s - &#x27;a&#x27;]++; &#125; for(auto&amp; s : s2)&#123; if(map[s - &#x27;a&#x27;] != 0)&#123; map[s - &#x27;a&#x27;]--; &#125; else return false; &#125; return true; &#125;&#125;;","categories":[{"name":"每日LeetCode","slug":"每日LeetCode","permalink":"http://example.com/categories/%E6%AF%8F%E6%97%A5LeetCode/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"}]},{"title":"(每日LeetCode)面试题 17.19. 消失的两个数字","slug":"每日LeetCode/2022-9/面试题 17.19 消失的两个数字","date":"2022-09-26T14:25:00.000Z","updated":"2022-09-27T04:42:48.846Z","comments":true,"path":"2022/09/26/每日LeetCode/2022-9/面试题 17.19 消失的两个数字/","link":"","permalink":"http://example.com/2022/09/26/%E6%AF%8F%E6%97%A5LeetCode/2022-9/%E9%9D%A2%E8%AF%95%E9%A2%98%2017.19%20%E6%B6%88%E5%A4%B1%E7%9A%84%E4%B8%A4%E4%B8%AA%E6%95%B0%E5%AD%97/","excerpt":"","text":"题目： 给定一个数组，包含从 1 到 N 所有的整数，但其中缺了两个数字。你能在 O(N) 时间内只用 O(1) 的空间找到它们吗？ 以任意顺序返回这两个数字均可。 示例： 输入: [2,3]输出: [1,4] 代码(cpp)： 1234567891011121314151617181920212223242526class Solution &#123;public: vector&lt;int&gt; missingTwo(vector&lt;int&gt;&amp; nums) &#123; //总长度 int all = nums.size() + 2; //获取总长度的元素总和 int all_sum = all*(1 + all) / 2; //计算剩余的总和 int remain_sum = all_sum; for(auto&amp; num : nums)&#123; remain_sum -= num; &#125; //获取结果中间的元素，说明有一个答案必定有一个小于mid的 int mid = remain_sum / 2; //计算出总和 int mid_sum = mid*(1 + mid) / 2; //获取那个小于mid的答案 for(auto&amp; num : nums)&#123; if(num &lt;= mid)&#123; mid_sum -= num; &#125; &#125; //用剩余的减去mid_sumjiu&#x27;de return &#123;mid_sum, remain_sum - mid_sum&#125;; &#125;&#125;;","categories":[{"name":"每日LeetCode","slug":"每日LeetCode","permalink":"http://example.com/categories/%E6%AF%8F%E6%97%A5LeetCode/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"}]},{"title":"(每日LeetCode)1652. 拆炸弹","slug":"每日LeetCode/2022-9/1652 拆炸弹","date":"2022-09-24T01:25:00.000Z","updated":"2022-09-24T01:25:16.126Z","comments":true,"path":"2022/09/24/每日LeetCode/2022-9/1652 拆炸弹/","link":"","permalink":"http://example.com/2022/09/24/%E6%AF%8F%E6%97%A5LeetCode/2022-9/1652%20%E6%8B%86%E7%82%B8%E5%BC%B9/","excerpt":"","text":"题目：你有一个炸弹需要拆除，时间紧迫！你的情报员会给你一个长度为 n 的 循环 数组 code 以及一个密钥 k 。 为了获得正确的密码，你需要替换掉每一个数字。所有数字会 同时 被替换。 如果 k &gt; 0 ，将第 i 个数字用 接下来 k 个数字之和替换。 如果 k &lt; 0 ，将第 i 个数字用 之前 k 个数字之和替换。 如果 k &#x3D;&#x3D; 0 ，将第 i 个数字用 0 替换。 由于 code 是循环的， code[n-1] 下一个元素是 code[0] ，且 code[0] 前一个元素是 code[n-1] 。 给你 循环 数组 code 和整数密钥 k ，请你返回解密后的结果来拆除炸弹！ 示例： 输入：code &#x3D; [5,7,1,4], k &#x3D; 3输出：[12,10,16,13]解释：每个数字都被接下来 3 个数字之和替换。解密后的密码为 [7+1+4, 1+4+5, 4+5+7, 5+7+1]。注意到数组是循环连接的。 输入：code &#x3D; [2,4,9,3], k &#x3D; -2输出：[12,5,6,13]解释：解密后的密码为 [3+9, 2+3, 4+2, 9+4] 。注意到数组是循环连接的。如果 k 是负数，那么和为 之前 的数字。 思路：分为3中情况，模拟出3种情况即可 代码(cpp)：123456789101112131415161718192021222324252627282930class Solution &#123;public: vector&lt;int&gt; decrypt(vector&lt;int&gt;&amp; code, int k) &#123; vector&lt;int&gt; ans; int n = code.size(); if(k == 0)&#123; return vector&lt;int&gt;(n); &#125; else if (k &gt; 0)&#123; for(int i = 0; i &lt; code.size(); i++)&#123; int sum = 0; for(int j = 0; j &lt; k; j++)&#123; sum += code[(i + j + 1) % n]; &#125; ans.emplace_back(sum); &#125; &#125; else &#123; for(int i = 0; i &lt; code.size(); i++)&#123; int sum = 0; for(int j = 0; j &lt; abs(k); j++)&#123; sum += code[(i - j - 1 + n) % n]; &#125; ans.emplace_back(sum); &#125; &#125; return ans; &#125;&#125;;","categories":[{"name":"每日LeetCode","slug":"每日LeetCode","permalink":"http://example.com/categories/%E6%AF%8F%E6%97%A5LeetCode/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"}]},{"title":"(每日LeetCode)707. 设计链表","slug":"每日LeetCode/2022-9/707 设计链表","date":"2022-09-23T01:23:00.000Z","updated":"2022-09-23T01:24:10.730Z","comments":true,"path":"2022/09/23/每日LeetCode/2022-9/707 设计链表/","link":"","permalink":"http://example.com/2022/09/23/%E6%AF%8F%E6%97%A5LeetCode/2022-9/707%20%E8%AE%BE%E8%AE%A1%E9%93%BE%E8%A1%A8/","excerpt":"","text":"题目：设计链表的实现。您可以选择使用单链表或双链表。单链表中的节点应该具有两个属性：val 和 next。val 是当前节点的值，next 是指向下一个节点的指针&#x2F;引用。如果要使用双向链表，则还需要一个属性 prev 以指示链表中的上一个节点。假设链表中的所有节点都是 0-index 的。 在链表类中实现这些功能： get(index)：获取链表中第 index 个节点的值。如果索引无效，则返回-1。 addAtHead(val)：在链表的第一个元素之前添加一个值为 val 的节点。插入后，新节点将成为链表的第一个节点。 addAtTail(val)：将值为 val 的节点追加到链表的最后一个元素。 addAtIndex(index,val)：在链表中的第 index 个节点之前添加值为 val 的节点。如果 index 等于链表的长度，则该节点将附加到链表的末尾。如果 index 大于链表长度，则不会插入节点。如果index小于0，则在头部插入节点。 deleteAtIndex(index)：如果索引 index 有效，则删除链表中的第 index 个节点。 示例： MyLinkedList linkedList &#x3D; new MyLinkedList();linkedList.addAtHead(1);linkedList.addAtTail(3);linkedList.addAtIndex(1,2); &#x2F;&#x2F;链表变为1-&gt; 2-&gt; 3linkedList.get(1); &#x2F;&#x2F;返回2linkedList.deleteAtIndex(1); &#x2F;&#x2F;现在链表是1-&gt; 3linkedList.get(1); &#x2F;&#x2F;返回3 代码(cpp)：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566class MyLinkedList &#123;public: MyLinkedList() &#123; this-&gt;head = new ListNode(-1, nullptr); this-&gt;size = 0; &#125; int get(int index) &#123; if(index &lt; 0 || this-&gt;size &lt;= index) return -1; auto temp = this-&gt;head; while(index &gt;=0) &#123; temp = temp-&gt;next; index--; &#125; return temp-&gt;val; &#125; void addAtHead(int val) &#123; addAtIndex(0, val); &#125; void addAtTail(int val) &#123; this-&gt;addAtIndex(this-&gt;size, val); &#125; void addAtIndex(int index, int val) &#123; if(index &lt; 0 || this-&gt;size &lt; index) return; auto temp = this-&gt;head; while(index &gt; 0) &#123; temp = temp-&gt;next; index--; &#125; ListNode* newNode = new ListNode(val, temp-&gt;next); temp-&gt;next = newNode; this-&gt;size++; &#125; void deleteAtIndex(int index) &#123; if(index &lt; 0 || this-&gt;size &lt;= index) return; auto temp = this-&gt;head; while(index &gt; 0) &#123; temp = temp-&gt;next; index--; &#125; auto e = temp-&gt;next; temp-&gt;next = e-&gt;next; delete e; this-&gt;size--; &#125;private: class ListNode &#123; public: int val; ListNode* next; ListNode(int val, ListNode* next) &#123; this-&gt;val = val; this-&gt;next = next; &#125; &#125;; int size; ListNode* head;&#125;; 复杂度分析： 时间复杂度：初始化消耗 O(1)，get 消耗 O(index)，addAtHead 消耗 O(1)，addAtTail 消耗 O(n)，其中 n 为链表当前长度，即 addAtHead，addAtTail 和 addAtIndex 已调用次数之和，addAtIndex 消耗 O(index)。 空间复杂度：所有函数的单次调用空间复杂度均为 O(1)，总体空间复杂度为 O(n)，其中 n 为 addAtHead，addAtTail 和 addAtIndex 调用次数之和。","categories":[{"name":"每日LeetCode","slug":"每日LeetCode","permalink":"http://example.com/categories/%E6%AF%8F%E6%97%A5LeetCode/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"}]},{"title":"Git的学习笔记","slug":"Java/Git","date":"2022-09-21T14:17:30.898Z","updated":"2023-02-03T03:51:48.790Z","comments":true,"path":"2022/09/21/Java/Git/","link":"","permalink":"http://example.com/2022/09/21/Java/Git/","excerpt":"","text":"1.概述1.1 开发常用场景 备份 代码还原 协同开发 追溯问题代码的编写人员和编写时间 1.2 SVNSVN(subversion)，是一个开放源代码的版本控制系统，通过采用分支管理系统的高效管理，简而言之就是用于多个人共同开发同一个项目，实现共享资源，实现最终集中式的管理。 工作流程： SVN是集中式版本控制系统，版本库是集中放在中央服务器的工作流程如下: 从中央服务器远程仓库下载代码 修改后将代码提交到中央服务器远程仓库 优缺点: 优点：简单,易操作 缺点：所有代码必须放在中央服务器 服务器一旦宕机无法提交代码,即容错性较差 离线无法提交代码,无法及时记录我们的提交行为 1.3 Git工作流程： Git是分布式版本控制系统(Distributed Version Control System，简称 DVCS)，分为两种类型的仓库： 本地仓库 远程仓库 工作流程如下： 从远程仓库中克隆或拉取代码到本地仓库(clone&#x2F;pull) 从本地进行代码修改 在提交前先将代码提交到暂存区 提交到本地仓库。本地仓库中保存修改的各个历史版本 修改完成后，需要和团队成员共享代码时，将代码push到远程仓库 Git和SVN的区别： SVN 是集中式版本控制工具，Git是分布式版本控制工具 SVN不支持离线提交，Git支持离线提交代码 1.4 Git 工作流程 命令如下： clone(克隆)：从玩程仓庄中克隆代码到本地仓库 checkout(检出)：从本地仓库中检出一个仓库分支然后进行修订 add(添加)：在提交的先格代码堤交到智存区 commit(提交)：提交到本地仓库，本地仓南中保存修放的各个历史版本 fetch(抓取)：从污程车，抓取到本地仓库，不进行任何的合井动作，一般操作比较少。 pull(拉取)：从运程库拉到本地库，白动进行合井(merge)，然后放到到工作区，相当于fetch+merge push(推送)：修改完成后，需要和团队成员共享代码，将代码推送到远程仓库 2.Git的使用及常用命令再windows桌面或者文件夹中右键，会出现： Git GUI：Git提供的图像化界面工具 Git Bash：Git提供的命令行工具 2.1 基本配置配置用户信息 打开Git Bash 设置用户信息 git config --global user.name&quot;XXX&quot; git config --global user.email&quot;666@qq.com&quot; 查看用户信息 git config --global user.name git config --global user.email 为常用指令配置别名有些常用的指令参数非常多，每次都要出入好多参数，我们可以起别名： 打开Users目录，创建.bashrc文件 再Users目录中右键，打开Git Bash，输入下面来创建.bashrc文件 1touch ~/.bashrc 再.bashrc文件输入以下内容 1234#用于输出git提交日志alias git-log=&#x27;git log --pretty=oneline --all --graph --abbrev-commit&#x27;#用于输出当前目录所有文件及其文件信息alias ll=&#x27;ls -al&#x27; 接着执行： 1source ~/.bash 解决Git Bash乱码问题 打开Git Bash执行下面命令： 1git config --global core.quotepath false $&#123;git_home&#125;/etc/bash.bashrc文件最后加入下面内容： 12export LANG=&quot;zh_CN.UTF-8&quot;export LC_ALL=&quot;zh_CN.UTF-8&quot; 2.2 获取本地仓库要使用Git对代码进行版本控制，首先需要获得本地仓库 在电脑的任意位置创建一个空目录(例如test)作为我们的本地Git仓库 进入这个目录中，点击右键打开Git bash窗口 执行命令： 1git init 如果创建成功后可在文件夹下看到隐藏的.git目录。 2.3 基础操作命令Git工作目录对于文件的修改(增加、删除、更新)会存在几个状态，这些修改状态会随着执行Git命令而发生变化 使用命令来控制这些状态之间的转换： git add：工作区–&gt;暂存区 git commit：暂存区–&gt;本地仓库 查看修改的状态查看修改的状态(暂存区、工作区)： 1git status 添加工作区到暂存区1git add 文件名 或者使用通配符，如：将所有文件添加到暂存区 1git add . 提交暂存区到本地仓库1git commit -m &#x27;注释内容&#x27; 查看日志1git log [option] option多个参数： --all：显示所有分支 --pretty=oneline：将提交的信息显示为一行 --abbrev-commit：使得输出的commitId更简短 --graph：以图的形式显示 1git log --pretty=oneline --all --graph --abbrev-commit 或者在之前的常用指令设置的别名： 1git-log 版本回退1git reset --hard commitID commitID可以使用git-log或git log查看 查看已经删除的记录： 1git reflog 添加文件至忽略列表在工作目录创建一个名为.gitignore的文件(文件名固定) 可以列出要忽略的文件名，如： 忽略后缀为a的文件： 1*.a 2.4 分支几乎所有的版本控制系统都以某种形式支持分支。使用分支意味着你可以把你的工作从开发主线上分离来进行重大的BUG修改，开发新功能，以免影响开发主线 查看本地分支1git branch 创建本地分支1git branch 分支名 切换分支1git checkout 分支名 还可以切换到另一个不存在的分支(创建并切换) 1git checkout -b 分支名 合并分支一个分支上的提交可以合并到另一个分支 1git merge 分支名称 删除分支不能删除当前分支，只能删除其他分支 删除分支时，需要删除其他分支： 1git branch -d b1 不做任何检查，强制删除： 1git branch -D b1 解决冲突当两个分支上对文件的修改可能会存在冲突，如同时修改同一个文件的同一行，这时需要手动解决冲突，解决步骤如下： 处理文件中冲突的地方 将解决完的冲突的文件加入暂存区(add) 提交到仓库(commit) 开发中分支使用原则在开发中，一般有如下分支使用原则与流程： master(生产分支) 线上分支、主分支、中小规模项目作为线上运行的应用对应的分支 develop(开发分支) 是从master创建的分支，一般作为开发部门的主要开发分支，如果没有其他并行开发不同期上线要求，都可以在此版本进行开发，阶段开发完成后，需要合并到master分支，准备上线 feature&#x2F;XXX分支 从develop创建的分支，一般是同期并行开发，但不同期上线时创建的分支，分支上的研发任务完成后合并到develop分支。 hotfix&#x2F;XXX分支 从master派生的分支，一般作为线上bug修复使用，修复完成后需要合并到master、test、 develop分支。 还有其他一些分支如，test分支(用于代码测试)、pre分支(预上线分支)等 3.Git远程仓库3.1 常用的托管仓库那么我们如何搭建Git远程仓库呢？ 我们可以借助互联网上提供的一些代码托管服务水实现，其中比较常用的有GitHub、码云等。 gitHub是一个面向开源及私有软件项目的托管平台，因为只支持Git作为唯一的版本库格式进行托管，故名gitHub 码云(gitee)是国内的一个代码托管平台，由手服务器在国内，所以相比于GitHub，码云速度会更快 3.2 操作远程仓库远程仓库的添加命令：git remote add &lt;远端名称&gt; &lt;仓库路径&gt; 远端名称：默认为origin(可以自己取)，取决于远端服务器设置 仓库名称：从远程仓库服务器获取的URL 1git remote add origin 仓库地址 查看远程仓库1git remote 推送到远程仓库命令：git push [-f] [--set-upstream] [远端名称] [本地分支名]:[远端分支名] -f：强制覆盖 注意：如果本地分支名和远端分支名相同，则只需写本地分支名即可 1git push origin master --set-upstream：推送到远端的同时并建立起与远端分支的关联 1git push --set-upstream origin master 如果当前分支已经和远端分支关联，则可以省略分支名和远端名 1git push 本地分支与远端分支查看关联关系： 1git branch -vv 从远程仓库克隆将远程仓库克隆到本地： 命令：git clone &lt;仓库路径&gt; &lt;本地目录&gt; 注意：本地目录可以省略，会在当前文件夹自动生成一个目录 1git clone 仓库路径 从远程仓库抓取和拉取抓取：将仓库里的更新都抓取到本地，不会进行合并 抓取命令：git fetch [remote name] [branch name] 如果不指定远端名称和分支名，则会抓取所有分支 拉取：将远端仓库的修改拉到本地并自动进行合并，等同于fetch+merge 拉取命令：git pull [remote name] [branch name] 如果不指定远端名称和分支名，则会抓取所有分支并更新当前分支 解决合并冲突在一段时间，A、B用户修改了同一个文件，且修改了同一行位置的代码，此时会发生合并冲突。 A用户在本地修改代码后优先推送到远程仓库，此时B用户在本地修订代码，提交到本地仓库后，也需要推送到远程仓库，此时B用户晚于A用户，故需要先拉取远程仓库的提交，经过合井后才能推送到远端分支,如下图所示。 在B用户拉取代码时，因为A、B用户同一段时同修改了同一个文件的相同位置代码，故会发生合并冲突。 远程分支也是分支，所以合井时冲突的解决方式也和解決本地分支冲突相同相同","categories":[{"name":"Java","slug":"Java","permalink":"http://example.com/categories/Java/"}],"tags":[{"name":"Git","slug":"Git","permalink":"http://example.com/tags/Git/"}]},{"title":"(每日LeetCode)698. 划分为k个相等的子集","slug":"每日LeetCode/2022-9/698 划分为k个相等的子集","date":"2022-09-20T01:18:00.000Z","updated":"2022-09-20T01:18:46.428Z","comments":true,"path":"2022/09/20/每日LeetCode/2022-9/698 划分为k个相等的子集/","link":"","permalink":"http://example.com/2022/09/20/%E6%AF%8F%E6%97%A5LeetCode/2022-9/698%20%E5%88%92%E5%88%86%E4%B8%BAk%E4%B8%AA%E7%9B%B8%E7%AD%89%E7%9A%84%E5%AD%90%E9%9B%86/","excerpt":"","text":"题目：给定一个整数数组 nums 和一个正整数 k，找出是否有可能把这个数组分成 k 个非空子集，其总和都相等。 示例： 输入： nums &#x3D; [4, 3, 2, 3, 5, 2, 1], k &#x3D; 4输出： True说明： 有可能将其分成 4 个子集（5），（1,4），（2,3），（2,3）等于总和。 思路：计算出nums的元素总和。 除以k，不能除尽，则说明不存在解 总和除以k，可以求出平均值，得出每个桶(arr数组)需要装的元素大小 利用回溯进行装球(nums中的元素)，得出解 代码(cpp)；123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354class Solution &#123;public: bool dfs(vector&lt;int&gt;&amp; nums, int target, vector&lt;int&gt; arr, int k, int index)&#123; //如果index到了nums的末尾的后一位 if(index == nums.size())&#123; for(auto&amp; a : arr)&#123; //如果有一个桶里的数不等于平均数，则返回false if(a != target) return false; &#125; //遍历完成，返回true return true; &#125; //遍历每个桶 for(int i = 0; i &lt; k; i++)&#123; //如果第i桶加上nums中的index位置的元素，大于平均数 if(arr[i] + nums[index] &gt; target) //进入到下一个桶(i+1) continue; //第i桶加上index位置元素 arr[i] += nums[index]; //调用递归，插入index+1位置的元素 if(dfs(nums, target, arr, k, index + 1)) //如果递归完成后每个桶里的数都等于平均数，则返回为真 return true; //运行到这里说明，这个index位置的元素，放到i桶里不合适 //将i桶中的这个位置的元素剔除，放到i+1桶里试试 arr[i] -= nums[index]; //剔除这个位置的元素后，如果这个桶为0，则说明放到别的桶里也一样 //每个桶要放的大小都一样 if(arr[i] == 0) break; //剪枝 &#125; //遍历完全后，还没有找到解，则返回false return false; &#125; bool canPartitionKSubsets(vector&lt;int&gt;&amp; nums, int k) &#123; //如果nums的元素个数小于k，则返回flase if(nums.size() &lt; k) return false; //获取nums的元素总和 int sum = accumulate(nums.begin(),nums.end(),0); //如果不能被k除尽，则返回false if(sum%k != 0) return false; //降序排列 sort(nums.begin(), nums.end(), greater&lt;int&gt;()); //获取sum的平均数 int target = sum / k; //用来记录每个桶的大小 vector&lt;int&gt; arr(k); //调用回溯,得出解 return dfs(nums, target, arr, k, 0); &#125;&#125;;","categories":[{"name":"每日LeetCode","slug":"每日LeetCode","permalink":"http://example.com/categories/%E6%AF%8F%E6%97%A5LeetCode/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"}]},{"title":"(每日LeetCode)1636. 按照频率将数组升序排序","slug":"每日LeetCode/2022-9/1636 按照频率将数组升序排序","date":"2022-09-19T01:48:00.000Z","updated":"2022-09-19T01:48:44.717Z","comments":true,"path":"2022/09/19/每日LeetCode/2022-9/1636 按照频率将数组升序排序/","link":"","permalink":"http://example.com/2022/09/19/%E6%AF%8F%E6%97%A5LeetCode/2022-9/1636%20%E6%8C%89%E7%85%A7%E9%A2%91%E7%8E%87%E5%B0%86%E6%95%B0%E7%BB%84%E5%8D%87%E5%BA%8F%E6%8E%92%E5%BA%8F/","excerpt":"","text":"题目：给你一个整数数组 nums ，请你将数组按照每个值的频率 升序 排序。如果有多个值的频率相同，请你按照数值本身将它们 降序 排序。 请你返回排序后的数组。 示例： 输入：nums &#x3D; [1,1,2,2,2,3]输出：[3,1,1,2,2,2]解释：’3’ 频率为 1，’1’ 频率为 2，’2’ 频率为 3 。 思路：获取nums数组中的每个元素的频率，通过频率比较： 如果频率相等的情况，按照元素的大小进行降序排列 如果频率不相等的情况，按照元素的排列大小进行升序排列 代码(cpp)：123456789101112131415161718192021class Solution &#123;public: vector&lt;int&gt; frequencySort(vector&lt;int&gt;&amp; nums) &#123; unordered_map&lt;int, int&gt; map; //获取nums中各个元素的频率 for(auto&amp; num : nums)&#123; map[num]++; &#125; //给nums自定义排序 sort(nums.begin(), nums.end(), [&amp;](int a, int b)&#123; //频率不相等的情况，按照升序排列 if(map[a] != map[b])&#123; return map[a] &lt; map[b]; &#125; //排列相等的情况，按照降序排序 return a &gt; b; &#125;); return nums; &#125;&#125;; 复杂度分析： 时间复杂度：O(nlogn)，其中 n 是数组 nums 的长度。排序消耗 O(nlogn) 时间。 空间复杂度：O(n)，存储数组元素频率的哈希表消耗 O(n) 空间。","categories":[{"name":"每日LeetCode","slug":"每日LeetCode","permalink":"http://example.com/categories/%E6%AF%8F%E6%97%A5LeetCode/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"}]},{"title":"(每日LeetCode)1640. 能否连接形成数组","slug":"每日LeetCode/2022-9/1640 能否连接形成数组","date":"2022-09-19T01:48:00.000Z","updated":"2022-09-22T01:34:16.162Z","comments":true,"path":"2022/09/19/每日LeetCode/2022-9/1640 能否连接形成数组/","link":"","permalink":"http://example.com/2022/09/19/%E6%AF%8F%E6%97%A5LeetCode/2022-9/1640%20%E8%83%BD%E5%90%A6%E8%BF%9E%E6%8E%A5%E5%BD%A2%E6%88%90%E6%95%B0%E7%BB%84/","excerpt":"","text":"题目：给你一个整数数组 arr ，数组中的每个整数 互不相同 。另有一个由整数数组构成的数组 pieces，其中的整数也 互不相同 。请你以 任意顺序 连接 pieces 中的数组以形成 arr 。但是，不允许 对每个数组 pieces[i] 中的整数重新排序。 如果可以连接 pieces 中的数组形成 arr ，返回 true ；否则，返回 false 。 示例： 输入：arr &#x3D; [91,4,64,78], pieces &#x3D; [[78],[4,64],[91]]输出：true解释：依次连接 [91]、[4,64] 和 [78] 思路：使用哈希表存储pieces中每个数组的首元素及其该数组的位置 再与arr数组比较： 如果未找到(arr与pieces中的元素都相同)，则说明该元素不是pieces的数组中的首元素，返回false 如果找到，再依次比较后面的元素，如果有不同的元素，返回false 直到遍历完全，没有上述问题，返回true 代码(cpp)：12345678910111213141516171819202122232425class Solution &#123;public: bool canFormArray(vector&lt;int&gt;&amp; arr, vector&lt;vector&lt;int&gt;&gt;&amp; pieces) &#123; unordered_map&lt;int, int&gt; map; for(int i = 0; i &lt; pieces.size(); i++)&#123; map.emplace(pieces[i][0], i); &#125; int i = 0; while(i &lt; arr.size())&#123; auto temp = map.find(arr[i]); if(temp != map.end())&#123; for(int j = 0; j &lt; pieces[temp-&gt;second].size(); j++)&#123; if(arr[i++] != pieces[temp-&gt;second][j])&#123; return false; &#125; &#125; &#125; else &#123; return false; &#125; &#125; return true; &#125;&#125;; 复杂度分析： 时间复杂度：O(n)，其中 n 是数组 arr 的长度。 空间复杂度：O(n)。保存哈希表需要 O(n) 的空间。","categories":[{"name":"每日LeetCode","slug":"每日LeetCode","permalink":"http://example.com/categories/%E6%AF%8F%E6%97%A5LeetCode/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"}]},{"title":"","slug":"Java/手写Spring","date":"2022-09-17T13:54:33.871Z","updated":"2022-09-20T10:27:33.908Z","comments":true,"path":"2022/09/17/Java/手写Spring/","link":"","permalink":"http://example.com/2022/09/17/Java/%E6%89%8B%E5%86%99Spring/","excerpt":"","text":"手写Spring启动和扫描123456@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)public @interface ComponentScan &#123; String value() default &quot;&quot;;&#125; 123456@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)public @interface Component &#123; String value() default &quot;&quot;;&#125; 12345@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)public @interface Scope &#123; public String value() default &quot;&quot;;&#125; 1234567891011121314151617181920212223242526272829public class BeanDefinition &#123; private Class cls; private String scope; public BeanDefinition()&#123; &#125; public BeanDefinition(Class cls, String scope) &#123; this.cls = cls; this.scope = scope; &#125; public Class getCls() &#123; return cls; &#125; public void setCls(Class cls) &#123; this.cls = cls; &#125; public String getScope() &#123; return scope; &#125; public void setScope(String scope) &#123; this.scope = scope; &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667public class MyApplicationContext &#123; private Class ApplicationConfig; private final ConcurrentHashMap&lt;String, Object&gt; beanDefinitionMap = new ConcurrentHashMap&lt;&gt;(); public MyApplicationContext(Class ApplicationConfig) &#123; this.ApplicationConfig = ApplicationConfig; //解析配置类 scan(ApplicationConfig); &#125; //扫描路径中的bean private void scan(Class ApplicationConfig) &#123; //判断是否存在ComponentScan注解 if (!ApplicationConfig.isAnnotationPresent(ComponentScan.class))&#123; throw new RuntimeException(&quot;not found interface ComponentScan&quot;); &#125; //获取ComponentScan注解 ComponentScan componentScan = (ComponentScan) ApplicationConfig.getDeclaredAnnotation(ComponentScan.class); //获取扫描的路径 String path = componentScan.value(); path = path.replace(&quot;.&quot;,&quot;/&quot;); //扫描路径 ClassLoader classLoader = MyApplicationContext.class.getClassLoader(); //app URL resource = classLoader.getResource(path); File file = new File(resource.getFile()); //获取目录 if (file.isDirectory())&#123; //目录是否为空 File[] files = file.listFiles(); //获取目录中的类路径 for (File f : files) &#123; String fileName = f.getAbsolutePath(); //获取类路径字符串 if (fileName.endsWith(&quot;.class&quot;))&#123; //判断是否是类文件 //分割获取指定的路径 String className = fileName.substring(fileName.indexOf(&quot;com&quot;),fileName.indexOf(&quot;.class&quot;)); className = className.replace(&quot;\\\\&quot;, &quot;.&quot;); try &#123; Class&lt;?&gt; cls = classLoader.loadClass(className); //获取到类 //判断是否类中是否有Component注解 if (cls.isAnnotationPresent(Component.class))&#123; //获取Component中的bean名 Component component = cls.getDeclaredAnnotation(Component.class); String beanName = component.value(); BeanDefinition definition = new BeanDefinition(); definition.setCls(cls); //判断是否类中是否有Scope注解 if (cls.isAnnotationPresent(Scope.class))&#123; Scope scope = cls.getDeclaredAnnotation(Scope.class); definition.setScope(scope.value()); &#125; else &#123; definition.setScope(&quot;singleton&quot;); &#125; beanDefinitionMap.put(beanName, definition); &#125; &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; &#125; //TODO public Object getBean(String beanName)&#123; return null;&#125; 手写getBean()123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112public class MyApplicationContext &#123; private Class ApplicationConfig; //单例对象池 private final ConcurrentHashMap&lt;String, Object&gt; singletonObjects = new ConcurrentHashMap&lt;&gt;(); private final ConcurrentHashMap&lt;String, Object&gt; beanDefinitionMap = new ConcurrentHashMap&lt;&gt;(); public MyApplicationContext(Class ApplicationConfig) &#123; this.ApplicationConfig = ApplicationConfig; //解析配置类 scan(ApplicationConfig); //创建出单例bean，多例bean无需创建随用随创 for (String beanName : beanDefinitionMap.keySet()) &#123; BeanDefinition beanDefinition = (BeanDefinition) beanDefinitionMap.get(beanName); if (beanDefinition.getScope().equals(&quot;singleton&quot;)) &#123; Object bean = createBean(beanDefinition); singletonObjects.put(beanName, bean); &#125; &#125; &#125; //通过beanDefinition中的cls创建bean private Object createBean(BeanDefinition beanDefinition)&#123; Class cls = beanDefinition.getCls(); try &#123; Object instance = cls.getDeclaredConstructor().newInstance(); return instance; &#125; catch (InstantiationException e) &#123; e.printStackTrace(); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; catch (InvocationTargetException e) &#123; e.printStackTrace(); &#125; catch (NoSuchMethodException e) &#123; e.printStackTrace(); &#125; return null; &#125; //扫描路径中的bean private void scan(Class ApplicationConfig) &#123; //判断是否存在ComponentScan注解 if (!ApplicationConfig.isAnnotationPresent(ComponentScan.class))&#123; throw new RuntimeException(&quot;not found interface ComponentScan&quot;); &#125; //获取ComponentScan注解 ComponentScan componentScan = (ComponentScan) ApplicationConfig.getDeclaredAnnotation(ComponentScan.class); //获取扫描的路径 String path = componentScan.value(); path = path.replace(&quot;.&quot;,&quot;/&quot;); //扫描路径 ClassLoader classLoader = MyApplicationContext.class.getClassLoader(); //app URL resource = classLoader.getResource(path); File file = new File(resource.getFile()); //获取目录 if (file.isDirectory())&#123; //目录是否为空 File[] files = file.listFiles(); //获取目录中的类路径 for (File f : files) &#123; String fileName = f.getAbsolutePath(); //获取类路径字符串 if (fileName.endsWith(&quot;.class&quot;))&#123; //判断是否是类文件 //分割获取指定的路径 String className = fileName.substring(fileName.indexOf(&quot;com&quot;),fileName.indexOf(&quot;.class&quot;)); className = className.replace(&quot;\\\\&quot;, &quot;.&quot;); try &#123; Class&lt;?&gt; cls = classLoader.loadClass(className); //获取到类 //判断是否类中是否有Component注解 if (cls.isAnnotationPresent(Component.class))&#123; //获取Component中的bean名 Component component = cls.getDeclaredAnnotation(Component.class); String beanName = component.value(); BeanDefinition definition = new BeanDefinition(); definition.setCls(cls); //判断是否类中是否有Scope注解 if (cls.isAnnotationPresent(Scope.class))&#123; Scope scope = cls.getDeclaredAnnotation(Scope.class); definition.setScope(scope.value()); &#125; else &#123; definition.setScope(&quot;singleton&quot;); &#125; beanDefinitionMap.put(beanName, definition); &#125; &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; &#125; //getBean方法 public Object getBean(String beanName)&#123; if (beanDefinitionMap.containsKey(beanName))&#123; BeanDefinition beanDefinition = (BeanDefinition) beanDefinitionMap.get(beanName); if (beanDefinition.getScope().equals(&quot;singleton&quot;))&#123; //如果是单例bean，直接在单例池中取 Object bean = singletonObjects.get(beanName); return bean; &#125;else &#123; //多例bean就创建新的bean对象 Object bean = createBean(beanDefinition); return bean; &#125; &#125;else &#123; throw new RuntimeException(&quot;not found bean&quot;); &#125; &#125;&#125; 测试：配置类： 1234@ComponentScan(&quot;com.mine.service&quot;)public class AppConfig &#123;&#125; 主函数： 1234567891011public class Application &#123; public static void main(String[] args) &#123; MyApplicationContext app = new MyApplicationContext(AppConfig.class); UserService userService = (UserService) app.getBean(&quot;userService&quot;); UserService userService1 = (UserService) app.getBean(&quot;userService&quot;); UserService userService2 = (UserService) app.getBean(&quot;userService&quot;); System.out.println(&quot;userService = &quot; + userService); System.out.println(&quot;userService1 = &quot; + userService1); System.out.println(&quot;userService2 = &quot; + userService2); &#125;&#125; 将UserService设置为单例(默认就为单例)： 123@Component(&quot;userService&quot;)public class UserService &#123;&#125; 运行结果： 123userService2 = com.mine.service.UserService@2e817b38userService1 = com.mine.service.UserService@2e817b38userService3 = com.mine.service.UserService@2e817b38 将UserService设为多例： 12345@Component(&quot;userService&quot;)@Scope(&quot;prototype&quot;)public class UserService &#123;&#125; 运行结果： 123userService2 = com.mine.service.UserService@433c675duserService1 = com.mine.service.UserService@3f91beefuserService3 = com.mine.service.UserService@1a6c5a9e 手写依赖注入123456@Target(&#123;ElementType.METHOD, ElementType.FIELD&#125;)@Retention(RetentionPolicy.RUNTIME)public @interface Autowired &#123; String value() default &quot;&quot;;&#125; 123@Component(&quot;orderService&quot;)public class OrderService &#123;&#125; 12345678910@Component(&quot;userService&quot;)@Scope(&quot;prototype&quot;)public class UserService &#123; @Autowired private OrderService orderService; public void test()&#123; System.out.println(&quot;orderService = &quot; + orderService); &#125;&#125; 在createBean方法中添加： 1234567891011121314151617181920212223242526272829private Object createBean(BeanDefinition beanDefinition)&#123; Class cls = beanDefinition.getCls(); try &#123; Object instance = cls.getDeclaredConstructor().newInstance(); //获取每个字段 for (Field field : cls.getDeclaredFields()) &#123; //判断该字段是否有Autowired注解 if (field.isAnnotationPresent(Autowired.class)) &#123; field.setAccessible(true); //设置可以访问private变量的变量值 Object bean = getBean(field.getName()); //将该字段注入 field.set(instance, bean); &#125; &#125; return instance; &#125; catch (InstantiationException e) &#123; e.printStackTrace(); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; catch (InvocationTargetException e) &#123; e.printStackTrace(); &#125; catch (NoSuchMethodException e) &#123; e.printStackTrace(); &#125; return null; &#125; 测试：12345678public class Application &#123; public static void main(String[] args) &#123; MyApplicationContext app = new MyApplicationContext(AppConfig.class); UserService userService = (UserService) app.getBean(&quot;userService&quot;); System.out.println(&quot;userService = &quot; + userService); userService.test(); &#125;&#125; 运行结果： 12userService = com.mine.service.UserService@179d3b25orderService = com.mine.service.OrderService@254989ff Aware回调123public interface BeanNameAware &#123; void setBeanName(String name);&#125; 实现BeanNameAware的接口 123456789101112131415161718@Component(&quot;userService&quot;)@Scope(&quot;prototype&quot;)public class UserService implements BeanNameAware &#123; @Autowired private OrderService orderService; private String beanName; @Override public void setBeanName(String name) &#123; beanName = name; &#125; public void test()&#123; System.out.println(&quot;orderService = &quot; + orderService); System.out.println(&quot;beanName = &quot; + beanName); &#125;&#125; 需要在createBean添加内容，并添加一个参数(记得把调用的createBean方法也进行修改) 123456789101112131415161718192021222324252627282930313233private Object createBean(String beanName, BeanDefinition beanDefinition)&#123; Class cls = beanDefinition.getCls(); try &#123; Object instance = cls.getDeclaredConstructor().newInstance(); //获取每个字段 for (Field field : cls.getDeclaredFields()) &#123; //判断该字段是否有Autowired注解 if (field.isAnnotationPresent(Autowired.class)) &#123; field.setAccessible(true); //设置可以访问private变量的变量值 Object bean = getBean(field.getName()); //将该字段注入 field.set(instance, bean); &#125; &#125; //Aware回调 if (instance instanceof BeanNameAware) &#123; //判断instance是否实现了BeanNameAware的方法 ((BeanNameAware) instance).setBeanName(beanName); &#125; return instance; &#125; catch (InstantiationException e) &#123; e.printStackTrace(); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; catch (InvocationTargetException e) &#123; e.printStackTrace(); &#125; catch (NoSuchMethodException e) &#123; e.printStackTrace(); &#125; return null; &#125; 测试：12345678public class Application &#123; public static void main(String[] args) &#123; MyApplicationContext app = new MyApplicationContext(AppConfig.class); UserService userService = (UserService) app.getBean(&quot;userService&quot;); System.out.println(&quot;userService = &quot; + userService); userService.test(); &#125;&#125; 运行结果·： 123userService = com.mine.service.UserService@254989fforderService = com.mine.service.OrderService@5d099f62beanName = userService 初始化机制123public interface InitializingBean &#123; void afterPropertiesSet() throws Exception;&#125; 123456789101112131415@Component(&quot;userService&quot;)@Scope(&quot;prototype&quot;)public class UserService implements InitializingBean &#123; @Autowired private OrderService orderService; public void test()&#123; System.out.println(&quot;orderService = &quot; + orderService); &#125; @Override public void afterPropertiesSet() throws Exception &#123; System.out.println(&quot;初始化&quot;); &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142private Object createBean(String beanName, BeanDefinition beanDefinition)&#123; Class cls = beanDefinition.getCls(); try &#123; Object instance = cls.getDeclaredConstructor().newInstance(); //获取每个字段 for (Field field : cls.getDeclaredFields()) &#123; //判断该字段是否有Autowired注解 if (field.isAnnotationPresent(Autowired.class)) &#123; field.setAccessible(true); //设置可以访问private变量的变量值 Object bean = getBean(field.getName()); //将该字段注入 field.set(instance, bean); &#125; &#125; //Aware回调 if (instance instanceof BeanNameAware) &#123; //instance是否实现了BeanNameAware的方法 ((BeanNameAware) instance).setBeanName(beanName); &#125; //初始化 if (instance instanceof InitializingBean) &#123; try &#123; ((InitializingBean) instance).afterPropertiesSet(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; return instance; &#125; catch (InstantiationException e) &#123; e.printStackTrace(); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; catch (InvocationTargetException e) &#123; e.printStackTrace(); &#125; catch (NoSuchMethodException e) &#123; e.printStackTrace(); &#125; return null;&#125; 测试：12345678public class Application &#123; public static void main(String[] args) &#123; MyApplicationContext app = new MyApplicationContext(AppConfig.class); UserService userService = (UserService) app.getBean(&quot;userService&quot;); System.out.println(&quot;userService = &quot; + userService); userService.test(); &#125;&#125; 运行结果： 123初始化userService = com.mine.service.UserService@254989fforderService = com.mine.service.OrderService@5d099f62 手写BeanPostProcessor机制12345public interface BeanPostProcessor &#123; Object postProcessBeforeInitialization(Object bean, String beanName); Object postProcessAfterInitialization(Object bean, String beanName);&#125; 1234567891011121314@Componentpublic class MyBeanPostProcessor implements BeanPostProcessor &#123; @Override public Object postProcessBeforeInitialization(Object bean, String beanName) &#123; System.out.println(&quot;初始化前&quot;+beanName); return bean; &#125; @Override public Object postProcessAfterInitialization(Object bean, String beanName) &#123; System.out.println(&quot;初始化后&quot;+beanName); return bean; &#125;&#125; scan方法中的部分代码，添加判断BeanPostProcessor接口： 12345678910111213141516171819202122232425try &#123; Class&lt;?&gt; cls = classLoader.loadClass(className); //获取到类 if (cls.isAnnotationPresent(Component.class))&#123; //判断是否类中是否有Component注解 //判断是否实现了BeanPostProcessor接口 if(BeanPostProcessor.class.isAssignableFrom(cls)) &#123; BeanPostProcessor beanPostProcessor = (BeanPostProcessor) cls.getDeclaredConstructor().newInstance(); beanPostProcessorList.add(beanPostProcessor); &#125; Component component = cls.getDeclaredAnnotation(Component.class); String beanName = component.value(); BeanDefinition definition = new BeanDefinition(); definition.setCls(cls); if (cls.isAnnotationPresent(Scope.class))&#123; Scope scope = cls.getDeclaredAnnotation(Scope.class); definition.setScope(scope.value()); &#125; else &#123; definition.setScope(&quot;singleton&quot;); &#125; beanDefinitionMap.put(beanName, definition); &#125; &#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950private Object createBean(String beanName, BeanDefinition beanDefinition)&#123; Class cls = beanDefinition.getCls(); try &#123; Object instance = cls.getDeclaredConstructor().newInstance(); //获取每个字段 for (Field field : cls.getDeclaredFields()) &#123; //判断该字段是否有Autowired注解 if (field.isAnnotationPresent(Autowired.class)) &#123; field.setAccessible(true); //设置可以访问private变量的变量值 Object bean = getBean(field.getName()); //将该字段注入 field.set(instance, bean); &#125; &#125; //Aware回调 if (instance instanceof BeanNameAware) &#123; //o是否实现了BeanNameAware的方法 ((BeanNameAware) instance).setBeanName(beanName); &#125; //调用初始化前定义的方法 for (BeanPostProcessor beanPostProcessor : beanPostProcessorList) &#123; instance = beanPostProcessor.postProcessBeforeInitialization(instance, beanName); &#125; //初始化 if (instance instanceof InitializingBean) &#123; try &#123; ((InitializingBean) instance).afterPropertiesSet(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; //调用初始化后定义的方法 for (BeanPostProcessor beanPostProcessor : beanPostProcessorList) &#123; instance = beanPostProcessor.postProcessAfterInitialization(instance, beanName); &#125; return instance; &#125; catch (InstantiationException e) &#123; e.printStackTrace(); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; catch (InvocationTargetException e) &#123; e.printStackTrace(); &#125; catch (NoSuchMethodException e) &#123; e.printStackTrace(); &#125; return null; &#125; 123456public class Application &#123; public static void main(String[] args) &#123; MyApplicationContext app = new MyApplicationContext(AppConfig.class); UserService userService = (UserService) app.getBean(&quot;userService&quot;); &#125;&#125; 运行结果： 123456初始化前初始化后初始化前orderService初始化后orderService初始化前userService初始化后userService 手写Bean生命周期 手写Aop机制","categories":[],"tags":[]},{"title":"","slug":"Java/Java基础","date":"2022-09-17T12:53:05.148Z","updated":"2023-02-01T06:08:48.149Z","comments":true,"path":"2022/09/17/Java/Java基础/","link":"","permalink":"http://example.com/2022/09/17/Java/Java%E5%9F%BA%E7%A1%80/","excerpt":"","text":"注解java中注解分为两种：元注解与自定义注解 元注解：描述注解的注解 自定义注解：开发者自己定义的注解，如Spring框架中@Value、@Autowired等 JDK提供了4个标准的注解： 元注解 作用 @Target 指定注解使用的作用范围(类、方法、字段等) @Retention 指定注解的生命周期(源码、class文件、运行等) @Documented 表示该注解会被javadoc文档记录 @Inherited 表示该注解的子类可以继承父类的注解，只能作用于类上的注解 除了以上4个注解其余都是自定义注解 元注解参数说明： @Target参数 ElementType.METHOD：用于描述方法 ElementType.TYPE：用于描述类、接口(包括注解类型)或enum声明 ElementType.CONSTRUCTOR：用于描述构造器 ElementType.FIELD：成员变量、对象、属性(包括enum实例) ElementType.LOCAL_VARIABLE：用于描述局部变量 ElementType.PACKAGE：用于描述包 ElementType.PARAMETER：用于描述参数 ElementType.ANNOTATION_TYPE:用于描述参数 @Retention参数 RetentionPolicy.RUNTIME：始终不会丢弃，运行期也保留该注解，因此可以使用反射机制读取该注解的信息 RetentionPolicy.SOURCE：在编译阶段丢弃，这些注解在编译结束后就不再有任何意义，所以它们不会写入字节码。如：@Override就属于这类注解 RetentionPolicy.CLASS：在类加载的时候丢弃，在字节码文件的处理中有用，注解默认使用这种方式 自定义注解实现： 需求：需要记录方法的入口参数以及方法的返回参数，以及方法执行的时间 自定义一个@MyLog注解： 123456@Target(ElementType.METHOD)@Retention(RetentionPolicy.RUNTIME)public @interface MyLog &#123; //描述方法 String value() default &quot;&quot;;&#125; ThreadLocal1.简介ThreadLocal叫做线程变量，意思是ThreadLocal中填充的变量属于当前线程，该变量对其他线程而言是隔离的，也就是说该变量是当前线程独有的变量。 ThreadLocal为变量在每个线程中都创建了一个副本，那么每个线程只可以访问自己内部的副本变量。 ThreadLocal 适用于每个线程需要自己独立的实例且该实例需要在多个方法中被使用，即变量在线程间隔离而在方法或类间共享的场景 2.基本使用1234567891011public class test &#123; public static void main(String[] args) &#123; ThreadLocal&lt;String&gt; threadLocal = new ThreadLocal&lt;&gt;(); //设置当前线程的本地变量 threadLocal.set(&quot;ayb&quot;); //获取当前线程的本地变量 String s = threadLocal.get(); //删除当前线程的本地变量 threadLocal.remove(); &#125;&#125; 3.原理分析从ThreadLocal的set()方法看： 1234567891011121314public void set(T value) &#123; //获取当前线程对象 Thread t = Thread.currentThread(); //获取ThreadLocalMap对象 ThreadLocalMap map = getMap(t); //判断ThreadLocalMap对象是否存在 if (map != null) &#123; //存在ThreadLocalMap对象，设置设置key,value，中this为ThreadLocal对象 map.set(this, value); &#125; else &#123; //不存在ThreadLocalMap对象，则创建ThreadLocalMap，并且设置key,value createMap(t, value); &#125;&#125; ThreadLocalMap map = getMap(t)： 12345//ThreadLocal类的getMap()方法ThreadLocalMap getMap(Thread t) &#123; //返回ThreadLocalMap对象 return t.threadLocals;&#125; 先看map.set(this, value)： 1234567891011121314151617181920212223242526//ThreadLocalMap类的set()方法private void set(ThreadLocal&lt;?&gt; key, Object value) &#123; //获取ThreadLocalMap中，私有成员Entry数组table Entry[] tab = table; int len = tab.length; int i = key.threadLocalHashCode &amp; (len-1); //判断是否存在此key for (Entry e = tab[i]; e != null; e = tab[i = nextIndex(i, len)]) &#123; if (e.refersTo(key)) &#123; e.value = value; return; &#125; if (e.refersTo(null)) &#123; replaceStaleEntry(key, value, i); return; &#125; &#125; //将key，value放入Entry数组中，key为ThreadLocal tab[i] = new Entry(key, value); int sz = ++size; if (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold) rehash();&#125; 再看createMap(t, value)： 1234567891011121314151617//ThreadLocal的create()方法void createMap(Thread t, T firstValue) &#123; //实例化ThreadLocalMap对象，保存在Thread对象的threadLocals变量中 //其中this为ThreadLocal对象 t.threadLocals = new ThreadLocalMap(this, firstValue);&#125;//ThreadLocalMap(this, firstValue)的构造函数ThreadLocalMap(ThreadLocal&lt;?&gt; firstKey, Object firstValue) &#123; //初始化table数组 table = new Entry[INITIAL_CAPACITY]; int i = firstKey.threadLocalHashCode &amp; (INITIAL_CAPACITY - 1); //将key， value放入table数组中 table[i] = new Entry(firstKey, firstValue); size = 1; setThreshold(INITIAL_CAPACITY);&#125; Thread、ThreadLocal、ThreadLocalMap的关系： 执行ThreadLocal.set(T value)方法，通过调用ThreadLocal.getMap(Thread t)方法 得到当前线程的ThreadLocalMap对象 如果存在，以此ThreadLocal对象为key以及value，插入到ThreadLocalMap的Entry数组中 如果不存在，则创建ThreadLocalMap对象，以此ThreadLocal对象为key以及value，插入到ThreadLocalMap的Entry数组中","categories":[],"tags":[]},{"title":"(每日LeetCode)1624. 两个相同字符之间的最长子字符串","slug":"每日LeetCode/2022-9/1624 两个相同字符之间的最长子字符串","date":"2022-09-17T01:21:00.000Z","updated":"2022-09-17T01:22:01.274Z","comments":true,"path":"2022/09/17/每日LeetCode/2022-9/1624 两个相同字符之间的最长子字符串/","link":"","permalink":"http://example.com/2022/09/17/%E6%AF%8F%E6%97%A5LeetCode/2022-9/1624%20%E4%B8%A4%E4%B8%AA%E7%9B%B8%E5%90%8C%E5%AD%97%E7%AC%A6%E4%B9%8B%E9%97%B4%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2/","excerpt":"","text":"题目：给你一个字符串 s，请你返回 两个相同字符之间的最长子字符串的长度 ，计算长度时不含这两个字符。如果不存在这样的子字符串，返回 -1 。 子字符串 是字符串中的一个连续字符序列。 示例： 输入：s &#x3D; “abca”输出：2解释：最优的子字符串是 “bc” 。 思路：使用哈希表存放某个字母第一次出现的位置，之后与后面再次出现的字母得到字串长度，最后得到最长的字串长度 代码(cpp)：1234567891011121314151617181920class Solution &#123;public: unordered_map&lt;char, int&gt; map; int maxLengthBetweenEqualCharacters(string s) &#123; int ans = -1; for(int i = 0; i &lt; s.size(); i++)&#123; auto it = map.find(s[i]); if(it == map.end())&#123; map.emplace(s[i], i); &#125; else &#123; int temp = i - 1 - it-&gt;second; ans = max(temp, ans); &#125; &#125; return ans; &#125;&#125;; 复杂度分析： 时间复杂度：O(n)，其中 n 表示字符串的长度。我们只需遍历一遍字符串即可。 空间复杂度：O(∣Σ∣)，其中 Σ 是字符集，在本题中字符集为所有小写字母，∣Σ∣&#x3D;26。","categories":[{"name":"每日LeetCode","slug":"每日LeetCode","permalink":"http://example.com/categories/%E6%AF%8F%E6%97%A5LeetCode/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"}]},{"title":"(每日LeetCode)670. 最大交换","slug":"每日LeetCode/2022-9/670 最大交换","date":"2022-09-13T00:42:00.000Z","updated":"2022-09-13T00:42:46.437Z","comments":true,"path":"2022/09/13/每日LeetCode/2022-9/670 最大交换/","link":"","permalink":"http://example.com/2022/09/13/%E6%AF%8F%E6%97%A5LeetCode/2022-9/670%20%E6%9C%80%E5%A4%A7%E4%BA%A4%E6%8D%A2/","excerpt":"","text":"题目：给定一个非负整数，你至多可以交换一次数字中的任意两位。返回你能得到的最大值。 示例： 输入: 2736输出: 7236解释: 交换数字2和数字7。 思路：遍历先用第一个数字与后面的数字比较，找出最大的并且大于第一个数字，未找到，则用第二个数字与后面的数字比较 依次遍历，直到找到有比所比较的数字大的数字后交换位置，返回交换后的数字 如果遍历完全后，未找到，则说明，此数字已经为最大数，直接返回 代码(cpp)：123456789101112131415161718192021class Solution &#123;public: int maximumSwap(int num) &#123; string str = to_string(num); for(int i = 0; i &lt; str.size(); i++)&#123; int temp = i; for(int j = str.size() - 1; j &gt;= i + 1; j--)&#123; if(str[temp] &lt; str[j])&#123; temp = j; &#125; &#125; if(temp != i)&#123; swap(str[i], str[temp]); int ans = stoi(str); return ans; &#125; &#125; return num; &#125;&#125;; 复杂度分析： 时间复杂度：O(n^2) 空间复杂度：O(n)","categories":[{"name":"每日LeetCode","slug":"每日LeetCode","permalink":"http://example.com/categories/%E6%AF%8F%E6%97%A5LeetCode/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"}]},{"title":"(每日LeetCode)1608. 特殊数组的特征值","slug":"每日LeetCode/2022-9/1608 特殊数组的特征值","date":"2022-09-12T01:12:00.000Z","updated":"2022-09-12T01:12:09.046Z","comments":true,"path":"2022/09/12/每日LeetCode/2022-9/1608 特殊数组的特征值/","link":"","permalink":"http://example.com/2022/09/12/%E6%AF%8F%E6%97%A5LeetCode/2022-9/1608%20%E7%89%B9%E6%AE%8A%E6%95%B0%E7%BB%84%E7%9A%84%E7%89%B9%E5%BE%81%E5%80%BC/","excerpt":"","text":"题目：给你一个非负整数数组 nums 。如果存在一个数 x ，使得 nums 中恰好有 x 个元素 大于或者等于 x ，那么就称 nums 是一个 特殊数组 ，而 x 是该数组的 特征值 。 注意： x 不必 是 nums 的中的元素。 如果数组 nums 是一个 特殊数组 ，请返回它的特征值 x 。否则，返回 -1 。可以证明的是，如果 nums 是特殊数组，那么其特征值 x 是 唯一的 。 示例： 输入：nums &#x3D; [3,5]输出：2解释：有 2 个元素（3 和 5）大于或等于 2 。 代码(cpp)：暴力枚举12345678910111213141516171819class Solution &#123;public: int specialArray(vector&lt;int&gt;&amp; nums) &#123; int size = nums.size(); for(int i = 0; i &lt;= size; i++)&#123; int count = 0; for(int j = 0; j &lt; size; j++)&#123; if(nums[j] &gt;= i)&#123; count++; &#125; &#125; if(count == i)&#123; return i; &#125; &#125; return -1; &#125;&#125;; 思路：降序排序+一次遍历先将nums数组降序排序， 先以x = 0为例：这就说明nums数组中第一个元素以及之后的都要小于x x = 1时：nums数组第一个元素要大于等于x，之后的要小于x x = 2时：nums数组第二个元素要大于等于x(因为是降序所以第一个元素肯定大于x)，之后的要小于x 结论：nums[x-1] &gt;= x并且num[x] &lt; x 代码(cpp)：123456789101112131415161718192021class Solution &#123;public: int specialArray(vector&lt;int&gt;&amp; nums) &#123; int size = nums.size(); //降序排列 sort(nums.begin(), nums.end(), greater&lt;int&gt;()); for(int x = 0; x &lt;= size; x++)&#123; //如果存在nums[x-1] &lt; x的情况，跳出此次遍历，进入下一个 if(x-1 &gt;=0 &amp;&amp; nums[x-1] &lt; x)&#123; break; &#125; //如果num[x] &lt; x，返回x if(x == size || nums[x] &lt; i)&#123; return x; &#125; &#125; return -1; &#125;&#125;; 复杂度分析： 时间复杂度：O(nlogn)，其中 n 是数组 nums 的长度。 空间复杂度：O(logn)，即为排序需要的栈空间。","categories":[{"name":"每日LeetCode","slug":"每日LeetCode","permalink":"http://example.com/categories/%E6%AF%8F%E6%97%A5LeetCode/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"}]},{"title":"(每日LeetCode)1619. 删除某些元素后的数组均值","slug":"每日LeetCode/2022-9/1619 删除某些元素后的数组均值","date":"2022-09-12T01:12:00.000Z","updated":"2022-09-14T02:37:02.282Z","comments":true,"path":"2022/09/12/每日LeetCode/2022-9/1619 删除某些元素后的数组均值/","link":"","permalink":"http://example.com/2022/09/12/%E6%AF%8F%E6%97%A5LeetCode/2022-9/1619%20%E5%88%A0%E9%99%A4%E6%9F%90%E4%BA%9B%E5%85%83%E7%B4%A0%E5%90%8E%E7%9A%84%E6%95%B0%E7%BB%84%E5%9D%87%E5%80%BC/","excerpt":"","text":"题目：给你一个整数数组 arr ，请你删除最小 5% 的数字和最大 5% 的数字后，剩余数字的平均值。 与 标准答案 误差在 10^(-5) 的结果都被视为正确结果。 示例： 输入：arr &#x3D; [1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,3]输出：2.00000解释：删除数组中最大和最小的元素后，所有元素都等于 2，所以平均值为 2 。 思路：将size设为数组的元素个数 将数组排序后，将左边size*0.05个元素删除，并且将右边size*0.05个元素删除 再计算出总和除以size*0.9个元素(删除左右两边各size*0.05个元素，还剩size*0.9个元素) 返回平均数 代码(cpp)：1234567891011121314class Solution &#123;public: double trimMean(vector&lt;int&gt;&amp; arr) &#123; sort(arr.begin(), arr.end()); int size = arr.size(); int temp = int(size * 0.05); int sum = 0; for(int i = temp; i &lt; size - temp; i++)&#123; sum += arr[i]; &#125; double ans = sum / (size*0.9); return ans; &#125;&#125;; 复杂度分析： 时间复杂度：O(nlogn)，其中 n 是数组 arr 的长度。 空间复杂度：O(logn)。排序需要 O(logn) 的栈空间。","categories":[{"name":"每日LeetCode","slug":"每日LeetCode","permalink":"http://example.com/categories/%E6%AF%8F%E6%97%A5LeetCode/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"}]},{"title":"(每日LeetCode)669. 修剪二叉搜索树","slug":"每日LeetCode/2022-9/669 修剪二叉搜索树","date":"2022-09-10T01:35:00.000Z","updated":"2022-09-10T01:35:18.888Z","comments":true,"path":"2022/09/10/每日LeetCode/2022-9/669 修剪二叉搜索树/","link":"","permalink":"http://example.com/2022/09/10/%E6%AF%8F%E6%97%A5LeetCode/2022-9/669%20%E4%BF%AE%E5%89%AA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/","excerpt":"","text":"题目：给你二叉搜索树的根节点 root ，同时给定最小边界low 和最大边界 high。通过修剪二叉搜索树，使得所有节点的值在[low, high]中。修剪树 不应该 改变保留在树中的元素的相对结构 (即，如果没有被移除，原有的父代子代关系都应当保留)。 可以证明，存在 唯一的答案 。 所以结果应当返回修剪好的二叉搜索树的新的根节点。注意，根节点可能会根据给定的边界发生改变。 示例： 输入：root &#x3D; [3,0,4,null,2,null,null,1], low &#x3D; 1, high &#x3D; 3输出：[3,2,null,1] 思路：DFS通过深度优先搜索，找出不符合[low, high]区间的结点，并剔除 二叉平衡树的性质：父节点大于左子树，小于右子树 如果有节点存在，val值小于low值，则说明该节点的左子树，也均小于low值 同理，如果有节点存在，val值大于high值，则说明该节点的右子树，也均大于high值 代码(cpp)：1234567891011121314151617181920class Solution1 &#123;public: TreeNode* trimBST(TreeNode* root, int low, int high) &#123; //找到符合区间的结点 while(root != nullptr)&#123; if(root-&gt;val &lt; low) root = root-&gt;right; else if(root-&gt;val &gt; high) root = root-&gt;left; else break; &#125; //遍历左右子树 if(root != nullptr)&#123; root-&gt;left = trimBST(root-&gt;left, low, high); root-&gt;right = trimBST(root-&gt;right, low, high); &#125; return root; &#125;&#125;; 官方代码(cpp)：12345678910111213141516171819class Solution &#123;public: TreeNode* trimBST(TreeNode* root, int low, int high) &#123; if (root == nullptr) return nullptr; //小于low的情况 if (root-&gt;val &lt; low) //返回该节点的右子树 return trimBST(root-&gt;right, low, high); //大于high的情况 else if (root-&gt;val &gt; high) //返回该节点的左子树 return trimBST(root-&gt;left, low, high); //遍历左右子树 root-&gt;left = trimBST(root-&gt;left, low, high); root-&gt;right = trimBST(root-&gt;right, low, high); return root; &#125;&#125;; 复杂度分析： 时间复杂度：O(n)，其中 n 为二叉树的结点数目。 空间复杂度：O(n)。递归栈最坏情况下需要 O(n) 的空间。","categories":[{"name":"每日LeetCode","slug":"每日LeetCode","permalink":"http://example.com/categories/%E6%AF%8F%E6%97%A5LeetCode/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"}]},{"title":"","slug":"软件安装/Docker安装Nacos","date":"2022-09-09T03:52:41.536Z","updated":"2022-09-12T02:24:30.593Z","comments":true,"path":"2022/09/09/软件安装/Docker安装Nacos/","link":"","permalink":"http://example.com/2022/09/09/%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85/Docker%E5%AE%89%E8%A3%85Nacos/","excerpt":"","text":"1.安装Nacos1.1 搜索Nacos镜像1docker search nacos 1.2 拉取Nacos镜像1docker pull nacos/nacos-server 1.3 启动Nacos容器1234567docker run -id \\--name c_nacos \\-p 8848:8848 \\--privileged=true \\-e MODE=standalone \\-e PREFER_HOST_MODE=hostname \\nacos/nacos-server:latest 参数： --privileged=true：使容器内的root拥有真正的root权限 1.4 测试访问：http://主机地址:8848/nacos/index.html 2.搭建Nacos集群2.1 拉取mysql镜像 1docker pull mysql 2.2 拉取","categories":[],"tags":[]},{"title":"(每日LeetCode)1598. 文件夹操作日志搜集器","slug":"每日LeetCode/2022-9/1598 文件夹操作日志搜集器","date":"2022-09-09T01:07:00.000Z","updated":"2022-09-09T01:07:42.354Z","comments":true,"path":"2022/09/09/每日LeetCode/2022-9/1598 文件夹操作日志搜集器/","link":"","permalink":"http://example.com/2022/09/09/%E6%AF%8F%E6%97%A5LeetCode/2022-9/1598%20%E6%96%87%E4%BB%B6%E5%A4%B9%E6%93%8D%E4%BD%9C%E6%97%A5%E5%BF%97%E6%90%9C%E9%9B%86%E5%99%A8/","excerpt":"","text":"题目：每当用户执行变更文件夹操作时，LeetCode 文件系统都会保存一条日志记录。 下面给出对变更操作的说明： &quot;../&quot; ：移动到当前文件夹的父文件夹。如果已经在主文件夹下，则 继续停留在当前文件夹 。 &quot;./&quot; ：继续停留在当前文件夹。 &quot;x/&quot; ：移动到名为 x 的子文件夹中。题目数据 保证总是存在文件夹 x 。给你一个字符串列表 logs ，其中 logs[i] 是用户在 i^th 步执行的操作。 文件系统启动时位于主文件夹，然后执行 logs 中的操作。 执行完所有变更文件夹操作后，请你找出 返回主文件夹所需的最小步数 。 示例： 输入：logs &#x3D; [“d1&#x2F;“,”d2&#x2F;“,”..&#x2F;“,”d21&#x2F;“,”.&#x2F;“]输出：2解释：执行 “..&#x2F;“ 操作变更文件夹 2 次，即可回到主文件夹 思路：栈模拟代码(cpp)：1234567891011121314151617181920class Solution &#123;public: int minOperations(vector&lt;string&gt;&amp; logs) &#123; stack&lt;string&gt; s; for(auto&amp; log : logs)&#123; if(log == &quot;../&quot;)&#123; if(!s.empty())&#123; s.pop(); &#125; &#125; else if(log == &quot;./&quot;)&#123; continue; &#125; else &#123; s.emplace(log); &#125; &#125; return s.size(); &#125;&#125;; 复杂度分析： 时间复杂度：O(n)，其中 n 字符串数组的长度。只需遍历一遍字符串数组即可。 空间复杂度：O(1)。","categories":[{"name":"每日LeetCode","slug":"每日LeetCode","permalink":"http://example.com/categories/%E6%AF%8F%E6%97%A5LeetCode/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"}]},{"title":"(每日LeetCode)1592. 重新排列单词间的空格","slug":"每日LeetCode/2022-9/1592 重新排列单词间的空格","date":"2022-09-07T02:59:00.000Z","updated":"2022-09-07T02:59:51.599Z","comments":true,"path":"2022/09/07/每日LeetCode/2022-9/1592 重新排列单词间的空格/","link":"","permalink":"http://example.com/2022/09/07/%E6%AF%8F%E6%97%A5LeetCode/2022-9/1592%20%E9%87%8D%E6%96%B0%E6%8E%92%E5%88%97%E5%8D%95%E8%AF%8D%E9%97%B4%E7%9A%84%E7%A9%BA%E6%A0%BC/","excerpt":"","text":"题目：给你一个字符串 text ，该字符串由若干被空格包围的单词组成。每个单词由一个或者多个小写英文字母组成，并且两个单词之间至少存在一个空格。题目测试用例保证 text 至少包含一个单词 。 请你重新排列空格，使每对相邻单词之间的空格数目都 相等 ，并尽可能 最大化 该数目。如果不能重新平均分配所有空格，请 将多余的空格放置在字符串末尾 ，这也意味着返回的字符串应当与原 text 字符串的长度相等。 返回 重新排列空格后的字符串 。 示例： 输入：text &#x3D; “ this is a sentence “输出：”this is a sentence”解释：总共有 9 个空格和 4 个单词。可以将 9 个空格平均分配到相邻单词之间，相邻单词间空格数为：9 &#x2F; (4-1) &#x3D; 3 个。 代码(cpp)：感觉像屎山，不确定我在看看~ 1234567891011121314151617181920212223242526272829303132333435363738394041424344class Solution &#123;public: string reorderSpaces(string text) &#123; vector&lt;string&gt; str; int count = 0; //空格数初始化为0 string temp = &quot;&quot;; //初始化单词为空 for(int i = 0; i &lt; text.size(); i++) &#123; if(text[i] == &#x27; &#x27;) &#123; //如果是空格 //temp不为空，插入str，并将temp置空，获取下一个单词 if(temp != &quot;&quot;)&#123; str.emplace_back(temp); temp = &quot;&quot;; &#125; count++; //空格数加1 &#125; else &#123; //如果不为空格 temp += text[i]; //添加字符 //如果处在text字符串的末尾，直接将temp插入str中 if(i == text.size() - 1)&#123; str.emplace_back(temp); &#125; &#125; &#125; int num = 0; //初始化两个单词之间的空格数为0 if(str.size() &gt; 1)&#123; //获取两个单词之间的空格数 num = count / (str.size()-1); &#125; //拼接字符串 string ans = str[0]; for(int i = 1; i &lt; str.size(); i++)&#123; //拼接 ans += string(num, &#x27; &#x27;) + str[i]; count -= num; //剩余的空格数 &#125; //将剩余的空格加到ans的末尾 ans += string(count, &#x27; &#x27;); return ans; &#125;&#125;;","categories":[{"name":"每日LeetCode","slug":"每日LeetCode","permalink":"http://example.com/categories/%E6%AF%8F%E6%97%A5LeetCode/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"}]},{"title":"(每日LeetCode)652. 寻找重复的子树","slug":"每日LeetCode/2022-9/652 寻找重复的子树","date":"2022-09-05T00:28:00.000Z","updated":"2022-09-05T00:51:43.629Z","comments":true,"path":"2022/09/05/每日LeetCode/2022-9/652 寻找重复的子树/","link":"","permalink":"http://example.com/2022/09/05/%E6%AF%8F%E6%97%A5LeetCode/2022-9/652%20%E5%AF%BB%E6%89%BE%E9%87%8D%E5%A4%8D%E7%9A%84%E5%AD%90%E6%A0%91/","excerpt":"","text":"题目：给定一棵二叉树 root，返回所有重复的子树。 对于同一类的重复子树，你只需要返回其中任意一棵的根结点即可。 如果两棵树具有相同的结构和相同的结点值，则它们是重复的。 示例： 输入：root &#x3D; [2,2,2,3,null,3,null]输出：[[2,3],[3]] 思路：递归通过递归获取每一段的子树的字符串 如果哈希表中不存在此字符串，则插入，存在此字符串，说明此字符串存在重复的子树 代码(cpp)：12345678910111213141516171819202122232425class Solution &#123;public: unordered_set&lt;TreeNode*&gt; set; unordered_map&lt;string, TreeNode*&gt; map; string dfs(TreeNode* node)&#123; if(node == nullptr) return &quot;&quot;; //获取node结点的子树字符串 string str = to_string(node-&gt;val) + &quot;(&quot; + dfs(node-&gt;left) + &quot;)(&quot; + dfs(node-&gt;right) + &quot;)&quot;; //在哈希表中查询 auto temp = map.find(str); if(temp != map.end()) //存在，则插入到set中 set.emplace(temp-&gt;second); else map[str] = node; //不存在，插入到哈希表中 return str; &#125; vector&lt;TreeNode*&gt; findDuplicateSubtrees(TreeNode* root) &#123; dfs(root); //将set中的元素拷贝到vector中 return &#123;set.begin(), set.end()&#125;; &#125;&#125;; 复杂度分析： 时间复杂度：O(n^2)，其中 n 是树中节点的数目。在最坏情况下，树呈现链状的结构，而每一个节点都会在其左右子树序列的基础上再增加最多 99 个字符（两组括号以及节点本身的值），那么所有子树的序列长度之和为 $\\sum_{i&#x3D;1}^n$ 9n &#x3D; O(n^2)。构造出这些序列就需要 O(n^2) 的时间。 空间复杂度：O(n^2)，即为哈希表需要使用的空间。","categories":[{"name":"每日LeetCode","slug":"每日LeetCode","permalink":"http://example.com/categories/%E6%AF%8F%E6%97%A5LeetCode/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"}]},{"title":"(每日LeetCode)1582. 二进制矩阵中的特殊位置","slug":"每日LeetCode/2022-9/1582 二进制矩阵中的特殊位置","date":"2022-09-04T01:21:00.000Z","updated":"2022-09-04T01:21:39.244Z","comments":true,"path":"2022/09/04/每日LeetCode/2022-9/1582 二进制矩阵中的特殊位置/","link":"","permalink":"http://example.com/2022/09/04/%E6%AF%8F%E6%97%A5LeetCode/2022-9/1582%20%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E7%89%B9%E6%AE%8A%E4%BD%8D%E7%BD%AE/","excerpt":"","text":"题目：给你一个大小为 rows x cols 的矩阵 mat，其中 mat[i][j] 是 0 或 1，请返回 矩阵 mat 中特殊位置的数目 。 特殊位置 定义：如果 mat[i][j] &#x3D;&#x3D; 1 并且第 i 行和第 j 列中的所有其他元素均为 0（行和列的下标均 从 0 开始 ），则位置 (i, j) 被称为特殊位置。 示例： 输入：mat &#x3D; [[1,0,0], [0,0,1], [1,0,0]]输出：1解释：(1,2) 是一个特殊位置，因为 mat[1][2] &#x3D;&#x3D; 1 且所处的行和列上所有其他元素都是 0 思路：模拟获取mat数组中的每行i及每列j的1元素的总个数row、column 如果某i行只有一个1元素，某j列也只有一个1元素，并且该行列在mat数组中存在为1 说明mat[i][j]所处的行和列上所有其他元素都是 0 代码(cpp)：1234567891011121314151617181920212223242526class Solution &#123;public: int numSpecial(vector&lt;vector&lt;int&gt;&gt;&amp; mat) &#123; int n = mat.size(); //获取行数 int m = mat[0].size(); //获取列数 vector&lt;int&gt; row(n); vector&lt;int&gt; column(m); for(int i = 0; i &lt; n; i++)&#123; for(int j = 0; j &lt; m; j++)&#123; row[i] += mat[i][j]; //获取每行的1元素的总个数 column[j] += mat[i][j]; //获取每列的1元素的总个数 &#125; &#125; int ans = 0; for(int i = 0; i &lt; n; i++)&#123; for(int j = 0; j &lt; m; j++)&#123; //如果i行只有一个1，j列只有一个1，并且mat数组i行j列为1 if(mat[i][j] == 1 &amp;&amp; row[i] == 1 &amp;&amp; column[j] == 1)&#123; ans++; &#125; &#125; &#125; return ans; &#125;&#125;; 复杂度分析： 时间复杂度：O(m×n)，其中 m 为矩阵 mat 的行数，n 为矩阵 mat 的列数。 空间复杂度：O(m+n)，主要为预处理每一行和列的空间开销。","categories":[{"name":"每日LeetCode","slug":"每日LeetCode","permalink":"http://example.com/categories/%E6%AF%8F%E6%97%A5LeetCode/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"}]},{"title":"C++11的学习笔记","slug":"C++/C++11特性","date":"2022-09-03T03:49:33.141Z","updated":"2022-09-27T14:06:55.074Z","comments":true,"path":"2022/09/03/C++/C++11特性/","link":"","permalink":"http://example.com/2022/09/03/C++/C++11%E7%89%B9%E6%80%A7/","excerpt":"","text":"C++11 简介C++11是对目前C++语言的扩展与修正，C++11不仅包含核心语言的新机能，而且拓展了C++的标准库(STL)，并入了大部分的C++Trehnical Report 1(TR1)程序库。 C++11包括的新特性，包括：lambda表达式、类型推导关键字auto、decltype以及模板的大量改进 1.类型推导1.1 auto在C中，auto修饰局部变量，局部变量也叫auto变量，自动变量 而在C++11中，auto根据用户初始化数据类型自动推导 举例前，需要引入typeinfo： 1#include &lt;typeinfo&gt; 其中下面的函数可返回a的数据类型的字符串形式： 1typeid(a).name(); 1. 1234567891011121314#include&lt;iostream&gt;#include &lt;typeinfo&gt;using namespace std;void main()&#123; int a = 1; auto b = 2; //b的数据类型自动推导为int cout &lt;&lt; typeid(b).name() &lt;&lt; endl; auto c = 2.5; //c的数据类型自动推导为double cout &lt;&lt; typeid(c).name() &lt;&lt; endl;&#125; 运行结果： 12intdouble 2. 123456789101112131415#include&lt;iostream&gt;#include &lt;typeinfo&gt;using namespace std;double fun()&#123; return 1.5;&#125;void main()&#123; auto a = fun(); //c的数据类型根据返回值自动推导为double cout &lt;&lt; typeid(a).name() &lt;&lt; endl;&#125; 运行结果： 1double 3. 12345678910111213141516#include&lt;iostream&gt;#include &lt;typeinfo&gt;using namespace std;struct Test&#123; int a;&#125;;void main()&#123; Test t = &#123; 1 &#125;; //初始化Test结构体 a = 1 auto a = t; // d的数据类型自动推导为Test cout &lt;&lt; typeid(a).name() &lt;&lt; endl;&#125; 运行结果： 1&gt;struct Test 两种遍历方式： 12345678910111213141516171819#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;void fun1(vector&lt;int&gt;&amp; v)&#123; for (auto it = v.begin(); it != v.end(); it++) &#123; cout &lt;&lt; *it &lt;&lt; endl; &#125;&#125;void fun2(vector&lt;int&gt;&amp; v) &#123; for (auto&amp; i : v) &#123; cout &lt;&lt; i &lt;&lt; endl; &#125;&#125; 注意： 使用auto时，数据必须要初始化： 12345void main()&#123; auto a; //报错 a = 10;&#125; vs不支持函数形参是auto变量(部分编译器会支持)： 1234void fun3(auto a) //报错&#123;&#125; 不能作为自定义类型的成员变量： 123456struct Test&#123; int a; auto b; //报错 auto c = 0; //报错&#125;; auto不能作为初始化数组，但是可以赋值： 1234567891011#include&lt;iostream&gt;#include &lt;typeinfo&gt;using namespace std;void main()&#123; //auto a[3] = &#123; 1, 2, 3 &#125;; //报错 int b[3] = &#123; 1, 2, 3 &#125;; auto c = b; cout &lt;&lt; typeid(c).name() &lt;&lt; endl;&#125; 运行结果： 1int * __ptr64 模板实例化不能是auto类型： 1234567void main()&#123; //vector&lt;auto&gt; v1; //报错 //vector&lt;auto&gt; v2 = &#123; 1 &#125;; //报错 vector&lt;int&gt; v3 = &#123; 1 &#125;; auto v4 = v3; //正常&#125; 1.2 decltypedecltype()与auto相反，可以获取a的数据类型，并用做b的数据类型 1decltype(a) b; 1. 12345678910#include&lt;iostream&gt;using namespace std;void main()&#123; int i; //decltype(i)等价于int decltype(i) j = 0; cout &lt;&lt; typeid(j).name() &lt;&lt; endl;&#125; 运行结果： 1int 2. 1234567891011#include&lt;iostream&gt;#include&lt;typeinfo&gt;using namespace std;void main()&#123; float a; double b; decltype(a + b) c; cout &lt;&lt; typeid(c).name() &lt;&lt; endl;&#125; 运行结果： 1&gt;double 3. 1234567891011121314151617#include&lt;iostream&gt;#include&lt;typeinfo&gt;#include&lt;vector&gt;using namespace std;void main()&#123; vector&lt;int&gt; v; decltype(v.begin()) it; //打印迭代器数据类型 cout &lt;&lt; typeid(it).name() &lt;&lt; endl; for (it = v.begin(); it != v.end(); it++) &#123; //数组为空，无打印 cout &lt;&lt; *it &lt;&lt; endl; &#125;&#125; 运行结果： 1&gt;class std::_Vector_iterator&lt;class std::_Vector_val&lt;struct std::_Simple_types&lt;int&gt; &gt; &gt; 匿名数据类型： 1234567891011#include&lt;iostream&gt;#include&lt;typeinfo&gt;using namespace std;void main()&#123; //匿名类型的枚举变量 enum &#123;OK, Error&#125; flag; decltype(flag) flag2; cout &lt;&lt; typeid(flag2).name() &lt;&lt; endl;&#125; 运行结果： 1enum `void __cdecl main(void)&#x27;::`2&#x27;::&lt;unnamed-type-flag&gt; 1.3 跟踪返回类型 正常写函数以及返回值 1234double fun(int a, double b)&#123; return a + b;&#125; 引入auto作为返回值，并指定返回值为double与上面的函数效果等价 1234auto fun1(int a, double b) -&gt; double&#123; return a + b;&#125; 自定义返回值 1234auto fun2(int a, double b) -&gt; decltype(a + b)&#123; return a + b;&#125; 引入模板 12345template&lt;class T1, class T2&gt;auto fun3(T1 a, T2 b) -&gt; decltype(a + b)&#123; return a + b;&#125; 2.易用性改进2.1 类内成员初始化 类中的数据成员在申明时可以直接赋予一个默认值 12345678910111213141516171819202122#include&lt;string&gt;using namespace std;class A&#123;public: A(int a, int b) : a(a),b(b) //参数列表初始化 &#123; &#125; int a = 10; //`=`等号初始化默认值 int b&#123; 20 &#125;; //`&#123;&#125;`大括号初始化默认值 string str1 = &quot;str1&quot;; //`=`等号初始化默认值 //string str2(&quot;str2&quot;); //报错 string str3&#123; &quot;str3&quot; &#125;; //`&#123;&#125;`大括号初始化默认值&#125;;void main()&#123; A a&#123;1&#125;; //通过大括号初始化&#125; 2.2 列表初始化 列表初始化(&#123;&#125;初始化方式) 123456789101112131415161718192021#include&lt;iostream&gt;using namespace std;struct Test&#123; int age; double money; char name[20];&#125;;void main()&#123; Test t = &#123; 18, 64.8, &quot;Tom&quot; &#125;; int a = 1; int b = &#123; 1 &#125;; int c&#123; 1 &#125;; int arr1[] = &#123; 1, 2, 3 &#125;; int arr2[]&#123; 1, 2, 3 &#125;;&#125; 使用列表初始化的方式可以防止类型收窄(隐式转换导致数据丢失) =赋值的情况： 12345678910#include&lt;iostream&gt;using namespace std;void main()&#123; int a = 128; char b = a; cout &lt;&lt; a &lt;&lt; endl; cout &lt;&lt; b &lt;&lt; endl;&#125; 运行结果： 12&gt;128 //为空，数据丢失。c语言中ascii码最多能表示0~127，共128个字符 &#123;&#125;赋值的情况： 1234567void main()&#123; int a = 128; char b&#123; a &#125;; cout &lt;&lt; a &lt;&lt; endl; cout &lt;&lt; b &lt;&lt; endl;&#125; vs运行报错：从“int”转换到“char”需要收缩转换 2.3 for循环 for循环遍历数组 12345678910111213#include&lt;iostream&gt;using namespace std;void main()&#123; int a[] = &#123; 1, 2, 3, 4, 5 &#125;; int size = sizeof(a) / sizeof(*a); //获取元素个数 for (int i = 0; i &lt; size; i++) &#123; cout &lt;&lt; a[i] &lt;&lt; endl; &#125;&#125; 基于范围的for循环 123456789101112#include&lt;iostream&gt;using namespace std;void main()&#123; int a[] = &#123; 1, 2, 3, 4, 5 &#125;; for (auto&amp; temp : a) &#123; cout &lt;&lt; temp &lt;&lt; endl; &#125;&#125; 运行结果： 1234512345 容器范围的for遍历 12345678910111213#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;void main()&#123; vector&lt;int&gt; v = &#123; 1, 2, 3, 4, 5 &#125;; for (auto&amp; temp : v) &#123; cout &lt;&lt; temp &lt;&lt; endl; &#125;&#125; 注意： 容器的范围的for遍历，需要容器含有begin()和end()才可以使用 例如：queue、stack等容器无法使用范围的for遍历 2.4 静态断言C++提供了调试工具assert，这是个宏，用于在运行阶段对断言进行检查，如果条件为true，执行程序，否则调用abort() 使用assert()需要导入： 1#include &lt;cassert&gt; assert()断言： 运行时检查条件 条件应为常量、变量均可 123456789101112#include&lt;iostream&gt;#include &lt;cassert&gt;using namespace std;void main()&#123; bool flag = false; //运行时检查条件，如果为真，继续执行；否则中断程序，报错 assert(flag == true); cout &lt;&lt; &quot;hello assert&quot; &lt;&lt; endl;&#125; 运行报错： 1Assertion failed: flag == true, file E:\\08_静态断言.cpp, line 9 static_assert()静态断言： 编译时检查条件 条件应为常量，编译阶段不会有变量 下面为，检查是否不为64位系统： 12345678910#include&lt;iostream&gt;#include &lt;cassert&gt;using namespace std;void main()&#123; static_assert(sizeof(void*) == 8, &quot;不支持64位系统&quot;); cout &lt;&lt; &quot;hello static_assert&quot; &lt;&lt; endl;&#125; 2.5 noexcept修饰符抛出异常： 1234void fun1()&#123; throw 1; //抛出异常&#125; 不让函数抛出异常： 12345//fun2函数不能抛出任何异常，老式写法，在C++11中被废弃void fun2() throw()&#123;&#125; 注意：此写法，在C++11中被废弃 新写法使用noexcept修饰符 来替代throw() 12345//fun3函数不能抛出任何异常void fun3() noexcept&#123;&#125; 2.6 nullptrnullptr是为了解决C++中NULL的二义性问题从而引进的一种新的类型，NULL实际上代表的是0 重载fun函数： ​ 当调用fun(NULL)时，我们希望它打印的是：fun2 1234567891011121314151617#include&lt;iostream&gt;using namespace std;void fun(int a)&#123; cout &lt;&lt; &quot;fun1&quot; &lt;&lt; endl;&#125;void fun(int* p)&#123; cout &lt;&lt; &quot;fun2&quot; &lt;&lt; endl;&#125;void main()&#123; fun(NULL);&#125; 运行结果： 1fun1 但是，打印的是：fun1； 如果要解决这个二义性，所以就需要使用nullptr： 1234567891011121314151617#include&lt;iostream&gt;using namespace std;void fun(int a)&#123; cout &lt;&lt; &quot;fun1&quot; &lt;&lt; endl;&#125;void fun(int* p)&#123; cout &lt;&lt; &quot;fun2&quot; &lt;&lt; endl;&#125;void main()&#123; fun(nullptr);&#125; 运行结果： 1&gt;fun2 比较NULL和nullptr： 12345678910111213#include&lt;iostream&gt;using namespace std;void main()&#123; int* p1 = NULL; int* p2 = nullptr; if (p1 == p2) &#123; cout &lt;&lt; &quot;p1 = p2&quot; &lt;&lt; endl; &#125;&#125; 运行结果： 1&gt;p1 = p2 证明：NULL和nullptr相等 nullptr不能赋值给普通类型： 1234567void main()&#123; int a = NULL; //正常 //int b = nullptr; //报错 //double c = nullptr; //报错 int* p = nullptr; //正常&#125; 2.7 强类型枚举12345void main()&#123; enum Status1 &#123; Ok, Error &#125;; enum Status2 &#123; Ok, Error &#125;;&#125; 运行报错： 12“main::Ok”: 重定义；以前的定义是“枚举数”“main::Error”: 重定义；以前的定义是“枚举数” 强类型枚举：enum后面加上class或struct修饰，即可： 12345void main()&#123; enum class Status1 &#123; Ok, Error &#125;; enum class Status2 &#123; Ok, Error &#125;;&#125; 运行成功！ 调用时，需要指定枚举类型的作用域： 12345678void main()&#123; enum class Status1 &#123; Ok, Error &#125;; enum class Status2 &#123; Ok, Error &#125;; //Status1 flag = OK; //报错，必须要指定枚举的作用域 Status1 flag = Status1::Ok; //正常&#125; 强枚举类型，并且可以指定成员变量的类型： 12345678void main()&#123; enum class Status1 &#123; Ok, Error &#125;; enum class Status2 : char &#123; Ok, Error &#125;; cout &lt;&lt; sizeof(Status1::Ok) &lt;&lt; endl; //4字节 cout &lt;&lt; sizeof(Status2::Ok) &lt;&lt; endl; //1字节&#125; 运行结果： 12&gt;4&gt;1 2.8 常量表达式常量表达式要在程序编译时执行，普通变量要在程序运行时执行 constexpr：可以将变量或函数在编译阶段初始化 1234567891011121314151617181920212223242526272829#include&lt;iostream&gt;using namespace std;//运行时初始化，非常量int getNum1()&#123; return 2;&#125;//const修饰的常量属于右值//const修饰的形参不是常量const int getNum2()&#123; return 2;&#125;//常量表达式，发生在编译阶段constexpr int getNum3()&#123; return 2;&#125;void main()&#123; // 枚举类型成员初始化，必须是整型常量 //enum &#123;e1 = getNum1(), e2 &#125;; //报错 //enum &#123; e1 = getNum2(), e2 &#125;; //const，报错 enum &#123; e1 = getNum3(), e2 &#125;; //正常 constexpr int temp = getNum3(); //正常，发生在编译阶段 enum &#123; e3 = temp, e4 &#125;; //正常&#125; constexpr的限制： 函数中允许包含typedef、using指令、静态断言 函数必须有返回值 在使用前必须已有定义 return返回语句表达式不能使用非常量表达式的函数、全局函数，且必须是一个常量表达式 总结：运行阶段产生的变量或函数，不要瞎掺和到常量表达式中 2.9 自定义字面量根据C++11标准，只有以下参数才是合法的： char const * unsigned long long long double char const *, size_t wchar const *, size_t char16_t const *, size_t char32_t const *, size_t 123456789101112131415161718192021222324252627#include&lt;iostream&gt;using namespace std;//自定义字面量，起名要求 operator&quot;&quot;XXX//只需要传递第一个参数，第二个参数自动推导出第一个参数的长度并赋值size_t operator&quot;&quot;_len(char const* str, size_t size)&#123; return size;&#125;char const* operator&quot;&quot;_str(char const* str, size_t size)&#123; return str;&#125;char const* operator&quot;&quot;_test(char const* str)&#123; return str;&#125;void main()&#123; cout &lt;&lt; &quot;abc&quot;_len &lt;&lt; endl; //正常 cout &lt;&lt; &quot;abc&quot;_str &lt;&lt; endl; //正常 //cout &lt;&lt; &quot;abc&quot;_test &lt;&lt; endl; //报错 cout &lt;&lt; 123_test &lt;&lt; endl; //正常&#125; 运行结果： 123&gt;3&gt;abc&gt;123 2.10 原生字符串字面值原生字符串字面值：使用户书写的字符串”所见即所得” C++11中使用原生字符串字面值只需要在R&quot;()&quot;括号中写入字符串，即可 123456789101112131415#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;void main()&#123; cout &lt;&lt; R&quot;(Hello ,\\n \\rworld !!!)&quot; &lt;&lt; endl; cout &lt;&lt; &quot;-------------------&quot; &lt;&lt; endl; //也可以赋值给string数据类型 string str = R&quot;(Hello ,\\n \\r)&quot;; cout &lt;&lt; str &lt;&lt; endl;&#125; 运行结果： 12345&gt;Hello ,\\n \\r&gt;world !!!&gt;-------------------&gt;Hello ,\\n \\r 3.类的改进….. 4.模板的改进4.1 右尖括号&gt;在C++98&#x2F;03中，模板实例化时，连续的右尖括号&gt;&gt;会被编译成右移动操作符 需要在两个右尖括号之间添加空格&gt; &gt; 123456789#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;void main()&#123; //vector&lt;vector&lt;int&gt;&gt; v1; //报错 vector&lt;vector&lt;int&gt; &gt; v2; //正常&#125; 在C++11中解决了此问题： 12345678#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;void main()&#123; vector&lt;vector&lt;int&gt;&gt; v //正常&#125; 4.2 类型的别名需要导入一个库来判断数据类型是否相同 1#include&lt;type_traits&gt; is_same判断两个数据类型是否相同，返回值为bool类型： 1is_same&lt;T1, T2&gt;::value 12345678910111213#include&lt;iostream&gt;#include&lt;type_traits&gt;using namespace std;//通过typedef给一个类型起别名，不能新建类型typedef int int32;//C++11起别名方式using my_int = int;void main()&#123; cout &lt;&lt; is_same&lt;int32, my_int&gt;::value &lt;&lt; endl;&#125; 4.3 函数模板的默认模板参数1234567891011121314151617181920212223242526272829#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;//类模板支持默认模板参数//注意：如果有多个类模板参数，默认模板参数要写在**最右边**template&lt;class T = int&gt;class A&#123;public: A(T a) : a(a) &#123;&#125; T a;&#125;;//C++11支持函数模板的默认模板参数template&lt;class T = int&gt;void fun(T t)&#123; &#125;void main()&#123; A&lt;&gt; a(10); //默认为int cout &lt;&lt; a.a &lt;&lt; endl; A&lt;string&gt; b(&quot;abc&quot;); //指定为string cout &lt;&lt; b.a &lt;&lt; endl; fun(10); //传入int fun&lt;string&gt;(&quot;abc&quot;); //传入string&#125; 4.4 可变参数模板函数可变模板函数的声明： 123456789101112131415161718#include&lt;iostream&gt;using namespace std;//下面为可变参数模板函数template&lt;class ... T&gt; //T为模板参数包void fun(T ... args) //args为函数参数包&#123; //获取可变参数个数 cout &lt;&lt; sizeof ... (args) &lt;&lt; endl;&#125;void main()&#123; fun&lt;int&gt;(10); fun&lt;int, string&gt;(10, &quot;abc&quot;); fun&lt;int, string, char&gt;(10, &quot;abc&quot;, &#x27;a&#x27;); fun(1, 1, 1, 1); //不指定数据类型也可以&#125; 运行结果： 1234&gt;1&gt;2&gt;3&gt;4 参数包的展开 递归的方式展开： 12345678910111213141516171819202122#include&lt;iostream&gt;using namespace std;//递归终止函数，当参数列表遍历完后，调用此重载函数结束递归//本质就是重载函数void fun()&#123; cout &lt;&lt; &quot;参数已为空&quot; &lt;&lt; endl;&#125;template&lt;class T1, class ... T2&gt;void fun(T1 first, T2 ... last)&#123; cout &lt;&lt; first &lt;&lt; endl; fun(last ...);&#125;void main()&#123; fun(1, 2.5, 3, &quot;abc&quot;, &#x27;a&#x27;);&#125; 运行结果： 123456&gt;1&gt;2.5&gt;3&gt;abc&gt;a&gt;参数已为空 非递归的方式展开： 123456789101112131415161718192021#include&lt;iostream&gt;using namespace std;template&lt;class T&gt;void print(T t)&#123; cout &lt;&lt; t &lt;&lt; endl;&#125;template&lt;class ... T&gt;void fun(T ... args)&#123; //逗号运算符 //初始化列表 int a[] = &#123; (print(args), 0) ... &#125;;&#125;void main()&#123; fun(1, 2.5, &quot;abc&quot;, &#x27;a&#x27;);&#125; 运行结果： 1234&gt;1&gt;2.5&gt;abc&gt;a 4.5 可变参数模板类继承的方式展开参数模板类 类模板继承方式展开参数包： 12345678910111213141516171819202122232425262728#include&lt;iostream&gt;#include&lt;typeinfo&gt;using namespace std;//可变参数模板的声明，必须要声明template &lt;class ... T&gt;class Car; //主模板的声明中不允许使用模板参数列表&lt; &gt;//递归继承模板类template&lt;class Head, class ... Tail&gt;class Car&lt;Head, Tail ...&gt; : public Car&lt;Tail ...&gt;&#123;public: Car() &#123; cout &lt;&lt; typeid(Head).name() &lt;&lt; endl; &#125;&#125;;//递归终止类template&lt;&gt; class Car&lt;&gt;&#123; &#125;;void main()&#123; //初始化Car Car&lt;int, double, string, char&gt; c;&#125; 运行结果： 1234&gt;char&gt;class std::basic_string&lt;char,struct std::char_traits&lt;char&gt;,class std::allocator&lt;char&gt; &gt;&gt;double&gt;int 类模板递归和特化方式展开参数包 下面的是获得相加的数据类型的字节总数： 123456789101112131415161718192021222324//可变参数模板的声明template&lt;class ... T&gt;class Add;//可变参数模板的定义template&lt;class first, class ... last&gt;class Add&lt;first, last ...&gt;&#123;public: static const int val = Add&lt;first&gt;::val + Add&lt;last ...&gt;::val;&#125;;//边界条件，递归终止条件template&lt;class first&gt;class Add&lt;first&gt;&#123;public: static const int val = sizeof(first);&#125;;void main()&#123; cout &lt;&lt; Add&lt;int&gt;::val &lt;&lt; endl; //int类型字节为4 cout &lt;&lt; Add&lt;double&gt;::val &lt;&lt; endl; //double类型字节为8 cout &lt;&lt; Add&lt;int, int, double&gt;::val &lt;&lt; endl; //int+int+double字节数为16 &#125; 运行结果： 123&gt;4&gt;8&gt;16 也可以指定数据类型： 指定数据类型为int，并获得他们的之间相乘的总和： 1234567891011121314151617181920212223242526272829#include&lt;iostream&gt;#include&lt;typeinfo&gt;using namespace std;//可变参数模板的声明//并指定为int类型template&lt;int ... T&gt;class Mul;//可变参数模板的定义template&lt;int first, int ... last&gt;class Mul&lt;first, last ...&gt;&#123;public: static const int val = first * Mul&lt;last ...&gt;::val;&#125;;//边界条件，递归终止条件template&lt;&gt;class Mul&lt;&gt;&#123;public: static const int val = 1;&#125;;void main()&#123; cout &lt;&lt; Mul&lt;2&gt;::val &lt;&lt; endl; //2*1 cout &lt;&lt; Mul&lt;2, 2&gt;::val &lt;&lt; endl; //2*2 cout &lt;&lt; Mul&lt;3, 3, 3&gt;::val &lt;&lt; endl; //3*3*3&#125; 运行结果： 123&gt;2&gt;4&gt;27 5.左值、右值5.1 左值、右值引用左值引用： 1234567891011121314151617void main1()&#123; //引用&amp;：给一个内存起别名，定义时必须初始化 int a; const int temp = 1; int t1 = 1; int t2 = 2; int&amp; b = a; //正常 //int&amp; c = 1; //报错，非常量引用的初始值必须为左值 //int&amp; d = t1 + t2; //报错，非常量引用的初始值必须为左值 //const int&amp; 万能引用 const int&amp; e = a; //正常 const int&amp; f = 1; //正常 const int&amp; t = temp; //正常&#125; 右值引用： 1234567891011void main()&#123; //右值引用 int&amp;&amp; a = 10; //正常 int&amp;&amp; b = fun(); //正常 int t1 = 1; int t2 = 1; //int&amp;&amp; c = t1; //报错，无法将右值引用绑定到左值 int&amp;&amp; d = t1 + t2; //正常&#125; 左值、右值判断： 123456789101112131415161718192021222324#include&lt;iostream&gt;using namespace std;//通过重载函数的特点，来进行判断void test(int&amp; left)&#123; cout &lt;&lt; &quot;左值&quot; &lt;&lt; endl;&#125;void test(int&amp;&amp; right)&#123; cout &lt;&lt; &quot;右值&quot; &lt;&lt; endl;&#125;void main()&#123; int a = 1; int b = 1; int&amp;&amp; c = 1; test(a); //左值 test(1); //右值 test(a + b); //右值 test(c); //左值&#125; 运行结果： 1234&gt;左值&gt;右值&gt;右值&gt;左值 5.2 返回值优化…… 6.移动语义…… 6.3 std::move123456789#include&lt;iostream&gt;using namespace std;void main()&#123; int a = 10; //int&amp;&amp; b = a; //报错，左值不能绑定到右值引用 int&amp;&amp; c = move(a); //正常，move将左值转化为右值&#125; 6.4 std::forward当我们需要将一组参数原封不动的传递给里一个函数时： 12345678910111213141516171819202122232425262728293031323334#include&lt;iostream&gt;using namespace std;template&lt;class T&gt;void fun(const T&amp; t)&#123; cout &lt;&lt; &quot;fun(const T&amp; t) &quot; &lt;&lt; endl;&#125;template&lt;class T&gt;void fun(T&amp; t)&#123; cout &lt;&lt; &quot;fun(T&amp; t) &quot; &lt;&lt; endl;&#125;template&lt;class T&gt;void forwardVal(const T&amp; t)&#123; fun(t);&#125;template&lt;class T&gt;void forwardVal(T&amp; t)&#123; fun(t);&#125;void main()&#123; int a = 0; const int b = 1; forwardVal(a); forwardVal(b);&#125; 运行结果： 12&gt;fun(T&amp; t)&gt;fun(const T&amp; t) 使用std::forward函数，实现完美转发： 12345678910111213141516171819202122232425262728293031323334template&lt;class T&gt;void fun(const T&amp; t)&#123; cout &lt;&lt; &quot;fun(const T&amp; t) &quot; &lt;&lt; endl;&#125;template&lt;class T&gt;void fun(T&amp; t)&#123; cout &lt;&lt; &quot;fun(T&amp; t) &quot; &lt;&lt; endl;&#125;template&lt;class T&gt;void fun(const T&amp;&amp; t)&#123; cout &lt;&lt; &quot;fun(const T&amp;&amp; t) &quot; &lt;&lt; endl;&#125;//只需定义一个函数，无需重载函数template&lt;class T&gt;void forwardVal(T&amp;&amp; t)&#123; //forward保存参数的左值、右值属性 fun(forward&lt;T&gt;(t));&#125;void main()&#123; int a = 1; const int b = 2; forwardVal(a); forwardVal(b); forwardVal(10);&#125; 运行结果： 123&gt;fun(T&amp; t)&gt;fun(const T&amp; t)&gt;fun(const T&amp;&amp; t) 7.智能指针7.1 unique_ptr12345678910111213141516#include&lt;iostream&gt;#include&lt;memory&gt; //智能指针头文件using namespace std;void main()&#123; //智能指针无需释放，自动释放 unique_ptr&lt;int&gt; ptr(new int(10)); cout &lt;&lt; *ptr &lt;&lt; endl; //重载了operator*() cout &lt;&lt; ptr &lt;&lt; endl; //可以人为指定释放堆区空间 //ptr = nullptr; //正常 //ptr = NULL; //正常 ptr.reset(); //正常&#125; 1234567891011121314151617#include&lt;iostream&gt;#include&lt;memory&gt; //智能指针头文件using namespace std;void main()&#123; unique_ptr&lt;int&gt; ptr1(new int(10)); //报错，禁用拷贝构造 //unique_ptr&lt;int&gt; ptr2 = ptr; //int* p = ptr //报错 //将ptr1使用权(指向的内存)交给ptr3，ptr1不能再操作堆区内存了 unique_ptr&lt;int&gt; ptr3 = move(ptr1); //cout &lt;&lt; *ptr1 &lt;&lt; endl; //报错 cout &lt;&lt; *ptr3 &lt;&lt; endl; //正常&#125; 1234567891011121314#include&lt;iostream&gt;#include&lt;memory&gt; //智能指针头文件using namespace std;void main()&#123; unique_ptr&lt;int&gt; ptr(new int(10)); //无参，作用为显式释放堆区内存 //ptr.reset(); //有参，先释放堆区内存，再重新绑定一个新堆区内存 ptr.reset(new int(20));&#125; 1234567891011121314151617#include&lt;iostream&gt;#include&lt;memory&gt; //智能指针头文件using namespace std;void main()&#123; unique_ptr&lt;int&gt; ptr(new int(10)); //释放ptr对堆区内存的控制权但是不释放堆区的内存，并将控制权交给指针p int* p = ptr.release(); //cout &lt;&lt; *ptr &lt;&lt; endl; //报错 cout &lt;&lt; *p &lt;&lt; endl; //正常 //需要人为将p指针的堆区释放 delete p;&#125; 7.2 shared_ptrshared_ptr允许多个智能指针共享并拥有同一个堆区分配对象的内存。通过引用计数实现，会记录有多少个shared_ptr共同指向同一个对象，如果最后一个共享指针被销毁，也就是对某个引用对象的计数变为0时，自动释放此内存。 123456789101112131415161718192021222324#include&lt;iostream&gt;#include&lt;memory&gt;using namespace std;void main()&#123; //shared_ptr也会自动释放堆区空间 shared_ptr&lt;int&gt; ptr1(new int(10)); //拷贝构造，此时有2个对象和堆区内存绑定 shared_ptr&lt;int&gt; ptr2 = ptr1; //正常 //打印ptr1与ptr2的地址 cout &lt;&lt; ptr1 &lt;&lt; endl; cout &lt;&lt; ptr2 &lt;&lt; endl; //计数器，获取与堆区绑定的对象的个数 cout &lt;&lt; ptr1.use_count() &lt;&lt; endl; //2 //释放ptr1对象，计数器减1，不会释放堆区内存 ptr1.reset(); cout &lt;&lt; ptr2.use_count() &lt;&lt; endl; //1 //当计数器为0时，才会释放堆区空间 ptr2.reset();&#125; 运行结果： 1234&gt;0000026C3E3E6CA0&gt;0000026C3E3E6CA0&gt;2&gt;1 7.3 weak_ptrweak_ptr是为配合 shared_ptr 而引入的一种智能指针来协助 shared_ptr 工作，它可以从一个shared_ptr 或另一个 weak_ptr 对象构造，它的构造和析构不会引起引用计数的增加或减少。没有重载 * 和-&gt;但可以使用 lock 获得一个可用的 shared_ptr 对象。 weak_ptr 的使用更为复杂一点，它可以指向 shared_ptr 指针指向的对象内存，却并不拥有该内存，而使用 weak_ptr 成员lock，则可返回其指向内存的一个 share_ptr 对象，且在所指对象内存己经无效时，返回指针空值 nullptr。 12345678910111213141516171819202122232425262728293031323334#include&lt;iostream&gt;#include&lt;memory&gt;using namespace std;void main()&#123; shared_ptr&lt;int&gt; ptr1(new int(10)); shared_ptr&lt;int&gt; ptr2 = ptr1; //2个对象绑定堆区空间 //weak_ptr不和堆区空间绑定，可以通过lock函数获取shared_ptr的对象 weak_ptr&lt;int&gt; ptr3 = ptr1; cout &lt;&lt; ptr1.use_count() &lt;&lt; endl; //打印计数器 cout &lt;&lt; ptr3.use_count() &lt;&lt; endl; //打印计数器 cout &lt;&lt; &quot;----------------&quot; &lt;&lt; endl; //通过lock函数获取shared_ptr的对象 shared_ptr&lt;int&gt; ptr4 = ptr3.lock(); //3个对象绑定堆区空间 cout &lt;&lt; ptr1.use_count() &lt;&lt; endl; //打印计数器 cout &lt;&lt; ptr3.use_count() &lt;&lt; endl; //打印计数器 cout &lt;&lt; *ptr1 &lt;&lt; &quot;,&quot; &lt;&lt; *ptr2 &lt;&lt; &quot;,&quot; &lt;&lt; *ptr4 &lt;&lt; endl; //正常 //cout &lt;&lt; *ptr3 &lt;&lt; endll; //报错，没有重载*和-&gt; //释放所有shared_ptr对象 ptr1.reset(); ptr2.reset(); ptr4.reset(); shared_ptr&lt;int&gt; temp = ptr3.lock(); if (temp == nullptr) &#123; cout &lt;&lt; &quot;temp为空，已经释放了堆区空间！&quot; &lt;&lt; endl; &#125;&#125; 运行结果： 1234567&gt;2&gt;2&gt;----------------&gt;3&gt;3&gt;10,10,10&gt;temp为空，已经释放了堆区空间！ 8.闭包的实现8.1 闭包是什么闭包有很多种定义，一种说法是，闭包是带有上下文的函数。说白了，就是有状态的函数，更直接一些，不就是个类吗？换了个名字化 。 一个函数，带上了一个状态，就变成了闭包了。那什么叫“带上状态，呢？意思是这个闭包有属于自己的变量，这些个变量的值是创建闭包的时候设置的，并在调用闭包的时候，可以访问这些变量。 函数是代码，状态是一组变量，将代码和一组变量捆绑(bind)，就形成了闭包。 闭包的状态㧢绑，必须发生在运行时。 8.2 仿函数：重载operator()C++11之前就已经支持 比较大小： 123456789101112131415161718#include&lt;iostream&gt;using namespace std;//仿函数：重载operator()class Compare&#123;public: //如果val1小于val2,则返回真，否则返回假 bool operator()(int val1, int val2) &#123; return val1 &lt; val2; &#125;&#125;;void main()&#123; cout &lt;&lt; Compare()(11, 12) &lt;&lt; endl;&#125; 运行结果： 1&gt;1 8.3 std::function在C++中，可调用实体主要包括：函数、函数指针、函数引用、可以隐式转换为函数指定的对系，或者实现了 opetator()的对象。 C++11中，新增加了一个 std::function 类模板，它是对 C++中现有的可调用实体的一种类型安全的包装。通过指定它的模板参数，它可以用统一的方式处理函数、函数对象、函数指针，并允许保存和延迟执行它们。 12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;iostream&gt;#include&lt;functional&gt; //std::functionusing namespace std;//普通函数void fun()&#123; //__func__：返回函数名 cout &lt;&lt; __func__ &lt;&lt; endl;&#125;//类中静态函数class Test&#123;public: static int testFun(int a) &#123; cout &lt;&lt; __func__ &lt;&lt; endl; return a; &#125;&#125;;//类中仿函数class MyFun&#123;public: int operator()(int a) &#123; cout &lt;&lt; __func__ &lt;&lt; endl; return a; &#125;&#125;;void main()&#123; //绑定普通函数 function&lt;void()&gt; f1 = fun; f1(); //绑定类中的静态函数 function&lt;int(int)&gt; f2 = Test::testFun; cout &lt;&lt; f2(100) &lt;&lt; endl; //绑定类中的仿函数，绑定对象 function&lt;int(int)&gt; f3 = MyFun(); cout &lt;&lt; f3(30) &lt;&lt; endl;&#125; 运行结果： 12345&gt;fun&gt;testFun&gt;100&gt;operator ()&gt;30 std:function对象最大的用处就是在实现函数回调，使用者需要注忘，它不能被用来检查相等或者不相等，但是可以与 NULL 或者nullptr 进行比较。 8.4 std::bindstd:bind 是这样一种机制，它可以预先把指定可调用实体的某些参数鄉定到己有的变量，产生一个新的可调用实体，这种机制在 回调函数 的使用过程中也频为有用。 C++98中，有两个两数bindlst 和bind2nd，它们分别可以用来绑定 functor 的第一个和第二个参数，它们都是只可以绑定一个参数，各种限制，使得 bind1st 和 bind2nd 的可用性大大降低。 在C++11中，提供了std:bind， 它鄉定的参数的个数不受限制，绑定的具体哪些参数也不受限制，由用户指定，这个bind 才是真正意义上的绑定。 123456789101112131415161718192021222324252627282930#include&lt;iostream&gt;#include&lt;functional&gt; //std::bindusing namespace std;void fun(int x, int y)&#123; cout &lt;&lt; x &lt;&lt; &quot; &quot; &lt;&lt; y &lt;&lt; endl;&#125;void main()&#123; bind(fun, 1, 2)(); //输出1 2 //std::placeholders::_1 表示函数调用，第1个参数替换 //std::placeholders::_2 表示函数调用，第2个参数替换 //std::placeholders::_3 表示函数调用，第3个参数替换 bind(fun, placeholders::_1, placeholders::_2)(5, 10); //输出5 10 //简化写法 using namespace std::placeholders; //将第1个参数与_1替换 bind(fun, 5, _1)(2, 4, 10); //输出5 2 //将第2个参数与_2替换 bind(fun, 5, _2)(2, 4, 10); //输出5 4 //第1个参数与第一个参数互换 bind(fun, _2, _1)(2, 4, 10); //输出4 2 //bind(fun, _2, 10)(20); //报错，不存咋第2个参数&#125; 运行结果： 12345&gt;1 2&gt;5 10&gt;5 2&gt;5 4&gt;4 2 8.5 function结合bind12345678910111213141516171819202122232425262728#include&lt;iostream&gt;#include&lt;functional&gt;using namespace std;using namespace std::placeholders;class Test&#123;public: int a; void fun(int x, int y) &#123; cout &lt;&lt; x &lt;&lt; &quot; &quot; &lt;&lt; y &lt;&lt; endl; &#125;&#125;;void main()&#123; Test test; //创建对象 //绑定成员函数 function&lt;void(int, int)&gt; f1 = bind(&amp;Test::fun, &amp;test, _1, _2); f1(1, 2); //test.fun(1, 2) //绑定成员变量 function&lt;int&amp; ()&gt; f2 = bind(&amp;Test::a, &amp;test); f2() = 12; //test.a = 12; cout &lt;&lt; test.a &lt;&lt; endl;&#125; 运行结果： 12&gt;1 2&gt;12 8.6 lambda表达式lambda表达式的基本格式： 1234[]()&#123; &#125; 基础语法： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include&lt;iostream&gt;using namespace std;//[]中只能捕获全局变量与同一作用域的变量void main()&#123; auto f1 = []() &#123;&#125;; int a = 1; int b = 2; cout &lt;&lt; &quot;f2-------------&quot; &lt;&lt; endl; //a、b以值传递方式 auto f2 = [a, b]() &#123; cout &lt;&lt; a &lt;&lt; &quot; &quot; &lt;&lt; b &lt;&lt; endl; &#125;; f2(); cout &lt;&lt; &quot;f3-------------&quot; &lt;&lt; endl; //添加x、y参数 auto f3 = [a, b](int x, int y) &#123; cout &lt;&lt; a &lt;&lt; &quot; &quot; &lt;&lt; b &lt;&lt; endl; cout &lt;&lt; &quot;x=&quot; &lt;&lt; x &lt;&lt; &quot;,y=&quot; &lt;&lt; y &lt;&lt; endl; &#125;; f3(3, 6); cout &lt;&lt; &quot;f4-------------&quot; &lt;&lt; endl; //=：以值传递的方式捕获外面的变量 auto f4 = [=]() &#123; f3(4, 8); cout &lt;&lt; a &lt;&lt; &quot; &quot; &lt;&lt; b &lt;&lt; endl; &#125;; f4(); cout &lt;&lt; &quot;f5-------------&quot; &lt;&lt; endl; //&amp;：以引用的方式捕获外面的变量 auto f5 = [&amp;]() &#123; f3(5, 10); cout &lt;&lt; a &lt;&lt; &quot; &quot; &lt;&lt; b &lt;&lt; endl; &#125;; f5(); cout &lt;&lt; &quot;f6-------------&quot; &lt;&lt; endl; //a为值传递，其余为引用 auto f6 = [&amp;, a]() &#123; f3(6, 12); cout &lt;&lt; a &lt;&lt; &quot; &quot; &lt;&lt; b &lt;&lt; endl; &#125;; f6(); cout &lt;&lt; &quot;f7-------------&quot; &lt;&lt; endl; //a为引用，其余为值传递 auto f7 = [=, &amp;a]() &#123; f3(7, 14); cout &lt;&lt; a &lt;&lt; &quot; &quot; &lt;&lt; b &lt;&lt; endl; &#125;; f7(); //默认情况下，lambda表达式以const修饰函数体 //添加mutable，就可以修改了 auto f8 = [=]() mutable &#123; //不加mutable会报错，无法修改 a++; //正常 &#125;;&#125; 运行结果： 1234567891011121314151617181920&gt;1 2&gt;f3-------------&gt;1 2&gt;x=3,y=6&gt;f4-------------&gt;1 2&gt;x=4,y=8&gt;1 2&gt;f5-------------&gt;1 2&gt;x=5,y=10&gt;1 2&gt;f6-------------&gt;1 2&gt;x=6,y=12&gt;1 2&gt;f7-------------&gt;1 2&gt;x=7,y=14&gt;1 2 类和全局变量： 12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;iostream&gt;using namespace std;int globality = 10;class Test&#123;public: int i = 10; void testFun() &#123; int a = 5; cout &lt;&lt; __func__ &lt;&lt; endl; auto f1 = [=]() &#123; cout &lt;&lt; i &lt;&lt; endl; //正常 cout &lt;&lt; globality &lt;&lt; endl; //正常 &#125;; auto f2 = [&amp;]() &#123; cout &lt;&lt; i &lt;&lt; endl; //正常 cout &lt;&lt; globality &lt;&lt; endl; //正常 &#125;; //只能捕获类成员变量和全局变量，不能捕获局部变量 auto f3 = [this]() &#123; cout &lt;&lt; i &lt;&lt; endl; //正常 cout &lt;&lt; globality &lt;&lt; endl; //正常 //cout &lt;&lt; a &lt;&lt; endl; //报错 &#125;; &#125;&#125;;//[]中只能捕获全局变量与同一作用域的变量void main()&#123; auto f1 = [=]() &#123; cout &lt;&lt; globality &lt;&lt; endl; &#125;; f1();&#125; 8.7 值传递与引用捕获参数的区别12345678910111213141516171819202122232425#include&lt;iostream&gt;using namespace std;void main()&#123; int a = 1; auto f1 = [=]() mutable &#123; a++; cout &lt;&lt; a &lt;&lt; endl; //a = 2; &#125;; f1(); cout &lt;&lt; a &lt;&lt; endl; //a = 1; cout &lt;&lt; &quot;-----------&quot; &lt;&lt; endl; int b = 1; auto f2 = [&amp;]() mutable &#123; b++; cout &lt;&lt; b &lt;&lt; endl; //b = 2; &#125;; f2(); cout &lt;&lt; b &lt;&lt; endl; //b = 2;&#125; 运行结果： 12345&gt;2&gt;1&gt;-----------&gt;2&gt;2 8.8 lambda表达式与仿函数事实上，仿函数是编译器实现lambda 的一种方式，通过编译器都是把lambda表达式转化为一个仿函数对象。 因此，在C++11中，lambda 可以视为仿函数的一种等价形式。 1234567891011121314151617181920212223242526272829303132#include&lt;iostream&gt;using namespace std;class MyFun&#123;private: int a;public: MyFun(int a) &#123; this-&gt;a = a; &#125; int operator()(int val) &#123; return this-&gt;a + val; &#125;&#125;;void main()&#123; int a = 10; //仿函数 cout &lt;&lt; MyFun(a)(20) &lt;&lt; endl; //lambda表达式 auto f = [=](int val) &#123; return a + val; &#125;; cout &lt;&lt; f(20) &lt;&lt; endl;;&#125; 8.9 lambda表达式类型1234567891011121314151617181920212223#include&lt;iostream&gt;#include&lt;functional&gt;using namespace std;using namespace std::placeholders;void main()&#123; function&lt;int(int)&gt; f1 = [](int x) &#123;return x + 1; &#125;; cout &lt;&lt; f1(1) &lt;&lt; endl; //2 function&lt;int(int)&gt; f2 = bind([](int x) &#123;return x + 1; &#125;, _1); cout &lt;&lt; f2(2) &lt;&lt; endl; //3 auto f3 = [](int x, int y) -&gt;int &#123;return x + y; &#125;; auto f4 = [=](int x, int y) -&gt;int &#123;return x + y; &#125;; //定义一个FUN_PTR函数指针，参数列表为两个int，返回值为int typedef int (*FUN_PTR)(int, int); FUN_PTR p1 = f3; //正常，lambda表达式可以转化为函数指针 //FUN_PTR p2 = f4; //报错，lambda表达式转化为函数指针不允许捕获变量 cout&lt;&lt; p1(1, 2) &lt;&lt; endl; //3&#125; 运行结果： 123233 8.10 lambda的优势传统筛选出大于5的数： 12345678910111213141516171819202122232425262728293031323334#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;vector&lt;int&gt; arr;vector&lt;int&gt; largeNums; //筛选出大于5的数void print(const vector&lt;int&gt;&amp; v)&#123; for (auto&amp; i : v) &#123; cout &lt;&lt; i &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl;&#125;void main()&#123; for (int i = 0; i &lt; 10; i++) &#123; arr.emplace_back(i); &#125; int temp = 5; //传统操作 for (auto&amp; a : arr) &#123; if (a &gt; temp) &#123; largeNums.emplace_back(a); &#125; &#125; print(largeNums);&#125; 回调函数： 12345678910111213141516171819202122232425262728293031323334#include&lt;iostream&gt;#include&lt;algorithm&gt; //std::for_each#include&lt;vector&gt;using namespace std;vector&lt;int&gt; arr;vector&lt;int&gt; largeNums; //筛选出大于5的数int temp = 5;void fun(int&amp; n)&#123; if (n &gt; temp) &#123; largeNums.emplace_back(n); &#125;&#125;void print(int&amp; n)&#123; cout &lt;&lt; n &lt;&lt; &quot; &quot;;&#125;void main()&#123; for (int i = 0; i &lt; 10; i++) &#123; arr.emplace_back(i); &#125; //筛选 for_each(arr.begin(), arr.end(), fun); //遍历 for_each(largeNums.begin(), largeNums.end(), print);&#125; lambda表达式： 123456789101112131415161718192021222324252627#include&lt;iostream&gt;#include&lt;algorithm&gt; //std::for_each#include&lt;vector&gt;using namespace std;vector&lt;int&gt; arr;vector&lt;int&gt; largeNums; //筛选出大于5的数void main()&#123; for (int i = 0; i &lt; 10; i++) &#123; arr.emplace_back(i); &#125; int temp = 5; //筛选 for_each(arr.begin(), arr.end(), [&amp;temp](int&amp; n) &#123; if (n &gt; temp) largeNums.emplace_back(n); &#125;); //遍历 for_each(largeNums.begin(), largeNums.end(), [](int&amp; n) &#123; cout &lt;&lt; n &lt;&lt; &quot; &quot;; &#125;);&#125;","categories":[{"name":"C++","slug":"C","permalink":"http://example.com/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"}]},{"title":"(每日LeetCode)646. 最长数对链","slug":"每日LeetCode/2022-9/646 最长数对链","date":"2022-09-03T00:34:00.000Z","updated":"2022-09-03T00:35:59.480Z","comments":true,"path":"2022/09/03/每日LeetCode/2022-9/646 最长数对链/","link":"","permalink":"http://example.com/2022/09/03/%E6%AF%8F%E6%97%A5LeetCode/2022-9/646%20%E6%9C%80%E9%95%BF%E6%95%B0%E5%AF%B9%E9%93%BE/","excerpt":"","text":"题目： 给出 n 个数对。 在每一个数对中，第一个数字总是比第二个数字小。 现在，我们定义一种跟随关系，当且仅当 b &lt; c 时，数对(c, d) 才可以跟在 (a, b) 后面。我们用这种形式来构造一个数对链。 给定一个数对集合，找出能够形成的最长数对链的长度。你不需要用到所有的数对，你可以以任何顺序选择其中的一些数对来构造。 示例： 输入：[[1,2], [2,3], [3,4]]输出：2解释：最长的数对链是 [1,2] -&gt; [3,4] 思路：动态规划遍历数组pairs 用 i表示 如果存在pairs[j][1] &lt; pairs[i][0] 重新遍历之前已经遍历过的元素(i位置之前的元素)pairs用j表示并且j &lt; i，找到最大的dp[j] + 1，记录到dp[i]中 返回dp数组的最后一个元素就为最长数对链 代码(cpp)：12345678910111213141516class Solution &#123;public: int findLongestChain(vector&lt;vector&lt;int&gt;&gt;&amp; pairs) &#123; vector&lt;int&gt; dp(pairs.size(), 1); sort(pairs.begin(), pairs.end()); for(int i = 0; i &lt; pairs.size(); i++)&#123; for(int j = 0; j &lt; i; j++)&#123; if (pairs[j][1] &lt; pairs[i][0]) &#123; dp[i] = max(dp[i], dp[j] + 1); &#125; &#125; &#125; return dp.back(); &#125;&#125;; 复杂度分析： 时间复杂度：O(n^2)，其中 n 为 pairs 的长度。排序的时间复杂度为 O(nlogn)，两层 for 循环的时间复杂度为 O(n^2)。 空间复杂度：O(n)，数组 dp 的空间复杂度为 O(n)。","categories":[{"name":"每日LeetCode","slug":"每日LeetCode","permalink":"http://example.com/categories/%E6%AF%8F%E6%97%A5LeetCode/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"}]},{"title":"(每日LeetCode)687. 最长同值路径","slug":"每日LeetCode/2022-9/687 最长同值路径","date":"2022-09-02T01:36:00.000Z","updated":"2022-09-02T01:36:36.365Z","comments":true,"path":"2022/09/02/每日LeetCode/2022-9/687 最长同值路径/","link":"","permalink":"http://example.com/2022/09/02/%E6%AF%8F%E6%97%A5LeetCode/2022-9/687%20%E6%9C%80%E9%95%BF%E5%90%8C%E5%80%BC%E8%B7%AF%E5%BE%84/","excerpt":"","text":"题目：给定一个二叉树的 root ，返回 最长的路径的长度 ，这个路径中的 每个节点具有相同值 。 这条路径可以经过也可以不经过根节点。 两个节点之间的路径长度 由它们之间的边数表示。 示例： 输入：root &#x3D; [5,4,5,1,1,5]输出：2 思路：深度优先搜索(DFS)递归到树的最底部后，得到左右子树的路径长度 其中ans记录了左右子树由它们的父节点相连，所得到的左右子树相加的路径长度 返回值为左右子树中最长路径的长度 举例： ​ 1 &#x2F; \\ 1 1 &#x2F; \\ 1 1 此时，红色标记的就是父节点 1 &#x2F; \\ 1 1 ans的值就为：2(左右子树的路径长度的相加之和)，也就是局部的最优解 但是返回值应为左右子树的中的最长路径的长度 因为如果返回左右子树相加之和的路径长度就会导致： ​ 1 &#x2F; 1 &#x2F; \\ 1 1 出现”三岔口”。 返回左右子树的中的最长路径的长度 ​ 1 &#x2F; 1 \\ ​ 1 不会出现”三岔口”。 一直向上返回值，直至到达root根节点，最后得到ans的最大值(全局最优解) ​ 1 &#x2F; \\ 1 1 \\ ​ 1 代码(cpp)：12345678910111213141516171819202122232425262728class Solution &#123;public: int ans = 0; //记录最长的路径 int dfs(TreeNode* root)&#123; if(root == nullptr) return 0; //进入最底层的节点，从下往上计算 int L = dfs(root-&gt;left); //获取左子树中最长的一段路径 int R = dfs(root-&gt;right); //获取右子树中最长的一段路径 int temp_L = 0; int temp_R = 0; //如果左子树的值与父节点的值相同，则加一，否则置为0 if(root-&gt;left != nullptr &amp;&amp; root-&gt;left-&gt;val == root-&gt;val) temp_L = L + 1; if(root-&gt;right != nullptr &amp;&amp; root-&gt;right-&gt;val == root-&gt;val) temp_R = R + 1; //将左右子树相加变为一条路径，与之前的最长路径比较 ans = max(ans, temp_L + temp_R); //返回左子树或右子树中的最长的一段路径 return max(temp_L, temp_R); &#125; int longestUnivaluePath(TreeNode* root) &#123; dfs(root); return ans; &#125;&#125;; 复杂度分析： 时间复杂度：O(n)，其中 n 为树的结点数目。 空间复杂度：O(n)。递归栈最坏情况下需要 O(n) 的空间。","categories":[{"name":"每日LeetCode","slug":"每日LeetCode","permalink":"http://example.com/categories/%E6%AF%8F%E6%97%A5LeetCode/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"}]},{"title":"(每日LeetCode)1475. 商品折扣后的最终价格","slug":"每日LeetCode/2022-9/1475 商品折扣后的最终价格","date":"2022-09-01T01:35:00.000Z","updated":"2022-09-01T01:36:05.052Z","comments":true,"path":"2022/09/01/每日LeetCode/2022-9/1475 商品折扣后的最终价格/","link":"","permalink":"http://example.com/2022/09/01/%E6%AF%8F%E6%97%A5LeetCode/2022-9/1475%20%E5%95%86%E5%93%81%E6%8A%98%E6%89%A3%E5%90%8E%E7%9A%84%E6%9C%80%E7%BB%88%E4%BB%B7%E6%A0%BC/","excerpt":"","text":"题目：给你一个数组 prices ，其中 prices[i] 是商店里第 i 件商品的价格。 商店里正在进行促销活动，如果你要买第 i 件商品，那么你可以得到与 prices[j] 相等的折扣，其中 j 是满足 j &gt; i 且 prices[j] &lt;= prices[i] 的 最小下标 ，如果没有满足条件的 j ，你将没有任何折扣。 请你返回一个数组，数组中第 i 个元素是折扣后你购买商品 i 最终需要支付的价格。 示例： 输入：prices &#x3D; [8,4,6,2,3]输出：[4,2,4,2,3]解释：商品 0 的价格为 price[0]&#x3D;8 ，你将得到 prices[1]&#x3D;4 的折扣，所以最终价格为 8 - 4 &#x3D; 4 。商品 1 的价格为 price[1]&#x3D;4 ，你将得到 prices[3]&#x3D;2 的折扣，所以最终价格为 4 - 2 &#x3D; 2 。商品 2 的价格为 price[2]&#x3D;6 ，你将得到 prices[3]&#x3D;2 的折扣，所以最终价格为 6 - 2 &#x3D; 4 。商品 3 和 4 都没有折扣。 思路：遍历遍历找到满足 j &gt; i 且 prices[j] &lt;= prices[i] 的 最小下标 代码(cpp)：123456789101112131415161718class Solution &#123;public: vector&lt;int&gt; finalPrices(vector&lt;int&gt;&amp; prices) &#123; int n = prices.size(); vector&lt;int&gt; ans(n); for(int i = 0; i &lt; n; i++)&#123; ans[i] = prices[i]; for(int j = i + 1; j &lt; n; j++)&#123; if(prices[j] &lt;= prices[i])&#123; ans[i] -= prices[j]; break; &#125; &#125; &#125; return ans; &#125;&#125;; 复杂度分析： 时间复杂度：O(n^2)，其中 n 为数组的长度。对于每个商品，我们需要遍历一遍数组查找符合题目要求的折扣。 空间复杂度：O(1)。返回值不计入空间复杂度。","categories":[{"name":"每日LeetCode","slug":"每日LeetCode","permalink":"http://example.com/categories/%E6%AF%8F%E6%97%A5LeetCode/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"}]},{"title":"(每日LeetCode)946. 验证栈序列","slug":"每日LeetCode/2022-8/946 验证栈序列","date":"2022-08-31T00:20:00.000Z","updated":"2022-08-31T00:20:45.457Z","comments":true,"path":"2022/08/31/每日LeetCode/2022-8/946 验证栈序列/","link":"","permalink":"http://example.com/2022/08/31/%E6%AF%8F%E6%97%A5LeetCode/2022-8/946%20%E9%AA%8C%E8%AF%81%E6%A0%88%E5%BA%8F%E5%88%97/","excerpt":"","text":"题目：给定 pushed 和 popped 两个序列，每个序列中的 值都不重复，只有当它们可能是在最初空栈上进行的推入 push 和弹出 pop 操作序列的结果时，返回 true；否则，返回 false 。 示例： 输入：pushed &#x3D; [1,2,3,4,5], popped &#x3D; [4,5,3,2,1]输出：true解释：我们可以按以下顺序执行：push(1), push(2), push(3), push(4), pop() -&gt; 4,push(5), pop() -&gt; 5, pop() -&gt; 3, pop() -&gt; 2, pop() -&gt; 1 思路：模拟依次将pushed数组中的元素入栈，如果栈s的栈顶等于popped的第一个元素，将栈顶元素出栈，并判断popped数组的下一个元素 最后只需要判断栈s是否为空即可 代码(cpp)：123456789101112131415class Solution &#123;public: bool validateStackSequences(vector&lt;int&gt;&amp; pushed, vector&lt;int&gt;&amp; popped) &#123; stack&lt;int&gt; s; int pos = 0 for (int i = 0; i &lt; pushed.size(); i++) &#123; s.emplace(pushed[i]); while (!s.empty() &amp;&amp; s.top() == popped[pos]) &#123; s.pop(); pos++; &#125; &#125; return s.empty(); &#125;&#125;; 复杂度分析： 时间复杂度：O(n)，其中 nn 是数组 pushed 和 popped 的长度。需要遍历数组 pushed 和 popped 各一次，判断两个数组是否为有效的栈操作序列。 空间复杂度：O(n)，其中 n 是数组 pushed 和 popped 的长度。空间复杂度主要取决于栈空间，栈内元素个数不超过 n。","categories":[{"name":"每日LeetCode","slug":"每日LeetCode","permalink":"http://example.com/categories/%E6%AF%8F%E6%97%A5LeetCode/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"}]},{"title":"(每日LeetCode)998. 最大二叉树 II","slug":"每日LeetCode/2022-8/998 最大二叉树 II","date":"2022-08-30T00:45:00.000Z","updated":"2022-08-30T00:49:28.038Z","comments":true,"path":"2022/08/30/每日LeetCode/2022-8/998 最大二叉树 II/","link":"","permalink":"http://example.com/2022/08/30/%E6%AF%8F%E6%97%A5LeetCode/2022-8/998%20%E6%9C%80%E5%A4%A7%E4%BA%8C%E5%8F%89%E6%A0%91%20II/","excerpt":"","text":"题目： 最大树 定义：一棵树，并满足：其中每个节点的值都大于其子树中的任何其他值。 给你最大树的根节点 root 和一个整数 val 。 就像 之前的问题 那样，给定的树是利用 Construct(a) 例程从列表 a（root &#x3D; Construct(a)）递归地构建的： 如果 a 为空，返回 null 。否则，令 a[i] 作为 a 的最大元素。创建一个值为 a[i] 的根节点 root 。root 的左子树将被构建为 Construct([a[0], a[1], …, a[i - 1]]) 。root 的右子树将被构建为 Construct([a[i + 1], a[i + 2], …, a[a.length - 1]]) 。返回 root 。请注意，题目没有直接给出 a ，只是给出一个根节点 root &#x3D; Construct(a) 。 假设 b 是 a 的副本，并在末尾附加值 val。题目数据保证 b 中的值互不相同。 返回 Construct(b) 。 示例： 输入：root &#x3D; [4,1,3,null,null,2], val &#x3D; 5输出：[5,4,null,1,3,null,null,2]解释：a &#x3D; [1,4,2,3], b &#x3D; [1,4,2,3,5] 没看懂题目… 看题解大概是：val足够大，整个树都是左子树。val足够小，变成一个右叶子。 代码(cpp)： 12345678910111213class Solution &#123;public: TreeNode* insertIntoMaxTree(TreeNode* root, int val) &#123; if(root == nullptr)&#123; return new TreeNode(val); &#125; if(root-&gt;val &lt; val)&#123; return new TreeNode(val, root, nullptr); &#125; root-&gt;right = insertIntoMaxTree(root-&gt;right, val); return root; &#125;&#125;;","categories":[{"name":"每日LeetCode","slug":"每日LeetCode","permalink":"http://example.com/categories/%E6%AF%8F%E6%97%A5LeetCode/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"}]},{"title":"(每日LeetCode)1470. 重新排列数组","slug":"每日LeetCode/2022-8/1470 重新排列数组","date":"2022-08-28T23:54:00.000Z","updated":"2022-08-28T23:54:54.268Z","comments":true,"path":"2022/08/29/每日LeetCode/2022-8/1470 重新排列数组/","link":"","permalink":"http://example.com/2022/08/29/%E6%AF%8F%E6%97%A5LeetCode/2022-8/1470%20%E9%87%8D%E6%96%B0%E6%8E%92%E5%88%97%E6%95%B0%E7%BB%84/","excerpt":"","text":"题目：给你一个数组 nums ，数组中有 2n 个元素，按 [x1,x2,...,xn,y1,y2,...,yn] 的格式排列。 请你将数组按 [x1,y1,x2,y2,...,xn,yn] 格式重新排列，返回重排后的数组。 示例： 输入：nums &#x3D; [2,5,1,3,4,7], n &#x3D; 3输出：[2,3,5,4,1,7]解释：由于 x1&#x3D;2, x2&#x3D;5, x3&#x3D;1, y1&#x3D;3, y2&#x3D;4, y3&#x3D;7 ，所以答案为 [2,3,5,4,1,7] 思路：双指针在数组nums的起始位置和中间位置依次遍历添加到ans新数组中 代码(cpp)：123456789101112131415class Solution &#123;public: vector&lt;int&gt; shuffle(vector&lt;int&gt;&amp; nums, int n) &#123; vector&lt;int&gt; ans(2*n); int left = 0; int right = n; while(left &lt; n)&#123; ans.emplace_back(nums[left]); ans.emplace_back(nums[right]); left++; right++; &#125; return ans; &#125;&#125;; 复杂度分析： 时间复杂度：O(n)，其中 n 是给定的参数。需要遍历长度为 2n 的数组 nums 一次将数组重新排列，每个元素重新排列的时间是 O(1)O(1)。 空间复杂度：O(1)。注意返回值不计入空间复杂度。","categories":[{"name":"每日LeetCode","slug":"每日LeetCode","permalink":"http://example.com/categories/%E6%AF%8F%E6%97%A5LeetCode/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"}]},{"title":"(每日LeetCode)662. 二叉树最大宽度","slug":"每日LeetCode/2022-8/662 二叉树最大宽度","date":"2022-08-27T02:23:00.000Z","updated":"2022-08-27T02:24:07.404Z","comments":true,"path":"2022/08/27/每日LeetCode/2022-8/662 二叉树最大宽度/","link":"","permalink":"http://example.com/2022/08/27/%E6%AF%8F%E6%97%A5LeetCode/2022-8/662%20%E4%BA%8C%E5%8F%89%E6%A0%91%E6%9C%80%E5%A4%A7%E5%AE%BD%E5%BA%A6/","excerpt":"","text":"题目：给你一棵二叉树的根节点 root ，返回树的 最大宽度 。 树的 最大宽度 是所有层中最大的 宽度 。 每一层的 宽度 被定义为该层最左和最右的非空节点（即，两个端点）之间的长度。将这个二叉树视作与满二叉树结构相同，两端点间会出现一些延伸到这一层的 null 节点，这些 null 节点也计入长度。 题目数据保证答案将会在 32 位 带符号整数范围内。 示例： 输入：root &#x3D; [1,3,2,5,3,null,9]输出：4解释：最大宽度出现在树的第 3 层，宽度为 4 (5,3,null,9) 。 思路：广度优先搜索(BFS)就是一个二叉树的层序遍历 只是遍历的时候增加了一个 标记每个结点的序号 的过程 如果某节点node的序号为n，那么它的左节点为2n，右节点为2n+1 每层的尾序号与首序号之间的差就是该层的宽度 返回最大宽度 代码(cpp)：1234567891011121314151617181920212223class Solution &#123;public: int widthOfBinaryTree(TreeNode* root) &#123; // 初始化数组储存结点以及对应的序号 vector&lt;pair&lt;TreeNode*, unsigned long long&gt;&gt; array; array.emplace_back(root, 1L); unsigned long long ans = 0; while(!array.empty())&#123; //层序遍历 vector&lt;pair&lt;TreeNode*, unsigned long long&gt;&gt; temp; // 获取每个结点以及对应的序号 for(auto&amp; [node, index] : array)&#123; //遍历该层的每个结点 if(node-&gt;left) temp.emplace_back(node-&gt;left, index*2); if(node-&gt;right) temp.emplace_back(node-&gt;right, index*2 + 1); &#125; ans = max(ans, array.back().second - array[0].second + 1); array = move(temp); //将temp(就是下一层的结点)引用给array &#125; return ans; &#125;&#125;; 复杂度分析： 时间复杂度：O(n)，其中 n 是二叉树的节点个数。需要遍历所有节点。 空间复杂度：O(n)。广度优先搜索的空间复杂度最多为 O(n)。","categories":[{"name":"每日LeetCode","slug":"每日LeetCode","permalink":"http://example.com/categories/%E6%AF%8F%E6%97%A5LeetCode/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"}]},{"title":"(每日LeetCode)1464. 数组中两元素的最大乘积","slug":"每日LeetCode/2022-8/1464 数组中两元素的最大乘积","date":"2022-08-26T01:01:00.000Z","updated":"2022-08-26T01:01:39.525Z","comments":true,"path":"2022/08/26/每日LeetCode/2022-8/1464 数组中两元素的最大乘积/","link":"","permalink":"http://example.com/2022/08/26/%E6%AF%8F%E6%97%A5LeetCode/2022-8/1464%20%E6%95%B0%E7%BB%84%E4%B8%AD%E4%B8%A4%E5%85%83%E7%B4%A0%E7%9A%84%E6%9C%80%E5%A4%A7%E4%B9%98%E7%A7%AF/","excerpt":"","text":"题目：给你一个整数数组 nums，请你选择数组的两个不同下标 i 和 j，使 (nums[i]-1)*(nums[j]-1) 取得最大值。 请你计算并返回该式的最大值。 示例： 输入：nums &#x3D; [3,4,5,2]输出：12解释：如果选择下标 i&#x3D;1 和 j&#x3D;2（下标从 0 开始），则可以获得最大值，(nums[1]-1)(nums[2]-1) &#x3D; (4-1)(5-1) &#x3D; 3*4 &#x3D; 12 。 代码(cpp)：1234567class Solution &#123;public: int maxProduct(vector&lt;int&gt;&amp; nums) &#123; sort(nums.begin(), nums.end()); return (nums[nums.size()-2] - 1)*(nums[nums.size()-1] - 1); &#125;&#125;; 复杂度分析： 时间复杂度：O(nlogn)，其中 n 为数组 nums 的长度，主要为数组排序的时间复杂度。 空间复杂度：O(1)，仅使用常量空间。","categories":[{"name":"每日LeetCode","slug":"每日LeetCode","permalink":"http://example.com/categories/%E6%AF%8F%E6%97%A5LeetCode/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"}]},{"title":"(每日LeetCode)658. 找到 K 个最接近的元素","slug":"每日LeetCode/2022-8/658 找到 K 个最接近的元素","date":"2022-08-25T02:34:00.000Z","updated":"2022-08-25T02:34:05.353Z","comments":true,"path":"2022/08/25/每日LeetCode/2022-8/658 找到 K 个最接近的元素/","link":"","permalink":"http://example.com/2022/08/25/%E6%AF%8F%E6%97%A5LeetCode/2022-8/658%20%E6%89%BE%E5%88%B0%20K%20%E4%B8%AA%E6%9C%80%E6%8E%A5%E8%BF%91%E7%9A%84%E5%85%83%E7%B4%A0/","excerpt":"","text":"题目：给定一个 排序好 的数组 arr ，两个整数 k 和 x ，从数组中找到最靠近 x（两数之差最小）的 k 个数。返回的结果必须要是按升序排好的。 整数 a 比整数 b 更接近 x 需要满足： |a - x| &lt; |b - x| 或者|a - x| == |b - x| 且 a &lt; b 示例： 输入：arr &#x3D; [1,2,3,4,5], k &#x3D; 4, x &#x3D; 3输出：[1,2,3,4] 思路：二分查找+双指针利用 二分查找 找到第一个不小于x的元素 利用 双指针 循环找到最接近x值的元素区间 返回此区间的元素即可 代码(cpp)：1234567891011121314151617181920212223class Solution &#123;public: vector&lt;int&gt; findClosestElements(vector&lt;int&gt;&amp; arr, int k, int x) &#123; auto right = lower_bound(arr.begin(), arr.end(), x); auto left = right - 1; while (k &gt; 0) &#123; if (left &lt; arr.begin()) &#123; right++; &#125; else if (right &gt;= arr.end()) &#123; left--; &#125; else if (x - *left &lt;= *right - x) &#123; left--; &#125; else &#123; right++; &#125; k--; &#125; return vector&lt;int&gt;(left + 1, right); &#125;&#125;; 复杂度分析： 时间复杂度：O(logn+k)，其中 n 是数组 arr 的长度。二分查找需要 O(logn)，双指针查找需要 O(k)。 空间复杂度：O(1)。返回值不计入空间复杂度。","categories":[{"name":"每日LeetCode","slug":"每日LeetCode","permalink":"http://example.com/categories/%E6%AF%8F%E6%97%A5LeetCode/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"}]},{"title":"(每日LeetCode)1460. 通过翻转子数组使两个数组相等","slug":"每日LeetCode/2022-8/1460 通过翻转子数组使两个数组相等","date":"2022-08-24T01:54:00.000Z","updated":"2022-08-24T01:55:04.953Z","comments":true,"path":"2022/08/24/每日LeetCode/2022-8/1460 通过翻转子数组使两个数组相等/","link":"","permalink":"http://example.com/2022/08/24/%E6%AF%8F%E6%97%A5LeetCode/2022-8/1460%20%E9%80%9A%E8%BF%87%E7%BF%BB%E8%BD%AC%E5%AD%90%E6%95%B0%E7%BB%84%E4%BD%BF%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9B%B8%E7%AD%89/","excerpt":"","text":"题目：给你两个长度相同的整数数组 target 和 arr 。每一步中，你可以选择 arr 的任意 非空子数组 并将它翻转。你可以执行此过程任意次。 如果你能让 arr 变得与 target 相同，返回 True；否则，返回 False 。 示例： 输入：target &#x3D; [1,2,3,4], arr &#x3D; [2,4,1,3]输出：true解释：你可以按照如下步骤使 arr 变成 target：1- 翻转子数组 [2,4,1] ，arr 变成 [1,4,2,3]2- 翻转子数组 [4,2] ，arr 变成 [1,2,4,3]3- 翻转子数组 [4,3] ，arr 变成 [1,2,3,4]上述方法并不是唯一的，还存在多种将 arr 变成 target 的方法。 思路：这道题很简单！ 不需要关注过程，只需要看到结果即可 将target与arr排序后比较是否相同即可 代码(cpp)：123456789class Solution &#123;public: bool canBeEqual(vector&lt;int&gt;&amp; target, vector&lt;int&gt;&amp; arr) &#123; sort(target.begin(), target.end()); sort(arr.begin(), arr.end()); return target == arr; &#125;&#125;; 复杂度分析： 时间复杂度：O(n×logn)，其中 n 是输入数组的长度。排序消耗 O(n×logn) 复杂度，判断是否相同消耗 O(n) 复杂度。 空间复杂度：O(logn)，快速排序递归深度平均为 O(logn)。","categories":[{"name":"每日LeetCode","slug":"每日LeetCode","permalink":"http://example.com/categories/%E6%AF%8F%E6%97%A5LeetCode/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"}]},{"title":"(每日LeetCode)655. 输出二叉树","slug":"每日LeetCode/2022-8/655 输出二叉树","date":"2022-08-22T02:20:00.000Z","updated":"2022-08-22T02:21:03.902Z","comments":true,"path":"2022/08/22/每日LeetCode/2022-8/655 输出二叉树/","link":"","permalink":"http://example.com/2022/08/22/%E6%AF%8F%E6%97%A5LeetCode/2022-8/655%20%E8%BE%93%E5%87%BA%E4%BA%8C%E5%8F%89%E6%A0%91/","excerpt":"","text":"题目：给你一棵二叉树的根节点 root ，请你构造一个下标从 0 开始、大小为 m x n 的字符串矩阵 res ，用以表示树的 格式化布局 。构造此格式化布局矩阵需要遵循以下规则： 树的 高度 为 height ，矩阵的行数 m 应该等于 height + 1 。矩阵的列数 n 应该等于 2^(height+1 - 1) 。根节点 需要放置在 顶行 的 正中间 ，对应位置为 res[0][(n-1)/2] 。对于放置在矩阵中的每个节点，设对应位置为 res[r][c] ，将其左子节点放置在 res[r+1][c-2height-r-1] ，右子节点放置在 res[r+1][c+2height-r-1]。继续这一过程，直到树中的所有节点都妥善放置。任意空单元格都应该包含空字符串 &quot;&quot; 。返回构造得到的矩阵 res 。 示例： 输入：root &#x3D; [1,2,3,null,4]输出：[[“”,””,””,”1”,””,””,””],[“”,”2”,””,””,””,”3”,””],[“”,””,”4”,””,””,””,””]] 思路：DFS(深度优先搜索) 利用DFS获取深度 利用DFS遍历二叉树获取对应的val值 代码(cpp)：1234567891011121314151617181920212223242526272829303132333435class Solution &#123;public: int getHeight(TreeNode* root)&#123; int height = 0; if(root-&gt;left)&#123; height = max(height, getHeight(root-&gt;left) + 1); &#125; if(root-&gt;right)&#123; height = max(height, getHeight(root-&gt;right) + 1); &#125; return height; &#125; void dfs(int r, int c, TreeNode* root, vector&lt;vector&lt;string&gt;&gt;&amp; res, int&amp; height)&#123; if(root == nullptr) return; res[r][c] = to_string(root-&gt;val); dfs(r+1, c-pow(2, height-r-1), root-&gt;left, res, height); dfs(r+1, c+pow(2, height-r-1), root-&gt;right, res, height); &#125; vector&lt;vector&lt;string&gt;&gt; printTree(TreeNode* root) &#123; int height = getHeight(root); //获取深度 int m = height + 1; int n = pow(2, m) - 1; //初始化res vector&lt;vector&lt;string&gt;&gt; res(m, vector&lt;string&gt;(n)); //dfs遍历二叉树 dfs(0, (n-1)/2, root, res, height); return res; &#125;&#125;; 复杂度分析： 时间复杂度：O(height×2^height)，其中height 是二叉树的高度。需要填充 (height + 1)×(2^(height+1) − 1) 的数组。 空间复杂度：O(height)，其中 height 是二叉树的高度。空间复杂度主要是递归调用的栈空间，取决于二叉树的高度。注意返回值不计入空间复杂度。","categories":[{"name":"每日LeetCode","slug":"每日LeetCode","permalink":"http://example.com/categories/%E6%AF%8F%E6%97%A5LeetCode/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"}]},{"title":"","slug":"小技巧/C++中1《《 n的意思","date":"2022-08-22T01:35:19.667Z","updated":"2022-08-22T01:42:23.591Z","comments":true,"path":"2022/08/22/小技巧/C++中1《《 n的意思/","link":"","permalink":"http://example.com/2022/08/22/%E5%B0%8F%E6%8A%80%E5%B7%A7/C++%E4%B8%AD1%E3%80%8A%E3%80%8A%20n%E7%9A%84%E6%84%8F%E6%80%9D/","excerpt":"","text":"1 &lt;&lt; n是什么意思？1的二进制是0000 0001&lt;&lt;：将二进制编码向左移动n位并将空位补0 例如： 1 &lt;&lt; 2 就是将0000 0001左移2位为变成0000 0100 转换成十进制最终变成4 同理： 1 &gt;&gt; n：将二进制编码向右移动n位","categories":[],"tags":[]},{"title":"(每日LeetCode)1455. 检查单词是否为句中其他单词的前缀","slug":"每日LeetCode/2022-8/1455 检查单词是否为句中其他单词的前缀","date":"2022-08-21T00:33:00.000Z","updated":"2022-08-21T00:40:32.493Z","comments":true,"path":"2022/08/21/每日LeetCode/2022-8/1455 检查单词是否为句中其他单词的前缀/","link":"","permalink":"http://example.com/2022/08/21/%E6%AF%8F%E6%97%A5LeetCode/2022-8/1455%20%E6%A3%80%E6%9F%A5%E5%8D%95%E8%AF%8D%E6%98%AF%E5%90%A6%E4%B8%BA%E5%8F%A5%E4%B8%AD%E5%85%B6%E4%BB%96%E5%8D%95%E8%AF%8D%E7%9A%84%E5%89%8D%E7%BC%80/","excerpt":"","text":"题目：给你一个字符串 sentence 作为句子并指定检索词为 searchWord ，其中句子由若干用 单个空格 分隔的单词组成。请你检查检索词 searchWord 是否为句子 sentence 中任意单词的前缀。 如果 searchWord 是某一个单词的前缀，则返回句子 sentence 中该单词所对应的下标（下标从 1 开始）。如果 searchWord 是多个单词的前缀，则返回匹配的第一个单词的下标（最小下标）。如果 searchWord 不是任何单词的前缀，则返回 -1 。 字符串 s 的 前缀 是 s 的任何前导连续子字符串。 示例： 输入：sentence &#x3D; “i love eating burger”, searchWord &#x3D; “burg”输出：4解释：”burg” 是 “burger” 的前缀，而 “burger” 是句子中第 4 个单词。 代码(cpp)：123456789101112131415161718192021class Solution &#123;public: int isPrefixOfWord(string sentence, string searchWord) &#123; int ans = 1; //初始化第一个单词的wei for (int i = 0; i &lt; sentence.size(); i++) &#123; int temp = 0; while (sentence[i] == searchWord[temp]) &#123; // 与searchWord进行比较 if (temp == searchWord.size() - 1) &#123; //比较完，返回单词位置 return ans; &#125; temp++; i++; &#125; while (i &lt; sentence.size() &amp;&amp; sentence[i] != &#x27; &#x27;)&#123;//遍历到下一个单词 i++; &#125; ans++; // 进入下一个单词的位置 &#125; return -1; //不存在，返回-1 &#125;&#125;;","categories":[{"name":"每日LeetCode","slug":"每日LeetCode","permalink":"http://example.com/categories/%E6%AF%8F%E6%97%A5LeetCode/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"}]},{"title":"(每日LeetCode)654. 最大二叉树","slug":"每日LeetCode/2022-8/654 最大二叉树","date":"2022-08-20T02:04:00.000Z","updated":"2022-08-20T02:05:04.652Z","comments":true,"path":"2022/08/20/每日LeetCode/2022-8/654 最大二叉树/","link":"","permalink":"http://example.com/2022/08/20/%E6%AF%8F%E6%97%A5LeetCode/2022-8/654%20%E6%9C%80%E5%A4%A7%E4%BA%8C%E5%8F%89%E6%A0%91/","excerpt":"","text":"题目：给定一个不重复的整数数组 nums 。 最大二叉树 可以用下面的算法从 nums 递归地构建: 创建一个根节点，其值为 nums 中的最大值。递归地在最大值 左边 的 子数组前缀上 构建左子树。递归地在最大值 右边 的 子数组后缀上 构建右子树。返回 nums 构建的 最大二叉树 。 示例： 输入：nums &#x3D; [3,2,1,6,0,5]输出：[6,3,5,null,2,0,null,null,1]解释：递归调用如下所示： [3,2,1,6,0,5] 中的最大值是 6 ，左边部分是 [3,2,1] ，右边部分是 [0,5] 。 [3,2,1] 中的最大值是 3 ，左边部分是 [] ，右边部分是 [2,1] 。 空数组，无子节点。 [2,1] 中的最大值是 2 ，左边部分是 [] ，右边部分是 [1] 。 空数组，无子节点。 只有一个元素，所以子节点是一个值为 1 的节点。 [0,5] 中的最大值是 5 ，左边部分是 [0] ，右边部分是 [] 。 只有一个元素，所以子节点是一个值为 0 的节点。 空数组，无子节点。 思路：递归每次递归遍历中找到left和right区间的最大值作为该节点的val值，以及该最大值的位置max_pos 划分该节点的左子树的区间为left和max_pos 划分该节点的右子树的区间为max_pos+1和right 如果左右区间left &gt;= right说明已经遍历完全，退出递归 代码(cpp)：12345678910111213141516171819202122232425class Solution &#123;public: TreeNode* def(vector&lt;int&gt;&amp; nums, int left, int right)&#123; if(left &gt;= right) return nullptr; int temp = -1; int max_pos = 0; for(int i = left; i &lt; right; i++)&#123; if(nums[i] &gt; temp)&#123; temp = nums[i]; max_pos = i; &#125; &#125; TreeNode* node = new TreeNode(temp); node-&gt;left = def(nums, left, max_pos); node-&gt;right = def(nums, max_pos + 1, right); return node; &#125; TreeNode* constructMaximumBinaryTree(vector&lt;int&gt;&amp; nums) &#123; return def(nums, 0, nums.size()); &#125;&#125;; 复杂度分析： 时间复杂度：O(n^2)，其中 n 是数组 nums 的长度。在最坏的情况下，数组严格递增或递减，需要递归 n 层，第 (0 ≤ i &lt; n) 层需要遍历 n-i 个元素以找出最大值，总时间复杂度为 O(n^2)。 空间复杂度：O(n)，即为最坏情况下需要使用的栈空间。","categories":[{"name":"每日LeetCode","slug":"每日LeetCode","permalink":"http://example.com/categories/%E6%AF%8F%E6%97%A5LeetCode/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"}]},{"title":"Docker中安装es以及kibana","slug":"软件安装/Docker中安装es以及kibana","date":"2022-08-19T02:55:08.053Z","updated":"2022-08-20T04:48:54.524Z","comments":true,"path":"2022/08/19/软件安装/Docker中安装es以及kibana/","link":"","permalink":"http://example.com/2022/08/19/%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85/Docker%E4%B8%AD%E5%AE%89%E8%A3%85es%E4%BB%A5%E5%8F%8Akibana/","excerpt":"","text":"1.es1.1 安装es镜像我的容器中jdk版本为8 这里我选择的是es的7.17.5版本镜像镜像安装，因为es8以上的版本不支持jdk8 1docker pull elasticsearch:7.17.5 1.2 启动es容器12345docker run -id \\--name c_es \\-p 9200:9200 \\-e &quot;discovery.type=single-node&quot; \\elasticsearch:7.17.5 1.3 测试在浏览器中访问：http://主机地址ip:9200 如果出现： 1234567891011121314151617&#123; &quot;name&quot; : &quot;3c9efa3c75db&quot;, &quot;cluster_name&quot; : &quot;docker-cluster&quot;, &quot;cluster_uuid&quot; : &quot;1hr4ILNNQfufDSJYgcuIHQ&quot;, &quot;version&quot; : &#123; &quot;number&quot; : &quot;7.17.5&quot;, &quot;build_flavor&quot; : &quot;default&quot;, &quot;build_type&quot; : &quot;docker&quot;, &quot;build_hash&quot; : &quot;8d61b4f7ddf931f219e3745f295ed2bbc50c8e84&quot;, &quot;build_date&quot; : &quot;2022-06-23T21:57:28.736740635Z&quot;, &quot;build_snapshot&quot; : false, &quot;lucene_version&quot; : &quot;8.11.1&quot;, &quot;minimum_wire_compatibility_version&quot; : &quot;6.8.0&quot;, &quot;minimum_index_compatibility_version&quot; : &quot;6.0.0-beta1&quot; &#125;, &quot;tagline&quot; : &quot;You Know, for Search&quot;&#125; 则说明安装成功！ 1.4 跨域访问问题进入容器： 1docker exec -it c_es /bin/bash 修改elasticsearch.yml： 12cd /usr/share/elasticsearch/config/vi elasticsearch.yml 文件末尾添加以下内容： 12http.cors.enabled: truehttp.cors.allow-origin: &quot;*&quot; 重启容器： 1docker restart c_es 2.kibana2.1 安装kibana镜像前提：已经成功部署es 注意：kibana版本要与es的版本一致 1docker pull kibana:7.17.5 2.2 获取es容器内部ip查看c_es容器信息： 1docker inspect c_es 找到IPAddress: &quot;ip&quot;，此ip就是es容器内部ip 2.3 启动kibana容器将ELASTICSEARCH_HOSTS修改为自己es容器内部ip 12345docker run -id \\--name c_kibana \\-e ELASTICSEARCH_HOSTS=http://es容器内部ip:9200 \\-p 5601:5601 \\kibana:7.17.5 2.4 修改中文进入容器： 1docker exec -u 0 -it c_kibana /bin/bash 12cd configvi kibana.yml 在末尾加上一下内容： 1i18n.locale: &quot;zh-CN&quot; 2.5 测试在浏览器中访问：http://主机地址ip:5601 就可以看到kibana的界面了！","categories":[{"name":"软件安装","slug":"软件安装","permalink":"http://example.com/categories/%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85/"}],"tags":[{"name":"容器","slug":"容器","permalink":"http://example.com/tags/%E5%AE%B9%E5%99%A8/"},{"name":"es","slug":"es","permalink":"http://example.com/tags/es/"},{"name":"kibana","slug":"kibana","permalink":"http://example.com/tags/kibana/"}]},{"title":"(每日LeetCode)1450. 在既定时间做作业的学生人数","slug":"每日LeetCode/2022-8/1450 在既定时间做作业的学生人数","date":"2022-08-19T00:21:00.000Z","updated":"2022-08-19T00:21:37.245Z","comments":true,"path":"2022/08/19/每日LeetCode/2022-8/1450 在既定时间做作业的学生人数/","link":"","permalink":"http://example.com/2022/08/19/%E6%AF%8F%E6%97%A5LeetCode/2022-8/1450%20%E5%9C%A8%E6%97%A2%E5%AE%9A%E6%97%B6%E9%97%B4%E5%81%9A%E4%BD%9C%E4%B8%9A%E7%9A%84%E5%AD%A6%E7%94%9F%E4%BA%BA%E6%95%B0/","excerpt":"","text":"题目：给你两个整数数组 startTime（开始时间）和 endTime（结束时间），并指定一个整数 queryTime 作为查询时间。 已知，第 i 名学生在 startTime[i] 时开始写作业并于 endTime[i] 时完成作业。 请返回在查询时间 queryTime 时正在做作业的学生人数。形式上，返回能够使 queryTime 处于区间 [startTime[i], endTime[i]]（含）的学生人数。 示例： 输入：startTime &#x3D; [1,2,3], endTime &#x3D; [3,2,7], queryTime &#x3D; 4输出：1解释：一共有 3 名学生。第一名学生在时间 1 开始写作业，并于时间 3 完成作业，在时间 4 没有处于做作业的状态。第二名学生在时间 2 开始写作业，并于时间 2 完成作业，在时间 4 没有处于做作业的状态。第三名学生在时间 3 开始写作业，预计于时间 7 完成作业，这是是唯一一名在时间 4 时正在做作业的学生。 思路：枚举代码(cpp)：123456789101112class Solution &#123;public: int busyStudent(vector&lt;int&gt;&amp; startTime, vector&lt;int&gt;&amp; endTime, int queryTime) &#123; int sum = 0; for(int i = 0; i &lt; startTime.size(); i++)&#123; if(startTime[i] &lt;= queryTime &amp;&amp; queryTime &lt;= endTime[i]) &#123; sum++; &#125; &#125; return sum; &#125;&#125;; 复杂度分析： 时间复杂度：O(n)，其中 n 为 数组的长度。只需遍历一遍数组即可。 空间复杂度：O(1)。","categories":[{"name":"每日LeetCode","slug":"每日LeetCode","permalink":"http://example.com/categories/%E6%AF%8F%E6%97%A5LeetCode/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"}]},{"title":"(每日LeetCode)1302. 层数最深叶子节点的和","slug":"每日LeetCode/2022-8/1302 层数最深叶子节点的和","date":"2022-08-17T02:50:00.000Z","updated":"2022-08-17T02:50:49.131Z","comments":true,"path":"2022/08/17/每日LeetCode/2022-8/1302 层数最深叶子节点的和/","link":"","permalink":"http://example.com/2022/08/17/%E6%AF%8F%E6%97%A5LeetCode/2022-8/1302%20%E5%B1%82%E6%95%B0%E6%9C%80%E6%B7%B1%E5%8F%B6%E5%AD%90%E8%8A%82%E7%82%B9%E7%9A%84%E5%92%8C/","excerpt":"","text":"题目：给你一棵二叉树的根节点 root ，请你返回 层数最深的叶子节点的和 。 示例： 输入：root &#x3D; [1,2,3,4,5,null,6,7,null,null,null,null,8]输出：15 思路一：深度优先搜索(DFS)代码(cpp)：12345678910111213141516171819202122232425class Solution &#123;public: int max_level = 0; int sum = 0; void dfs(TreeNode* root, int level)&#123; if(!root) return; if(max_level &lt; level)&#123; //max_sum如果不是最大深度，重新开始 sum = root-&gt;val; max_level = level; &#125; else if(max_level == level) &#123; //为最大深度，le sum += root-&gt;val; &#125; dfs(root-&gt;left, level + 1); dfs(root-&gt;right, level + 1); &#125; int deepestLeavesSum(TreeNode* root) &#123; dfs(root, 0); return sum; &#125;&#125;; 复杂度分析： 时间复杂度：O(n)，其中 n 是二叉树的节点数。深度优先搜索需要遍历每个节点一次。 空间复杂度：O(n)，其中 n 是二叉树的节点数。空间复杂度主要取决于递归调用栈的深度，为二叉树的深度，最坏情况下二叉树的深度是 O(n)。 思路二：广度优先搜索(BFS)代码(cpp)：1234567891011121314151617181920class Solution &#123;public: int deepestLeavesSum(TreeNode* root) &#123; queue&lt;TreeNode*&gt; q; q.emplace(root); int sum = 0; while(!q.empty())&#123; //层遍历 sum = 0; int size = q.size(); //获取该层的元素个数 for(int i = 0; i &lt; size; i++)&#123; //该层的元素遍历 TreeNode* node = q.front(); q.pop(); if(node-&gt;left) q.emplace(node-&gt;left); if(node-&gt;right) q.emplace(node-&gt;right); sum += node-&gt;val; &#125; &#125; return sum; &#125;&#125;; 复杂度分析： 时间复杂度：O(n)，其中 n 是二叉树的节点数。广度优先搜索需要遍历每个节点一次。 空间复杂度：O(n)，其中 n 是二叉树的节点数。空间复杂度主要取决于队列空间，队列中的节点个数不超过 n 个。","categories":[{"name":"每日LeetCode","slug":"每日LeetCode","permalink":"http://example.com/categories/%E6%AF%8F%E6%97%A5LeetCode/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"}]},{"title":"(每日LeetCode)1656. 设计有序流","slug":"每日LeetCode/2022-8/1656 设计有序流","date":"2022-08-16T03:34:00.000Z","updated":"2022-08-16T03:34:20.019Z","comments":true,"path":"2022/08/16/每日LeetCode/2022-8/1656 设计有序流/","link":"","permalink":"http://example.com/2022/08/16/%E6%AF%8F%E6%97%A5LeetCode/2022-8/1656%20%E8%AE%BE%E8%AE%A1%E6%9C%89%E5%BA%8F%E6%B5%81/","excerpt":"","text":"题目：有 n 个 (id, value) 对，其中 id 是 1 到 n 之间的一个整数，value 是一个字符串。不存在 id 相同的两个 (id, value) 对。 设计一个流，以 任意 顺序获取 n 个 (id, value) 对，并在多次调用时 按 id 递增的顺序 返回一些值。 实现 OrderedStream 类： OrderedStream(int n) 构造一个能接收 n 个值的流，并将当前指针 ptr 设为 1 。 String[] insert(int id, String value) 向流中存储新的 (id, value) 对。存储后： 如果流存储有 id = ptr 的 (id, value) 对，则找出从 id = ptr 开始的 最长 id 连续递增序列 ，并 按顺序 返回与这些 id 关联的值的列表。然后，将 ptr 更新为最后那个 id + 1 。 否则，返回一个空列表。 示例： 输入[“OrderedStream”, “insert”, “insert”, “insert”, “insert”, “insert”][[5], [3, “ccccc”], [1, “aaaaa”], [2, “bbbbb”], [5, “eeeee”], [4, “ddddd”]]输出[null, [], [“aaaaa”], [“bbbbb”, “ccccc”], [], [“ddddd”, “eeeee”]] 解释OrderedStream os&#x3D; new OrderedStream(5);os.insert(3, “ccccc”); &#x2F;&#x2F; 插入 (3, “ccccc”)，返回 []os.insert(1, “aaaaa”); &#x2F;&#x2F; 插入 (1, “aaaaa”)，返回 [“aaaaa”]os.insert(2, “bbbbb”); &#x2F;&#x2F; 插入 (2, “bbbbb”)，返回 [“bbbbb”, “ccccc”]os.insert(5, “eeeee”); &#x2F;&#x2F; 插入 (5, “eeeee”)，返回 []os.insert(4, “ddddd”); &#x2F;&#x2F; 插入 (4, “ddddd”)，返回 [“ddddd”, “eeeee”] 代码(cpp)：12345678910111213141516171819class OrderedStream &#123;public: int ptr; vector&lt;string&gt; array; OrderedStream(int n) &#123; ptr = 1; array = vector&lt;string&gt;(n + 1); &#125; vector&lt;string&gt; insert(int idKey, string value) &#123; vector&lt;string&gt; ans; array[idKey] = value; while(ptr &lt; array.size() &amp;&amp; array[ptr] != &quot;&quot;)&#123; ans.emplace_back(array[ptr]); ptr++; &#125; return ans; &#125;&#125;; 复杂度分析： 时间复杂度：OrderedStream(int n) 的时间复杂度为 O(n)；String[] insert(int id, String value) 的时间复杂度为均摊 O(1)，这是因为我们会恰好调用该函数 n 次，那么每一个字符串最多会被包含在返回数组中一次。 空间复杂度：O(n)，即为存储 n 个字符串需要的空间。","categories":[{"name":"每日LeetCode","slug":"每日LeetCode","permalink":"http://example.com/categories/%E6%AF%8F%E6%97%A5LeetCode/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"}]},{"title":"(每日LeetCode)641. 设计循环双端队列","slug":"每日LeetCode/2022-8/641 设计循环双端队列","date":"2022-08-15T02:29:00.000Z","updated":"2022-08-15T02:29:10.370Z","comments":true,"path":"2022/08/15/每日LeetCode/2022-8/641 设计循环双端队列/","link":"","permalink":"http://example.com/2022/08/15/%E6%AF%8F%E6%97%A5LeetCode/2022-8/641%20%E8%AE%BE%E8%AE%A1%E5%BE%AA%E7%8E%AF%E5%8F%8C%E7%AB%AF%E9%98%9F%E5%88%97/","excerpt":"","text":"题目：设计实现双端队列。 实现 MyCircularDeque 类: MyCircularDeque(int k) ：构造函数,双端队列最大为 k 。 boolean insertFront()：将一个元素添加到双端队列头部。 如果操作成功返回 true ，否则返回 false。 boolean insertLast() ：将一个元素添加到双端队列尾部。如果操作成功返回 true ，否则返回 false 。 boolean deleteFront() ：从双端队列头部删除一个元素。 如果操作成功返回 true ，否则返回 false 。 boolean deleteLast() ：从双端队列尾部删除一个元素。如果操作成功返回 true ，否则返回 false 。 int getFront()：从双端队列头部获得一个元素。如果双端队列为空，返回 -1 。 int getRear() ：获得双端队列的最后一个元素。 如果双端队列为空，返回 -1 。 boolean isEmpty() ：若双端队列为空，则返回 true ，否则返回 false 。 boolean isFull() ：若双端队列满了，则返回 true ，否则返回 false 。 示例： 输入[“MyCircularDeque”, “insertLast”, “insertLast”, “insertFront”, “insertFront”, “getRear”, “isFull”, “deleteLast”, “insertFront”, “getFront”][[3], [1], [2], [3], [4], [], [], [], [4], []]输出[null, true, true, true, false, 2, true, true, true, 4] 解释MyCircularDeque circularDeque &#x3D; new MycircularDeque(3); &#x2F;&#x2F; 设置容量大小为3circularDeque.insertLast(1); &#x2F;&#x2F; 返回 truecircularDeque.insertLast(2); &#x2F;&#x2F; 返回 truecircularDeque.insertFront(3); &#x2F;&#x2F; 返回 truecircularDeque.insertFront(4); &#x2F;&#x2F; 已经满了，返回 falsecircularDeque.getRear(); &#x2F;&#x2F; 返回 2circularDeque.isFull(); &#x2F;&#x2F; 返回 truecircularDeque.deleteLast(); &#x2F;&#x2F; 返回 truecircularDeque.insertFront(4); &#x2F;&#x2F; 返回 truecircularDeque.getFront(); &#x2F;&#x2F; 返回 4 思路：数组可参考力扣 622 设计循环队列 代码(cpp)：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657class MyCircularDeque &#123;public: vector&lt;int&gt; deque; int front; int rear; int capacity; MyCircularDeque(int k) &#123; capacity = k; deque = vector&lt;int&gt;(k + 1); front = 0; rear = 0; &#125; bool insertFront(int value) &#123; if(isFull()) return false; front = (front - 1 + capacity + 1) % (capacity + 1); deque[front] = value; return true; &#125; bool insertLast(int value) &#123; if(isFull()) return false; deque[rear] = value; rear = (rear + 1) % (capacity + 1); return true; &#125; bool deleteFront() &#123; if(isEmpty()) return false; front = (front + 1) % (capacity + 1); return true; &#125; bool deleteLast() &#123; if(isEmpty()) return false; rear = (rear - 1 + capacity + 1) % (capacity + 1); return true; &#125; int getFront() &#123; if(isEmpty()) return -1; return deque[front]; &#125; int getRear() &#123; if(isEmpty()) return -1; return deque[(rear - 1 + capacity + 1) % (capacity + 1)]; &#125; bool isEmpty() &#123; return front == rear; &#125; bool isFull() &#123; return (rear + 1) % (capacity + 1) == front; &#125;&#125;; 复杂度分析： 时间复杂度：初始化和每项操作的时间复杂度均为 O(1)。 空间复杂度：O(k)，其中 k 为给定的队列元素数目。","categories":[{"name":"每日LeetCode","slug":"每日LeetCode","permalink":"http://example.com/categories/%E6%AF%8F%E6%97%A5LeetCode/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"}]},{"title":"(每日LeetCode)1422. 分割字符串的最大得分","slug":"每日LeetCode/2022-8/1422 分割字符串的最大得分","date":"2022-08-14T01:44:00.000Z","updated":"2022-08-14T01:45:00.113Z","comments":true,"path":"2022/08/14/每日LeetCode/2022-8/1422 分割字符串的最大得分/","link":"","permalink":"http://example.com/2022/08/14/%E6%AF%8F%E6%97%A5LeetCode/2022-8/1422%20%E5%88%86%E5%89%B2%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%9C%80%E5%A4%A7%E5%BE%97%E5%88%86/","excerpt":"","text":"题目：给你一个由若干 0 和 1 组成的字符串 s ，请你计算并返回将该字符串分割成两个 非空 子字符串（即 左 子字符串和 右 子字符串）所能获得的最大得分。 「分割字符串的得分」为 左 子字符串中 0 的数量加上 右 子字符串中 1 的数量。 示例： 输入：s &#x3D; “011101”输出：5解释：将字符串 s 划分为两个非空子字符串的可行方案有：左子字符串 &#x3D; “0” 且 右子字符串 &#x3D; “11101”，得分 &#x3D; 1 + 4 &#x3D; 5左子字符串 &#x3D; “01” 且 右子字符串 &#x3D; “1101”，得分 &#x3D; 1 + 3 &#x3D; 4左子字符串 &#x3D; “011” 且 右子字符串 &#x3D; “101”，得分 &#x3D; 1 + 2 &#x3D; 3左子字符串 &#x3D; “0111” 且 右子字符串 &#x3D; “01”，得分 &#x3D; 1 + 1 &#x3D; 2左子字符串 &#x3D; “01110” 且 右子字符串 &#x3D; “1”，得分 &#x3D; 2 + 1 &#x3D; 3 思路：枚举获得每一种可能的分数，比较出最高得分 代码(cpp)：123456789101112131415161718192021class Solution &#123;public: int maxScore(string s) &#123; int score = 0; for(int i = 0; i &lt; s.size() - 1; i++)&#123; int temp_score = 0; for(int j = 0; j &lt;= i; j++)&#123; if(s[j] == &#x27;0&#x27;)&#123; temp_score++; &#125; &#125; for(int k = i + 1; k &lt; s.size(); k++)&#123; if(s[k] == &#x27;1&#x27;)&#123; temp_score++; &#125; &#125; score = max(score, temp_score); &#125; return score; &#125;&#125;; 复杂度分析： 时间复杂度：O(n^2)，其中 n 是字符串 s 的长度。需要遍历 n−1 个分割点，对于每个分割点需要 O(n) 的时间遍历整个字符串计算分割字符串的得分，因此时间复杂度是 O(n^2) 空间复杂度：O(1)","categories":[{"name":"每日LeetCode","slug":"每日LeetCode","permalink":"http://example.com/categories/%E6%AF%8F%E6%97%A5LeetCode/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"}]},{"title":"(每日LeetCode)1282. 用户分组","slug":"每日LeetCode/2022-8/1282 用户分组","date":"2022-08-12T02:14:00.000Z","updated":"2022-08-12T02:14:47.826Z","comments":true,"path":"2022/08/12/每日LeetCode/2022-8/1282 用户分组/","link":"","permalink":"http://example.com/2022/08/12/%E6%AF%8F%E6%97%A5LeetCode/2022-8/1282%20%E7%94%A8%E6%88%B7%E5%88%86%E7%BB%84/","excerpt":"","text":"题目：有 n 个人被分成数量未知的组。每个人都被标记为一个从 0 到 n - 1 的唯一ID 。 给定一个整数数组 groupSizes ，其中 groupSizes[i] 是第 i 个人所在的组的大小。例如，如果 groupSizes[1] &#x3D; 3 ，则第 1 个人必须位于大小为 3 的组中。 返回一个组列表，使每个人 i 都在一个大小为 groupSizes[i] 的组中。 每个人应该 恰好只 出现在 一个组 中，并且每个人必须在一个组中。如果有多个答案，返回其中 任何 一个。可以 保证 给定输入 至少有一个 有效的解。 示例： 输入：groupSizes &#x3D; [3,3,3,3,3,1,3]输出：[[5],[0,1,2],[3,4,6]]解释：第一组是 [5]，大小为 1，groupSizes[5] &#x3D; 1。第二组是 [0,1,2]，大小为 3，groupSizes[0] &#x3D; groupSizes[1] &#x3D; groupSizes[2] &#x3D; 3。第三组是 [3,4,6]，大小为 3，groupSizes[3] &#x3D; groupSizes[4] &#x3D; groupSizes[6] &#x3D; 3。其他可能的解决方案有 [[2,1,6],[5],[0,4,3]] 和 [[5],[0,6,2],[4,3,1]]。 思路：哈希表使用哈希表获取用户人数相同的元素的所在位置 遍历哈希表，依次截取用户人数为大小的片段 代码(cpp)：1234567891011121314151617class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; groupThePeople(vector&lt;int&gt;&amp; groupSizes) &#123; unordered_map&lt;int, vector&lt;int&gt;&gt; groups; for(int i = 0; i &lt; groupSizes.size(); i++)&#123; groups[groupSizes[i]].emplace_back(i); &#125; vector&lt;vector&lt;int&gt;&gt; ans; for(auto&amp; group : groups)&#123; for(auto it = group.second.begin(); it != group.second.end();)&#123; ans.emplace_back(vector&lt;int&gt;(it, it + group.first)); //截取数组片段 it += group.first; &#125; &#125; return ans; &#125;&#125;; 复杂度分析： 时间复杂度：O(n)，其中 n 是数组 groupSize 的长度。需要遍历数组一次得到每个组的大小对应的所有人的编号，然后需要遍历所有元素完成分组。 空间复杂度：O(n)，其中 n 是数组 groupSize 的长度。空间复杂度主要取决于哈希表，哈希表需要 O(n) 的空间记录每个组的大小对应的所有人的编号。","categories":[{"name":"每日LeetCode","slug":"每日LeetCode","permalink":"http://example.com/categories/%E6%AF%8F%E6%97%A5LeetCode/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"}]},{"title":"(每日LeetCode)1417. 重新格式化字符串","slug":"每日LeetCode/2022-8/1417 重新格式化字符串","date":"2022-08-11T03:17:00.000Z","updated":"2022-08-11T03:17:50.166Z","comments":true,"path":"2022/08/11/每日LeetCode/2022-8/1417 重新格式化字符串/","link":"","permalink":"http://example.com/2022/08/11/%E6%AF%8F%E6%97%A5LeetCode/2022-8/1417%20%E9%87%8D%E6%96%B0%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2/","excerpt":"","text":"题目：给你一个混合了数字和字母的字符串 s，其中的字母均为小写英文字母。 请你将该字符串重新格式化，使得任意两个相邻字符的类型都不同。也就是说，字母后面应该跟着数字，而数字后面应该跟着字母。 请你返回 重新格式化后 的字符串；如果无法按要求重新格式化，则返回一个 空字符串 。 示例：输入：s &#x3D; “a0b1c2”输出：”0a1b2c”解释：”0a1b2c” 中任意两个相邻字符的类型都不同。 “a0b1c2”, “0a1b2c”, “0c2a1b” 也是满足题目要求的答案。 思路：分别获取数字num和字母letter 求得数字长度与字母长度之间的差： 差的绝对值大于1，则无解； 差等于0，依次添加数字、字母； 差等于1，先添加数字再添加字母； 差等于-1，先添加字母再添加数字； 代码(cpp)：1234567891011121314151617181920212223242526272829303132333435363738394041class Solution &#123;public: string reformat(string s) &#123; string num = &quot;&quot;; string letter = &quot;&quot;; for(auto i : s)&#123; if(i &gt;= 48 &amp;&amp; i &lt;= 57)&#123; num += i; &#125; else&#123; letter += i; &#125; &#125; int temp = num.size() - letter.size(); if(temp &gt; 1 || temp &lt; -1)&#123; return &quot;&quot;; &#125; string ans; if(temp == 0)&#123; for(int i = 0; i &lt; num.size(); i++)&#123; ans += num[i]; ans += letter[i]; &#125; &#125; else if(temp == 1)&#123; ans += num[0]; for(int i = 0; i &lt; letter.size(); i++)&#123; ans += letter[i]; ans += num[i + 1]; &#125; &#125; else&#123; ans += letter[0]; for(int i = 0; i &lt; num.size(); i++)&#123; ans += num[i]; ans += letter[i + 1]; &#125; &#125; return ans; &#125;&#125;;","categories":[{"name":"每日LeetCode","slug":"每日LeetCode","permalink":"http://example.com/categories/%E6%AF%8F%E6%97%A5LeetCode/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"}]},{"title":"","slug":"C++/做题常用函数","date":"2022-08-11T02:49:11.978Z","updated":"2023-02-07T02:42:03.173Z","comments":true,"path":"2022/08/11/C++/做题常用函数/","link":"","permalink":"http://example.com/2022/08/11/C++/%E5%81%9A%E9%A2%98%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/","excerpt":"","text":"函数 bool isdigit(char c) 判断字符是否为数字 int abs(int num) 获取num的绝对值 string to_string (int val) 数字转字符串 iterator lower_bound(iterator first, iterator last, T&amp; val) 指定区域内查找不小于目标值的第一个元素 二分查找 T move(T t) 将左值强制转化为右值引用 效率更高,增强型等号 int atoi(const char *nptr) 将char*类型的字符串转为int整型 int stoi(string str) 将string类型的字符串转为int整型 accumulate(起始迭代器, 结束迭代器, 初始值, 自定义操作函数) 累加 int islower(int c) 检查所传的字符是否是小写字母 string substr(int start, int length); 从start位置开始，截取length个字符","categories":[],"tags":[]},{"title":"(每日LeetCode)1413. 逐步求和得到正数的最小值","slug":"每日LeetCode/2022-8/1413 逐步求和得到正数的最小值","date":"2022-08-09T01:31:00.000Z","updated":"2022-08-09T01:31:40.351Z","comments":true,"path":"2022/08/09/每日LeetCode/2022-8/1413 逐步求和得到正数的最小值/","link":"","permalink":"http://example.com/2022/08/09/%E6%AF%8F%E6%97%A5LeetCode/2022-8/1413%20%E9%80%90%E6%AD%A5%E6%B1%82%E5%92%8C%E5%BE%97%E5%88%B0%E6%AD%A3%E6%95%B0%E7%9A%84%E6%9C%80%E5%B0%8F%E5%80%BC/","excerpt":"","text":"题目：给你一个整数数组 nums 。你可以选定任意的 正数 startValue 作为初始值。 你需要从左到右遍历 nums 数组，并将 startValue 依次累加上 nums 数组中的值。 请你在确保累加和始终大于等于 1 的前提下，选出一个最小的 正数 作为 startValue 。 示例： 输入：nums &#x3D; [-3,2,-3,4,2]输出：5解释：如果你选择 startValue &#x3D; 4，在第三次累加时，和小于 1 。 累加求和 startValue &#x3D; 4 | startValue &#x3D; 5 | nums (4 -3 ) &#x3D; 1 | (5 -3 ) &#x3D; 2 | -3 (1 +2 ) &#x3D; 3 | (2 +2 ) &#x3D; 4 | 2 (3 -3 ) &#x3D; 0 | (4 -3 ) &#x3D; 1 | -3 (0 +4 ) &#x3D; 4 | (1 +4 ) &#x3D; 5 | 4 (4 +2 ) &#x3D; 6 | (5 +2 ) &#x3D; 7 | 2 思路：遍历数组，如果累加中小于1时，增加startValue的值直到累加为1 代码(cpp)：123456789101112131415class Solution &#123;public: int minStartValue(vector&lt;int&gt;&amp; nums) &#123; int startValue = 1; //初始化为1，因为startValue为最小的正数 int sum = 1; //初始化为1，因为一开始初始化为0要加上startValue就变成了1 for(auto&amp; num : nums)&#123; sum += num; //累加 if(sum &lt; 1)&#123; //小于1的情况 startValue += 1 - sum; //加上相差的数 sum = 1; //总和就变成了1 &#125; &#125; return startValue; &#125;&#125;;","categories":[{"name":"每日LeetCode","slug":"每日LeetCode","permalink":"http://example.com/categories/%E6%AF%8F%E6%97%A5LeetCode/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"}]},{"title":"(每日LeetCode)636. 函数的独占时间","slug":"每日LeetCode/2022-8/636 函数的独占时间","date":"2022-08-07T03:38:00.000Z","updated":"2022-08-07T03:38:19.485Z","comments":true,"path":"2022/08/07/每日LeetCode/2022-8/636 函数的独占时间/","link":"","permalink":"http://example.com/2022/08/07/%E6%AF%8F%E6%97%A5LeetCode/2022-8/636%20%E5%87%BD%E6%95%B0%E7%9A%84%E7%8B%AC%E5%8D%A0%E6%97%B6%E9%97%B4/","excerpt":"","text":"题目：有一个 单线程 CPU 正在运行一个含有 n 道函数的程序。每道函数都有一个位于 0 和 n-1 之间的唯一标识符。 函数调用 存储在一个 调用栈 上 ：当一个函数调用开始时，它的标识符将会推入栈中。而当一个函数调用结束时，它的标识符将会从栈中弹出。标识符位于栈顶的函数是 当前正在执行的函数 。每当一个函数开始或者结束时，将会记录一条日志，包括函数标识符、是开始还是结束、以及相应的时间戳。 给你一个由日志组成的列表 logs ，其中 logs[i] 表示第 i 条日志消息，该消息是一个按&quot;&#123;function_id&#125;:&#123;&quot;start&quot; | &quot;end&quot;&#125;:&#123;timestamp&#125;&quot; 进行格式化的字符串。例如，&quot;0:start:3&quot; 意味着标识符为 0 的函数调用在时间戳 3 的 起始开始执行 ；而 &quot;1:end:2&quot; 意味着标识符为 1 的函数调用在时间戳 2 的 末尾结束执行。注意，函数可以 调用多次，可能存在递归调用 。 函数的 独占时间 定义是在这个函数在程序所有函数调用中执行时间的总和，调用其他函数花费的时间不算该函数的独占时间。例如，如果一个函数被调用两次，一次调用执行 2 单位时间，另一次调用执行 1 单位时间，那么该函数的 独占时间 为 2 + 1 = 3 。 以数组形式返回每个函数的 独占时间 ，其中第 i 个下标对应的值表示标识符 i 的函数的独占时间。 示例： 输入：n = 2, logs = [&quot;0:start:0&quot;,&quot;1:start:2&quot;,&quot;1:end:5&quot;,&quot;0:end:6&quot;]输出：[3,4]解释：函数 0 在时间戳 0 的起始开始执行，执行 2 个单位时间，于时间戳 1 的末尾结束执行。函数 1 在时间戳 2 的起始开始执行，执行 4 个单位时间，于时间戳 5 的末尾结束执行。函数 0 在时间戳 6 的开始恢复执行，执行 1 个单位时间。所以函数 0 总共执行 2 + 1 &#x3D; 3 个单位时间，函数 1 总共执行 4 个单位时间。 思路：栈遍历logs数组 遍历到status为start时： 将栈顶函数的运行部分时长更新，因为要运行新的函数，先暂时停止运行栈顶函数 将栈顶函数的时刻更新为现在的时刻，再入栈 status为end时： 获取栈顶函数，更新运行总时长，将此函数弹出，因为已经运行完毕了 此时栈顶函数就是之前的那个函数了，要继续运行此函数， 将此函数从时刻更新为现在的时刻，因为是现在的时刻开始继续运行的 代码(cpp)：12345678910111213141516171819202122232425262728293031class Solution &#123;public: vector&lt;int&gt; exclusiveTime(int n, vector&lt;string&gt;&amp; logs) &#123; stack&lt;pair&lt;int, int&gt;&gt; s; vector&lt;int&gt; ans(n); for(auto&amp; log : logs)&#123; int id; char status[10]; int cur_time; sscanf(log.c_str(), &quot;%d:%[^:]:%d&quot;, &amp;id, status, &amp;cur_time); if(status[0] == &#x27;s&#x27;)&#123; if(!s.empty())&#123; ans[s.top().first] += cur_time - s.top().second; s.top().second = cur_time; &#125; s.emplace(id, cur_time); &#125; else&#123; auto temp = s.top(); s.pop(); ans[temp.first] += cur_time + 1 - temp.second; if(!s.empty())&#123; s.top().second = cur_time + 1; &#125; &#125; &#125; return ans; &#125;&#125;; 复杂度分析： 时间复杂度：O(n)，其中 n 为全部日志 logs 的数量，n 条日志信息对应总共 n 次入栈和出栈操作。 空间复杂度：O(n)，其中 n 为全部日志 logs 的数量，n 条日志信息对应 n&#x2F;2 次入栈操作，最坏的情况下全部 n&#x2F;2 条日志入栈后才会依次弹栈。","categories":[{"name":"每日LeetCode","slug":"每日LeetCode","permalink":"http://example.com/categories/%E6%AF%8F%E6%97%A5LeetCode/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"}]},{"title":"Docker容器的学习笔记","slug":"Java/Docker容器","date":"2022-08-06T13:24:22.587Z","updated":"2022-08-20T04:31:38.169Z","comments":true,"path":"2022/08/06/Java/Docker容器/","link":"","permalink":"http://example.com/2022/08/06/Java/Docker%E5%AE%B9%E5%99%A8/","excerpt":"","text":"1.初识Docker我们写好的代码会接触到好几个环境：开发环境、测试环境和生产环境 可能导致在不同的环境下代码运行产生问题(“水土”不服) 所以就需要将代码以及运行环境装到一个容器 测试只需要在容器中进行测试即可，使用的是容器中的运行环境，解决了软件跨环境迁移的问题 1.1 Docker概念 Docker是一个开源的应用容器引擎 诞生于2013年初，基于Go语言实现 Docker可以让开发者打包他们的应用以及依赖包到一个轻量级、可移值的容器中，然后发布到任何流行的Linux机器上 容器是完全使用沙箱机制，相互隔离(一台Linux机器可以启动多个容器，容器之间互不影响) 容器性能开销极低 小结：docker是一种容器技术，解决软件跨环境迁移的问题 1.2 Docker架构 镜像(Image)：Docker镜像(image)，就相当于是一个root文件系统。比如官方镜像ubuntu:16.04包含了一个完整的一套Ubuntu 16.04最小系统的root文件系统。 容器(Container)：镜像(image)和容器(Container)的关系就像是面向对象程序设计中的类和对象一样，镜像是静态的定义，容器是镜像运行时的实体类。容器可以被创建、启动、停止、删除、暂停等操作。 仓库(Repository)：仓库看成一个代码控制中心，用来保存镜像。 1.3 Docker与虚拟机容器就是将软件打包成标准化单元，以用于开发、交付和部署。 容器镜像是轻量的、可执行的独立软件包，包含软件运行新需的所有内容：代码、运行时环境、系结工具、系统库和设置。 容器化软件在任何环境中都能够始终如一地运行。 容器赋于了软件独立性，使其免受外在环境差异的影响，从而有助于减少团队间在相同基础设施上运行不同软件时的冲突。 docker容器虚拟化与传统虚拟机比较 相同： 容器和虚拟机具有相似的资源隔离和分配优势 不同： 容器虛拟化的是操作系統，虛拟机虚拟化的是硬件。 传统虚拟机可以运行不同的操作系统，容器只能运行同一类型操作系统 特性 容器 虚拟机 启动 秒级 分钟级 硬盘使用 一般为MB 一般为GB 性能 接近原生 较弱 系统支持量 单机支持上千个容器 一般为几十个 2.Docker命令2.1 服务相关命令 启动docker服务： 1systemctl start docker 停止docker服务： 1systemctl stop docker 重启docker服务： 1systemctl restart docker 查看docker服务状态： 1systemctl status docker 设置开机启动docker服务： 1systemctl enable docker 2.2 镜像相关命令 查看镜像： 1docker images 查看镜像所有的image id： 1docker images -q 搜索镜像： 搜索redis镜像 1docker search redis 拉取(下载)镜像： 默认下载最新版本的redis镜像 1docker search redis 也可以指定版本号： 下载7.0版本的redis镜像 1docker search redis:7.0 查看版本：打开docker官网，搜索redis，找到并打开官方镜像查看描述信息 删除镜像： 通过image id删除镜像 1docker rmi &lt;IMAGE ID&gt; 也可以通过名称指定版本：删除7.0版本的redis镜像 1docker rmi redis:7.0 删除所有镜像： 1docker rmi &#x27;docker images -q&#x27; 删除无用镜像： 1docker rmi $(docker images -f &quot;dangling=true&quot; -q) 2.3 容器相关命令 查看容器： 查看正在运行的容器： 1docker ps 查看所有容器： 1docker ps -a 创建容器： 1docker run [参数] 例子： 1docker run -it --name=c1 centos:latest /bin/bash 1docker run -id --name=c2 centos:latest -i：保持容器运行 -t：为容器重新分配一个伪终端(可与-i合并为-it) -it创建的容器称为交互式容器 -d：守护(后台)模式运行容器 -id：创建的容器称为守护式容器，需要使用docker exec进入容器 --name=c1：给容器起名为c1 退出容器： 1exit 进入容器： 1docker exec [参数] 进入c2容器： 1docker exec -it c2 /bin/bash 以root权限进入容器： 参数 0 表示root 1docker exec -u 0 -it 容器名 /bin/bash 启动容器： 1docker start 容器名称 停止容器： 1docker stop 容器名称 删除容器： 1docker rm 容器名称 查看容器信息： 1docker inspect 容器名称 3.Docker容器数据卷3.1 数据卷概念 数据卷是宿主机中的一个目录或文件 当容器目录和数据卷目录被绑定后，双方的修改会立即同步 一个数据卷可以被多个容器同时挂载 一个容器可以被挂载多个数据卷 数据卷的作用： 容器的持久化 外部机器和容器间接通信 容器之间数据交换 3.2 配置数据卷创建启动容器时，使用-v设置数据卷 docker run -v 宿主机目录(或文件):容器内目录(或文件) 注意事项： 目录必须是绝对路径 如果目录不存在，会自动创建 可以挂载多个数据卷 例子： 1docker run -it --name=c1 -v /root/data:/root/data_container centos:latest /bin/bash 挂载多个数据卷： 1234docker run -it --name=c2 \\-v /root/data1:/root/data_container1 \\-v /root/data2:/root/data_container2 \\centos:latest /bin/bash 3.3 配置数据卷容器多容器进行数据交换： 多个容器挂载同一个数据卷 数据卷容器 创建启动c3数据卷容器，使用-v 参数设置数据卷： 1docker run -it --name=c3 -v /volume centos:latest /bin/bash 创建启动c1、c2容器，使用--volume-from 参数设置数据卷： 1docker run -it --name=c1 --volume-from c3 centos:latest /bin/bash 1docker run -it --name=c2 --volume-from c3 centos:latest /bin/bash 3.4 数据卷小结 数据卷的概念 宿主机的一个目录或文件 数据卷的作用 容器数据持久化 客户端和容器数据交换 容器之间数据交换 数据卷容器 创建一个容器，挂载一个目录，让其他容器继承该容器 通过简单方式实现数据卷配置 4.Docker应用部署基本步骤： 搜索镜像 拉取镜像 创建容器 操作容器 容器内的网络服务和外部机器不能直接通信 外部机器和宿主机可以直接通信 宿主机和容器可以直接通信 当容器中的网络服务需要被外部机器访问时，可以将容器中提供服务的端口映射到宿主机的端口上。外部机器访问宿主机的该端口，从而问接访问容器的服务。 这种操作称为：端口映射 4.1 MySQL部署需求： 在Docker容器中部署MySQL，并通过外部mysql客户端操作MySQL server 搜索镜像 1docker search mysql 拉取镜像 1docker pull mysql 创建容器，设置端口映射、目录映射 123#在/root目录下创建mysql目录用于存储mysql数据信息mkdir ~/mysqlcd ~/mysql 1234567docker run -id \\-p 3307:3306 \\--name=c_mysql \\-v $PWD/conf:/etc/mysql/conf.d \\-v $PWD/data:/var/lib/mysql \\-e MYSQL_ROOT_PASSWORD=123456 \\mysql:latest 参数说明： $PWD：相当于主机目录的 &#x2F;root&#x2F;mysql -p 3307:3306：将容器的3306端口映射到宿主机的3306端口 端口映射 -V $PWD/conf:/etc/mysql/conf.d：将主机当前目录下的 conf&#x2F;my.cnf 挂载到容器的&#x2F;etc&#x2F;mysql&#x2F;my.cnf 配置目录 -V $PWD/logs:/logs：将主机当前目录下的logs目录挂载到容器的 &#x2F;logs 日志目录 -V $PWD/data:/var/lib/mysql：将主机当前目录下的data目录挂载到容器的 &#x2F;var&#x2F;lib&#x2F;mysql 数据目录 -e MYSOL_ROOT_PASSWORD=123456：初始化root 用户的密码为123456 操作MySQL容器 容器内连接MySQL： 1docker exec -it c_mysql /bin/bash 1mysql -uroot -p123456 图形化客户端连接MySQL： 主机：宿主机的ip 端口：为上面映射为的3307 用户名：root 密码：为上面的123456 4.2 Tomcat部署需求： 在Docker容器中部署Tomcat，并通过外部机器访问Tomcat部署的项目 搜索Tomcat镜像 1docker search tomcat 拉取Tomcat镜像 1docker pull tomcat 创建容器，设置端口映射、目录映射 123#在/root目录下创建tomcat目录用于存储tomcat数据信息mkdir ~/tomcatcd ~/tomcat 12345docker run -id \\--name=c_tomcat \\-p 8080:8080 \\-v $PWD:/usr/local/tomcat/webapps \\tomcat:latest 参数说明： -p 8080:8080：将容器的8080端口映射到主机的8080端口 -v $PWD:/user/local/tomcat/webapps：将主机中当前目录挂载到容器中的 &#x2F;user&#x2F;local&#x2F;tomcat&#x2F;webapps 测试Tomcat 在tomcat目录下，创建test包，在test包中创建一个测试文件： 123mkdir testcd testvim index.html 在index.html文件中写入： 1&lt;h1&gt; Hello Tomcat &lt;/h1&gt; 保存退出： Esc+:wq 使用浏览器访问Tomcat：主机地址:8080/test/index.html 4.3 Redis部署需求： 在Docker容器中部署Redis，并通过外部机器连接Redis 搜索Redis镜像 1docker search redis 拉取Tomcat镜像 1docker pull redis 创建容器，设置端口映射 1234docker run -id \\-p 6379:6379 \\--name=c_redis \\redis:latest 图形化客户端连接redis 主机地址：宿主机的ip 端口：为6379 4.4 Nginx部署需求： 在Docker容器中部署Nginx，并通过外部机器访问Nginx 搜索Nginx镜像 1docker search nginx 拉取Nginx镜像 1docker pull nginx 部署Nginx 在&#x2F;root目录下创建nginx目录用于存储nginx数据信息： 12mkdir ~/nginxcd ~/nginx 在~&#x2F;nginx&#x2F;conf&#x2F;下创建nginx.conf文件： 123mkdir confcd confvim nginx.conf 在nginx.conf中写入： 1234567891011121314151617181920212223242526272829user nginx;worker_processes 1;error_log /var/log/nginx/error.log warn;pid /var/run/nginx.pid;events &#123; worker_connections 1024;&#125;http &#123; include /etc/nginx/mime.types; default_type application/octet-stream; log_format main &#x27;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#x27; &#x27;$status $body_bytes_sent &quot;$http_referer&quot; &#x27; &#x27;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#x27;; access_log /var/log/nginx/access.log main; sendfile on; #tcp_nopush on; keepalive_timeout 65; #gzip on; include /etc/nginx/conf.d/*.conf;&#125; 回到nginx目录： 1cd .. 创建容器，设置端口映射、目录映射： 1234567docker run -id \\--name=c_nginx \\-p 80:80 \\-v $PWD/conf/nginx.conf:/etc/nginx/nginx.conf \\-v $PWD/logs:/var/log/nginx \\-v $PWD/html:/usr/share/nginx/html \\nginx:latest 参数说明： -p 80:80：将容器的80端口映射到宿主机的 80 端口 -v $PWD/conf/nginx.conf:/etc/nginx/nginx.conf：将主机当前目录下的&#x2F;conf&#x2F;nginx.conf 挂载到容器的：&#x2F;etc&#x2F;nginx&#x2F;nginx.conf 配置目录 -v $PWD/logs:/var/log/nginx：将主机当前目录下的 logs 目录挂载到容器的&#x2F;var&#x2F;log&#x2F;nginx 日志目录 使用浏览器访问nginx 创建nginx&#x2F;html&#x2F;test&#x2F;index.html文件： 1234cd htmlmkdir testcd testvim index.html 写入下面内容： 1&lt;h1&gt; Hello Nginx &lt;/h1&gt; 浏览器访问：主机地址/test/index.html 5.DockerFile5.1 Docker镜像原理 操作系统组成部分： 进程调度子系统 进程通信子系統 内存管理子系统 设备管理子系统 文件管理子系统 网络通信子系统 作业控制子系统 Linux文件系统由bootfs和rootfs两部分组成： bootfs：包含bootloader(引导加载程序)和kernel(内核） rootfs：root文件系统，包含的就是典型Linux 系统中的&#x2F;dev、&#x2F;proc、&#x2F;bin、&#x2F;etc等标准目录和文件 不同的linux发行版，bootfs基本一样，而rootis不同。如ubuntu、centos等 Docker镜像原理： Docker镜像是由特殊的文件系统叠加而成 最底端是bootfs， 并使用宿主机的bootfs 第二层是root文件系统rootfs称为base image(基础镜像) 然后再往上可以叠加其他的镜像文件 统一文件系统 (Union File System）技术能够将不同的层整合成一个文件系统，为这些层提供了一个统一的视角，迹样就隐藏了多层的存在，在用户的角度看来，只存在一个文件系统。 一个镜像可以放在另一个镜像的上面。位于下面的镜像称为父镜像，最底部的镜像成为基础镜像。 当一个镜像启动容器时，Docker会在最底层加载一个读写文件系统作为容器 这样分层的好处就是复用 总结： Docker镜像的本质是什么? 一个分层文件系统 centos镜像只有200MB，而一个centos的操作系统的iso文件要几个G？ centos的镜像文件包含bootfs和rootfs，而docker的centos镜像复用了操作系统(就是宿主机)的bootfs，只有rootfs和其他镜像层 Docker中一个tomcat镜像为什么有500MB，而—个tomcat安装包只有70多MB? 由于docker中镜像是分层的，tomcat虽然只有70多MB，但他需要依赖于父镜像和基础镜像，所有整个对外暴露的tomcat镜像加起来大小500多MB 5.2 容器转镜像容器转镜像 1docker commit [容器id] [新的镜像名称]:[自定义版本号] 镜像转压缩文件 1docker save -o [自定义压缩文件名称.tar] [镜像名称]:[自定义版本号] 压缩文件转镜像 1docker load -i [压缩文件] 5.3 DockerFile概念 DockerFile是一个文本系统 包含了一条条的指令 每条指令构建一层，基于基础镜像，最终构建出一个新的镜像 可以为开发团队提高一个完全一致的开发环境 在部署时，可以实现应用的无缝移植 例如： centos7的dockerfile nginx的dockerfile 5.4 DockerFile的关键字 关键字 作用 FROM 指定父镜像 MAINTAINER 作者信息 LABEL 标签 RUN 执行命令 CMD 容器启动命令 ENTRYPOINT 入口 COPY 复制文件 ADD 添加文件 ENV 环境变量 ARG 构建参数 VOLUME 定义外部可以挂载的数据卷 EXPOSE 暴露端口 WORKDIR 工作目录 USER 指定执行用户 HEALTHCHECK 健康检查 ONBUILD 触发器 STOPSIGNAL 发送信息量到宿主机 SHELL 执行执行脚本shell 5.5 部署SpringBoot项目需求： 定义dockerfile，发布springboot项目 实现步骤： 定义父镜像 定义作者信息 将jar包添加到容器 定义容器启动执行的命令 通过dockerfile构建镜像 创建目录： 12mkdir ~/docker-filescd ~/docker-files 将打包好的SpringBoot项目上传到~&#x2F;docker-files目录下 注意：SpringBoot项目也要为java8版本 在docker-files目录编写springboot_dockerfile： 1vim springboot_dockerfile 写入下面的内容： 1234FROM java:8MAINTAINER AiADD springboot-demo-0.0.1-SNAPSHOT.jar app.jarCMD java -jar app.jar 保存退出，将jar包转换为镜像： 1docker build -f ./springboot_dockerfile -t app . 测试 创建容器： 1docker run -id --name=c_app -p 8080:8080 app:latest 浏览器访问：主机地址:8080/hello 5.6 自定义Centos需求： 自定义centos:7镜像，要求： 默认登录路径为&#x2F;usr 可以使用vim 实现步骤： 定义父镜像 定义作者信息 执行安装vim命令 定义默认的工作目录 定义容器启动执行的命令 转到~&#x2F;docker-files目录 1cd ~/docker-files 编写centos7_dockerfile 1vim centos7_dockerfile 写入下面内容： 12345FROM centos:7MAINTAINER AiRUN yum install -y vimWORKDIR /usrCMD /bin/bash 保存退出 创建自定义centos7镜像 1docker build -f ./centos7_dockerfile -t my_centos:1 . 6.Docker服务编排6.1 Docker Compose概述微服务架构的应用系统中一般包含若干个微服务，每个微服务一般都会部署多个实例，如果每个微服务都要手动启停，维护的工作量会很大。 要从Dockerfile build image 或者去dockerhub拉取image 要创建多个container 要管理这些container(启动停止删除) 服务编排：按照一定的业务规则批量管理容器 Docker Compose是一个编排多容器分布式部署的工具，提供命令集管理容器化应用的完整开发周期，包括服务构建、启动和停止。使用步骤： 利用 Dockerfile 定义运行环境镜像 使用 docker-compose.yml定义组成应用的各服务 运行 docker-compose up 启动应用 6.2 Docker Compose安装在安装docker-compose之前要安装docker，以二进制包的方式安装在Linux中： 1curl -L https://get.daocloud.io/docker/compose/releases/download/v2.9.0/docker-compose-`uname -s`-`uname -m` &gt; /usr/local/bin/docker-compose 设置可执行权限： 1chmod +x /usr/local/bin/docker-compose 查看版本信息： 1docker-compose -v docker-compose的卸载，删除二进制文件即可： 1rm /usr/local/bin/docker-compose 6.3 编排Nginx+SpringBoot项目 创建目录 123mkdir ~/docker-composecd ~/docker-composevim docker-compose.yml 编写docker-compose.yml文件 1234567891011121314version: &#x27;3&#x27;services: nginx: image: nginx ports: - 80:80 links: - app volumes: - ./nginx/conf.d:/etc/nginx/conf.d app: image: app expose: - &quot;8080&quot; 创建.&#x2F;nginx&#x2F;conf.d目录下 123mkdir -p ./nginx/conf.dcd ./nginx/conf.dvim my.conf 编写my.conf文件： 1234567server &#123; listen 80; access_log off; location / &#123; proxy_pass http://app:8080; &#125;&#125; 在~&#x2F;docker-compose目录下使用docker-compose启动容器 1docker-compose up 测试 使用浏览器访问：主机地址:80/hello 7.Docker私有仓库Docker私有仓库： Docker官方的Docker hub是一个用于管理公共镜像的仓库，我们可以从上面拉取镜像到本地，也可以把我们自己的镜像推送上去。但是，有时候我们的服务器无法访问互联网，或者你不希望将自己的镜像放到公网当中，那么我们就需要搭建自己的私有仓库来存储和管理自己的镜像。 7.1 搭建私有仓库 拉取私有仓库镜像 1docker pull registry 启动私有仓库容器 1docker run -id --name=registry -p 5000:5000 registry 打开浏览器，输入地址https://私有仓库服务器ip:5000/v2/_catalog 如果看到&#123;&quot;repositories&quot;:[]&#125;表示私有仓库搭建成功 修改deamon.json 1vim /etc/docker/daemon.json 在deamon.json中添加一个key，让docker信任私有仓库地址，添加下面内容： 1&#123;&quot;insecure-registries&quot;: [&quot;私有仓库服务器ip:5000&quot;]&#125; 重启docker服务 1systemctl restart docker 启动registry容器 1docker start registry 7.2 上传镜像到私有仓库上传centos:7为例： 标记镜像为私有仓库的镜像 1docker tag centos:7 私有仓库地址ip:5000/centos:7 上传标记的镜像 1docker push 私有仓库地址ip:5000/centos:7 注意：要启动registry容器，才可以上传到私有仓库 1docker start registry 7.3 从私有仓库拉取镜像拉取centos:7为例： 1dokcer pull 私有仓库地址ip:5000/centos:7","categories":[{"name":"Java","slug":"Java","permalink":"http://example.com/categories/Java/"}],"tags":[{"name":"容器","slug":"容器","permalink":"http://example.com/tags/%E5%AE%B9%E5%99%A8/"},{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"}]},{"title":"数据结构的学习笔记","slug":"计算机4件套/数据结构","date":"2022-08-06T11:11:16.400Z","updated":"2023-02-09T13:25:14.967Z","comments":true,"path":"2022/08/06/计算机4件套/数据结构/","link":"","permalink":"http://example.com/2022/08/06/%E8%AE%A1%E7%AE%97%E6%9C%BA4%E4%BB%B6%E5%A5%97/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/","excerpt":"","text":"0.排序0.1 冒泡排序12345678910111213141516171819202122#include&lt;vector&gt;#include&lt;functional&gt;using namespace std;class Bubble&#123;public: template &lt;class T, class compare = less&lt;&gt;&gt; static void sort(vector&lt;T&gt;&amp; v) &#123; for (int i = v.size() - 1; i &gt; 0; i--) &#123; for (int j = 0; j &lt; i; j++) &#123; if (!compare()(v[j], v[j + 1])) &#123; swap(v[j], v[j + 1]); &#125; &#125; &#125; &#125;&#125;; 时间复杂度：O(n^2) 0.2 选择排序12345678910111213141516171819202122#include&lt;vector&gt;#include&lt;functional&gt;using namespace std;class Selection&#123;public: template&lt;class T, class compare = less&lt;&gt;&gt; static void sort(vector&lt;T&gt;&amp; v) &#123; for (int i = 0; i &lt; v.size(); i++) &#123; int temp = i; for (int j = i + 1; j &lt; v.size(); j++) &#123; if (!compare()(v[temp], v[j])) temp = j; &#125; swap(v[i], v[temp]); &#125; &#125;&#125;; 时间复杂度：O(n^2) 0.3 插入排序12345678910111213141516171819202122#include&lt;vector&gt;#include&lt;functional&gt;using namespace std;class Insertion&#123;public: template&lt;class T, class compare = less&lt;&gt;&gt; static void sort(vector&lt;T&gt;&amp; v) &#123; for (int i = 1; i &lt; v.size(); i++) &#123; for (int j = i; j &gt; 0; j--) &#123; if (!compare()(v[j - 1], v[j])) swap(v[j - 1], v[j]); else break; &#125; &#125; &#125;&#125;; 时间复杂度：O(n^2) 0.4 希尔排序123456789101112131415161718192021222324252627#include&lt;vector&gt;#include&lt;functional&gt;using namespace std;class Shell&#123;public: template&lt;class T, class compare = less&lt;&gt;&gt; static void sort(vector&lt;T&gt;&amp; v) &#123; int h = v.size() / 2; while (h &gt; 0) &#123; for (int i = h; i &lt; v.size(); i++) &#123; for (int j = i; j &gt;= h; j -= h) &#123; if (!compare()(v[j - h], v[j])) swap(v[j - h], v[j]); else break; &#125; &#125; h = h &gt;&gt; 1; &#125; &#125;&#125;; 时间复杂度为O(logn)~O(n^2) 0.5 归并排序12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include&lt;vector&gt;#include&lt;functional&gt;using namespace std;class Merge&#123;public: template&lt;class T&gt; static void sort(vector&lt;T&gt;&amp; v) &#123; sort(v, 0, v.size() - 1); &#125;private: template&lt;class T&gt; static void sort(vector&lt;T&gt;&amp; v, int left, int right) &#123; if (left &gt;= right) return; int mid = (left + right) / 2; sort(v, left, mid); sort(v, mid + 1, right); merge(v, left, mid, right); &#125; template&lt;class T, class compare = less&lt;&gt;&gt; static void merge(vector&lt;T&gt;&amp; v, int left, int mid, int right) &#123; vector&lt;T&gt; temp; int L = left; int R = mid + 1; while (L &lt;= mid &amp;&amp; R &lt;= right) &#123; if (compare()(v[L], v[R])) temp.emplace_back(v[L++]); else temp.emplace_back(v[R++]); &#125; while (L &lt;= mid) temp.emplace_back(v[L++]); while (R &lt;= right) temp.emplace_back(v[R++]); int pos = 0; while (pos &lt; temp.size()) v[left++] = temp[pos++]; &#125;&#125;; 0.6 快速排序1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;vector&gt;#include&lt;functional&gt;using namespace std;class Insertion&#123;public: template&lt;class T&gt; static void sort(vector&lt;T&gt;&amp; v) &#123; sort(v, 0, v.size() - 1); &#125;private: template&lt;class T, class compare = less&lt;&gt;&gt; static void sort(vector&lt;T&gt;&amp; v, int left, int right) &#123; if (left &gt;= right) return; T key = v[left]; int L = left; int R = right; while (L &lt; R) &#123; //必须要先走R指针在走L指针 //找到比key值小的元素的位置 while (!compare()(v[R], key) &amp;&amp; L &lt; R) R--; //找到比key值大的元素的位置 while (!compare()(key, v[L]) &amp;&amp; L &lt; R) L++; if (L &lt; R) swap(v[L], v[R]); &#125; v[left] = v[L]; v[L] = key; sort(v, left, L - 1); sort(v, L + 1, right); &#125;&#125;; 由于使用了类模板，导致测试时，导入头文件，例如：#include&quot;ArrayList.h&quot;，会报错。 所以改用导入源文件，例如：#include&quot;ArrayList.cpp&quot;，这样就能成功运行了！ 1.线性表1.1 顺序表(动态数组)Cpp实现，顺序表的基本实现 头文件ArrayList.h： 12345678910111213141516171819202122#pragma oncetemplate &lt;class T&gt;class ArrayList &#123; private: T* arrayList; // 存储元素的数组 int size; // 数组的大小 int capacity; // 数组的容量 void resize(int newCapacity); // 重新设置容量 public: ArrayList(int capacity); // 构造函数，初始化容量 ~ArrayList(); // 析构函数 void clear(); // 清空数组 bool isEmpty(); // 数组是否为空 int length(); // 获取数组的长度 T get(int pos); // 获取该位置的元素 void insert(T val); // 在数组末尾插入元素 void insert(int pos, T val); // 指定数组中的位置插入元素 T remove(int pos); // 删除该位置的元素并返回该元素 int indexOf(T val); // 根据元素值查找最小索引的位置，没有返回-1&#125;; 源文件ArrayList.cpp： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125#include&quot;ArrayList.h&quot;template&lt;class T&gt;ArrayList&lt;T&gt;::ArrayList()&#123; this-&gt;capacity = 5; this-&gt;arrayList = new T[this-&gt;capacity]; this-&gt;size = 0;&#125;template&lt;class T&gt;ArrayList&lt;T&gt;::ArrayList(int capacity)&#123; this-&gt;capacity = capacity; this-&gt;arrayList = new T[this-&gt;capacity]; this-&gt;size = 0;&#125;template &lt;class T&gt;ArrayList&lt;T&gt;::~ArrayList() &#123; if (this-&gt;arrayList != nullptr)&#123; delete[] this-&gt;arrayList; this-&gt;arrayList = nullptr; &#125;&#125;template&lt;class T&gt;void ArrayList&lt;T&gt;::clear()&#123; this-&gt;size = 0;&#125;template&lt;class T&gt;bool ArrayList&lt;T&gt;::isEmpty()&#123; return this-&gt;arrayList == nullptr;&#125;template&lt;class T&gt;int ArrayList&lt;T&gt;::length()&#123; return this-&gt;size;&#125;template&lt;class T&gt;T ArrayList&lt;T&gt;::get(int pos)&#123; if (pos &lt;0 || pos &gt;= this-&gt;size) return T(); return this-&gt;arrayList[pos];&#125;template&lt;class T&gt;void ArrayList&lt;T&gt;::insert(T val)&#123; if (this-&gt;size == this-&gt;capacity) &#123; this-&gt;resize(this-&gt;capacity * 2); &#125; this-&gt;arrayList[this-&gt;size] = val; this-&gt;size++;&#125;template&lt;class T&gt;void ArrayList&lt;T&gt;::insert(int pos, T val)&#123; if (this-&gt;size == this-&gt;capacity) &#123; this-&gt;resize(this-&gt;capacity * 2); &#125; for (int i = this-&gt;size - 1; i &gt;= pos ; i--) &#123; this-&gt;arrayList[i + 1] = this-&gt;arrayList[i]; &#125; this-&gt;arrayList[pos] = val; this-&gt;size++;&#125;template&lt;class T&gt;T ArrayList&lt;T&gt;::remove(int pos)&#123; if (pos &lt;0 || pos &gt;= this-&gt;size) return T(); T val = this-&gt;arrayList[pos]; for (int i = pos; i &lt; this-&gt;size; i++) &#123; this-&gt;arrayList[i] = this-&gt;arrayList[i + 1]; &#125; this-&gt;size--; if (this-&gt;size &lt; this-&gt;capacity / 4) &#123; this-&gt;resize(this-&gt;capacity / 2); &#125; return val;&#125;template&lt;class T&gt;int ArrayList&lt;T&gt;::indexOf(T val)&#123; for (int i = 0; i &lt; this-&gt;size; i++) &#123; if (this-&gt;arrayList[i] == val) &#123; return val; &#125; &#125; return -1;&#125;template&lt;class T&gt;void ArrayList&lt;T&gt;::resize(int newCapacity)&#123; this-&gt;capacity = newCapacity; T* temp = new T[this-&gt;capacity]; for (int i = 0; i &lt; this-&gt;size; i++) &#123; temp[i] = this-&gt;arrayList[i]; &#125; delete[] this-&gt;arrayList; this-&gt;arrayList = temp;&#125; 部分测试main.cpp： 12345678910111213141516171819202122#include&quot;ArrayList.cpp&quot;#include&lt;iostream&gt;using namespace std;void main() &#123; ArrayList a(3); for (int i = 0; i &lt; 6; i++) &#123; a.insert(i); &#125; cout &lt;&lt; a.isEmpty() &lt;&lt; endl; cout &lt;&lt; a.remove(1) &lt;&lt; endl; cout &lt;&lt; a.indexOf(1) &lt;&lt; endl; for (int i = 0; i &lt; a.length(); i++) &#123; cout &lt;&lt; a.get(i) &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl;&#125; 1.2 单向链表头文件： 123456789101112131415161718192021222324252627282930313233343536373839#pragma oncetemplate&lt;class T&gt;class LinkedList&#123;private: class Node &#123; public: T data; Node* next; Node() &#123;&#125; Node(Node* next) &#123; this-&gt;next = next; &#125; Node(T data, Node* next) &#123; this-&gt;data = data; this-&gt;next = next; &#125; &#125;; Node* head; int size; Node* reverse(Node* curr); // 当前节点实现反转public: LinkedList(); ~LinkedList(); void clear(); bool isEmpty(); int length(); T get(int pos); void insert(T data); void insert(int pos, T data); T remove(int pos); int indexOf(T data); void reverse(); T getMid();&#125;; 源文件： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175#include&quot;LinkedList.h&quot;#include&lt;iostream&gt;using namespace std;template&lt;class T&gt;typename LinkedList&lt;T&gt;::Node* LinkedList&lt;T&gt;::reverse(Node* curr)&#123; if (curr-&gt;next == nullptr) &#123; this-&gt;head-&gt;next = curr; return curr; &#125; Node* p = reverse(curr-&gt;next); p-&gt;next = curr; curr-&gt;next = nullptr; return curr;&#125;template&lt;class T&gt;LinkedList&lt;T&gt;::LinkedList()&#123; this-&gt;head = new Node(nullptr); this-&gt;size = 0;&#125;template&lt;class T&gt;LinkedList&lt;T&gt;::~LinkedList()&#123; if (this-&gt;head == nullptr) &#123; return; &#125; this-&gt;clear(); delete this-&gt;head; this-&gt;head = nullptr;&#125;template&lt;class T&gt;void LinkedList&lt;T&gt;::clear()&#123; if (this-&gt;head == nullptr) &#123; return; &#125; Node* p = this-&gt;head-&gt;next; while (p != nullptr) &#123; Node* newNode = p-&gt;next; delete p; p = newNode; &#125; this-&gt;head-&gt;next = nullptr; this-&gt;size = 0;&#125;template&lt;class T&gt;bool LinkedList&lt;T&gt;::isEmpty()&#123; return this-&gt;size == 0;&#125;template&lt;class T&gt;int LinkedList&lt;T&gt;::length()&#123; return this-&gt;size;&#125;template&lt;class T&gt;T LinkedList&lt;T&gt;::get(int pos)&#123; if (pos &lt; 0 || pos &gt;= this-&gt;size) return T(); Node* p = this-&gt;head-&gt;next; for (int i = 0; i &lt; pos; i++) &#123; p = p-&gt;next; &#125; return p-&gt;data;&#125;template&lt;class T&gt;void LinkedList&lt;T&gt;::insert(T data)&#123; Node* p = this-&gt;head; while (p-&gt;next != nullptr) &#123; p = p-&gt;next; &#125; Node* newNode = new Node(data, nullptr); p-&gt;next = newNode; this-&gt;size++;&#125;template&lt;class T&gt;void LinkedList&lt;T&gt;::insert(int pos, T data)&#123; Node* p = this-&gt;head; for (int i = 0; i &lt; pos; i++) &#123; p = p-&gt;next; &#125; Node* newNode = new Node(data, p-&gt;next); p-&gt;next = newNode; this-&gt;size++;&#125;template&lt;class T&gt;T LinkedList&lt;T&gt;::remove(int pos)&#123; if (pos &lt; 0 || pos &gt;= this-&gt;size) return T(); Node* p = this-&gt;head; for (int i = 0; i &lt; pos; i++) &#123; p = p-&gt;next; &#125; Node* e = p-&gt;next; p-&gt;next = e-&gt;next; T res = e-&gt;data; delete e; e = nullptr; this-&gt;size--; return res;&#125;template&lt;class T&gt;int LinkedList&lt;T&gt;::indexOf(T data)&#123; Node* p = this-&gt;head-&gt;next; int pos = 0; while (p != nullptr) &#123; if (p-&gt;data == data) &#123; return pos; &#125; p = p-&gt;next; pos++; &#125; return -1;&#125;template&lt;class T&gt;void LinkedList&lt;T&gt;::reverse()&#123; if (this-&gt;size &lt; 2) &#123; return; &#125; reverse(this-&gt;head-&gt;next);&#125;template&lt;class T&gt;T LinkedList&lt;T&gt;::getMid()&#123; if (this-&gt;head-&gt;next == nullptr) return T(); Node* fast = this-&gt;head-&gt;next; Node* slow = this-&gt;head-&gt;next; while (fast != nullptr &amp;&amp; fast-&gt;next != nullptr) &#123; fast = fast-&gt;next-&gt;next; slow = slow-&gt;next; &#125; return slow-&gt;data;&#125; 测试： 123456789101112131415161718192021222324#include&quot;LinkedList.cpp&quot;#include&lt;iostream&gt;using namespace std;void main()&#123; LinkedList&lt;int&gt; list; for (int i = 0; i &lt; 6; i++) &#123; list.insert(i); &#125; list.insert(2, 100); cout &lt;&lt; list.isEmpty() &lt;&lt; endl; cout &lt;&lt; list.remove(5) &lt;&lt; endl; cout &lt;&lt; list.indexOf(5) &lt;&lt; endl; //list.clear(); for (int i = 0; i &lt; list.length(); i++) &#123; cout &lt;&lt; list.get(i) &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl;&#125; 1.3 双向链表头文件： 12345678910111213141516171819202122232425262728293031323334353637383940414243#pragma oncetemplate&lt;class T&gt;class DoubleLinkedList&#123;private: class Node &#123; public: T data; Node* pre; Node* next; Node() &#123;&#125; Node(Node* pre, Node* next) &#123; this-&gt;pre = pre; this-&gt;next = next; &#125; Node(Node* pre, T data, Node* next) &#123; this-&gt;pre = pre; this-&gt;data = data; this-&gt;next = next; &#125; &#125;; Node* head; Node* last; int size; Node* getNode(int pos);public: DoubleLinkedList(); ~DoubleLinkedList(); void clear(); bool isEmpty(); int length(); T get(int pos); void insert(T data); void insert(int pos, T data); T remove(int pos); int indexOf(T data); T getFirst(); T getLast();&#125;; 源文件： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161#include&quot;DoubleLinkedList.h&quot;template&lt;class T&gt;typename DoubleLinkedList&lt;T&gt;::Node* DoubleLinkedList&lt;T&gt;::getNode(int pos)&#123; Node* p; //从前往后遍历 if (pos &lt; int(this-&gt;size / 2)) &#123; p = this-&gt;head-&gt;next; for (int i = 0; i &lt; pos; i++) &#123; p = p-&gt;next; &#125; &#125; //从后往前遍历 else &#123; p = this-&gt;last; for (int i = 0; i &lt; pos; i++) &#123; p = p-&gt;pre; &#125; &#125; return p;&#125;template&lt;class T&gt;DoubleLinkedList&lt;T&gt;::DoubleLinkedList()&#123; this-&gt;head = new Node(nullptr, nullptr); this-&gt;last = this-&gt;head; this-&gt;size = 0;&#125;template&lt;class T&gt;DoubleLinkedList&lt;T&gt;::~DoubleLinkedList()&#123; if (this-&gt;head == nullptr) &#123; return; &#125; this-&gt;clear(); delete this-&gt;head; this-&gt;head = nullptr; this-&gt;last = nullptr;&#125;template&lt;class T&gt;void DoubleLinkedList&lt;T&gt;::clear()&#123; if (this-&gt;head == nullptr) &#123; return; &#125; Node* p = this-&gt;head-&gt;next; while (p != nullptr) &#123; Node* newNode = p-&gt;next; delete p; p = newNode; &#125; this-&gt;head-&gt;next = nullptr; this-&gt;last = this-&gt;head; this-&gt;size = 0;&#125;template&lt;class T&gt;bool DoubleLinkedList&lt;T&gt;::isEmpty()&#123; return this-&gt;size == 0;&#125;template&lt;class T&gt;int DoubleLinkedList&lt;T&gt;::length()&#123; return this-&gt;size;&#125;template&lt;class T&gt;T DoubleLinkedList&lt;T&gt;::get(int pos)&#123; if (pos &lt; 0 || pos &gt;= this-&gt;size) return T(); Node* p = this-&gt;getNode(pos); return p-&gt;data;&#125;template&lt;class T&gt;void DoubleLinkedList&lt;T&gt;::insert(T data)&#123; Node* newNode = new Node(this-&gt;last, data, nullptr); this-&gt;last-&gt;next = newNode; this-&gt;last = newNode; this-&gt;size++;&#125;template&lt;class T&gt;void DoubleLinkedList&lt;T&gt;::insert(int pos, T data)&#123; Node* p = this-&gt;getNode(pos); Node* newNode = new Node(p, data, p-&gt;next); p-&gt;next-&gt;pre = newNode; p-&gt;next = newNode; this-&gt;size++;&#125;template&lt;class T&gt;T DoubleLinkedList&lt;T&gt;::remove(int pos)&#123; if (pos &lt; 0 || pos &gt;= this-&gt;size) return T(); Node* p = this-&gt;getNode(pos); T res = p-&gt;data; p-&gt;pre-&gt;next = p-&gt;next; p-&gt;next-&gt;pre = p-&gt;pre; delete p; p = nullptr; this-&gt;size--; return res;&#125;template&lt;class T&gt;int DoubleLinkedList&lt;T&gt;::indexOf(T data)&#123; Node* p = this-&gt;head-&gt;next; int pos = 0; while (p != nullptr) &#123; if (p-&gt;data == data) &#123; return pos; &#125; p = p-&gt;next; &#125; return -1;&#125;template&lt;class T&gt;T DoubleLinkedList&lt;T&gt;::getFirst()&#123; if (this-&gt;isEmpty()) return T(); return this-&gt;head-&gt;next-&gt;data;&#125;template&lt;class T&gt;T DoubleLinkedList&lt;T&gt;::getLast()&#123; if (this-&gt;isEmpty()) return T(); return this-&gt;last-&gt;data;&#125; 1.4 栈(链栈)头文件： 1234567891011121314151617181920212223242526272829303132#pragma oncetemplate&lt;class T&gt;class Stack&#123;private: class Node &#123; public: T data; Node* next; Node() &#123;&#125; Node(Node* next) &#123; this-&gt;next = next; &#125; Node(T data, Node* next) &#123; this-&gt;data = data; this-&gt;next = next; &#125; &#125;; Node* head; int size;public: Stack(); ~Stack(); bool isEmpty(); int getSize(); T pop(); void push(T data);&#125;; 源文件： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include &quot;Stack.h&quot;template&lt;class T&gt;Stack&lt;T&gt;::Stack()&#123; this-&gt;head = new Node(nullptr); this-&gt;size = 0;&#125;template&lt;class T&gt;Stack&lt;T&gt;::~Stack()&#123; if (this-&gt;head == nullptr) &#123; return; &#125; Node* p = this-&gt;head-&gt;next; while (p != nullptr) &#123; Node* newNode = p-&gt;next; delete p; p = newNode; &#125; delete this-&gt;head; this-&gt;head = nullptr;&#125;template&lt;class T&gt;bool Stack&lt;T&gt;::isEmpty()&#123; return this-&gt;size == 0;&#125;template&lt;class T&gt;int Stack&lt;T&gt;::getSize()&#123; return this-&gt;size;&#125;template&lt;class T&gt;T Stack&lt;T&gt;::pop()&#123; if (this-&gt;size == 0) return T(); Node* p = this-&gt;head-&gt;next; T data = p-&gt;data; this-&gt;head-&gt;next = p-&gt;next; this-&gt;size--; return data;&#125;template&lt;class T&gt;void Stack&lt;T&gt;::push(T data)&#123; Node* p = new Node(data, this-&gt;head-&gt;next); this-&gt;head-&gt;next = p; this-&gt;size++;&#125; 1.5 队列(链队)头文件： 1234567891011121314151617181920212223242526272829303132#pragma oncetemplate&lt;class T&gt;class Queue&#123;private: class Node &#123; public: T data; Node* next; Node() &#123;&#125; Node(Node* next) &#123; this-&gt;next = next; &#125; Node(T data, Node* next) &#123; this-&gt;data = data; this-&gt;next = next; &#125; &#125;; Node* head; Node* last; int size;public: Queue(); ~Queue(); bool isEmpty(); T dequeue(); //出队 void enqueue(T data); //入队&#125;; 源文件： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &quot;Queue.h&quot;template&lt;class T&gt;Queue&lt;T&gt;::Queue()&#123; this-&gt;head = new Node(nullptr); this-&gt;last = this-&gt;head; this-&gt;size = 0;&#125;template&lt;class T&gt;Queue&lt;T&gt;::~Queue()&#123; if (this-&gt;head == nullptr) &#123; return; &#125; Node* p = this-&gt;head-&gt;next; while (p != nullptr) &#123; Node* newNode = p-&gt;next; delete p; p = newNode; &#125; delete this-&gt;head; this-&gt;head = nullptr; this-&gt;last = nullptr;&#125;template&lt;class T&gt;bool Queue&lt;T&gt;::isEmpty()&#123; return this-&gt;size == 0;&#125;template&lt;class T&gt;T Queue&lt;T&gt;::dequeue()&#123; if (this-&gt;size == 0) return T(); Node* p = this-&gt;head-&gt;next; T data = p-&gt;data; this-&gt;head-&gt;next = p-&gt;next; delete p; this-&gt;size--; if (this-&gt;isEmpty()) &#123; this-&gt;last = this-&gt;head; &#125; return data;&#125;template&lt;class T&gt;void Queue&lt;T&gt;::enqueue(T data)&#123; Node* newNode = new Node(data, nullptr); this-&gt;last-&gt;next = newNode; this-&gt;last = newNode; this-&gt;size++;&#125; 2.符号表2.1 符号表(map)头文件： 12345678910111213141516171819202122232425262728293031323334#pragma oncetemplate&lt;class K, class V&gt;class Map&#123;private: class Node &#123; public: K key; V value; Node* next; Node() &#123;&#125; Node(Node* next) &#123; this-&gt;next = next; &#125; Node(K key, V value, Node* next) &#123; this-&gt;key = key; this-&gt;value = value; this-&gt;next = next; &#125; &#125;; Node* head; int size;public: Map(); ~Map(); V get(K key); void put(K key, V value); bool remove(K key); int getSize();&#125;; 源文件： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include&quot;Map.h&quot;template&lt;class K, class V&gt;Map&lt;K, V&gt;::Map()&#123; this-&gt;head = new Node(nullptr); this-&gt;size = 0;&#125;template&lt;class K, class V&gt;Map&lt;K, V&gt;::~Map()&#123; if (this-&gt;head == nullptr) &#123; return; &#125; Node* p = this-&gt;head-&gt;next; while (p != nullptr) &#123; Node* newNode = p-&gt;next; delete p; p = newNode; &#125; delete this-&gt;head; this-&gt;head = nullptr;&#125;template&lt;class K, class V&gt;V Map&lt;K, V&gt;::get(K key)&#123; Node* p = this-&gt;head-&gt;next; while (p != nullptr) &#123; if (p-&gt;key == key) &#123; return p-&gt;value; &#125; p = p-&gt;next; &#125; return V();&#125;template&lt;class K, class V&gt;void Map&lt;K, V&gt;::put(K key, V value)&#123; Node* p = this-&gt;head; while (p-&gt;next != nullptr) &#123; p = p-&gt;next; if (p-&gt;key == key) &#123; p-&gt;value = value; return; &#125; &#125; Node* newNode = new Node(key, value, nullptr); p-&gt;next = newNode; this-&gt;size++;&#125;template&lt;class K, class V&gt;bool Map&lt;K, V&gt;::remove(K key)&#123; Node* p = this-&gt;head; while (p-&gt;next != nullptr) &#123; if (p-&gt;next-&gt;key == key) &#123; Node* e = p-&gt;next; p-&gt;next = e-&gt;next; delete e; this-&gt;size--; return true; &#125; p = p-&gt;next; &#125; return false;&#125;template&lt;class K, class V&gt;int Map&lt;K, V&gt;::getSize()&#123; return this-&gt;size;&#125; 2.2 有序符号表头文件： 123456789101112131415161718192021222324252627282930313233343536#pragma once#include&lt;functional&gt;using namespace std;template&lt;class K, class V, class compare = less&lt;K&gt;&gt;class OrderMap&#123;private: class Node &#123; public: K key; V value; Node* next; Node() &#123;&#125; Node(Node* next) &#123; this-&gt;next = next; &#125; Node(K key, V value, Node* next) &#123; this-&gt;key = key; this-&gt;value = value; this-&gt;next = next; &#125; &#125;; Node* head; int size;public: OrderMap(); ~OrderMap(); V get(K key); void put(K key, V value); bool remove(K key); int getSize();&#125;; 源文件： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394#include &quot;OrderMap.h&quot;template&lt;class K, class V, class compare&gt;OrderMap&lt;K, V, compare&gt;::OrderMap()&#123; this-&gt;head = new Node(nullptr); this-&gt;size = 0;&#125;template&lt;class K, class V, class compare&gt;OrderMap&lt;K, V, compare&gt;::~OrderMap()&#123; if (this-&gt;head == nullptr) &#123; return; &#125; Node* p = this-&gt;head-&gt;next; while (p != nullptr) &#123; Node* newNode = p-&gt;next; delete p; p = newNode; &#125; delete this-&gt;head; this-&gt;head = nullptr;&#125;template&lt;class K, class V, class compare&gt;V OrderMap&lt;K, V, compare&gt;::get(K key)&#123; Node* p = this-&gt;head-&gt;next; while (p != nullptr) &#123; if (p-&gt;key == key) &#123; return p-&gt;value; &#125; p = p-&gt;next; &#125; return V();&#125;template&lt;class K, class V, class compare&gt;void OrderMap&lt;K, V, compare&gt;::put(K key, V value)&#123; Node* p = this-&gt;head-&gt;next; Node* pre = this-&gt;head; while (p != nullptr &amp;&amp; compare()(p-&gt;key, key)) &#123; p = p-&gt;next; pre = pre-&gt;next; &#125; if (p == nullptr) &#123; Node* newNode = new Node(key, value, nullptr); pre-&gt;next = newNode; this-&gt;size++; return; &#125; if (p-&gt;key == key) &#123; p-&gt;value = value; return; &#125; Node* newNode = new Node(key, value, p); pre-&gt;next = newNode; this-&gt;size++;&#125;template&lt;class K, class V, class compare&gt;bool OrderMap&lt;K, V, compare&gt;::remove(K key)&#123; Node* p = this-&gt;head; while (p-&gt;next != nullptr) &#123; if (p-&gt;next-&gt;key == key) &#123; Node* e = p-&gt;next; p-&gt;next = e-&gt;next; delete e; this-&gt;size--; return true; &#125; p = p-&gt;next; &#125; return false;&#125;template&lt;class K, class V, class compare&gt;int OrderMap&lt;K, V, compare&gt;::getSize()&#123; return this-&gt;size;&#125; 3.树3.1 二叉查找树头文件： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#pragma once#include&lt;vector&gt;#include&lt;queue&gt;using namespace std;template&lt;class K, class V&gt;class BinaryTree&#123;private: class Node &#123; public: K key; V value; Node* left; Node* right; Node() &#123;&#125; Node(K key, V value, Node* left, Node* right) &#123; this-&gt;key = key; this-&gt;value = value; this-&gt;left = left; this-&gt;right = right; &#125; &#125;; Node* root; int size; Node* put(Node* node, K key, V value); V get(Node* node, K key); Node* remove(Node* node, K key); void destroy(Node* node); Node* min(Node* node); Node* max(Node* node); int depth(Node* node); void ergodic(Node* node, vector&lt;K&gt;&amp; keys, int select); void layerErgodic(Node* node, vector&lt;K&gt;&amp; keys);public: BinaryTree(); ~BinaryTree(); void put(K key, V value); V get(K key); void remove(K key); int getSize(); K getMin(); K getMax(); int getDepth(); vector&lt;K&gt; ergodic(int select); //0 层序 先序1 中序2 后序3&#125;; 源文件： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234#include &quot;BinaryTree.h&quot;template&lt;class K, class V&gt;typename BinaryTree&lt;K, V&gt;::Node* BinaryTree&lt;K, V&gt;::put(Node* node, K key, V value)&#123; if (node == nullptr) &#123; this-&gt;size++; return new Node(key, value, nullptr, nullptr); &#125; if (node-&gt;key &gt; key) node-&gt;left = this-&gt;put(node-&gt;left, key, value); else if (node-&gt;key &lt; key) node-&gt;right = this-&gt;put(node-&gt;right, key, value); else node-&gt;value = value; return node;&#125;template&lt;class K, class V&gt;V BinaryTree&lt;K, V&gt;::get(Node* node, K key)&#123; if (node == nullptr) return V(); if (node-&gt;key &gt; key) return this-&gt;get(node-&gt;left, key); else if (node-&gt;key &lt; key) return this-&gt;get(node-&gt;right, key); else return node-&gt;value; return V();&#125;template&lt;class K, class V&gt;typename BinaryTree&lt;K, V&gt;::Node* BinaryTree&lt;K, V&gt;::remove(Node* node, K key)&#123; //未找到key值 if (node == nullptr) return nullptr; if (node-&gt;key &gt; key) node-&gt;left = this-&gt;remove(node-&gt;left, key); else if (node-&gt;key &lt; key) node-&gt;right = this-&gt;remove(node-&gt;right, key); // node-&gt;key == key情况 else &#123; //左子树为空的情况 if (node-&gt;left == nullptr) &#123; Node* temp = node-&gt;right; delete node; node = temp; this-&gt;size--; return node; &#125; //右子树为空的情况 if (node-&gt;right == nullptr) &#123; Node* temp = node-&gt;left; delete node; node = temp; this-&gt;size--; return node; &#125; //左右字树都不为空的情况 Node* nodeLeft = node-&gt;left; //要删除的节点的左子树 Node* nodeRight = node-&gt;right; //要删除的节点的左子树 //循环，找到右子树的左节点的底节点e以及e的父节点p Node* p = node; //初始化父节点为node Node* e = node-&gt;right; //初始化底节点e为node的右节点 while (e-&gt;left != nullptr) &#123; p = e; e = e-&gt;left; &#125; // 如果node的右节点就是底节点e了 if (p == node) &#123; delete node; //将node节点销毁 node = e; //换成e节点 node-&gt;left = nodeLeft; //e节点(就是现在的node)的左子树为nodeLeft this-&gt;size--; //size-1 &#125; // 获取底层节点e，将e的父节点p左子树置空 else &#123; p-&gt;left = nullptr; //将父节点置空 delete node; //将node节点销毁 node = e; //换成e节点 node-&gt;left = nodeLeft; //e节点(就是现在的node)的左子树为nodeLeft //e节点遍历右子树到底层节点temp Node* temp = node; while (temp-&gt;right != nullptr) &#123; temp = temp-&gt;right; &#125; temp-&gt;right = nodeRight; //temp的右子树为nodeRight this-&gt;size--; //size-1 &#125; &#125; return node;&#125;template&lt;class K, class V&gt;void BinaryTree&lt;K, V&gt;::destroy(Node* node)&#123; if (node == nullptr) return; this-&gt;destroy(node-&gt;left); this-&gt;destroy(node-&gt;right); delete node;&#125;template&lt;class K, class V&gt;typename BinaryTree&lt;K, V&gt;::Node* BinaryTree&lt;K, V&gt;::min(Node* node)&#123; if (node-&gt;left == nullptr) return node; return this-&gt;min(node-&gt;left);&#125;template&lt;class K, class V&gt;typename BinaryTree&lt;K, V&gt;::Node* BinaryTree&lt;K, V&gt;::max(Node* node)&#123; if (node-&gt;right == nullptr) return node; return this-&gt;max(node-&gt;right);&#125;template&lt;class K, class V&gt;int BinaryTree&lt;K, V&gt;::depth(Node* node)&#123; if (node == nullptr) return 0; int left = this-&gt;depth(node-&gt;left) + 1; int right = this-&gt;depth(node-&gt;right) + 1; if (left &gt; right) return left; return right;&#125;template&lt;class K, class V&gt;void BinaryTree&lt;K, V&gt;::ergodic(Node* node, vector&lt;K&gt;&amp; keys, int select)&#123; if (node == nullptr) return; if (select == 1) keys.emplace_back(node-&gt;key); //先序的选择 this-&gt;ergodic(node-&gt;left, keys, select); if (select == 2) keys.emplace_back(node-&gt;key); //中序的选择 this-&gt;ergodic(node-&gt;right, keys, select); if (select == 3) keys.emplace_back(node-&gt;key); //后序的选择&#125;template&lt;class K, class V&gt;void BinaryTree&lt;K, V&gt;::layerErgodic(Node* node, vector&lt;K&gt;&amp; keys)&#123; queue&lt;Node*&gt; q; q.emplace(node); while (!q.empty()) &#123; Node* temp = q.front(); keys.emplace_back(temp-&gt;key); q.pop(); if (temp-&gt;left != nullptr) q.emplace(temp-&gt;left); if (temp-&gt;right != nullptr) q.emplace(temp-&gt;right); &#125;&#125;template&lt;class K, class V&gt;BinaryTree&lt;K, V&gt;::BinaryTree()&#123; this-&gt;root = nullptr; this-&gt;size = 0;&#125;template&lt;class K, class V&gt;BinaryTree&lt;K, V&gt;::~BinaryTree()&#123; this-&gt;destroy(this-&gt;root);&#125;template&lt;class K, class V&gt;void BinaryTree&lt;K, V&gt;::put(K key, V value)&#123; this-&gt;root = this-&gt;put(this-&gt;root, key, value);&#125;template&lt;class K, class V&gt;V BinaryTree&lt;K, V&gt;::get(K key)&#123; return this-&gt;get(this-&gt;root, key);&#125;template&lt;class K, class V&gt;void BinaryTree&lt;K, V&gt;::remove(K key)&#123; this-&gt;root = this-&gt;remove(this-&gt;root, key);&#125;template&lt;class K, class V&gt;int BinaryTree&lt;K, V&gt;::getSize()&#123; return this-&gt;size;&#125;template&lt;class K, class V&gt;K BinaryTree&lt;K, V&gt;::getMin()&#123; return this-&gt;min(this-&gt;root)-&gt;key;&#125;template&lt;class K, class V&gt;K BinaryTree&lt;K, V&gt;::getMax()&#123; return this-&gt;max(this-&gt;root)-&gt;key;&#125;template&lt;class K, class V&gt;int BinaryTree&lt;K, V&gt;::getDepth()&#123; return this-&gt;depth(this-&gt;root);&#125;template&lt;class K, class V&gt;vector&lt;K&gt; BinaryTree&lt;K, V&gt;::ergodic(int select)&#123; vector&lt;K&gt; keys; if (select == 0) this-&gt;layerErgodic(this-&gt;root, keys); //0 层序 this-&gt;ergodic(this-&gt;root, keys, select); return keys;&#125; 3.2 红黑树红黑树含有黑红链接满足下列条件： 红链接均为左链接 没有任何一个结点同时和两条红链接相连 该树是完美黑色平衡，即任意空链接到根节点的路径上的黑链接数量相同 头文件： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#pragma once#include&lt;functional&gt;using namespace std;//默认为less&lt;&gt;为左小右大，可修改为greater&lt;&gt;左大右小template&lt;class K, class V, class compare = less&lt;K&gt;&gt;class RedBlackTree&#123;private: class Node &#123; public: K key; V value; Node* left; Node* right; bool color; Node() &#123;&#125; Node(K key, V value, Node* left, Node* right, bool color) &#123; this-&gt;key = key; this-&gt;value = value; this-&gt;left = left; this-&gt;right = right; this-&gt;color = color; &#125; &#125;; Node* root; int size; static const bool RED = true; static const bool BLACK = false; bool isRed(Node* node); Node* rotateLeft(Node* node); Node* rotateRight(Node* node); void flipColors(Node* node); //颜色反转 Node* put(Node* node, K key, V value); V get(Node* node, K key); void destroy(Node* node);public: RedBlackTree(); ~RedBlackTree(); void put(K key, V value); V get(K key); int getSize();&#125;; 源文件： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116#include &quot;RedBlackTree.h&quot;template&lt;class K, class V, class compare&gt;bool RedBlackTree&lt;K, V, compare&gt;::isRed(Node* node)&#123; if (node == nullptr) return false; return node-&gt;color == this-&gt;RED;&#125;template&lt;class K, class V, class compare&gt;typename RedBlackTree&lt;K, V, compare&gt;::Node* RedBlackTree&lt;K, V, compare&gt;::rotateLeft(Node* node)&#123; Node* r = node-&gt;right; //获取node的右节点r node-&gt;right = r-&gt;left; //将node的右节点指向之前的右节点r的左节点 r-&gt;left = node; //将右节点r的左节点指向node r-&gt;color = node-&gt;color; node-&gt;color = this-&gt;RED; return r;&#125;template&lt;class K, class V, class compare&gt;typename RedBlackTree&lt;K, V, compare&gt;::Node* RedBlackTree&lt;K, V, compare&gt;::rotateRight(Node* node)&#123; Node* l = node-&gt;left; node-&gt;left = l-&gt;right; l-&gt;right = node; l-&gt;color = node-&gt;color; node-&gt;color = this-&gt;RED; return l;&#125;template&lt;class K, class V, class compare&gt;void RedBlackTree&lt;K, V, compare&gt;::flipColors(Node* node)&#123; node-&gt;color = this-&gt;RED; node-&gt;left-&gt;color = this-&gt;BLACK; node-&gt;right-&gt;color = this-&gt;BLACK;&#125;template&lt;class K, class V, class compare&gt;typename RedBlackTree&lt;K, V, compare&gt;::Node* RedBlackTree&lt;K, V, compare&gt;::put(Node* node, K key, V value)&#123; if (node == nullptr) &#123; this-&gt;size++; Node* newNode = new Node(key, value, nullptr, nullptr, RED); return newNode; &#125; if (compare()(key, node-&gt;key)) node-&gt;left = this-&gt;put(node-&gt;left, key, value); else if (compare()(node-&gt;key, key)) node-&gt;right = this-&gt;put(node-&gt;right, key, value); else node-&gt;value = value; //左旋 if (isRed(node-&gt;right) &amp;&amp; !isRed(node-&gt;left)) node = this-&gt;rotateLeft(node); //右旋 if (isRed(node-&gt;left) &amp;&amp; isRed(node-&gt;left-&gt;left)) node = this-&gt;rotateRight(node); //颜色反转 if (isRed(node-&gt;left) &amp;&amp; isRed(node-&gt;right)) this-&gt;flipColors(node); return node;&#125;template&lt;class K, class V, class compare&gt;V RedBlackTree&lt;K, V, compare&gt;::get(Node* node, K key)&#123; if (node == nullptr) return V(); if (compare()(key, node-&gt;key)) return this-&gt;get(node-&gt;left, key); else if (compare()(node-&gt;key, key)) return this-&gt;get(node-&gt;right, key); else return node-&gt;value; return V();&#125;template&lt;class K, class V, class compare&gt;void RedBlackTree&lt;K, V, compare&gt;::destroy(Node* node)&#123; if (node == nullptr) return; this-&gt;destroy(node-&gt;left); this-&gt;destroy(node-&gt;right); delete node;&#125;template&lt;class K, class V, class compare&gt;RedBlackTree&lt;K, V, compare&gt;::RedBlackTree()&#123; this-&gt;size = 0; this-&gt;root = nullptr;&#125;template&lt;class K, class V, class compare&gt;RedBlackTree&lt;K, V, compare&gt;::~RedBlackTree()&#123; this-&gt;destroy(this-&gt;root);&#125;template&lt;class K, class V, class compare&gt;void RedBlackTree&lt;K, V, compare&gt;::put(K key, V value)&#123; this-&gt;root = this-&gt;put(this-&gt;root, key, value); this-&gt;root-&gt;color = this-&gt;BLACK;&#125;template&lt;class K, class V, class compare&gt;V RedBlackTree&lt;K, V, compare&gt;::get(K key)&#123; return this-&gt;get(this-&gt;root, key);&#125;template&lt;class K, class V, class compare&gt; int RedBlackTree&lt;K, V, compare&gt;::getSize()&#123; return this-&gt;size;&#125; 3.3 并查集头文件： 12345678910111213141516#pragma onceclass UF_Tree_Weighted&#123;private: int* array; int* size; int count;public: UF_Tree_Weighted(int capacity); ~UF_Tree_Weighted(); int getCount(); bool connected(int p, int q); int find(int p); void merge(int p, int q);&#125;; 源文件： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &quot;UF_Tree_Weighted.h&quot;UF_Tree_Weighted::UF_Tree_Weighted(int capacity)&#123; this-&gt;array = new int[capacity]; this-&gt;size = new int[capacity]; this-&gt;count = capacity; for (int i = 0; i &lt; this-&gt;count; i++) &#123; this-&gt;array[i] = i; this-&gt;size[i] = 1; &#125;&#125;UF_Tree_Weighted::~UF_Tree_Weighted()&#123; if (this-&gt;array != nullptr) &#123; delete[] array; &#125;&#125;int UF_Tree_Weighted::getCount()&#123; return this-&gt;count;&#125;bool UF_Tree_Weighted::connected(int p, int q)&#123; return find(p) == find(q);&#125;int UF_Tree_Weighted::find(int p)&#123; while (true) &#123; if (this-&gt;array[p] == p) return p; p = this-&gt;array[p]; &#125;&#125;void UF_Tree_Weighted::merge(int p, int q)&#123; int pRoot = this-&gt;find(p); int qRoot = this-&gt;find(q); if (pRoot == qRoot) return; //判断哪个结点长，哪个就当根节点 if (this-&gt;size[pRoot] &lt; this-&gt;size[qRoot]) &#123; //让p的根节点指向q的根节点 this-&gt;array[pRoot] = qRoot; this-&gt;size[qRoot] += this-&gt;size[pRoot]; &#125; else &#123; this-&gt;array[qRoot] = pRoot; this-&gt;size[pRoot] += this-&gt;size[qRoot]; &#125; this-&gt;count--;&#125; 4.堆4.1 堆(完全二叉树)堆是用数组完成数据元素的存储(0位置被废止了) 如果一个节点的位置为k，那么它的父节点的位置为k/2，而它的子节点的位置为2k和2k+1 并且每个节点都要大于它的子节点之和，但是这两个子节点的顺序位置没有要求 头文件： 123456789101112131415161718192021222324#pragma once#include&lt;functional&gt;using namespace std;//默认less&lt;&gt;为小堆顶，使用可修改为greater&lt;&gt;为大堆顶template&lt;class T, class compare = less&lt;T&gt;&gt;class Heap&#123;private: T* arrayList; int size; int capacity; bool less(int i, int j); //判断i位置的元素是否小于j位置的元素 void exch(int i, int j); //交换i位置与j位置的元素 void swim(int pos); //使用上浮算法，使pos位置的元素能处于正确位置 void sink(int pos); //使用下浮算法，使pos位置的元素能处于正确位置 void resize(int newCapacity);public: Heap(); Heap(int capacity); ~Heap(); T delMax(); //删除堆中最大的元素，并返回该元素 void insert(T val); //插入一个元素&#125;; 源文件： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113#include &quot;Heap.h&quot;template&lt;class T, class compare&gt;bool Heap&lt;T, compare&gt;::less(int i, int j)&#123; return compare()(this-&gt;arrayList[i], this-&gt;arrayList[j]);&#125;template&lt;class T, class compare&gt;void Heap&lt;T, compare&gt;::exch(int i, int j)&#123; T temp = this-&gt;arrayList[i]; this-&gt;arrayList[i] = this-&gt;arrayList[j]; this-&gt;arrayList[j] = temp;&#125;template&lt;class T, class compare&gt;void Heap&lt;T, compare&gt;::swim(int pos)&#123; while (pos &gt; 1 &amp;&amp; this-&gt;less(pos, int(pos / 2))) &#123; this-&gt;exch(int(pos / 2), pos); pos = int(pos / 2); &#125;&#125;template&lt;class T, class compare&gt;void Heap&lt;T, compare&gt;::sink(int pos)&#123; while (2 * pos &lt;= this-&gt;size) &#123; int min; // 如果存在右节点，判断两个子节点哪个最小 if (2 * pos + 1 &lt;= this-&gt;size) &#123; if (this-&gt;less(2 * pos + 1, 2 * pos)) min = 2 * pos + 1; else min = 2 * pos; &#125; // 只有左节点 else min = 2 * pos; // 父节点pos小于最小的子节点，不需要继续下浮了 if (this-&gt;less(pos, min)) break; this-&gt;exch(pos, min); //交换 pos = min; &#125;&#125;template&lt;class T, class compare&gt;void Heap&lt;T, compare&gt;::resize(int newCapacity)&#123; this-&gt;capacity = newCapacity; T* temp = new T[this-&gt;capacity + 1]; for (int i = 1; i &lt;= this-&gt;size; i++) &#123; temp[i] = this-&gt;arrayList[i]; &#125; delete[] this-&gt;arrayList; this-&gt;arrayList = temp;&#125;template&lt;class T, class compare&gt;Heap&lt;T, compare&gt;::Heap()&#123; this-&gt;capacity = 5; this-&gt;arrayList = new T[this-&gt;capacity + 1]; this-&gt;size = 0;&#125;template&lt;class T, class compare&gt;Heap&lt;T, compare&gt;::Heap(int capacity)&#123; this-&gt;capacity = capacity; this-&gt;arrayList = new T[this-&gt;capacity + 1]; this-&gt;size = 0;&#125;template&lt;class T, class compare&gt;Heap&lt;T, compare&gt;::~Heap()&#123; if (this-&gt;arrayList != nullptr) &#123; delete[] this-&gt;arrayList; this-&gt;arrayList = nullptr; &#125;&#125;template&lt;class T, class compare&gt;T Heap&lt;T, compare&gt;::delMax()&#123; if (this-&gt;size == 0) return T(); T val = this-&gt;arrayList[1]; this-&gt;exch(1, this-&gt;size); this-&gt;size--; this-&gt;sink(1); //下沉算法 return val;&#125;template&lt;class T, class compare&gt;void Heap&lt;T, compare&gt;::insert(T val)&#123; if (this-&gt;size == this-&gt;capacity) &#123; this-&gt;resize(this-&gt;capacity * 2); &#125; //不用0位置 this-&gt;arrayList[this-&gt;size + 1] = val; this-&gt;size++; this-&gt;swim(this-&gt;size); //上浮算法&#125; 5.优先队列5.1 优先队列(堆实现)头文件： 1234567891011121314151617181920212223242526#pragma once#include&lt;functional&gt;using namespace std;//默认为greater&lt;&gt;最大优先队列，可修改为less&lt;&gt;为最小优先队列template&lt;class T, class compare = greater&lt;T&gt;&gt;class PriorityQueue&#123;private: T* arrayList; int size; int capacity; bool less(int i, int j); //判断i位置的元素是否小于j位置的元素 void exch(int i, int j); //交换i位置与j位置的元素 void swim(int pos); //使用上浮算法，使pos位置的元素能处于正确位置 void sink(int pos); //使用下浮算法，使pos位置的元素能处于正确位置 void resize(int newCapacity);public: PriorityQueue(); PriorityQueue(int capacity); ~PriorityQueue(); T delMax(); //删除堆中最大的元素，并返回该元素 void insert(T val); //插入一个元素 int getSize(); bool isEmpty();&#125;; 源文件： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125#include &quot;PriorityQueue.h&quot;template&lt;class T, class compare&gt;bool PriorityQueue&lt;T, compare&gt;::less(int i, int j)&#123; return compare()(this-&gt;arrayList[i], this-&gt;arrayList[j]);&#125;template&lt;class T, class compare&gt;void PriorityQueue&lt;T, compare&gt;::exch(int i, int j)&#123; T temp = this-&gt;arrayList[i]; this-&gt;arrayList[i] = this-&gt;arrayList[j]; this-&gt;arrayList[j] = temp;&#125;template&lt;class T, class compare&gt;void PriorityQueue&lt;T, compare&gt;::swim(int pos)&#123; while (pos &gt; 1 &amp;&amp; this-&gt;less(pos, int(pos / 2))) &#123; this-&gt;exch(int(pos / 2), pos); pos = int(pos / 2); &#125;&#125;template&lt;class T, class compare&gt;void PriorityQueue&lt;T, compare&gt;::sink(int pos)&#123; while (2 * pos &lt;= this-&gt;size) &#123; int max; // 如果存在右节点，判断两个子节点哪个最大 if (2 * pos + 1 &lt;= this-&gt;size) &#123; if (this-&gt;less(2 * pos + 1, 2 * pos)) max = 2 * pos + 1; else max = 2 * pos; &#125; // 只有左节点 else max = 2 * pos; // 父节点pos大于最大的子节点，不需要继续下浮了 if (this-&gt;less(pos, max)) break; this-&gt;exch(pos, max); //交换 pos = max; &#125;&#125;template&lt;class T, class compare&gt;void PriorityQueue&lt;T, compare&gt;::resize(int newCapacity)&#123; this-&gt;capacity = newCapacity; T* temp = new T[this-&gt;capacity + 1]; for (int i = 1; i &lt;= this-&gt;size; i++) &#123; temp[i] = this-&gt;arrayList[i]; &#125; delete[] this-&gt;arrayList; this-&gt;arrayList = temp;&#125;template&lt;class T, class compare&gt;PriorityQueue&lt;T, compare&gt;::PriorityQueue()&#123; this-&gt;capacity = 5; this-&gt;arrayList = new T[this-&gt;capacity + 1]; this-&gt;size = 0;&#125;template&lt;class T, class compare&gt;PriorityQueue&lt;T, compare&gt;::PriorityQueue(int capacity)&#123; this-&gt;capacity = capacity; this-&gt;arrayList = new T[this-&gt;capacity + 1]; this-&gt;size = 0;&#125;template&lt;class T, class compare&gt;PriorityQueue&lt;T, compare&gt;::~PriorityQueue()&#123; if (this-&gt;arrayList != nullptr) &#123; delete[] this-&gt;arrayList; this-&gt;arrayList = nullptr; &#125;&#125;template&lt;class T, class compare&gt;T PriorityQueue&lt;T, compare&gt;::delMax()&#123; if (this-&gt;size == 0) return T(); T val = this-&gt;arrayList[1]; this-&gt;exch(1, this-&gt;size); this-&gt;size--; this-&gt;sink(1); //下沉算法 return val;&#125;template&lt;class T, class compare&gt;void PriorityQueue&lt;T, compare&gt;::insert(T val)&#123; if (this-&gt;size == this-&gt;capacity) &#123; this-&gt;resize(this-&gt;capacity * 2); &#125; //不用0位置 this-&gt;arrayList[this-&gt;size + 1] = val; this-&gt;size++; this-&gt;swim(this-&gt;size); //上浮算法&#125;template&lt;class T, class compare&gt;int PriorityQueue&lt;T, compare&gt;::getSize()&#123; return this-&gt;size;&#125;template&lt;class T, class compare&gt;bool PriorityQueue&lt;T, compare&gt;::isEmpty()&#123; return this-&gt;size == 0;&#125; 5.2 索引优先队列头文件： 1 源文件： 1 6.图6.1 无向图(邻接表)头文件： 123456789101112131415161718192021222324252627282930#pragma once#include&lt;vector&gt;#include&lt;queue&gt;#include&lt;stack&gt;using namespace std;class Graph&#123;private: int V; int E; vector&lt;int&gt;* adj; int start; int* edgeTo; bool* visited; void dfs(int v, bool* marked, vector&lt;int&gt;&amp; visit); void bfs(int v, bool* marked, vector&lt;int&gt;&amp; visit); void dfsSeek(int s, bool* visited);public: Graph(int v); ~Graph(); int getV(); int getE(); void addEdge(int v, int w); vector&lt;int&gt; get(int v); vector&lt;int&gt; dfs(int v); vector&lt;int&gt; bfs(int v); bool isPath(int start, int end); stack&lt;int&gt; getPath(int start, int end);&#125;; 源文件： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135#include &quot;Graph.h&quot;void Graph::dfs(int v, bool* marked, vector&lt;int&gt;&amp; visit)&#123; marked[v] = false; for (auto&amp; w : this-&gt;adj[v]) &#123; if (marked[w]) &#123; visit.emplace_back(w); this-&gt;dfs(w, marked, visit); &#125; &#125;&#125;void Graph::bfs(int v, bool* marked, vector&lt;int&gt;&amp; visit)&#123; queue&lt;int&gt; q; marked[v] = false; q.emplace(v); while (!q.empty()) &#123; int temp = q.front(); q.pop(); visit.emplace_back(temp); for (auto&amp; w : this-&gt;adj[v]) &#123; if (marked[w]) &#123; marked[w] = false; q.emplace(w); &#125; &#125; &#125;&#125;void Graph::dfsSeek(int s, bool* visited)&#123; visited[s] = false; for (auto&amp; w : this-&gt;adj[s]) &#123; if (visited[w]) &#123; edgeTo[w] = s; this-&gt;dfsSeek(w, visited); &#125; &#125;&#125;Graph::Graph(int v)&#123; this-&gt;V = v; this-&gt;E = 0; this-&gt;start = -1; this-&gt;edgeTo = new int[v]; this-&gt;visited = new bool[v]; this-&gt;adj = new vector&lt;int&gt;[v];&#125;Graph::~Graph()&#123; if (this-&gt;adj != nullptr) delete[] this-&gt;adj; if (this-&gt;edgeTo != nullptr) delete[] this-&gt;edgeTo; if (this-&gt;visited != nullptr) delete[] this-&gt;visited;&#125;int Graph::getV()&#123; return this-&gt;V;&#125;int Graph::getE()&#123; return this-&gt;E;&#125;void Graph::addEdge(int v, int w)&#123; this-&gt;adj[v].emplace_back(w); this-&gt;adj[w].emplace_back(v); this-&gt;E++;&#125;vector&lt;int&gt; Graph::get(int v)&#123; return this-&gt;adj[v];&#125;vector&lt;int&gt; Graph::dfs(int v)&#123; vector&lt;int&gt; visit; bool* marked = new bool[this-&gt;getV()]; this-&gt;dfs(v, marked, visit); delete[] marked; return visit;&#125;vector&lt;int&gt; Graph::bfs(int v)&#123; vector&lt;int&gt; visit; bool* marked = new bool[this-&gt;getV()]; this-&gt;bfs(v, marked, visit); delete[] marked; return visit;&#125;bool Graph::isPath(int start, int end)&#123; if (this-&gt;start != start) &#123; delete[] visited; this-&gt;visited = new bool[this-&gt;getV()]; this-&gt;start = start; this-&gt;dfsSeek(this-&gt;start, visited); &#125; return !visited[end];&#125;stack&lt;int&gt; Graph::getPath(int start, int end)&#123; if(isPath(start, end)) return stack&lt;int&gt;(); stack&lt;int&gt; s; s.emplace(end); int temp = end; while (temp != start) &#123; temp = this-&gt;edgeTo[temp]; s.emplace(temp); &#125; return s;&#125; 6.2 有向图头文件： 12345678910111213141516171819202122232425#pragma once#include&lt;vector&gt;#include&lt;stack&gt;using namespace std;class Digraph&#123;private: int V; int E; vector&lt;int&gt;* adj; void dfsIsCycle(int v, bool* marked, bool* toStack, bool&amp; isCycle); void dfsSort(int v, bool* marked, stack&lt;int&gt;&amp; s); void reversePost(stack&lt;int&gt;&amp; s);public: Digraph(int v); ~Digraph(); int getV(); int getE(); void addEdge(int v, int w); vector&lt;int&gt; get(int v); Digraph reverse(); bool isCycle(); //是否有环 stack&lt;int&gt; order(); //拓扑排序&#125;; 源文件： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118#include &quot;Digraph.h&quot;void Digraph::dfsIsCycle(int v, bool* marked, bool* toStack, bool&amp; isCycle)&#123; marked[v] = false; //将此点标记为已经遍历过了 toStack[v] = false; //第一次标记此点 for (auto&amp; w : this-&gt;adj[v]) &#123; //如果没遍历过此点，则遍历 if (marked[w]) this-&gt;dfsIsCycle(w, marked, toStack, isCycle); //如果遍历过了此点，又出现了，说明此点存在环 if (!toStack[w]) &#123; isCycle = true; return; //直接退出，无需继续遍历了 &#125; &#125; //遍历完成，说明此点不存在环，将此点取消标记 //只有不存在环，才会运行到这里，并且结束递归时toStack又恢复到原来状态了 toStack[v] = true;&#125;void Digraph::dfsSort(int v, bool* marked, stack&lt;int&gt;&amp; s)&#123; marked[v] = false; for (auto&amp; w : this-&gt;adj[v]) &#123; if (marked[w]) this-&gt;dfsSort(w, marked, s); &#125; s.emplace(v);&#125;void Digraph::reversePost(stack&lt;int&gt;&amp; s)&#123; bool* marked = new bool[this-&gt;getV()]; for (int v = 0; v &lt; this-&gt;getV(); v++) &#123; if (marked[v]) this-&gt;dfsSort(v, marked, s); &#125; delete[] marked;&#125;Digraph::Digraph(int v)&#123; this-&gt;V = v; this-&gt;E = 0; this-&gt;adj = new vector&lt;int&gt;[v];&#125;Digraph::~Digraph()&#123; if (this-&gt;adj != nullptr) &#123; delete[] this-&gt;adj; &#125;&#125;int Digraph::getV()&#123; return this-&gt;V;&#125;int Digraph::getE()&#123; return this-&gt;E;&#125;void Digraph::addEdge(int v, int w)&#123; this-&gt;adj[v].emplace_back(w); this-&gt;E++;&#125;vector&lt;int&gt; Digraph::get(int v)&#123; return this-&gt;adj[v];&#125;Digraph Digraph::reverse()&#123; Digraph newDigraph(this-&gt;getV()); for (int v = 0; v &lt; this-&gt;getV(); v++) &#123; for (auto&amp; w : this-&gt;adj[v]) &#123; newDigraph.addEdge(w, v); &#125; &#125; return newDigraph;&#125;bool Digraph::isCycle()&#123; bool isCycle = false; bool* marked = new bool[this-&gt;getV()]; bool* toStack = new bool[this-&gt;getV()]; for (int v = 0; v &lt; this-&gt;getV(); v++) &#123; if (marked[v]) this-&gt;dfsIsCycle(v, marked, toStack, isCycle); &#125; delete[] marked, toStack; return isCycle;&#125;stack&lt;int&gt; Digraph::order()&#123; if (this-&gt;isCycle()) return stack&lt;int&gt;(); stack&lt;int&gt; s; this-&gt;reversePost(s); return s;&#125; 6.3 加权无向图7.字符串匹配7.1 KMP123456789101112#pragma once#include&lt;string&gt;using namespace std;class KMP&#123;public: KMP(); int match(string mainStr, string subStr);private: int* getNext(string subStr);&#125;; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &quot;KMP.h&quot;KMP::KMP()&#123;&#125;int KMP::match(string mainStr, string subStr)&#123; int* next = getNext(subStr); int pos = 0; int k = 0; while (pos &lt; mainStr.size() &amp;&amp; k &lt; int(subStr.size())) &#123; if (k == -1 || mainStr[pos] == subStr[k]) &#123; pos++; k++; &#125; else &#123; k = next[k]; &#125; &#125; delete[] next; if (k == subStr.size()) return pos - k; return -1;&#125;int* KMP::getNext(string subStr)&#123; int n = subStr.size(); int* next; if (n &lt; 3) next = new int[2]; else next = new int[n]; next[0] = -1; next[1] = 0; int pos = 2; int k = 0; while (pos &lt; n) &#123; if (subStr[pos - 1] == subStr[k]) next[pos++] = ++k; else if (k &gt; 0) k = next[k]; else next[pos++] = 0; &#125; return next;&#125;","categories":[{"name":"计算机4件套","slug":"计算机4件套","permalink":"http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA4%E4%BB%B6%E5%A5%97/"}],"tags":[{"name":"c++","slug":"c","permalink":"http://example.com/tags/c/"},{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"操作系统的学习笔记","slug":"计算机4件套/操作系统","date":"2022-08-06T11:11:16.398Z","updated":"2023-02-09T13:24:31.330Z","comments":true,"path":"2022/08/06/计算机4件套/操作系统/","link":"","permalink":"http://example.com/2022/08/06/%E8%AE%A1%E7%AE%97%E6%9C%BA4%E4%BB%B6%E5%A5%97/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/","excerpt":"","text":"一、操作系统概述1.1 特征操作系统的特征： 并发：指两个多个事件在同一时间间隔内发生 这些事件宏观上是同时发生的，但微观上是交替发生的 并行：指两个或多个事件在同一时刻同时发生 操作系统的并发性指计算机系统中同时存在着多个运行着的程序。 单核CPU同一时刻只能执行一个程序，因此操作系统会负责协调多个程序交替执行，但在宏观上看多个程序在同时执行 操作系统是伴随着”多道程序技术”而出现的，因此，操作系统和程序并发是一起诞生的 如今一般都是多核CPU，比如一个4核的CPU，同一时刻可以有4个程序并行执行，但是操作系统的并发性依然必不可少，因为不可能只运行4个程序 共享：即资源共享，是指系统中的资源可供内存中多个并发程序执行的进程共同使用 资源共享的方式： 互斥共享方式：系统中的某些资源，虽然可以提供给多个进程使用，但是一段时间内只允许一个进程访问该资源 示例：使用QQ和微信视频，同一时间内摄像头只能分配给其中一个进程 同时共享方式：系统中的某些资源，允许一个时间段由多个进程”同时”对它们进行访问 其中所谓”同时”，是在宏观上，而微观上，这些进程可能是交替地对该资源进行访问 示例：使用QQ发送文件A，同时使用微信发送文件B。从宏观上，两边都在同时读取并发送文件，从微观上，两个进程在交替着访问硬盘 虚拟：是指把一个物理上的实体变为若干逻辑上的对应物。物理实体实际存在的，而逻辑上对应物是用户感受到的 一个程序需要放入内存并分配给CPU才能执行 一个电脑内存4GB，GTA5运行需要4GB，QQ运行需要256MB，但是还是可以此电脑上运行。 这是因为使用了虚拟存储器技术，虚拟技术中的“空分复用技术” 在单核CPU的计算机中，打开多个的软件，依旧能运行，实际上只有一个单核CPU，但是用户认为有多个CPU在为自己服务。 这是运用了虚拟处理器技术中的“时分复用技术”，微观上处理机在各个微小的时间段内交替着为各个进程服务 虚拟技术： 空分复用技术 时分复用技术 如果失去并发性一段时间只能运行一个程序，则失去了虚拟性的意义(没有并发就谈不上虚拟性) 异步：在多道程序环境下，允许多个程序并发执行，但由于资源有限，进程的执行不是一贯到底的。而是走走停停的，已不可预知的速度向前推进，这就是进程的异步。 只有系统拥有并发性，才有可能导致异步性 并发与共享的关系： 如果失去并发性，则共享性失去存在意义(不需要两个进程交替着访问硬盘了) 如果失去共享性，则无法并发(QQ与微信无法同时读取硬盘资源) 并发性与共线性互为存在条件 没有并发和共享，就没有虚拟和异步，因此并发和共享是操作系统的两个最基本的特征 1.2 发展与分类发展： 手工操作阶段 主要缺点：用户独占全机，人机速度矛盾导致资源利用率极低 批处理阶段 单道批处理系统 引入脱机输入&#x2F;输出技术(用磁带完成)，并监督程序(操作系统的雏形)负责控制作业的输入、输出 主要优点：缓解了一定程度的人机速度矛盾，资源利用率有所提升。 主要缺点：内存中仅能有一道程序运行，只有该程序运行结束后才会进入下一道程序。CPU有大量的时间是在空闲等待IO完成，资源利用率依然很低 多道批处理系统 主要优点：多道程序并发执行，共享计算加资源。资源利用率大幅提升，CPU和其他资源保持”忙碌”状态，系统吞吐量增大 主要缺点：用户响应时间长，没有人机交互功能(用户提交作业后只能等待计算机处理完成，中间不能控制自己的作业执行) 分时操作系统：计算机以时间片为单位轮流为各个用户&#x2F;作业服务，各个用户可通过终端与计算机进行交互 主要优点：用户请求可以被即时响应，解决了人机交互问题，允许多个用户同时使用一台计算机，并且用户对计算机的操作相互独立，感受不到别人的存在 主要缺点：不能优先处理一些紧急任务，操作系统对各个用户&#x2F;作业完全公平，不区分任务的紧急性 实时操作系统 主要优点：能够优先响应一些紧急任务 ，某些紧急任务不需要时间片排队 在实时操作系统的控制下，计算机接收到信号后及时处理，并且在严格的时间内限时完成任务，实时操作系统的主要特点是：及时性和可靠性 硬实时系统：必须在绝对严格的规定时间内完成处理 软实时系统：能接受偶尔违反时间规定 其他几种操作系统： 网络操作系统：能够把网络中各个计算机有机的结合起来，实现数据传送等功能，实现网络中的各种资源的共享和各个计算机之间的通信 分布式操作系统：主要特点是分布式与并行性，任何工作都可以分布在这些计算机上，由它们并行、协同完成这个任务 个人计算机操作系统：如Windows、MacOS等 1.3 运行机制与体系结构运行机制： 指令：处理器能够识别、执行的最基本命令 特权指令：如内存清零指令(不允许用户程序使用) 非特权指令：如普通的运算指令 判断是否可以执行特权指令可以通过两种处理器状态： 用户态(目态)：此时CPU只能执行非特权指令 核心态(管态)：特权和非特权都可以执行 用程序状态寄存器(PSW)来标识当前处理器处于什么状态。如0为用户态，1为核心态 两种程序： 内核程序：操作系统的内核程序是系统发管理者，运行在核心态 应用程序：为了保证系统的安全运行，普通应用程序只能运行在用户态 操作系统内核又细分为：非内核功能和内核 内核：计算机上配置的底层软件，是操作系统最基本、最核心的部分 对系统资源进行管理功能(有的操作系统不会把这部分功能当作内核功能)： 进程管理、存储器管理、设备管理等功能 时钟管理：实现计时功能 中断处理：负责实现中断机制 原语(设备驱动、CPU切换等) 一种特殊的程序。 是最接近硬件的部分， 这种程序的运行具有原子性(要么不执行，要么一直执行到结束) 操作系统的体系结构：大内核和微内核 大内核：将操作系统的主要功能模块都作为系统内核，运行在核心态 优点：高性能 缺点：内核代码庞大、结构混乱、难以维护 微内核：只把最基本的功能保留在内核 优点：内核功能少、结构清晰、方便维护 缺点：需要频繁地在核心态和用户态之间切换、性能低 1.4 中断与异常中断： 当中断发生时，CPU立即进入核心态 当中断发生后，当前运行的进程暂停运行，并由操作系统内核对中断进行处理 对于不同的中断信号，会进行不同的处理 发生了中断，就意味着需要操作系统介入，开展管理工作。由于操作系统的管理工作(比如进程切换、分配IO设备等)需要使用特权指令，因此CPU要从用户态转换为核心态。 中断可以使CPU从用户态切换为核心态，使用操作系统获得计算机的控制权。有了中断，才能实现多道程序并发执行 用户态与核心态的转换： 用户态-&gt;核心态：通过中断实现的，并且只能是中断 核心态-&gt;用户态：通过执行一个特权指令，将程序状态标志设置为用户态 中断的分类： 内中断 外中断 …… 二、进程与线程OS中进程作为资源分配与独立运行的基本单位出现。OS的四大特征(并发、共享、虚拟、异步)都是基于进程而形成的。所以在OS中，进程是一个及其重要的概念 到了80年代中期，又出现了比进程更小的基本单位——线程。用来提高程序并发执行程度，以进一步改善系统的服务质量。现代OS无一例外的引入了线程，线程也是一个重要的概念 2.1 进程的描述进程控制块PCB 为了方便控制和管理参与并发执行的每个程序的独立运行，在操作系统中为之配置一种专门的数据结构，称为进程控制块：PCB(Process Control Block)。 系统利用PCB来描述进程的基本信息与活动过程，进而控制和管理程。 PCB、程序段、数据段三部分构成了进程实体(进程映像)，也叫进程 PCB在进程切换的作用操作系统就是根据PCB来感知进程的存在的。 PCB在进程切换过程中起着非常重要的作用，操作系统可以通过对PCB的修改来达到对进程的控制。 以下是PCB结构体的部分描述属性： 123456789101112131415struct task_struct &#123;long state; // 进程运行状态：-1不可运行，0可运行，&gt;0已停止long priority; // 进程运行优先级long counter; // 已运行时间计数器long exit_code; // 进程停止执行后退出码，其父进程需要读取unsigned long start_code; // 代码段起始地址unsigned long end_code; // 代码段长度，单位字节unsigned long next_code; // 下一条要执行代码的地址unsigned long start_data; // 数据段起始地址unsigned long end_data; // 代码段长度+数据段长度，单位字节unsigned long next_data; // 下一条要读取数据的地址long pid; // 进程标识long father; // 父进程标识...&#125;； 进程定义 从不同的角度，进程可以有不同的定义，比较传统典型的定义有： 进程是程序的一次执行的过程 进程是一个程序以及数据在处理顺序执行时所发生的活动 进程是具有独立功能的程序在数据集合上的运行的过程，它是系统进行资源分配和调度的一个独立单位 这3个定义都强调了**”动态性”** 引入进程实体的概念后，可以把进程定义为： 进程是进程实体的运行程序，是系统进行资源分配和调度的一个独立单位 注意：严格来说，进程实体和进程并不一样，进程实体是静态的，进程则是动态的。不过，除非题目刻意考察二者区别，否则是可以认为进程就是进程实体 引入进程后使得作业的并发执行得以实现， 同时也带来了一些问题： 增加了空间开销 需要为进程创建PCB 增加了时间开销 管理、协调、跟踪进程的执行需要时间 创建、更新、回收PCB需要时间 进程切换、保护、恢复CPU现场需要时间 增加了控制难度 协调多个进程对资源的竞争与共享增加了控制难度 对可能由进程引发的异常进行处理增加了控制难度 2.2 进程状态五种状态根据进程所拥有资源的不同，可以将进程所处的状态划分为五种状态： 就绪状态：进程已经获取到了除处理器之外执行所需的所有资源的状态。 执行状态：进程已经获取到了包括处理器在内的执行所需的所有资源的状态。 阻塞状态：进程在执行过程中因等待某事件的发生而无法继续执行的状态。 创建状态：进程缺少完整PCB与运行所需资源的状态。 终止状态：进程释放所拥有资源的过程的状态。 其中，就绪状态、执行状态、阻塞状态，称为进程的基本状态 状态转换flowchart LR A(创建状态) B(就绪状态) C(执行状态) D(阻塞状态) E(终止状态) A--资源分配-->B--获得CPU-->C--请求I/O-->D D--I/O完成-->B C--释放CPU-->B C--释放PCB-->E 状态转换的特点： 创建好的进程直接到达的是就绪态 就绪态进程无法直接转换为阻塞态 阻塞态只能是进程执行过程中由于等待某事件的发生而引发的 进程只能是在执行时终止 挂起与激活PCB的组织方式不同应用可以产生很多异类进程，一个应用可以产生很多同类进程。无论是何类进程，其会按照它们的 状态将它们组织到一起。 常见的组织方式有两种： 链表方式：同一状态的进程的PCB组成一个链表，所以多种状态的进程PCB组成多个链表。此时就会产生诸如就绪链表、阻塞链表等不同链表。 索引表方式：所有PCB都放入同一链表，再为每种状态创建出不同的PCB索引链表，其中存放的就是该状态的所有PCB的索引 粗俗的理解就是，无论就绪队列，还是阻塞队列中的元素就是PCB 2.3 进程控制进程控制是进程管理中最基本的功能。如，进程的创建与终止、进程状态转换等。进程控制一般是由 OS内核中的原语实现的。 进程控制就是实现进程状态的转换。 进程的创建无论是OS内核创建进程，还是用户进程创建子进程，都是调用了进程创建原语完成的。 进程创建过程 进程创建原语的创建过程如下： 生成进程标识符PID 这是一个数字标识符，用于区分系统中的所有进程，在系统中具有唯一 性。 申请空白PCB。 为进程分配其运行所需的一切资源(除CPU外) 这些资源要么从OS直接获得，要么从父进程获 得。 初始化PCB。 这些初始化信息包括自己的PID及父进程的PID，当前处理器的状态数据，进程的状态数据。 将进程写入就绪队列 (创建态-&gt;就绪态) 进程创建事件 一个进程可以由系统内核创建，也可以由另一个进程创建。发生进程创建的典型事件有三类： 用户登录：在分时系统中，用户登录后，系统内核会为该用户创建一个进程。 作业调度：在多道批处理系统中，当作业调度程序调度到某作业后，会将其装入内存，并由系统 内核为该作业创建一个进程。 提供服务：当某进程在运行过程中提出某种请求后，系统内核或主进程将会创建一个相应的子进程来处理该请求，以使主进程与子进程可以并发执行。 例如，用户进程提交了一个文件打印请求后，系统内核会创建一个打印进程来处理该请求。 应用请求：由用户主动请求创建一个子进程 进程的终止进程终止过程 系统中发生进程终止事件，OS就会调用进程终止原语去终止进程。 进程终止原语的终止过程如下： 根据被终止进程的PID，找出其PCB。 从PCB中读取其状态，若该进程处于执行态，则立即终止其执行，并置调度标志为真，用于标志该进程可被重新调度。 从PCB中读取其子进程PID，若该进程还有子进程，则要将其所有子进程全部终止。 从PCB中读取其所拥有的全部资源，并全部释放，归还给其父进程或系统。 这个资源释放的过程主要包含两步： 将其PCB赋值为null 在其父进程或系统的资源数量上增加相应释放的数量。 将该进程的PCB从PCB队列或链表中移出。 释放该PCB空间。 进程终止事件 引起进程终止的事件典型的有三类： 正常结束：进程的任务正常执行完毕后的进程终止。当进程的任务执行完毕后，进程会发出一条终止指令，此时会产生一个中断，以通知OS进程马上终止。 异常结束：进程在运行过程中发生了某种异常事件，导致进程无法继续运行。 常见的异常事件有： 访问越界 非法指令 权限异常 运行超时 等待超时 运算异常 IO异常 外界干预：进程被外界干预终止。 外界干预主要指三方面： 用户直接终止 OS终止 父进程终止 进程的堵塞与唤醒进程阻塞 阻塞是进程自身的一种主动行为。当系统中发生进程阻塞事件后，进程自己会调用进程阻塞原语将自 己阻塞。 进程阻塞原语的阻塞过程如下： 立即暂停CPU的执行，保留当前CPU的现场。 将PCB中的状态由执行态修改为阻塞态。 将PCB写入到相应阻塞原因的阻塞队列。 启动调度程序进行重新调度，即将CPU分配给另一就绪进程。 按照新进程的PCB设置CPU新的环境。 引发进程阻塞的事件 进程发生阻塞是由于**正在执行的进程突然发生执行条件缺失事件(需要等待系统分配资源和等待相互合作的进程的完成工作)**，进而暂停执行等待条件的满足 进程唤醒 进程唤醒过程 当被阻塞进程所期待的事件发生时，由“相关进程(促使执行条件满足的进程)”调用唤醒原语，将阻塞进程唤醒(唤醒是进程的被动行为)。 进程唤醒原语的唤醒过程如下： 将该进程的PCB从阻塞队列移出。 修改PCB中的状态由阻塞变为就绪。 将PCB插入到就绪队列 阻塞进程被唤醒则是由于发生了某些事件，从而具备了执行条件，到达了执行时机。 2.4 进程通信共享存储为了保证安全，一个进程不能直接访问另一个进程的地址空间 在通信的进程之间存在一块可直接访问的共享空间，通过对这片共享空间进行写&#x2F;读操作实现进程之间的信息交换。 两个进程对共享空间的访问必须是互斥的(互斥访问通过操作系统提供的工具实现)。 互斥访问就是在同一时间只能有一个进程对同一资源进行访问 操作系统只负责提供共享空间和同步互斥工具(如P、V操作)。 共享方式分为两种： 低级方式的共享是基于数据结构的共享 基于数据结构的共享：比如共享空间里只能发放一个长度为10的数组，这种共享方式速度慢，限制多，是一种低级通信方式。 高级方式的共享则是基于存储区的共享 基于存储区的共享：在内存中画出一块共享存储区，数据的形式、存放的位置都由进程决定，而不是操作系统。相比之下，这种共享方式速度更快，是一种高级通信方式。 管道通信 “管道”是指用于连接读写进程的一个共享文件，又名pipe文件，其实就是在内存中开辟的一个大小固定的缓冲区。 管道通信只能采用半双工通信，某一个时段内只能实现单向的传输，如果要实现双向同时通信，则需要设置两个管道。 各个进程要互斥的访问管道。write 数据以字符流的形式写入管道，当管道写满时，写进程的write()系统调用将被阻塞，等待读进程将数据取走。当读进程将数据全部取走后，管道变空，此时读进程的read()系统调用将被阻塞。 注意：如果没有写满，是不允许读的，如果没有读空，是不允许写的。 数据一旦被读出，就会从管道中被抛弃，这就意味着读进程最多只能有一个，否则可能会有读错数据的情况。 消息传递进程间的数据交换以格式化的消息(Message)为单位。 进程通过操作系统提供的”发送消息&#x2F;接收消息”两个原语进行数据交换 格式化的消息分为：消息头和消息体 消息头：包括发送的进程ID、接受进程ID、消息类型、消息长度等格式化信息 直接通信方式：A进程发送消息(原语)直接挂到接收进程B的消息缓冲队列上 间接通信方式：发送消息(原语)要先发送到**中间实体(信箱)**中，因此也称”信箱通信方式”。如：计网中的电子邮箱系统 2.5 线程的描述为什么要引入线程 进程是资源分配的基本单位，也是调度的基本单位 引入线程之后，线程是CPU调度的基本单位 由于切换进程时，需要保存&#x2F;恢复进程运行环境，还需要切换内存地址空间(更新快表、更新缓冲) 引入线程后，同一个进程内各个线程间并发，不需要切换进程运行环境和内存地址空间，省时省力。 注意：从属于不同进程的线程间的切换，也会导致进程的切换，开销也大 引入进程的目的是： 为了更好的让多道程序并发执行，提高资源利用率和系统吞吐量 为了减少程序在并发执行时所付出的时空开销，提高操作系统的并发性能。 进程可能需要”同时”做很多事情，而传统的进程只能 线程的特点 各个进程的内存地址空间相互独立，只能通过请求操作系统内核的帮助来完成进程之间的通信。 但同一个进程下的各个线程之间共享内存地址空间，可以直接通过读&#x2F;写内存空间进行通信。 从属于同一个进程各个线程共享进程的所有资源。 进程之间的通信必须请求操作系统服务(CPU要求换到核心态)，开销大。 同进程下的线程间通信不需要操作系统干预，开销更小。 引入线程前，进程既是资源分配的基本单位，也是调度的基本单位。 但是引入线程后，进程是资源分配的基本单位，而线程是调度的基本单位。同样线程也有运行态，就绪态和阻塞态。 而线程几乎不拥有资源，只拥有极少量的资源(线程控制块TCB、寄存器信息、堆栈等) 在多核CPU环境下，各个线程也可以分配到不同的CPU上并行的执行。 2.6 线程的实现方式线程分为：用户级线程和内核级线程 用户级线程 用户级线程由应用程序通过线程库实现，所有的线程管理工作都由应用程序负责(包括线程切换) 用户级线程中，线程切换可以在用户态下即可完成，无需操作系统干预。 在用户看来，是有多个线程，但是在操作系统的内核来看，并不意识到线程的存在。 “用户级线程”就是从用户视角所能看到的线程。 优点：用户级线程的切换在用户空间即可完成，不需要切换到核心态，线程管理的系统开销小，效率高。 缺点：当一个用户级线程被阻塞后，整个线程都会被阻塞，并发度不高。多个线程必须在多核处理机上并行运行。 在用户级线程中，CPU调度的基本单位依旧是进程，并非线程 ​ 内核级线程 内核级线程：又称”内核支撑的线程”，是由操作系统支撑的线程。 大多数的现代操作系统都实现了内核级线程，如Windows、Linux。 内核级线程的管理工作是由操作系统内核完成。 线程调度和切换等工作都是由内核负责，因此内核级线程的切换必然需要在核心态下才能完成。 操作系统会为**每个内核级线程建立相应的TCB(进程控制块)**，通过TCB对线程进行管理”。 “内核级线程”就是从操作系统内核视角看到的线程。 优点：当一个线程被阻塞后，别的线程还可以继续执行，并发能力强。多线程可在多核处理机上并行执行。 缺点：一个用户进程会占用多个内核程序，线程切换由操作系统内核完成，需要从用户态变为核心态，因此线程管理的成本高，开销大。 2.7 多线程模型一对一模型一对一模型： 一个用户及线程映射到一个肉核级线程。每个用户进程有与用户级线程同数量的内核级线程。 优点：当一个线程被阻塞后，别的线程还可以继续执行，并发能力强。多线程可在多核处理机上并行执行。 缺点：一个用户进程会占用多个内核级线程，线程切换由操作系统内核完成，需要切换到核心态，因此线程管理的成本高，开销大。 多对一模型多对一模型： 多个用户及线程映射到一个内核级线程。每个用户进程只对应一个内核级线程。 优点：用户级线程的切换在用户空间即可完成，不需要切换到核心态，线程管理的系统开销小，效率高 缺点：当一个用户级线程被阻塞后，整个进程都会被阻塞，并发度不高。多个线程不可在多核处理机上并行运行 多对多模型多对多模型： n用户及线程映射到m个内核级线程(n&gt;&#x3D;m)。每个用户进程对应m个内核级线程。 克服了多对一模型并发度不高的缺点，又克服了一对一模型中一个用户进程占用太多内核级线程，开销太大的缺点。 2.8 处理机调度 当有一堆任务要处理，但由于资源有限，这些事情没法同时处理。这就需要确定某种规则(时间短优先、先来先服务等)来决定这些任务的顺序，这就是“调度”研究的问题。 在多道程序系统中，进程的数量往往是多于处理机的个数的，这样不可能同时并行的处理各个进程。 处理机调度：就是从就绪队列中按照一定的算法选择一个进程并将处理机分配给它运行，以实现进程的并发执行。 高级调度高级调度是，也称为作业调度，根据不同的作业调度算法，将磁盘中后备队列中的不同的若干作业调入 内存的过程。作业一旦被调入内存，就会将其创建为进程，并为之分配必要的资源，进入就绪队列。 高级调度，主要存在于多道批处理系统，实时系统与分时系统中没有该调度方式 中级调度中级调度，也称为内存调度，也是OS中最基本的一种调度，是为提高内存利用率与系统吞吐量而引入 的一类调度。其功能是，将内存中暂时不能运行的进程，调到外存等待。当具备运行条件且内存有空闲 时，再根据不同的调度算法将其重新调入到内存。 中级调度，无论是多道批处理系统，还是分时系统、实时系统，都存在该调度方式 低级调度低级调度是，也称为进程调度，是OS中最基本的一种调度，是一个根据不同的进程调度算法，选择不 同的进程为其分配处理机的过程。 低级调度，无论是多道批处理系统，还是分时系统、实时系统，都存在该调度方式 2.9 进程调度进程调度的时机进程调度(低级调度)，就是按照某种算法从就绪队列中选择一个进程为其分配处理机。 需要进行进程调度与切换的情况： 当前运行的进程主动放弃处理机 进程正常终止 运行过程中发生异常而终止 进程主动请求阻塞，如等待I&#x2F;O 当前运行的进程被动放弃处理机 分给进程的时间片用完 有更紧急的事需要处理，如I&#x2F;O中断 有更高优先级的进程进入就绪队列 不能进行进程调度与切一换的情况： 在处理中断的过程中。中断处理过程复杂，与硬件密切相关，很难做到在中断处理过程中进行进程切换。 进程在操作系统内核程序临界区中。 在原子操作过程中(原语)。原子操作不可中断，要一气呵成。如之前讲过的修改PCB中进程状态标志，并把PCB放到相应队列 进程调度的方式 非剥夺调度方式，又称非抢占方式： 即，只允许进程主动放弃处理机。在运行过程中即便有更紧迫的任务到达，当前进程依然会继续使用处理机，直到该进程终止或主动要求进入阻塞态。特点：实现简单，系统开的小但是无法及时处理紧急任务，适合于早期的批处理系统 剥夺调度方式，又称抢占方式： 当一个进程正在处理机上执行时，如果有一个更重要或更紧迫的进程需要使用处理机，则立即暂停正在执行的进程，将处理机分配给更重要紧迫的那个进程。特点：可以优先处理更紧急的进程，也可实现让各进程按时间片轮流执行的功能(通过时钟中断)。适合于分时操作系统、实时操作系统 进程的切换与过程“狭义的进程调度”与“进程切换”的区别： 狭义的进程调度：指的是从就绪队列中选中一个要运行的进程(这个进程可以是刚刚被暂停执行的进程，也可能是另一个进程，后一种情况就需要进程切换) 进程切换：是指一个进程让出处理机，由另一个进程占用处理机的过程。 广义的进程调度：包含了选择一个进程和进程切换两个步骤。 进程切换过程完成后： 对原来运行进程各种数据的保存 对新的进程各种数据的恢复 如：程序计数器、程序状态字、各种数据寄存器等处理机现场信息，这些信息一班保存在进程控制块PCB中 注意：进程切换是有代价的，不能说进程切换越频繁系统并发性就越好，因为如果过于频繁的进行进程调度、切换，必然会使得整个系统的效率降低，使得系统大部分时间都花在了进程的切换上，而真正用于执行进程的时间减少。 2.10 调度算法调度算法的评价指标调度算法的评价指标主要有：CPU利用率，系统吞吐量、周转时间、等待时间和响应时间 CPU利用率：指的是CPU”忙碌”的时间占总时间的比例 利用率 = CPU忙碌的时间 / 总时间 系统吞吐量：单位时间内完成作业的数量 系统吞吐量 = 总共完成了多少道作业 / 总共花了多少时间 周转时间：是指从作业被提交给系统开始，到作业完成为止的这段时间间隔 周转时间 = 作业完成时间 - 作业提交时间 对于用户，更关心自己的单个作业的周转时间 平均周转时间 = 各个作业周转时间之和 / 作业数 对于操作系统，更关心系统的整体表现，因此更关心所有作业的周转时间的平均值 带权周转时间 = 作业周转时间 / 作业实际运行时间 ​ = (作业完成时间 - 作业提交时间) / 作业实际运行时间 带权周转时间与周转时间都是越小越好(带权周转时间必然 &gt;&#x3D; 1) 平均带权周转时间 = 各个带权周转时间之和 / 作业数 等待时间：指进程&#x2F;作业处于等待处理机状态时间之和，等待时间越短，用户越满意 对于进程来说，等待时间就是指进程建立后等待被服务的时间之和，在等待I&#x2F;O完成的期间其实进程也是被服务的，所以不计入等待时间。 而对于作业来说，不仅要考虑建立进程后的等待时间，还要加上作业在外存后备队列中的等待时间。 一个作业总共需要被CPU服务多久，被I&#x2F;O设备服务多久一般是确定不变的，因此调度算法其实只能影响作业或者进程的等待时间。当然，与前面指标类似，也有”平均等待时间”来评价整体性能。 响应时间：指从用户请求到首次产生响应所用的时间 调度算法一**先来先服务(FCFS)**： 例题：各进程到达就绪队列的时间、需要的运行时间如下表所示。使用先来先服务调度算法，计算各进程的等待时间、平均等待时间、周转时间、平均周转时间、带权周转时间、平均带权周转时间。 进程 到达时间 运行时间 开始运行时间 p1 0 7 0 p2 2 4 7 &#x3D; 7 p3 4 1 7 + 4 &#x3D; 11 p4 5 4 7 + 4 + 1 &#x3D; 12 先来先服务调度算法：按照到达的先后顺序调度,,事实上就是等待时间越久的越优先得到服务。 调度顺序：p1-&gt;p2-&gt;p3-&gt;p4 周转时间&#x3D;完成时间-到达时间 带权周转时间&#x3D;周转时间&#x2F;运行时间 等待时间&#x3D;周转时间-运行时间 平均周转时间&#x3D;(7+9+8+11)&#x2F;4&#x3D;8.75 平均带权周转时间&#x3D;(1+2.25+8+2.75)&#x2F;4&#x3D; 3.5 平均等待时间&#x3D;(0+5+7+7)&#x2F;4 &#x3D; 4.75 FCFS算法： 算法思想：主要从“公平”的角度考虑(类似于我们生活中排队买东西的例子) 算法规则：按照作业&#x2F;进程到达的先后顺序进行服务 用于作业&#x2F;进程调度：用于作业调度时，考虑的是哪个作业先到达后备队列；用于进程调度时，考虑的是哪个进程先到达就绪队列 是否可抢占：非抢占式的算法 优缺点： 优点:公平、算法实现简单 缺点:排在长作业(进程)后面的短作业需要等待很长时间，带权周转时间很大，对短作业来说用户体验不好。即，FCFS算法对长作业有利，对短作业不利(Eg :排队买奶茶…) 是否会导致饥饿(某进程&#x2F;作业长期得不到服务)：不会 **短作业优先(SJF)**： 一个作业可以由多个进程组成,且一个作业至少由一个进程组成 1.非抢占式的短作业优先算法 例题：各进程到达就绪队列的时间、需要的运行时间如下表所示。使用非抢占式的短作业优先调度算法，计算各进程的等待时间、平均等待时间、周转时间、平均周转时间、带权周转时间、平均带权周转时间。 进程 到达时间 运行时间 开始运行时间 p1 0 7 0 p2 2 4 7 + 1 &#x3D; 8 p3 4 1 7 &#x3D; 7 p4 5 4 7 + 4 + 1 &#x3D; 12 短作业&#x2F;进程优先调度算法:每次调度时选择当前已到达且运行时间最短的作业&#x2F;进程。 因此，调度顺序为：p1-&gt;p3-&gt;p2-&gt;p4 周转时间&#x3D;完成时间-到达时间 带权周转时间&#x3D;周转时间&#x2F;运行时间 等待时间&#x3D;周转时间-运行时间 平均周转时间&#x3D; (7+4+10+11)&#x2F;4 &#x3D; 8 平均带权周转时间&#x3D; (1+4+2.5+2.75)&#x2F;4&#x3D; 2.56 平均等待时间&#x3D;(0+3+6+7)&#x2F;4&#x3D; 4 对比FCFS算法的结果，显然SPF算法的平均等待&#x2F;周转&#x2F;带权周转时间都要更低 2.抢占式的短作业优先算法(又称最短剩余时间优先算法 SRTN) 例题：各进程到达就绪队列的时间、需要的运行时间如下表所示。使用抢占式的短作业优先调度算法,计算各进程的等待时间、平均等待时间、周转时间、平均周转时间、带权周转时间、平均带权周转时[间。 进程 到达时间 运行时间 开始运行时间 p1 0 7 0~2，11~16 p2 2 4 2~4，5~7 p3 4 1 4~5 p4 5 4 7~11 最短剩余时间优先算法:每当有进程加入就绪队列改变时就需要调度，如果新到达的进程剩余时间比当前运行的进程剩余时间更短，则由新进程抢占处理机，当前运行进程重新回到就绪队列。另外，当一个进程完成时也需要调度 周转时间&#x3D;完成时间-到达时间 带权周转时间&#x3D;周转时间&#x2F;运行时间 等待时间&#x3D;周转时间-运行时间 平均周转时间&#x3D;(16+5+1+6)&#x2F;4 &#x3D; 7 平均带权周转时间&#x3D;(2.28+1.25+1+1.5)&#x2F;4&#x3D; 1.50 平均等待时间&#x3D;(9+1+0+2)&#x2F;4&#x3D; 3 对比非抢占式的短作业优先算法，显然抢占式的这几个指标又要更低 短作业优先算法： 算法思想： 追求平均等待时间，平均周转时间，平均带权周转时间最短 算法规则：服务时间最短的优先得到服务 作业调度：SJF短作业优先 进程调度：SPF短进程优先 是否抢占式： SJF和SPF是非抢占式的算法。 但是也有抢占式的版本——最短剩余时间优先算法SRTM 优缺点： 优点：“最短的”平均等待时间、平均周转时间(前提是所有进程同时可运行或者说所有进程几乎都同时到达)因为最短剩余时间优先算法得到的平均等待时间、平均周转时间还要更少 缺点：不利于长作业，对短作业有利，由此可能产生饥饿现象 是否导致饥饿：会，当短作业&#x2F;进程不断到来会导致长作业&#x2F;进程长时间得不到服务 **高响应比优先(HRRN)**： 例题：各进程到达就绪队列的时间、需要的运行时间如下表所示。使用高响应比优先调度算法，计算各进程的等待时间、平均等待时间、周转时间、平均周转时间、带权周转时间、平均带权周转时间。 进程 到达时间 运行时间 p1 0 7 p2 2 4 p3 4 1 p4 5 4 高响应比优先算法:非抢占式的调度算法，只有当前运行的进程主动放弃CPU时(正常&#x2F;异常完成，或主动阻塞)，才需要进行调度，调度时计算所有就绪进程的响应比，选响应比最高的进程上处理机。 响应比=(等待时间+要求服务时间)/要求服务时间 0时刻：只有p1到达就绪队列，p1上处理机 7时刻(P1主动放弃CPU)：就绪队列中的响应比：p2：(5+4)/4=2.25、p3：(3+1)/1=4、p4：(2+4)/4=1.5 8时刻(P3完成)：响应比：P2：(6+4)/4=2.5、P4：(3+4)/4=1.75 12时刻(P2完成)：就绪队列中只剩下P4 高响应比优先调度算法： 算法思想：要综合考虑作业&#x2F;进程的等待时间和要求服务的时间 算法规则： 在每次调度时先计算各个作业&#x2F;进程的响应比，选择响应比最高的作业&#x2F;进程为其服务要求服务时间 响应比&#x3D; -等待时间+要求服务时间 用于作业&#x2F;进程调度：即可用于作业调度，也可用于进程调度 是否可抢占：非抢占式的算法。因此只有当前运行的作业&#x2F;进程主动放弃处理机时，才需要调度，才需要计算响应比 优缺点：综合考虑了等待时间和运行时间(要求服务时间)等待时间相同时，要求服务时间短的优先( SJF的优点)要求服务时间相同时，等待时间长的优先(FCFS的优点)对于长作业来说，随着等待时间越来越久，其响应比也越来越大，从而避免了长作业饥饿的问题 是否会导致饥饿：不会 调度算法二时间片轮转法： 例题：各进程到达就绪队列的时间、需要的运行时间如下表所示。使用时间片轮转调度算法，分析时间片大小分别是2、5时的进程运行情况 进程 到达时间 运行时间 p1 0 5 p2 2 4 p3 4 1 p4 5 6 时间片轮转调度算法：轮流让就绪队列中的进程依次执行一个时间片(每次选择的都是排在就绪队列队头的进程) 时间片大小为5 0时刻(p1(5))：只有p1到达，p1上处理机 2时刻(p2(4))：p2到达，但P1时间片尚未结束，因此暂不调度 4时刻(p2(4)-&gt;p3(1))：p3到达，但p1时间片尚未结束，因此暂不调度 5时刻(p2(4)-&gt;p3(1)-&gt;p4(6))：p4到达，同时，p1运行结束。发生调度，p2上处理机 9时刻(p3(1)-&gt;P4(6)：p2运行结束，虽然时间片没用完，但是会主动放弃处理机。发生调度 10时刻(p4(6))：p3运行结束，虽然时间片没用完，但是会主动放弃处理机。发生调度。 15时刻()：p4时间片用完，但就绪队列为空，因此会让p4继续执行一个时间片。 16时刻()：p4运行完，主动放弃处理机。所有进程运行完。 算法思想：公平地、轮流地为各个进程服务，让每个进程在一定时间可隔内都可以得到响应 算法规则：按照各进程到达就绪队列的顺序，轮流让各个进程执行一个时间片（如100ms）。若进程未在一个时间片内执行完则剥夺处理机，将进程重新放到就绪队列队尾重新排队 用于作业&#x2F;进程调度：用于进程调度（只看作亚放入内存建立了相应的进程后，不能被分配处理机时间片） 是否可抢占：若进程来能在时间片内运行完，将被强行刺夺处理机使用权，因此时间片轮转调度算法属于抢占式的算法。由时钟装置发出时钟中断来通知CPU时间片已到 优缺点： 优点：公平：响应快，适用于分时操作系统 缺点：由于高频率的进程切换，因此有一定开销：不区分任务的紧急程度。 是否会导致机饿：不会 补充：时间片太大或太小分别有什么影 优先级调度算法： 1.非抢占式的优先级调度算法 2.抢占式的优先级调度算法 多级反馈队列调度算法 …… 2.11 进程同步进程同步进程具有异步性的特征。异步性是指，并发执行的进程以各自独立的、不可预知的速度向前推进。而进程同步就是用来解决这种异步问题。 同步也称直接制约关系，它是指为完成某种任务而建立的两个或多个进程，这些进程因为需要在某些位置上协调它们工作次序而产生的制约关系。进程间的直接制约关系是源于他们之间的相互合作。 进程互斥我们把一个时间段内只允许一个进程使用的资源称为临界资源。许多物理设备（比如摄像头、打印机）都属于临界资源。此外还有许多变量、数据、内存缓冲区都属于临界资源。 对临界资源的访问，必须互斥的进行。互斥，也称间接制约关系。进程互斥指的是当一个进程访问某个临界资源时，另一个想要访问的该临界资源的进程必须等待。当前访问临界资源的进程访问结束，释放该资源之后，另一个进程才能访问该临界资源。 对临界资源的互斥访问，可以在逻辑上分为如下四个部分： 123456do &#123; entry section; //进入区 critical section; //临界区 exit section; //退出区 remainder section; //剩余区&#125;while(true) 进入区：负责检查是否可以进入临界区，若可以进入，则应设置正在访问临界资源的标志(可以理解为”上锁”)，以阻止其他进行同时进入临界区 临界区：访问临界资源的那段代码 退出区：负责解除正在访问临界资源的标志(可理解为”解锁”) 剩余区：做其他处理 注意： 临界区是进程中访问临界资源的代码段 进入区和退出区是负责实现互后的代码段 临界区也可称为”临界段” 为了实现对临界资源的互斥访问，同时保证系统整体性能， 需要遵循以下原则： 空闲让进。临界区空闲时，可以元许一个请求进入临界区的进程立即进入临界区； 忙则等待。当己有进程进入临界区时，其他试图进入临界区的进程必须等待； 有限等待。对请求访问的进程，应保证能在有限时间内进入临界区(保证不会饥饿)； 让权等待。当进程不能进入临界区时，应立即释放处理机，防止进程忙等待。 2.12 进程互斥的软件实现单标志法算法思想：两个进程在访问完临界区后会把使用临界区的权限转交给另一个进程。也就是说每个进程进入临界区的权限只能被另一个进程赋予 1int turn = 0; //turn 表示当前允许进入临界区的进程号 p0进程： 1234while (turn != 0); //进入区critical section; //临界区turn = 1; //退出区remainder section; //剩余区 p1进程： 1234while (turn != 1); //进入区，如果不为1，则一直卡在while循环中，等待critical section; //临界区turn = 0; //退出区remainder section; //剩余区 turn 表示当前允许进入临界区的进程号，而只有当前允许进入临界区的进程在访问了临界区之后，才会修改 turn 的值。也就是说，对于临界区的访问，一定是按p0-&gt;p1-&gt;p0-&gt;p1-&gt;…这样轮流访问。 这种必须 “轮流访问”带来的问题是，如果此时允许进入临界区的进程是p0，而p0一直不访问临界区，那么虽然此时临界区空闲，但是并不允许p1访问。 单标志法存在的主要问题：违背”空闲让进”的原则 双标志先检查法算法思想：设置一个布尔型数组 flag[]，数组中各个元素用来标记各进程想进入临界区的意愿，比如”flag[0]&#x3D;ture”意味着0号进程p0现在想要进入临界区。每个进程在进入临界区之前先检套当前有没有别的进程想进入临界区，如果没有，则把自身对应的标志 flag[i] 设为true，之后开始访问临界区。 123bool flag[2]; //表示进入临界区意愿的数组flag [0] = false;flag [1] = false; //刚开始设置为两个进程都不想进入临界区 p0进程： 12345while (flag[1]);flag [0l = true;critical section; flag [0] = false;remainder section; p1 进程： 12345while (flag[0]); //如果此时p0想进入临界区，p1就一直循环等待flag [1] = true; //标记为p1进程想要进入临界区critical section; //访问临界区flag [1] = false; //访问完临界区，修改标记为p1不想使用临界区remainder section; 但是有可能会导致p0和p1同时访问临界区 因此，双标志先检查法的主要问题是：违反”忙则等待”原则 原因在于，进入区的”检查”和”上锁” 两个处理不是一气呵成的。”检查” 后，”上锁”前可能发生进程切换。 双标志后检查法算法思想：双标志先检查法的改版。前一个算法的问题是先 “检查”后“上锁”，但是这两个操作又无法一气呵成，因此导致了两个进程同时进入临界区的问题。因此，人们又想到先 “上锁〞 后“检查”的方法，来避免上述问题。 123bool flag[2]; //表示进入临界区意愿的数组flag[0] = false;flag[1] = false; //刚开始设置为两个进程都不想进入临界区 p0进程： 12345flag[0] = true;while (flag[1]);critical section; flag[0] = false;remainder section; p1进程： 12345flag[1] = true; //标记为 P1 进程想要进入临界区while (flag[0]); //如果 PQ 也想进入临界区，则 P1 循环等待critical section; //访问临界区flag[1] = false; //访问完临界区，修改标记为 P1 不想使用临界区remainder section; 有可能会导致p0和p2将都无法进入临界区 因此，双标志后检查法虽然解决了 “忙则等待” 的问题，但是又违背了“空闲让进”和“有限等待”原则，会因各进程都长期无法访问临界资源而产生 “饥饿”现象。 两个进程都争着想进入临界区，但是谁也不让谁，最后谁都无法进入临界区。 Peterson算法算法思想：双标志后检查法中，两个进程都手着想进入临界区，但是谁也不让谁，最后谁都无法进入临界区。Gary L. Peterson 想到了一种方法，如果双方都争着想进入临界区，那可以让进程尝试 “孔融让梨”，主动让对方先使用临界区。 12bool flag[2]; //表示进入临界区意愿的数组，初始值都是falseint turn =0; //turn 表示优先让哪个进程进入临界区 p0进程： 1234567flag[0] = true; //三部分合为进入区：turn = 1: //主动争取while (flag[1] &amp;&amp; turn==1); //主动谦让 //检查对方是否也想使用，且最后一次是不是自己说了&quot;客气话&quot;critical section;flag [0] = false;remainder section; p1进程： 123456flag [1] = true; //表示自己想进入临界区turn = 0; //可以优先让对方进入临界区while (flag[0] &amp;&amp; turn==0); //对方想进，且最后一次是自己&quot;让梨&quot;，那自己就循环等待critical section;flag[1] = false; //访问完临界区，表示自己已经不想访问临界区了remainder section; Peterson算法用软件方法解决了进程互斥问题，遵循了空闲让进、忙则等待、有限等待三个原则，但是依然未遵循让权等待的原则。 2.13 进程互斥的硬件实现中断屏蔽方法利用”开&#x2F;关中断指令”实现(与原语的实现思想相同，即在某进程开始访问临界区到结束访问为止都不允许被中断，也就不能发生进程切换，因此也不可能发生两个同时访问临界区的情况) 12345...关中断; //关中断后即不允许当前进程被中断，也必然不会发生进程切换临界区;开中断; //直到当前进程访问完临界区，再执行开中断指令，才有可能有别的进程上处理机并访问临界区... 优点：简单、高效 缺点：不适用于多处理机；只适用于操作系统内核进程，不适用于用户进程(因为开&#x2F;关中断指令只能运行在内核态，这组指令如果能让用户随意使用会很危险) TestAndSet指令简称TS指令，或TSL指令 TSL指令是用硬件实现的，执行的过程不允许被中断，只能一气呵成。 以下是用C语言描述： 1234567891011121314//布尔型共享变量 lock 表示当前临界区是否被加锁//true 表示已加锁，false 表示未加锁bool TestAndset (bool *lock)&#123; bool old; old=*lock; //old用来存放Lock 原来的值 *lock = true; //无论之前是否已加锁，都将1ock设为true return old; //返回lock原来的值&#125;//以下是使用 TSL 指令实现互斥的算法逻辑while (TestAndset(&amp;lock)); //&quot;上锁&quot;并&quot;检查&quot;临界区代码段...lock = false; //解锁剩余区代码段... 若刚开始 lock 是false，则TSL返回的old 值为false， while 循环条件不满足，直接跳过循环，进入界区。 若刚开始 lock 是true，则执行TLS后old 返回的值为true， while 循环条件满足，会一直循环，直到当前访问临界区的进程在退出区进行 “解锁”。 相比软件实现方法，TSL指令把”上锁”和”检查”操作用硬件的方式变成了一气呵成的原子操作。 优点：实现简单，无需像软件实现方法那样严格检查是否会有逻辑漏洞；适用于多处理机环境 缺点：不满足”让权等待”原则，暂时无法进入临界区的进程会占用CPU并循环执行TSL指令，从而导致”忙等” Swap指令有的地方也叫 Exchange 指令，或简称XCHG 指令。 Swap 指令是用硬件实现的，执行的过程不允许被中断，只能一气呵成。 以下是用C语言描述： 12345678910111213141516//Swap 指令的作用是交换两个变量的值Swap (bool *a， bool *b)&#123; bool temp; temp = *a; *a = *b; *b = temp;&#125;//以下是用 Swap指令实现互斥的算法逻辑//lock 表示当前临界区是否被加锁bool old = true;while (old == true) Swap(&amp;lock, Sold);临界区代码段...lock = false;剩余区代码段... 逻辑上来看 Swap 和TSL 并无太大区别，都是先记录下此时临界区是否已经被上锁(记录在old变量上)，再将上锁标记 lock 设置为true，最后检查old，如果old 为false 则说明之前没有别的进程对临界区上锁，则可跳出循环，进入临界区。 优点：实现简单，无需像软件实现方法那样严格检查是否会有逻辑漏洞；适用于多处理机环境 缺点：不满足”让权等待” 原则，暂时无法进入临界区的进程会占用CPU并循环执行TSL指令，从而导致”忙等”。 2.14 信号量机制用户进程可以通过使用操作系统提供的一对原语来对信号量进行操作，从而很方便的实现了进程互斥、进程同步。 信号量其实就是一个变量(可以是一个整数，也可以是更复杂的记录型变量)，可以用一个信号量表示系统中某种资源的数量，比如：系统中只有一台打印机，就丽以设置一个初值为1的信号量。 原语是一种特殊的程序段，其执行只能一气呵成，不可被中断。原语是由关中断&#x2F;开中断指令实现的。软件解决方案的主要问题是由 “进入区的各种操作无法一气呵成”，因此如果能把进入区、退出区的操作都用 “原语〞实现，使这些操作能 “一气呵成”就能避免问题。 一对原语：wait(S) 原语和signal(S)原语，可以把原语理解为我们自1己写的函数，函数名分别为 wait和signal，括号里的信号量S其实就是函数调用时传入的一个参数。 wait、signal 原语常简称为P、V操作。因此，做题的时候常把wait(S)、signal(S)两个操作分别写为 P(S)、V(S) 整型信号量用一个整数型的变量作为信号量，用来表示系统中某种资源的数量。 Eg：某计算机系统中有一台打印机… 12345678int S = 1; //初始化整型信号量s，表示兰前系统中可用的打印机资源数void wait(int S) &#123; //wait原语，相当于&quot;进入区&quot;，检查、上锁一并合成，避免并发和异步问题 while (S &lt;= 0); //如果资源数不够，就一直循环等待，会发生&quot;让权等待&quot;，发生&quot;忙等&quot; S=S-1; //如果资源数够，则占用一个资源 void signal(int S) &#123; //signal原语，相当于&quot;退出区&quot; S=S+1; //使用完资源后，在退出区释放资源&#125; 进程p0~pn： 12345...wait(S); //进入区，申请资源使用打印机资源... //临界区，访问资源signal(S); //退出区，释放资源... 记录型信号量整型信号量的缺陷是存在“忙等”问题，因此人们又提出了 “记录型信号量”，即用记录型数据结构表示的信号量。 1234567891011121314151617181920212223/*记录型信号量的定义*/typedef struct &#123; int value; //剩余资源数 struct process *L; //等待队列&#125; semaphore;/*某进程需要使用资源时，通过wait原语申请*/void wait (semaphore S) &#123; S.value--; if(S.value &lt; 0) &#123; /*如果剩余资源不够，使用block原语使进程从运行态进入阻塞态，并把信号量S的等待队列L中*/ block(S.L); &#125;&#125;/*进程使零完资源后，通过signal原语释放*/void signal(semaphore S) &#123; S.value++; if(S.value &lt;= 0) &#123; /*释放资源后，若还有别的进程在等待这种资源，则使用wakeup原语唤醒等待队列L中的一个进程，使进程从阻塞态进入就绪态*/ wakeup(S.L); &#125;&#125; Eg：某计算机系统中有2台打印机…，则可在初始化信号量S时将 S.value 的值设为2，队列 S.L 设置为空 一共有p0、p1、p2、p3进程： p0调用wait(S);-&gt;S.value-1变为1，使用打印机 p1调用wait(S);-&gt;S.value-1变为0，使用打印机 p2调用wait(S);-&gt;S.value-1变为-1。打印机不够，p2进入等待队列，此时有1个进程等待 p3调用wait(S);-&gt;S.value-1变为-2。打印机不够，p3也进入等待队列，此时有2个进程等待 p0结束使用打印机，调用signal(S);-&gt;S.value+1变为-1。S.value&lt;=0说明有进程在等待该资源，唤醒等待队列中的1个进程p2，p2使用打印机 p1结束使用打印机，调用signal(S);-&gt;S.value+1变为0。S.value&lt;=0说明有进程在等待该资源，唤醒等待队列中的1个进程p3，p3使用打印机 p2结束使用打印机，调用signal(S);-&gt;S.value+1变为1。S.value&gt;0说明不存在进程等待该资源 p3结束使用打印机，调用signal(S);-&gt;S.value+1变为2。S.value&gt;0说明不存在进程等待该资源 实现进程互斥 分析并发进程的关键活动，划定临界区（如：对临界资源打印机的访问就应放在临界区） 设置互斥信号量mutex，初值为 1 在临界区之前执行 P(mutex) 在临界区之后执行 V(mutex) 注意： 对不同的临界资源需要设置不同的互斥信号量。 P、V操作必须成对出现。缺少P(mutex)就不能保证临界资源的互斥访问。缺少V(mutex)会导致资源永不被释放，等待进程永不被唤醒。 123456789101112131415161718/*信号量机制实现互反*/semaphore mutex=1; //初始化信号量，可以把信号量的声明简写成这种形式p1()&#123; ... P(mutex); //使用临界资源前需要加锁 临界区代码段... V(mutex); //使用临界资源后需要解锁 ...&#125;p2()&#123; ... P(mutex); 临界区代码段... V(mutex); ...&#125; 实现进程同步进程同步：要让各并发进程按要求有序地推进。 比如，p1、p2并发执行，由于存在异步性，因此二者交替推进的次序是不确定的。 若p2的”代码4”要基于p1的”代码1”和”代码2”的运行结果才能执行，那么我们就必须保证”代码4”一定是在”代码2”之后才会执行。 这就是进程同步问题，让本来异步并发的进程互相配合，有序推进。 用信号量实现进程同步： 分析什么地方需要实现“同步关系”，即必须保证“一前一后”执行的两个操作(或两句代码) 设置同步信号量S，初始为0 在”前操作”之后执行V(S) 在”后操作”之前执行P(S) 12345678910111213141516/*信号量机制实现同步*/semaphore S=0; //初始化同步信号量，初始值为0p1()&#123; 代码1; 代码2; V(S); 代码3;&#125;p2()&#123; P(S); 代码4; 代码5; 代码6;&#125; 解释： 若先执行到V(S) 操作，则S++ 后 S&#x3D;1。之后当执行到P(S)操作时，由于 S&#x3D;1，表示有可用资源，会执行 S–，S的值变回0，p2进程不会执行 block 原语，而是继续往下执行代码4。 若先执行到 P(S) 操作，由于 S&#x3D;0，S– 后S &#x3D; -1，表示此时没有可用资源，因此P操作中会执行 block 原语，主动请求阻塞。之后当执行完”代码2”，继而执行 v(S)操作，S++，使S变回0，由于此时有进程在该信号量对应的阻塞队列中，因此会在V操作中执行 wakeup 原语，唤醒 p2 进程。这样 p2就可以继续执行 “代码4”了 实现前驱关系进程p1中有代码s1，p2中有代码s2…..p6中有代码s6 这些代码要求如下前驱图所示的顺序来执行： flowchart TB s1-->s2-->s4-->s6 s1-->s3-->s6 s2-->s5-->s6 前驱关系问题，本质上就是一个复杂的同步问题 这就需要对每一对前驱关系各设置一个同步变量： 2.15 进程同步、互斥问题生产者-消费者问题生产者消费者问题是一个互斥、同步的综合问题 问题描述： 系统中有一组生产者进程和一组消费者进程，生产者进程每次生产一个产品放入缓冲区，消费者进程每次从缓冲区中取出一个产品并使用。(注：这里的”产品”理解为某种数据） 生产者、消费者共享一个初始为空、大小为n的缓冲区。 生产只有缓冲区没满时，生产者才能把产品放入缓冲区，否则必须等待 只有缓冲区不空时，消费者才能从中取出产品，否则必须等待。 缓冲区是临界资源，各进程必领互斥地访问。 PV操作题目分析步骤： 关系分析。找出题目中描述的各 个进程，分析它们之间的同步、互斥关系 整理思路。根据各进程的操作流程确定P、V操作的大致顺序。 设置信号量。设置需要的信号量，并根据题目条件确定信号量初值。 (互斥信号量初值一般为1，同步信号量的初始值要看对应资源的初始值是多少) 12345678910111213141516171819202122232425semaphore mutex = 1; //互斥信号量，实现对缓冲区的互斥访问semaphore empty = n; //同步信号量，表示空闲缓冲区的数量semaphore full = 0; //同步信号量，表示产品的数量，也即非空缓冲区的数量producer()&#123; while(1)&#123; 生产一个产品; P(empty); //消耗一个空闲缓冲区 P(mutex); 把产品放入缓冲区; V(mutex); V(full); //增加一个产品 &#125;&#125;consumer()&#123; while(1)&#123; P(full); //消耗一个产品 P(mutex); 从缓冲区取出一个产品; V(mutex); V(empty); //增加一个空闲缓冲区 使用产品; &#125;&#125; 多生产者-多消费者问题问题描述： 桌子上有一只盘子，每次只能向其中放入一个水果。爸爸专向盘子中放苹果，妈妈专向盘子中放橘子，儿子专等着吃盘子中的橘子，女儿专等着吃盘子中的苹果。只有盘子空时，爸爸或妈妈才可向盘子中放一个水果。仅当盘子中有自己需要的水果时，儿子或女儿可以从盘子中取出水果。 互斥关系： 对缓冲区(盘子)的访问要互斥地进行(只能有一人访问盘子) 同步关系(一前一后)： 父亲将苹果放入盘子后，女儿才能取苹果 母亲将橘子放入盘子后，儿子才能取橘子 只有盘子为空时，父亲或母亲才能放入水果 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849semaphore mutex = 1; //实现互斥访问盘子(缓冲区)semaphore apple = 0; //盘子中有几个苹果semaphore orange = 0; //盘子中有几个橘子semaphore plate = 1; //盘子中还可以放多少个水果dad()&#123; while(1)&#123; 准备一个苹果; P(plate); P(mutex); 苹果放入盘子; V(mutex); V(apple); &#125;&#125;mom()&#123; while(1)&#123; 准备一个橘子; P(plate); P(mutex); 橘子放入盘子; V(mutex); V(orange); &#125;&#125;son()&#123; while(1)&#123; P(apple); P(mutex); 拿走苹果; V(mutex); V(plate); 吃掉苹果; &#125;&#125;daughter()&#123; while(1)&#123; P(orange); P(mutex); 拿走橘子; V(mutex); V(plate); 吃掉橘子; &#125; &#125; 吸烟者问题问题描述： 假设一个系统有三个抽烟者进程和一个供应者进程。每个抽烟者不停地卷烟并抽掉它，但是要卷起并抽掉一支烟，抽烟者需要有三种材料：烟草、纸和胶水。三个抽烟者中，第一个拥有烟草、第二个拥有纸、第三个拥有胶水。供应者进程无限地提供三种材料，供应者每次将两种材料放桌子上，拥有剩下那种材料的抽烟者卷一根烟并抽掉它，并给供应者进程一个信号告诉完成了，供应者就会放另外两种材料再桌上，这个过程一直重复(让三个抽烟者轮流地抽烟) 桌上有组合一 -&gt; 第一个抽烟者取走东西 桌上有组合二 -&gt; 第二个抽烟者取走东西 桌上有组合三 -&gt; 第三个抽烟者取走东西 发出完成信号 -&gt; 供应者将下一个组合放到桌上 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748semaphore offer1 = 0; //桌上组合一的数量semaphore offer2 = 0; //桌上组合二的数量semaphore offer3 = 0; //桌上组合三的数量semaphore finish = 0; //抽烟是否完成int i = 0; //用于实现&quot;抽烟者轮流抽烟&quot;provider()&#123; while(1)&#123; if(i == 0)&#123; 将组合1放在桌上; V(offer1); &#125; else if(i == 1)&#123; 将组合2放在桌上; V(offer2); &#125; else&#123; 将组合3放在桌上; V(offer3); &#125; i = (i+1)%3; P(finish); &#125;&#125;smoker1()&#123; while(1)&#123; P(offer1); 拿走组合1，卷烟，抽掉 V(finish); &#125;&#125;smoker2()&#123; while(1)&#123; P(offer2); 拿走组合2，卷烟，抽掉 V(finish); &#125;&#125;smoker3()&#123; while(1)&#123; P(offer3); 拿走组合3，卷烟，抽掉 V(finish); &#125;&#125; 吸烟者问题可以为我们解决”可以生产多个产品的单生产者”问题提供一个思路。 值得吸取的精华是：”轮流让各个吸烟者吸烟”必然需要”轮流的在桌上放上组合一、二、三”，注意体会我们是如何用一个整型变量 i 实现这个”轮流”过程的。 读者-写者问题问题描述： 有读者和写者两组并发进程，共享一个文件，当两个或两个以上的读进程同时访问共享数据时不会产生副作用，但若某个写进程和其他进程（读进程或写进程）同时访问共享数据时则可能导致数据不一致的错误。因此要求： 允许多个读者可以同时对文件执行读操作 只允许一个写者往文件中写信息 任一写者在完成写操作之前不允许其他读者或写者工作 写者执行写操作前，应让己有的读者和写者全部退出 两类进程：写进程、读进程： 互斥关系：写进程——写进程、写进程——读进程。读进程与读进程不存在互斥问题。 写者进程和任何进程都互斥，设置一个互斥信号量 rw，在写者访问共享文件前后分别执行P、V操作。 读者进程和写者进程也要互斥，因此读者访问共享文件前后也要对rw 执行P、V操作。 如果所有读者进程在访问共享文件之前都执行 P(rw) 操作，那么会导致各个读进程之问也无法同时访问文件。 P(rw)和 V(rw)其实就是对共享文件的“加锁”和“解锁〞。既然各个读进程需要同时访问，而读进程与写进程又必须互斥访问，那么我们可以让第一个访问文件的读进程 “加锁〞，让最后一个访问完文件的读进程 “解锁”。可以设置一个整数变量 count 来记录当前有几个读进程在访问交件。 123456789101112131415161718192021222324252627282930313233semaphore mutex = 1; //用于实现对文件的互斥访问。表示当前是否有进程在访问共享文件semaphore rw = 1; //记录当前有几个读进程在访问文件semaphore w = 1; //用于实现&quot;写优先&quot;int count = 0; //用于保证对count变量的互斥访问writer()&#123; while(1)&#123; P(w); //防止写者饿死 P(rw); //写之前&quot;加锁&quot; 写文件; V(rw); //写之后&quot;解锁&quot; V(w); &#125;&#125;reader()&#123; while(1)&#123; P(w); //不要无限让读者访问，因为只要有读者，写者就只能等待，防止写者饿死 P(mutex); //各读者进程互斥访问count，防止一起进入导致另一个读者阻塞 if(count == 0) P(rw); //第一个读者进程负责&quot;加锁&quot; count++; //访问文件的读进程数+1 V(mutex); //解锁 V(w); 读文件; P(mutex); //各读者进程互斥访问count count--; //访问文件的读进程数-1 if(count == 0) V(rw); //最后一个读进程负责&quot;解锁&quot; V(mutex); //解锁 &#125;&#125; 在这种算法中，连续进入的多个读者可以同时读文件；写者和其他进程不能同时访问文件；写者不会饥饿，但也并不是真正的”写优先”，而是相对公平的先来先服务原则。有的书上把这种算法称为”读写公平法” 哲学家进餐问题问题描述： 一张圆桌上坐着5名哲学家，每两个哲学家之间的桌上摆一根筷子，桌子的中间是一碗米饭。哲学家们倾注毕生的精力用于思考和进餐，哲学家在思考时，并不影响他人。只有当哲学家饥饿时，才试图拿起左、右两根筷子（一根一根地拿起）。如果筷子已在他人手上，则需等待。饥饿的哲学家只有同时拿起两根筷子才可以开始进餐，当进餐完毕后，放下筷子继续思考。 123456789101112semaphore chopstick[5] = &#123;1,1,1,1,1&#125;;Pi()&#123; while(1)&#123; P(chopstick[i]); //拿左筷子 P(chopstick[(i+1)%5]); //拿右筷子 吃饭; V(chopstick[i]); //放下左筷子 V(chopstick[(i+1)%5]); //放下右筷子 思考; &#125;&#125;//会发生死锁！！ 如果5个哲学家并发地拿起了自己左手边的筷子，会导致每个哲学家都只有一个筷子，引发死锁 如何防止死锁的发生呢？ 可以对哲学家进程施加一些限制条件，比如最多允许四个哲学家同时进餐。这样可以保证至少有一个哲学家是可以拿到左右两只筷子的 1234567891011121314semaphore chopstick[5] = &#123;1,1,1,1,1&#125;;semaphore mutex = 4; //最多只允许4个人同时拿筷子Pi()&#123; while(1)&#123; P(mutex); P(chopstick[i]); //拿左筷子 P(chopstick[(i+1)%5]); //拿右筷子 吃饭; V(chopstick[i]); //放下左筷子 V(chopstick[(i+1)%5]); //放下右筷子 V(mutex); 思考; &#125;&#125; 要求奇数号哲学家先拿左边的筷子，然后再拿有边的筷子，而偶数号哲学家刚好相反。用这种方法可以保证如果相邻的两个奇偶号哲学家都想吃饭，那么只会有其中一个可以拿起第一只筷子，另一个会直接阻塞。这就避免了占有一支后再等待另一只的情況。 保证有一个哲学家吃饭 1234567891011121314semaphore chopstick[5] = &#123;1,1,1,1,1&#125;;semaphore mutex = 1; //互斥地拿筷子Pi()&#123; while(1)&#123; P(mutex); P(chopstick[i]); //拿左筷子 P(chopstick[(i+1)%5]); //拿右筷子 V(mutex); 吃饭; V(chopstick[i]); //放下左筷子 V(chopstick[(i+1)%5]); //放下右筷子 思考; &#125;&#125; 2.16 管程信号量机制存在的问题：编程程序困难、易出错 定义管程是一种特殊的软件模块，有这些部分组成： 局部于管程的共享数据结构说明； 对该数据结构进行操作的一组过程(函数)； 对局部于管程的共享数据设置初始值的语句； 管程有一个名字。 管程的基本特征： 局部于管程的数据只能被局部于管程的过程所访问： 一个进程只有通过调用管程内的过程才能进入管程访问共享数据； 每次仅允许一个进程在管程内执行某个内部过程。 解决生产者消费者问题可以用某种特殊的语法定义一个管程： 123456789101112131415161718monitor ProducerConsumercondition full, empty; //条件变量用来实现同步(排队)int count = 0; //缓冲区中的产品数void insert(Item item)&#123; //把产品item放入缓冲区 if(count == N) wait(full); count++; insert_item(item); if(count == 1) signal(empty);Item remove()&#123; //从缓冲区中取出一个产品 if(count == 0) wait(empty); count--; if(count == N-1) signal(full); return remove_item();end monitor; 实现生产者-消费者： 123456789101112131415//生产者进程producer()&#123; while(1)&#123; item = 生产一个产品; ProducerConsumer.insert(item); &#125;&#125;//消费者进程producer()&#123; while(1)&#123; ProducerConsumer.remove(item); 消费产品item; &#125;&#125; java中类似管制的机制java中，如果用关键宇synchronized来描述一个函数，那么这个函数同一时间段内只能被一个线程调用 1234567static class monitor &#123; private Item buffer[] = new Item[N]; private int count = 0; public synchronized void insert(Item item) &#123; ... &#125;&#125; 2.17 死锁死锁的概念在并发环境下，各进程因竞争资源而造成的一种互相等待对方手里的资源，导致各进程都阻塞，都无法向前推进的现象，就是”死锁”。发生死锁后若无外力干涉，这些进程都将无法向前推进。 死锁：各进程互相等待对方手里的资源，导致各进程都阻塞，无法向前推进的现象。 饥饿：由于长期得不到想要的资源，某进程无法向前推进的现象。比如：在短进程优先(SPF)算法中，若有源源不断的短进程到来，则长进程将一直得不到处理机，从而发生长进程”饥饿”。 死循环：某进程执行过程中一直跳不出某个循环的现象。有时是因为程序逻辑 bug 导致的，有时是程序员故意设计的。 死锁、饥饿、死循环 共同点：都是进程无法顺利向前推进的现象 区别： 死锁 死锁一定是”循环等待对方手里的资源”导致的，因此如果有死锁现象，那至少有两个或两个以上的进程同时发生死锁。另外，发生死锁的进程一定处于阻塞态。 饥饿 可能只有一个进程发生饥饿。发生饥饿的进程既可能是阻塞态(如长期得不到推进的现象需要的I&#x2F;O设备)，也可能是就绪态(长期得不到处理机） 死循环 可能只有一个进程发生死循环。死循环的进程可以上处理机运行(可以是运行态)，只不过无法像期待的那样顺利推进。死锁和饥饿问题是由于操作系统分配资源的策略不合理导致的，而死循环是由代码逻辑的错误导致的。死锁和饥饿是管理者(操作系统)的问题，死循环是被管理者的问题。 死锁产生的条件产生死锁必须同时满足一下四个条件，只要其中任一条件不成立，死锁就不会发生。 互斥条件：只有对必须互斥使用的资源的争抢才会导致死锁(如哲学家的筷子、打印机设备)像内存、扬声器这样可以同时让多个进程使用的资源是不会导致死锁的(因为进程不用阻塞等这种资源)。 不剥夺条件：进程所获得的资源在未使用完之前，不能由其他进程强行夺走，只能主动释放。 请求和保持条件：进程已经保特了至少一个资源，但又提出了新的资源请求，而该资源又被其他进程占有，此时请求进程被阻塞，但又对自己己有的资源保持不放。 循环等待条件：存在一种进程资源的循环等待链，链中的每一个进程己获得的资源同时被下一个进程所请求。 注意：发生死锁时一定有循环等待，但是发生循环等待时未必死锁(循环等待是死锁的必要不充分条件) 如果同类资源数大于1，则即使有循环等待，也未必发生死锁。但如果系统中每类资源都只有一个，那循环等待就是死锁的充分必要条件了。 总之，对不可剥夺资源的不合理分配，可能导致死锁 2.18 死锁的处理策略 预防死锁(静态策略)：破坏死锁产生的四个必要条件中的一个或几个 避免死锁(动态策略)：用某种方法防止系统进入不安全状态，从而避免死锁(银行家算法) 死锁的检测和解除：允许死锁的发生，不过操作系统会负责检测出死锁的发生，然后采取某种措施解除死锁 静态策略(预防死锁)破坏互斥条件 互斥条件：只有对必须互斥使用的资源的争抢才会导致死锁。 如果把只能互斥使用的资源改造为允许共享使用，则系统不会进入死锁状态。比如：SPOOLing技术。 操作系统可以采用 SPOOLing 技术把独占设备在逻辑上改造成共享设备。比如，用SPOOLing技术将打印机改造为共享设备，使用了SPOOLing技术后，在各进程看来，自己对打印机资源的使用请求立即就被接收处理了，不需要再阻塞等待。 该策略的缺点：并不是所有的资源都可以改造成可共享使用的资源。并且为了系统安全，很多地方还必须保护这种互斥性。因此，很多时候都无法破坏互斥条件。 破环不剥夺条件 不剥夺条件：进程所获得的资源在未使用完之前，不能由其他进程强行夺走，只能主动释放。 破坏不剥夺条件： 方案一：当某个进程请求新的资源得不到满足时，它必须立即释放保持的所有资源，待以后需要时再重新申请。也就是说，即使某些资源尚末使用完，也需要主动释放，从而破坏了不可剥夺条件。 方案二：当某个进程需要的资源被其他进程所占有的时候，可以由操作系统协助，将想要的资源强行剥夺。这种方式一般需要考虑各进程的优先级(比如：剥夺调度方式，就是将处理机资源强行剥夺给优先级更高的进程使用) 该策略的缺点： 实现起来比较复杂。 释放己获得的资源可能造成前一阶段工作的失效。因此这种方法一般只适用于易保存和恢复状态的资源，如CPU。 反复地申请和释放资源会增加系统开销，降低系统吞吐量。 若采用方案一，意味着只要暂时得不到某个资源，之前获得的那些资源就都需要放弃，以后再重新申请。如果一直发生这样的情况，就会导致进程饥饿。 破坏请求和保持条件 请求和保持条件：进程己经保持了至少一个资源，但又提出了新的资源请求，而该资源又被其他进程占有，此时请求进程被阻塞，但又对自己己有的资源保持不放。 可以采用静态分配方法，即进程在运行前一次申请完它所需要的全部资源，在它的资源未满足前，不让它投入运行。一旦投入运行后，这些资源就一直归它所有，该进程就不会再请求别的任何资源了。 该策略实现起来简单，但也有明显的缺点： 有些资源可能只需要用很短的时间，因此如果进程的整个运行期问都一直保持着所有资源，就会造成正重的资源浪费，资源利用率极低。另外，该策略也有可能导致某些进程饥饿。 破环循环等待条件 循环等待条件：存在一种进程资源的循环等待链，链中的每一个进程已获得的资源同时被下一个进程所请求。 可采用顺序资源分配法。首先给系统中的资源编号，规定每个进程必须按编号递增的顺序请求资源，同类资源(即编号相同的资源)一次申请完。 原理分析：一个进程只有己占有小编号的资源时，才有资格申请更大编号的资源。按此规则，己持有大编号资源的进程不可能逆向地回来申请小编号的资源，从而就不会产生循环等待的现象。 在任何一个时刻，总有一个进程拥有的资源编号是最大的，那这个进程申请之后的资源必然畅通无阻。因此，不可能出现所有进程都阻塞的死锁现象。 该策略的缺点： 不方便增加新的设备，因为可能需要重新分配所有的编号； 进程实际使用资源的顺序可能和编号递增顺序不一致，会导致资源浪费； 必须按规定次序申请资源，用户编程麻烦。 动态策略(避免死锁)安全序列 所谓安全序列，就是指如果系统按照这种序列分配资源，则每个进程都能顺利完成。只要能找出一个安全序列，系统就是安全状态。当然，安全序列可能有多个 如果分配了资源之后，系统中找不出任何一个安全序列，系统就进入了不安全状态。这就意味着之后可能所有进程都无法顺利的执行下去。当然，如果有进程提前归还了一些资源，那系统也有可能重新回到安全状态，不过我们在分配资源之前总是要考虑到最坏的情况。 如果系统处于安全状态，就一定不会发生死锁。如果系统进入不安全状态，就可能发生死锁(处于不安全状态未必就是发生了死锁，但发生死锁时一定是在不安全状态) 因此可以在资源分配之前预先判断这次分配是否会导致系统进入不安全状态，以此决定是否答应资源分配请求。这也是”银行家算法”的核心思想。 银行家算法 银行家算法是荷兰学者 Dijkstra 为银行系统设计的，以确保银行在发放现金贷款时，不会发生不能满足所有客户需要的情况。后来该算法被用在操作系统中，用于避免死锁。 核心思想：在进程提出资源申请时，先预判此次分配是否会导致系统进入不安全状态。如果会进入不安全状态，就暂时不答应这次请求，让该进程先阻塞等待。 在计算机系统中会有多种多样的资源，应该怎么把算法拓展为多种资源的情况呢？ 可以把单维的数字拓展为多维的向量。 比如：系统中有5个进程 p0p4, 3种资源 r0r2，初始数量为(10, 5, 7) 某一时刻的情况可表示如下： 进程 最大需求 已分配 最多还需要 p0 (7, 5, 3) (0, 1, 0) (7, 4, 3) p1 (3, 2, 2) (2, 0, 0) (1, 2, 2) p2 (9, 0, 2) (3, 0, 2) (6, 0, 0) p3 (2, 2, 2) (2, 1, 1) (0, 1, 1) p4 (4, 3, 3) (0, 0, 2) (4, 3, 1) 依次检查剩余可用资源为(3, 3, 2)能否被满足某个剩余进程的需求 可满足p1需求，将p1加入安全序列 说明：说明如果优先把资源分配给p1了，那p1一定是可以顺利执行结束的。等p1结束了就会归还资源。于是，资源数就可以增加到(2,0,0)+(3,3,2)&#x3D;(5,3,2) 依次检查剩余可用资源为(5, 3, 2)能否被满足某个剩余进程的需求 可满足p3需求，将p3加入安全序列 依次检查剩余可用资源为(7, 4, 3)能否被满足某个剩余进程的需求 可满足p0需求，将p0加入安全序列 以此类推。如果依次检查剩余可用资源都不能被满足剩余进程的需求，那么此时系统处于不安全状态，有可能发生死锁 最后得出安全序列：&#123;p1, p3, p0, p2, p4&#125; 假设系统中有n个进程，m种资源 每个进程在运行前先声明对各种资源的最大需求数，则可用一个n*m的矩阵(可用二维数组实现)表示所有进程对各种资源的最大需求数。最大需求Max矩阵， Max[i][j]=K 表示进程pi最多需要K个rj资源。 系统可以用一个n*m 的分配矩阵Allocation表示对所有进程的资源分配情況。 Max-Allocation&#x3D;Need矩阵，表示各进程最多还需要多少各类资源。 另外，还要用一个长度为m的一维数组 Available 表示当前系统中还有多少可用资源。 某进程pi向系统申请资源，可用一个长度为m的一维数组 Requesti 表示本次申请的各种资源量。 可用银行家算法预判本次分配是否会导致系统进入不安全状态： 如果 Requesti[j] &lt;&#x3D; Need[i, j] 便转向步骤2。否则认为出错，因为它所需要的资源数己超过它所宣布的最大值。 如果 Requesti[j] &lt;&#x3D; Available[j] 便转向步骤3；否则表示尚无足够资源，pi必须等待。 系统试探着把资源分配给进程pi，并修改相应的数据(并非真的分配，修改数值只是为了做预判) 修改可用资源：Available &#x3D; Available[i, j] + Requesti[j] 修改已分配资源：Allocation[i, j] &#x3D; Allocation[i, j] + Requesti[j] 修改最多还需要的资源：Need[i, j] &#x3D; Need[i, j] - Requesti[j] 操作系统执行安全性算法，检查此次资源分配后，系统是否处于安全状态。若安全，才正式分配；否则，恢复相应数据，让进程阻塞等待。 检测和解除死锁的检测 死锁定理：如果某时刻系统的资源分配图是不可完全简化的，那么此时系统死锁 如果按上述过程分析，最终能消除所有边，就称这个图是可完全简化的。此时一定没有发生死锁(相当于能我到一个安全序列) 死锁的解除 一旦检测出死锁的发生，就应该立即解除死锁。 补充：并不是系统中所有的进程都是死锁状态，用死锁检测算法化简资源分配图后，还连着边的那些进程就是死锁进程 解除死锁的主要方法有： 资源剥夺法。挂起〈暂时放到外在上，基些死锁进程，并抢占它的资源，将这些资源分配给其他的死锁进程。但是应防止被挂起的进程长时间得不到资源而饥饿。 撤销进程法（或称终止进程法）。强制撤销部分、甚至全部死锁进程，并剥夺这些进程的资源。这种方式的优点是实现简单，但所付出的代价可能会很大。因为有些进程可能已经运行了很长时间，己经接近结束了，一旦被终止可谓功亏一篑，以后还得从头再来。 进程回退法。让一个或多个死锁进程回退到足以避免死锁的地步。这就要求系统要记录进程的历史信息，设置还原点。 三、内存3.1 内存的概念内存是用于存放数据的硬件。程序执行前需要先放到内存中才能被CPU处理。 装入的三种方式绝对装入：在编译时，如果知道程序将放到内存中的哪个位置，编译程序将产生绝对地址的目标代码。装入程序按照装入模块中的地址，将程序和数据装入内存。 注意：绝对装入只适用于单道程序环境 静态重定位：又称可重定位装入。编译、链接后的装入模块的地址都是从0开始的，指令中使用的地址、数据存放的地址都是相对于起始地址而言的逻辑地址。可根据内存的当前情况，将装入模块装入到内存的适当位置。装入时对地址进行”重定位”，将逻辑地址变换为物理地址(地址变换是在装入时一次完成的)。 静态重定位的特点：在一个作业装入内存时，必须分配其要求的全部内存空间，如果没有足够的内存，就不能装入该作业。 动态重定位：又称动态运行时装入。编译、链接后的装入模块的地址都是从0开始的。装入程序把装入模块装入内存后，并不会立即把逻辑地址转换为物理地址，而是把地址转换推迟到程序真正要执行时才进行。因此装入内存后所有的地址依然是逻辑地址。这种方式需要一个重定位寄存器的支持。 采用动态重定位时允许程序在内存中发生移动。 链接的三种方式 静态链接：在程序运行之前，先将各目标模块及它们所需的库函数连接成一个完整的可执行文件(装入模块)，之后不再拆开。 装入时动态链接：将各目标模块装入内存时，边装入边链接的链接方式。 运行时动态链接：在程序执行中需要该目标模块时，才对它进行链接。其优点是便于修改和更新，便于实现对目标模块的共享。 3.2 内存管理 操作系统负责内存空间的分配与回收 操作系统需要提供某种技术从逻辑上对内存空间进行扩充 操作系统需要提供地址转换功能，负责程序的逻辑地址与物理地址的转换 操作系统需要提供内存保护功能。保证各进程在各自存储空间内运行，互不干扰 内存保护防止某进程更改操作系统所在的内存或者别的进程的内存 内存保护的两种方法： 在CPU中设置一对上、下限寄存器，存放进程的上、下限地址。进程的指令要访问某个地址时，CPU检查是否越界 采用重定位寄存器(又称基址寄存器)和界地址寄存器(又称限长寄存器)进行越界检查。重定位寄存器中存放的是进程的起始物理地址。界地址寄存器中存放的是进程的最大逻辑地址 内存扩充覆盖技术 覆盖技术的思想：将程序分为多个段(多个模块)。 常用的段常驻内存，不常用的段在需要时调入内存。 内存中分为一个”固定区”和若干个”覆盖区”。 需要常驻内存的段放在”固定区”中，调入后就不再调出(除非运行结束) 不常用的段放在”覆盖区”，需要用到时调入内存，用不到时调出内存 按照自身逻辑结构，让那些不可能同时被访问的程序段共享同一个覆盖区 必须由程序员声明覆盖结构，操作系统完成自动覆盖。缺点：对用户不透明，增加了用户编程负担。 覆盖技术只用于早期的操作系统中，现在已成为历史。 交换技术 交换(对换)技术的设计思想：内存空间紧张时，系统将内存中某些进程暂时换出外存，把外存中某些已具备运行条件的进程换入内存(进程在内存与磁盘间动态调度) 暂时换出外存等待的进程状态为挂起状态(挂起态，suspend) 挂起态又可以进一步细分为就绪挂起、阻塞挂起两种状态 具有对换功能的操作系统中，通常把磁盘空间分为文件区和对换区两部分。文件区主要用于存放文件，主要追求存储空间的利用率，因此对文件区空间的管理采用离散分配方式；对换区空间只占磁盘空间的小部分，被换出的进程数据就存放在对换区。由我对换的速度直按影响到系统的整体速度，因此对换区空问的管理主要追求换入换出度，因此通常对换区采用连续分配方式。总之，对换区的I&#x2F;O速度比文件区的更快 交换通常在许多进程运行且内存吃紧时进行，而系统负荷降低就暂停。 例如：在发现许多进程运行时经常发生缺页，就说明内存紧张，此时可以换出一些进程；如果缺页率明显下降，就可以暂停换出。 可优先换出阻塞进程；可换出优先级低的进程；为了防止优先级低的进程在被调入内存后很快又被换出，有的系统还会考虑进程在内存的驻留时间… 注意：PCB会常驻内存，不会被换出内存 3.3 连续分配管理方式单一连续分配在单一连续分配方式中，内存被分为系统区和用户区。 系统区通常位于内存的低地址部分，用于存放操作系统相关数据；用户区用于存放用户进程相关数据。 内存中只能有一道用户程序，用户程序独占整个用户区空间。 优点：实现简单；无外部碎片：可以采用覆盖技术扩充 内存：不一定需要采取内存保（eg：早期的 PC操作系統 MS-DOS)。 缺点：只能用于单用户、单任务的操作系统中；有内部碎片：存储器利用率极低。 分配给某进程的内存区域中，如果有些部分没有用就是”内部碎片“ 固定分区分配20世纪60年代出现了支持多道程序的系统，为了能在内存中装入多道程序，且这些程序之问又不会相互干扰，于是将整个用户空间划分为若干个固定大小的分区，在每个分区中只装入一道作业，这样就形成了最早的、最简单的一种可运行多道程序的内存管理方式。 分区大小相等：缺乏灵活性，但是很适合用于用一台计算机控制多个相同对象的场合(比如：钢铁厂有n个相同的炼钢炉，就可把内存分为n个大小相等的区域存放n个炼钢炉控制程序) 分区大小不等：增加了灵活性，“可以满足不同大小的进程需求。根据常在系统中运行的作业大小情况进行划分(比如：划分多个小分区、适量中等分区、少量大分区) 操作系统需要建立一个数据结构一一分区说明表，来实现各个分区的分配与回收。每个表项对应一个分区，通常按分区大小排列。每个表项包括对应分区的**大小、起始地址、状态(是否己分配)**。 当某用户程序要装入内存时，由操作系统内核程序根据用户程序大小检索该表，从中找到一个能满足大小的、未分配的分区，将之分配给该程序，然后修改状态为”已分配”。 优点：实现简单，无外部碎片。 缺点： 当用户程序太大时，可能所有的分区都不能满足需求，此时不得不采用覆盖技术来解决，但这又会降低性能； 会产生内部碎片，内存利用率低。 动态分区分配动态分区分配又称为可变分区分配。这种分配方式不会预先划分内存分区，而是在进程装入内存时，根据进程的大小动态地建立分区，并使分区的大小正好适合进程的需要。因此系统分区的大小和数目是可变的。 空闲分区表：每个空闲分区对应一个表项。表项中包含分区号、分区大小、分区起始地址等信息 空闲分区链：每个分区的起始部分和末尾部分分别设置前向指针和后向指针。起始部分处还可记录分区大小等信息 动态分区分配没有内部碎片，但是有外部碎片。 内部碎片，分配给某进程的内存区域中，如果有些部分没有用上。 外部碎片，是指内存中的某些空闲分区由于太小而难以利用。 如果内存中空闲空间的总和本来可以满足某进程的要求，但由于进程需要的是一整块连续的内存空间，因此这些”碎片”，不能满足进程的需求。可以通过紧凑(拼凑，Compaction)技术来解决外部碎片。 3.4 动态分区分配算法首次适应算法(First Fit)算法思想：每次都从低地址开始查找，找到第一个能满足大小的空闲分区。 如何实现：空闲分区以地址递增的次序排列。每次分配内存时顺序查找空闲分区链(或空闲分区表)，找到大小能满足要求的第一个空闲分区。 四种算法中，首次适应算法的效果的反而更好 最佳适应算法(Beat Fit)算法思想：由于动态分区分配是一种连续分配方式，为各进程分配的空间必须是连续的一整片区域。因此为了保证当”大进程”到来时能有连续的大片空间，可以尽可能多地留下大片的空闲区，即，优先使用更小的空闲区。 如何实现：空闲分区按容量递增次序链接。每次分配内存时顺序查找空闲分区链(或空闲分区表)，找到大小能满足要求的第一个空闲分区。 缺点：每次都选最小的分区进行分配，会留下越来越多的、很小的、难以利用的内存块。因此这种方法会产生很多的外部碎片。 最坏适应算法(Worst Fit)又称最大适应算法 (Largest Fit) 算法思想：为了解决最佳适应算法的问题一一即留下太多难以利用的小碎片，可以在每次分配时优先使用最大的连续空闲区，这样分配后剩余的空闲区就不会太小，更方便使用。 如何实现：空闲分区按容量递减次序链接。每次分配内存时顺序查找空闲分区链(或空闲分区表)，找到大小能满足要求的第一个空闲分区。 缺点：每次都选最大的分区进行分配，虽然可以让分配后留下的空闲区更大，更可用，但是这种方式会导致较大的连续空闲区被迅速用完。如果之后有”大进程”到达，就没有内存分区可用了。 邻近适应算法(Next Fit)算法思想：首次适应算法每次都从链头开始查找的。这可能会导致低地址部分出现很多小的空闲分区，而每次分配查找时，都要经过这些分区，因此也增加了查找的开销。如果每次都从上次查找结束的位置开始检索，就能解决上述问题。 如何实现：空闲分区以地址递增的顺序排列(可排成一个循环链表)。每次分配内存时从上次查找结束的位置开始查找空闲分区链(或空闲分区表)，找到大小能满足要求的第一个空闲分区。 首次适应算法每次都要从头查我，每次都需要检索低地址的小分区。但是这种规则也决定了当低地址部分有更小的分区可以满足需求时，会更有可能用到低地址部分的小分区，也会更有可能把高地址部分的大分区保留下来(最佳适应算法的优点) 邻近适应算法的规则可能会导致无论低地址、高地址部分的空闲分区都有相同的概率被使用，也就导致了高地址部分的大分区更可能被使用，划分为小分区，最后导致无大分区可用(最大适应算法的缺点) 3.5 基本分页存储管理考虑支持多道程序的两种连续分配方式： 固定分区分配：缺乏灵活性，会产生大量的内部碎片，内存的利用率很低。 动态分区分配：会产生很多外部碎片，虽然可以用”紧湊”技术来处理，但是”紧凑”的时间代价很高 如果允许将一个进程分散地装入到许主不相邻的分区中，便可充分地利用内存，而无需再进行”紧凑” 基于这一思想，产生了”非连续分配方式”，或者称为”离散分配方式” 思想基本分页存储管理思想：把内存分为一个个相等的小分区，再按照分区大小把进程拆分成一个个小部分 物理地址： 将内存空间分为一个个大小相等的分区(比如：每个分区4KB)，每个分区就是一个”页框”(或称”页帧”、”内存块”、”物理块”)。每个页框有一个编号，即”页框号”(或者”内存块号”、”页帧号”、”物理块号”)页框号从0开始。 逻辑地址： 将用户进程的地址空间也分为与页框大小相等的一个个区域，称为”页”或”页面”。每个页面也有一个编号，即”页号”，页号也是从0开始。 各个页面不必连续存放，也不必按先后顺序来，可以放到不相邻的各个页框中。 实现地址的转换 要算出逻辑地址对应的页号 要知道该页号对应页面在内存中的起始地址 要算出逻辑地址在页面内的”偏移” 物理地址&#x3D;页面始址 + 页内偏移量 页号 = 逻辑地址/页面长度(取除法的整数部分) 页内偏移量 = 逻辑地址%页面长度 如果有K位表示”页内偏移量”，则说明该系统中一个页面的大小是2^K^个内存单元 如果有M 位表示”页号”，则说明在该系统中，一个进程最多允许有2^M^ 个页面 页表为了能知道进程的每个页面在内存中存放的位置，操作系统要为每个进程建立一张页表。 页表： 页号(逻辑地址) 块页(物理地址) 0 3 1 6 2 4 … … n 8 一个进程对应一张页表 进程的每一页对应一个页表项 每个页表项由”页号”和”块号”组成 页表记录进程页面和实际存放的内存块之间的对应关系 假设某系统物理内存大小为 4GB，页面大小为 4KB，则每个页表项至少应该为多少字节？ 4GB&#x3D; 232B， 4KB &#x3D; 212B 因此4GB 的内存总共会被分为 2^32^&#x2F;2^12^ &#x3D; 2^20^个内存块，因此内存块号的范围应该是0~2^20^-1 因此至少要 20 个二进制位才能表示这么多的内存块号，因此至少要3个字节才够 各页表项会按顺序连续地存放在内存中 如果该页表在内存中存放的起始地址为x，则M号页对应的页表项一定是存放在内存地址为x+3*M 如果一个页面为 4KB，则每个页框可以存放 4096&#x2F;3&#x3D;1365个页表项，但是这个页框会剩余 4096%3=1B页内碎片因此，1365 号页表项存放的地址为x +3*1365 +1 如果每个页表项占4个字节，则每个页框刚好可存放 1024个页表项1024号页表项虽然是存放在下一个页框中的，但是它的址址依然可以用x+44*1024得出 结论：理论上，页表项长度为3B 即可表示内存块号的范围，但是，为了方便页表的查询，常常会让一个页表项占更多的字节，使得每个页面恰好可以装得下整数个页表项。 基地址变换机构例：若页面大小L为1K字节，页号2对应的内存块号b&#x3D;8，将逻辑地址 A&#x3D;2500 转换为物理地址E。等价描述：某系统按字节寻址，逻辑地址结构中，页内偏移量占10位，页号2对应的内存块号b&#x3D;8，将逻辑地址 A&#x3D;2500 转换为物理地址E。 页内偏移量占10位：说明一个页面的大小为 2^10^B&#x3D; 1KB 计算页号、页内偏移量 页号：P&#x3D;A&#x2F;L&#x3D;2500&#x2F;1024&#x3D;2 页内偏移量：W&#x3D;A%L&#x3D;2500%1024 &#x3D; 452 根据题中条件可知，页号2没有越界，其存放的内存块号b&#x3D;8 物理地址E=b*L+W = 8*1024 + 452 = 8644 在分页存储管理(页式管理)的系统中，只要确定了每个页面的大小，逻辑地址结构就确定了。因此，页式管理中地址是一维的。即，只要给出一个逻辑地址，系统就可以自动地算出页号、页内偏移量两个部分，并不需要显式地告诉系统这个逻辑地址中，页内偏移量占多少位。 快表地址变换机构局部性原理： 时间局部性：如果执行了程序中的某条指令，那么不久后这条指令很有可能再次执行；如果某个数据被访问过，不久之后该数据很可能再次被访问。(因为程序中存在大量的循环) 空间局部性：一旦程序访问了某个存储单元，在不久之后，其附近的存储单元也很有可能被访问。(因为很多数据在内存中都是连续存放的) 在基本地址变换机构中，每次要访问一个逻辑地址，都需要查询内存中的页表。由于局部性原理，可能连续很多次查到的都是同一个页表项。既然如此，能否利用这个特性减少访问页表的次数呢？ 快表，又称联想寄存器(TLB)，是一种访问速度比内存快很多的高速缓冲存储器，用于存放当前访问的若干页表项，以加速地址变换的过程。与此对应，内存中的页表常称为慢表。 CPU给出逻辑地址，由某个硬件算得页号、页内偏移量，将页号与快表中的所有页号进行比较。 如果找到匹配的页号，说明要访问的页表项在快表中有副本，则直接从中取出该页对应的内存块号，再将内存块号与页内偏移量拼接形成物理地址，最后，访问该物理地址对应的内存单元。因此，若快表命中，则访问某个逻辑地址仅需一次访存即可。 如果没有找到匹配的页号，则需要访问内存中的页表，找到对应页表项，得到页面存放的内存块号，再将内存块号与页内偏移量拼接形成物理地址，最后，访问该物理地址对应的内存单元。因此，若快表未命中，则访问某个逻辑地址需要两次访存(注意：在找到页表项后，应同时将其存入快表，以便后面可能的再次访问。但若快表已满，则必须按照一定的算法对旧的页表项进行替换) 由于查询快表的速度比查询页表的速度快很多，因此只要快表命中，就可以节省很多时间。因为局部性原理，一般来说快表的命中率可以达到 90%以上。 两级页表单极页表的问题： 页表必须连续存放，因此当页表很大时，需要占用很多个连续的页框。 没有必要让整个页表常驻内存，因为进程在一段时间内可能只需要访问某几个特定的页面。 可将长长的页表进行分组，使每个内存块刚好可以放入一个分组(比如上个例子中，页面大小4KB，每个页表项4B，每个页面可存放1K 个页表项，因此每 1K 个连续的页表项为一组，每组刚好占一个内存块，再讲各组离散地放到各个内存块中) 可以在需要访间页面时才把页面调入内存(虚拟存储技术)。可以在页表项中增加一个标志位，用于表示该页面是否已经调入内存 若想访问的页面不在内存中，则产生缺页中断(内中断)，然后将目标页面从外存调入内存 若采用多级页表机制，则各级页表的大小不能超过一个页面 例：某系统按字节编址，采用40位逻辑地址，页面大小为 4KB，页表项大小为 4B，假设采用纯页式存储，则要采用（）级页表，页内偏移量为（）位？ 页面大小&#x3D;4KB&#x3D;2^12^B，按字节编址，因此页内偏移量为12位 页号&#x3D;40-12&#x3D;28位 页面大小&#x3D;2^12^B，页表项大小&#x3D;4B，则每个页面可存放2^12^ &#x2F; 4&#x3D;2^10^个页表项 因此各级页表最多包含2^10^个页表项，需要10位二进制位才能映射到2^10^个页表项，因此每一级的页表对应页号应为10位。总共28位的页号至少要分为三级 逻辑地址：一级页表(8位) + 二级页表(10位) + 三级页表(10位) + 页内偏移量(12位) 两级页表的访存次数分析(假设没有快表机构) 第一次访存：访问内存中的页目录表 第二次访存：访问内存中的二级页表 第三次访存：访问目标内存单元 3.6 基本分段存储管理分段进程的地址空问：按照程序自身的逻辑关系划分为若干个段，每个段都有一个段名(在低级语言中，程序员使用段名来编程)，每段从0开始编址 内存分配规则：以段为单位进行分配，每个段在内存中占据连续空间，但各段之间可以不相邻。 分页、分段对比页是信息的物理单位。分页的主要目的是为了实现离散分配，提高内存利用率。分页仅仅是系统管理上的需要，完全是系统行为，对用户是不可见的。 段是信息的逻辑单位。分段的主要目的是更好地满足用户需求。一个段通常包含着一组属于一个逻辑模块的信息。 分段对用户是可见的，用户编程时需要显式地给出段名。 页的大小固定且由系统决定。段的长度却不固定，决定于用户编写的程序。 分页的用户进程地址空间是一维的，程序员只需给出一个记忆符即可表示一个地址。 分段的用户进程地址空间是二维的，程序员在标识一个地址时，既要给出段名，也要给出段内地址。 分段比分页更容易实现信息的共享和保护。不能被修改的代码称为纯代码或可重入代码(不属于临界资源)，这样的代码是可以共享的。可修改的代码是不能共享的 访问一个逻辑地址需要几次访存？ 分页(单级页表)： 第一次访存一一查内存中的页表 第二次访存一一访问目标内存单元。 总共两次访存 分段： 第一次访存一一查内存中的段表 第二次访存一一访问目标内存单元。 总共两次访存与分页系统类似，分段系统中也可以引入快表机构，将近期访问过的段表项放到快表中，这样可以少一次访问，加快地址变换速度。 3.7 段页管理方式分页、分段的优缺点 优点 缺点 分页管理 内存空间利用率高，不会产生外部碎片，只念有少量的页内碎片 不方便按照逻辑模块实现信息的共享和保护 分段管理 很方便按照逻辑模块实现信息的共享和保护 如果段长过大，为其分配很大的连续空间会很不方便。另外，段式管理会产生外部碎片 段页式管理的逻辑地址分段系统的逻辑地址结构由段号和段内地址(段內偏移量)组成。 段页式系统的逻辑地址结构由段号、页号、页内地址(页内偏移量)组成。 “分段”对用户是可见的，程序员编程时需要显式地给出段号、段内地址。 而将各段”分页”对用户是不可见的。 系统会根据段内地址自动划分页号和页内偏移量。因此段页式管理的地址结构是二维的。 段号的位数决定了每个进程最多可以分几个段 页号位数决定了每个段最大有多少页 页内偏移量决定了页面大小、内存块大小是多少 在上述例子中，若系统是按字节寻址的，则 段号占16位，因此在该系统中，每个进程最多有2^16^&#x3D;64K 个段 页号占4位，因此每个段最多有2^4^&#x3D;16页 页内偏移量占12位，因此每个页面每个内存块大小为 2^12^&#x3D;4KB 段表、页表每个段对应一个段表项，每个段表项由段号、页表长度、页表存放块号(页表起始地址)组成。每个段表项长度相等，段号是隐含的。 每个页面对应一个页表项，每个页表项由页号、页面存放的内存块号组成。每个页表项长度相等，页号是隐含的。 地址变换 由逻辑地址得到段号、页号、页内偏移量 段号与段表寄存器中的段长度比较，检查是否越界 由**段表始址、段号**找到对应段表项(第一次访存，查段表) 根据段表中记录的页表长度，检查页号是否越界 由**段表中的页表地址、页号**得到查询页表，找到相应页表项(第二次访存，查页表) 由页面存放的内存块号、页内偏移量得到最终的物理地址 访问目标单元(第三次访存) 如果采用快表机构，若快表命中，则只需一次访存 3.8 虚拟内存传统存储管理方式 一次性：作业必须一次性全部装入内存后才能开始运行。 这会造成两个问题： 作业很大时，不能全部装入内存，导致大作业无法运行 当大量作业要求运行时，由于内存无法容纳所有作业，因此只有少量作业能运行，导致多道程序并发度下降。 驻留性：一旦作业被装入内存，就会一直驻留在内存中，直至作业运行结束。 事实上，在一个时间段内，只需要访问作业的一小部分数据即可正常运行，这就导致了内存中会驻留大量的、惩时用不到的数据，浪费了宝贵的内存资源。 很多暂时用不到的数据也会长期占用内存，导致内存利用率不高 虚拟内存的定义局部性原理： 时间局部性：如果执行了程序中的某条指令，那么不久后这条指令很有可能再次执行； 如果某个数据被访问过，不久之后该数据很可能再次被访问。（因为程序中存在大量的循环） 空间局部性：一旦程序访问了某个存储单元，在不久之后，其附近的存储单元也很有可能被访问。 （因为很多数据在内存中都是连续存放的，并且程序的指令也是顺序地在内存中存放的） 高速缓冲技术的思想：将近期会频繁访间到的数据放到更高速的存储器中，暂时用不到的数据放在更低速存储器中。 基于局部性原理，在程序装入时，可以将程序中很快会用到的部分装入内存，暂时用不到的部分留在外存，就可以让程序开始执行。 在程序执行过程中，当所访问的信息不在内存时，由操作系统负责将所需信息从外存调入内存，然后继续执行程序。 若内存空间不够，由操作系统负责将内存中暂时用不到的信息换出到外存。 在操作系统的管理下，在用户看来似乎有一个比实际内存大得多的内存，这就是虚拟内存 虚拟内存的容量 虚拟内存的最大容量是由计算机的地址结构(CPU寻址范围)确定的 虚拟内存的实际容量&#x3D;min(内存和外存容量之和，CPU寻址范围) 如：某计算机地址结构为32位，按字节编址，内存大小为512MB，外存大小为2GB。 则虚拟内存的最大容量为 2^32^B&#x3D;4GB 虚拟内存的实际容量&#x3D;min(512MB+2GB, 2^32^)&#x3D;2GB+512MB 虚拟内存的特征虚拟内存有一下三个主要特征： 多次性：无需在作业运行时一次性全部装入内存，而是允许被分成多次调入内存。 对换性：在作业运行时无需一直常驻内存，而是允许在作业运行过程中，将作业换入、换出。 虚拟性：从逻辑上扩充了内存的容量，使用户看到的内存容量，远大于实际的容量。 实现虚拟内存技术虛拟内存技术，允许一个作业分多次调入内存。如果采用连续分配方式，会不方便实现。因此，虛拟内存的实现需要建立在离散分配的内存管理方式基础上。 虚拟内存的实现： 请求分页存储管理 请求分段存储管理 请求段页式存储管理 主要区别： 在程序执行过程中， 当所访问的信息不在内存时，由操作系统负责将所需信息从外存调入内存，然后继续执行程序。 操作系统要提供请求调页（或请求调段）功能 若内存空间不够时，由操作系统负责将内存中暂时用不到的信息换出到外存。 操作系统要提供页面置换（或段置换）的功能 3.9 请求分页管理方式*页表机制缺页中断机构地址变换机构3.10 页面置换算法请求分页存储管理与基本分页存储管理的主要区别： 在程序执行过程中，当所访问的信息不在内存时，由操作系统负责将所需信息从外存调入内存，然后继续执行程序。 若内存空间不够，由操作系统负责将内存中暂时用不到的信息换出到外存。 用页面置换算法决定应该换出哪个页面 最佳置换算法(OPT)最佳置换算法(OPT, Optimal)：每次选择淘汰的页面将是以后永不使用，或者在最长时间内不再被访问的页面，这样可以保证最低的缺页率。例：假设系统为某进程分配了三个内存块，并考虑到有一下页面号引用串(会依次访问这些页面)：7, 0, 1, 2, 0, 3, 0, 4, 2, 3, 0, 3, 2, 1, 2, 0, 1, 7, 0, 1 访问页面 7 0 1 2 0 3 0 4 2 3 0 3 2 1 2 0 1 7 0 1 内存块1 7 7 7 2 2 2 2 2 7 内存块2 0 0 0 0 4 0 0 0 内存块3 1 1 3 3 3 1 1 是否缺页 ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ 以在访问2号页面为例： 内存块1为7，内存块2为0，内存块3为1，都已经占用 选择从0、1、7中淘汰页。按最佳置换的规则，往后寻找，最后一个出现的页号就是要淘汰的页面 最后出现的为7，就变为： 内存块1为2，内存块2为0，内存块3为1 整个过程缺页中断发生了9次(打对勾的)，页面置换发生了6次(前三次有空闲内存块没有发生置换)。 注意：缺页时末必发生页面置换。若还有可用的空闲内存块，就不用进行页面置换。 最佳罝换算法可以保证最低的缺页率，但实际上，只有在进程执行的过程中才能知道接下来会访问到的是哪个页面。操作系统无法提前预判页面访问序列。因此，最佳置换算法是无法实现的。 先进先出置换算法(FIFO)先进先出置换算法 (FIFO)：每次选择淘汰的页面是最早进入内存的页面 实现方法：把调入内存的页面根据调入的先后顺序排成一个队列，需要换出页面时选择队头页面即可队列的最大长度取决于系统为进程分配了多少个内存块。 例：假设系统为某进程分配了三个内存块，并考虑到有以下页面号引用串：3, 2, 1, 0, 3, 2, 4, 3, 2, 1, 0, 4 最近最久未使用置换算法(LRU)最近最久未使用置换算法(LRU，least recently used)：每次淘汰的页面是最近最久未使用的页面 实现方法：赋子每个页面对应的页表项中，用访问字段记录该页面白上次被访问以来所经历的时间t。 当需要淘汰一个页面时，选择现有页面中t值最大的，即最近最久未使用的页面。 例：假设系统为某进程分配了四个内存块，并考虑到有以下页面号引用串：1, 8, 1, 7, 8, 2, 7, 2, 1, 8, 3, 8, 2, 1, 3, 1, 7, 1, 3, 7 访问页面 1 8 1 7 8 2 7 2 1 8 3 8 2 1 3 1 7 1 3 7 内存块1 1 1 1 1 1 1 内存块2 8 8 8 8 7 内存块3 7 7 3 3 内存块4 2 2 2 是否缺页 ✓ ✓ ✓ ✓ ✓ ✓ 在手动做题时，若需要淘汰页面，可以逆向检查(&lt;—)此时在内存中的几个页面号。 在逆向扫描过程中最后一个出现的页号就是要淘汰的页面。 时钟置换算法(CLOCK)改进型的时钟置换算法3.11 页面分配策略驻留集：指请求分页存储管理中给进程分配的物理块的集合。在采用了虚拟存储技术的系统中，驻留集大小一般小于进程的总大小。若驻留集太小，会导致缺页频繁，系统要花大量的时间来处理缺页，实际用于进程推进的时间很少驻留集太大，又会导致多道程序并发度下降，资源利用率降低。所以应该选择一个合适的驻留集大小。 固定分配：操作系统为每个进程分配一组固定数目的物理块，在进程运行期间不再改变。即，驻留集大小不变 可变分配：先为每个进程分配一定数目的物理块，在进程运行期间，可根据情况做适当的增加或减少。即，驻留集大小可变 局部置换：发生缺页时只能选进程自己的物理块进行置换。 全局置换：可以将操作系统保留的空闲物理块分配给缺页进程，也可以将别的进程持有的物理块置换到外存，再分配给缺页进程。 固定分配局部置换：系统为每个进程分配一定数量的物理块，在整个运行期间都不改变。若进程在运行中发生缺页，则只能从该进程在内存中的页面中选出一页换出，然后再调入需要的页面。这种策略的缺点是：很难在刚开始就确定应为每个进程分配多少个物理块才算合理。(采用这种策略的系统可以根据进程大小、优先级、或是根据程序 员给出的参数来确定为一个进程分配的内存块数) 可变分配全局置换：刚开始会为每个进程分配一定数量的物理块。操作系统会保持一个空闲物理块队当某进程发生缺页时，从空闲物理块中取出一块分配给该进程；若已无空闲物理块，则可选择一个未锁定的页面换出外存，再将该物理块分配给缺页的进程。采用这种策略时，只要某进程发生缺页，都将获得新的物理块，仅当空闲物理块用完时，系统才选择一个未锁定的页面调出。被选择调出的页可能是系统中任何一个进程中的页，因此这个被选中的进程拥有的物理块会减少，缺页率会增加。 四、文件4.1 初识文件管理文件属性 文件名：由创建文件的用户决定文件名，主要是为了方便用户找到文件，同一目录下不允许有重名文件。 标识符：一个系统内的各文件标识符唯一，对用户来说亳无可读性，因此标识符只是操作系统用于区分各个文件的一种内部名称。 类型：指明文件的类型 位置：文件存放的路径(让用户使用)、在外存中的地址(操作系统使用，对用户不可见)大小：指明文件大小 创建时间、上次修改时间、文件所有者信息 保护信息：对文件进行保护的访问控制信息 操作系统提供的功能 创建文件 删除文件 读文件 写文件 打开文件 关闭文件 4.2 文件的逻辑结构按文件是否有结构分类，可以分为无结构文件、有结构文件两种。 无结构文件：文件内部的数据就是一系列二进制流或字符流组成。又称“流式文件”。 如：Windows 操作系统中的.txt 文件。 有结构文件：由一组相似的记录组成，又称“记录式文件”。每条记录又若干个数据项组成。 如：数据库表文件。一般来说，每条记录有一个数据项可作为关键字。根据各条记录的长度(占用的存储空间)是否相等，又可分为定长记录和可变长记录两种。 有结构文件在逻辑上可分为三类：顺序文件、索引文件、索引顺序文件 顺序文件顺序文件：文件中的记录一个接一个地顺序排列（逻辑上），记录可以是定长的或可变长的。各个记录在物理上可以顺序存储或链式存储。 顺序存储一一逻辑上相邻的记录物理上也相邻(类似于顺序表) 链式存储一一逻辑上相邻的记录物理上不一定相邻(类似于链表) 顺序文件的结构： 串结构：记录之间的顺序与关键字无关(通常按照记录存入的时间决定记录的顺序) 顺序结构：记录之间的顺序按关键字顺序排列 定长记录的顺序文件，若物理上采用顺序存储，则可实现随机存取；若能再保证记录的顺序结构，则可实现快速检索(即根据关键字快速找到对应记录〉 一般来说，考试题目中所说的”顺序文件”指的是物理上顺序存储的顺序文件。之后的讲解中提到的顺序文件也默认如此。可见，顺序文件的缺点是增加&#x2F;删除一个记录比较困难（如果是串结构则相对简单） 索引文件建立一张索引表以加快文件检素速度。每条记录对应一个索引项。逻辑文件 索引表本身是定长记录的顺序文件。因此可以快速找到第i个记录对应的素引项。可将关键字作为索引号内容，若按关键字顺序排列，则还可以支持按照关键字折半查找。每当要增加&#x2F;删除一个记录时，需要对索引表进行修改。由于索引文件有很快的检索速度，因此主要用于对信息处理的及时性要求比较高的场合。 另外，可以用不同的数据项建立多个索引表。如：学生信息表中，可用关键字 “学号”建立一张素引表。也可用“姓名”建立一张索引表。这样就可以根据”姓名”快速地检索文件了。 文件目录两级目录多级目录文件的物理结构4.3 文件存储空间管理位示图法![F&#96;XC_DT2WYTE_CB~_40TU_M.png](https://s2.loli.net/2023/02/09/yREqvoUxCZ4MzFw.png) 位示图：每个二进制位对应一个盘块。在本例中，“0”代表盘块空闲，“1”代表盘块已分配。位示图一般用连续的“字”来表示，如本例中一个字的字长是16位，字中的每一位对应一个盘块。因此可以用（字号，位号)对应一个盘块号。当然有的题目中也描述为（行号，列号） 盘块号与字号、位号相互转换的公式 盘号&#x3D;字长*字号+位号 字号&#x3D;盘号&#x2F;字长 位号&#x3D;盘号%位号 成组链接法空闲表法、空闲链表法不适用于大型文件系统，因为空闲表或空闲链表可能过大。UNIX系统中采用了成组链接法对磁盘空闲块进行管理。 文件卷的目录区中专门用一个磁盘块作为”超级块”，当系统启动时需要将超级块读入内存。并且要保证内存与外存中的”超级块”数据一致。 磁盘调度算法先来先服务根据进程请求访问磁盘的先后顺序进行调度。 假设磁头的初始位置是100号磁道，有多个进程先后陆续地请求访问55、58、39、18、90、160、150、38、184号磁道 按照FCFS的规则，按照请求到达的顺序，磁头需要依次移动到55、58、39、18、90、160、150、38、184号磁道 磁头总共移动了45+3+19+21+72+70+10+112+146&#x3D;498个磁道 响应一个请求平均需要移动498&#x2F;9&#x3D;55.3个磁道(平均寻找长度) 优点：公平；如果请求访问的磁道比较集中的话，算法性能还算过的去 缺点：如果有大量进程竞争使用磁盘，请求访问的磁道很分散，则FCS在性能上很差，寻道时间长。 最短寻找时间优先SSTFSSTF算法会优先处理的磁道是与当前磁头最近的磁道。可以保证每次的寻道时间最短，但是并不能保证总的寻道时间最短。(其实就是贪心算法的思想，只是选择眼前最优，但是总体未必最优) 假设磁头的初始位置是100号磁道，有多个进程先后陆续地请求访问55、58、39、18、90、160、150、38、184号磁道 磁头总共移动了（100-18)+(184-18)&#x3D;248个磁道 响应一个请求平均需要移动248&#x2F;9&#x3D;27.5个磁道（平均寻找长度） 优点：性能较好，平均寻道时间短 缺点：可能产生”饥饿”现象 Eg:本例中，如果在处理18号磁道的访问请求时又来了一个38号磁道的访问请求，处理38号磁道的访问请求时又来了一个18号磁道的访问请求。如果有源源不断的18号、38号磁道的访问请求到来的话，150、160、184号磁道的访问请求就永远得不到满足，从而产生“饥饿”现象。 扫描算法SCANSSTF算法会产生饥饿的原因在于：磁头有可能在一个小区域内来回来去地移动。为了防止这个问题，可以规定，只有磁头移动到最外侧磁道的时候才能往内移动，移动到最内侧磁道的时候才能往外移动。这就是扫描算法(SCAN)的思想。由于磁头移动的方式很像电梯，因此也叫电梯算法。 假设某磁盘的磁道为0~200号，磁头的初始位置是100号磁道，且此时磁头正在往磁道号增大的方向移动，有多个进程先后陆续地请求访问55、58、39、18、90、160、150、38、184号磁道 磁头总共移动了(200-100)+(184-18)&#x3D;250个磁道 响应一个请求平均需要移动250&#x2F;9&#x3D;27.5个磁道（平均寻找长度） 循环扫描算法CSCANSCAN算法对于各个位置磁道的响应频率不平均，而C-SCAN算法就是为了解决这个问题。规定只有磁头朝某个特定方向移动时才处理磁道访问请求，而返回时直接快速移动至起始端而不处理任何请求。 假设某磁盘的磁道为0~200号，磁头的初始位置是100号磁道，且此时磁头正在往磁道号增大的方向移动，有多个进程先后陆续地请求访问55、58、39、18、90、160、150、38、184号磁道 磁头总共移动了(184-100)+(184-18)+(90-18)&#x3D;322个磁道 响应一个请求平均需要移动322&#x2F;9&#x3D;5.8个磁道（平均寻找长度） 五、I-O设备缓冲区管理单缓冲假设某用户进程请求某种块设备读入若干块的数据。若采用单缓冲的策略，操作系统会在主存中为其分配一个缓冲区(若题目中没有特别说明，一个缓冲区的大小就是一个块)。 注意：当缓冲区数据非空时，不能往缓冲区冲入数据，只能从缓冲区把数据传出：当缓冲区为空时可以往缓冲区冲入数据，但必须把缓冲区充满以后，才能从缓冲区把数据传出。 结论：采用单缓冲策略，处理一块数据平均耗时：Max(C,T)+M 双缓冲假设某用户进程请求某种块设备读入若干块的数据。若采用双缓冲的策略，操作系统会在主存中为其分配两个缓冲区(若题目中没有特别说明，一个缓冲区的大小就是一个块) 双缓冲题目中，假设初始状态为：工作区空，其中一个缓冲区满，另一个缓冲区空 结论：采用双缓冲策略，处理一个数据块的平均耗时为：Max(T,C+M)","categories":[{"name":"计算机4件套","slug":"计算机4件套","permalink":"http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA4%E4%BB%B6%E5%A5%97/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"","slug":"小技巧/@Autowired与@Resource","date":"2022-08-06T11:11:16.336Z","updated":"2022-09-08T00:30:02.078Z","comments":true,"path":"2022/08/06/小技巧/@Autowired与@Resource/","link":"","permalink":"http://example.com/2022/08/06/%E5%B0%8F%E6%8A%80%E5%B7%A7/@Autowired%E4%B8%8E@Resource/","excerpt":"","text":"@Autowired和@Resource区别1.提供方不同： @Autowired是由Spring提供，属于第三方 @Resource是由J2EE提供，属于Java的 2.装配时默认类型不同： @Autowired默认按type装配 默认情况下必须要求依赖对象存在，如果要允许null值，可以设置它的required属性为false。 如果想使用名称装配可以结合@Qualifier注解进行使用。 @Resource默认按name装配 名称可以通过name属性进行指定，如果没有指定name属性，当注解写在字段上时，默认取字段名进行名称查找。 如果注解写在setter方法上默认取属性名进行装配。 当找不到与名称匹配的bean时才按照类型进行装配。 但是需要注意的是，如果name属性一旦指定，就只会按照名称进行装配。 3.使用注意： @Autowired @Qualifier(“userService”) 是直接按照名字进行搜索，也就是说，对于UserServiceImpl 上面@Service注解必须写名字，不写就会报错，而且名字必须是@Autowired @Qualifier(“userService”) 保持一致。如果@Service上面写了名字，而@Autowired @Qualifier() ，一样会报错。 @Resource 根据这个注解的匹配效果可以看出，它进行了两次匹配，也就是说，如果你在UserService这个类上面这样写注解@Service。首先是找相同名字的，如果没有找到，再找相同类型的，而这里的@Service没有写名字，这个时候就进行了两次搜索，显然，速度就下降了许多。 @Resource根据名字搜索是这样写@Resource(“userService”)，如果你写了这个名字叫userService，那么UserServiceImpl的@Service注解也必须也是这个名字，不然还是会报错。","categories":[],"tags":[]},{"title":"Spring框架的学习笔记","slug":"Java/Spring框架","date":"2022-08-06T11:11:16.323Z","updated":"2022-10-11T14:43:19.080Z","comments":true,"path":"2022/08/06/Java/Spring框架/","link":"","permalink":"http://example.com/2022/08/06/Java/Spring%E6%A1%86%E6%9E%B6/","excerpt":"","text":"1.初识Spring 官网：spring官网 Spring已经发展成了一种开发的生态圈，Spring提供了若干个项目，每个项目用于完成特定的功能 Spring Framework Spring Boot Spring Cloud …. 目前已经发展到Spring 5.0，需要JDK8以上支持 2.Spring Framework架构 Spring Framework是Spring生态圈中最基础的项目，是其他项目的根基 Data Access：数据访问 Data Integeration：数据集成 Web：web开发 AOP：面向切面编程 Aspects：AOP思想实现 Core Container：核心容器 Test：单元测试与集成测试 3.核心概念3.1 项目结构 java包 com包 spring包 dao包 BookDao.java impl包 BookDaoImpl.java service包 BookSerive.java impl包 BookServiceImpl.java App.java主函数 resources包 applicationContext.xml jdbc.properties 3.2 初识IOC和DI12345public class BookDaoImpl implements BookDao &#123; public void save() &#123; System.out.println(&quot;book dao save...&quot;); &#125;&#125; 123456public class BookServiceImpl implements BookService &#123; private BookDao bookDao = new BookDaoImpl; public void save() &#123; bookDao.save(); &#125;&#125; 这是一种很常见的写法。但是这样的写法耦合度太高，耦合度可以简单的理解为：两个类之间的关联程度，耦合度高就代表两个类之间关联程度很高，动其中一个类，就不得不动另外一个类。 所以就需要解耦 123456public class BookServiceImpl implements BookService &#123; private BookDao bookDao;//service:我免费啦！ public void save() &#123; bookDao.save(); &#125;&#125; IOC(Inversion of Control) 控制反转 使用对象时，由以前主动new一个对象转换为由外部提供对象，创建对象的控制权交给了外部，此思想为控制反转。 Spring技术对IOC进行实现 Spring提供一个容器，称为IOC容器，用来当作IOC思想中的**”外部”** IOC容器负责对象的创建、初始化等工作 在IOC容器中被创建或被管理的对象称之为Bean DI(Dependency Injection) 依赖注入 在容器中建立的bean与bean之间的依赖关系的整个过程，称之为依赖注入。 例：service层需要依赖dao层运行，但无需自己new一个dao层，它会自动生成dao层。 目标：充分解耦 使用IOC容器管理bean(IOC思想) 在ICO容器内将依赖关系的bean进行关系绑定(DI思想) 在使用对象时不仅可以从IOC容器中获取，并且也可以获取到bean已经绑定的所有依赖关系 4.IOC入门 pom.xml导入spring的坐标 12345&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;5.3.18&lt;/version&gt;&lt;/dependency&gt; resources目录创建Spring配置文件applicationContext.xml 配置bean bean标签：配置bean id属性：给bean起名字 class属性：给bean定义类型 123&lt;bean id=&quot;bookDao&quot; class=&quot;com.spring.dao.impl.BookDaoImpl&quot;/&gt;&lt;bean id=&quot;bookService&quot; class=&quot;com.spring.service.impl.BookServiceImpl&quot;/&gt; 创建名为启动类App 1234567891011121314151617import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;import com.spring.dao.BookDao;public class App &#123; public static void main(String[] args) &#123; //获取ICO容器 ApplicationContext ac = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); //获取bean BookDao bookDao = (BookDao) ac.getBean(&quot;bookDao&quot;); bookDao.save(); BookService bookService = (BookService) ac.getBean(&quot;bookService&quot;); bookService.save(); &#125;&#125; 5.DI入门 基于IOC管理bean 不能保留Service层中用new创建的对象 通过spring配置文件进行配置Service与Dao的关系 12345678910111213public class BookServiceImpl implements BookService &#123; //删除业务层中用new创建对象的方式 //private BookDao bookDao = new BookDaoImpl(); private BookDao bookDao; //提供相应的set的方法 public void setBookDao(BookDao bookDao) &#123; this.bookDao = bookDao; &#125; public void save() &#123; bookDao.save(); &#125;&#125; 在spring配置文件applicationContext.xml中，配置property property标签：配置当前bean的属性 name属性：配置哪个具体的属性 ref属性：参照spring配置文件中的哪个bean的id 123456&lt;bean id=&quot;bookDao&quot; class=&quot;com.spring.dao.impl.BookDaoImpl&quot;/&gt;&lt;bean id=&quot;bookService&quot; class=&quot;com.spring.service.impl.BookServiceImpl&quot;&gt; &lt;!-- 配置service与dao的关系 --&gt; &lt;property name=&quot;bookDao&quot; ref=&quot;bookDao&quot;/&gt;&lt;/bean&gt; 配置完成后，BookDao无需使用new来手动创建对象，而是通过spring来自动创建 6.bean基础配置6.1 bean别名配置 name属性：可以起多个别名用;分号 空格,逗号分隔 123&lt;bean id=&quot;bookDao&quot; name=&quot;dao Dao&quot; class=&quot;com.spring.dao.impl.BookDaoImpl&quot;/&gt;&lt;bean id=&quot;bookService&quot; name=&quot;Service service&quot; class=&quot;com.spring.service.impl.BookServiceImpl&quot;/&gt; 别名可以用于getBean()方法 1234567891011public class App &#123; public static void main(String[] args) &#123; //获取ICO容器 ApplicationContext ac = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); //获取bean //BookService bookService=(BookService)ac.getBean(&quot;bookService&quot;); //通过别名获取BookService BookService bookService=(BookService)ac.getBean(&quot;Service&quot;); bookService.save(); &#125;&#125; 别名也可以用于ref属性，不建议用别名，建议使用id 123&lt;bean id=&quot;bookService&quot; class=&quot;com.spring.service.impl.BookServiceImpl&quot;&gt; &lt;property name=&quot;bookDao&quot; ref=&quot;Dao&quot;/&gt;&lt;/bean&gt; 6.2 bean的作用范围创建的bean是否为多个对象 123456789101112public class App &#123; public static void main(String[] args) &#123; //获取ICO容器 ApplicationContext ac = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); //获取bean BookDao bookDao1 = (BookDao) ac.getBean(&quot;bookDao&quot;); BookDao bookDao2 = (BookDao) ac.getBean(&quot;bookDao&quot;); System.out.println(bookDao1); System.out.println(bookDao2); &#125;&#125; 123运行结果：com.spring.dao.impl.BookDaoImpl@7219ec67com.spring.dao.impl.BookDaoImpl@7219ec67 结论：两个对象地址相同，spring默认创建的bean是单例的 需要在配置文件的bean标签里添加一个scope属性 scope属性有singleton单例模式和prototype非单例模式 scope属性默认为singleton单例模式 1&lt;bean id=&quot;bookDao&quot; class=&quot;com.spring.dao.impl.BookDaoImpl&quot; scope=&quot;prtotype&quot;/&gt; 123再次运行后，运行结果：com.spring.dao.impl.BookDaoImpl@7219ec67com.spring.dao.impl.BookDaoImpl@45018215 结论：两个对象地址不同，为非单例模式 bean作用范围说明 单例bean的优势 减少了新生成实例的消耗，可以快速获取到bean，更大程度的复用 适合交给容器进行管理的bean 表现层对象，业务层对象，数据层对象，工具对象 不适合交给容器进行管理的bean 封装实体的域对象(存在变量的) 7.bean实例化 bean的本质就是对象，创建bean都需要使用构造方法完成 7.1 构造方法实例化bean(常用) 在BookDaoImpl类中创建构造方法： 123456789101112public class BookDaoImpl implements BookDao &#123; public BookDaoImpl()&#123; System.out.println(&quot;BookDaoImpl构造函数&quot;); &#125; /*private BookDaoImpl()&#123; System.out.println(&quot;BookDaoImpl构造函数&quot;); &#125;*/ public void save() &#123; System.out.println(&quot;BookDao~~~~~&quot;); &#125;&#125; AppForInstanceBook类进行测试： 12345678public class AppForInstanceBook &#123; public static void main(String[] args) &#123; ApplicationContext ac = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); BookDao bookDao = (BookDao) ac.getBean(&quot;bookDao&quot;); bookDao.save(); &#125;&#125; 123运行结果：BookDaoImpl构造函数BookDao~~~~~ 并且BookDaoImpl中的构造方法无论是否私有都可以被调用，这就是反射。 无参构造方法不存在，将会抛出异常 在BookDaoImpl类中构造方法改为有参构造： 123public BookDaoImpl(int i)&#123; System.out.println(&quot;BookDaoImpl构造函数&quot;);&#125; 运行后会报错，同时说明Spring创建bean的时候，调用的是无参构造。 7.2 静态工厂实例化bean(早期实例化bean 了解) 创建一个factory软件包，并在里面创建一个BookDaoFactory类： 123456public class BookDaoFactory &#123; public static BookDao getBookDao()&#123; System.out.println(&quot;factory is running&quot;); return new BookDaoImpl(); &#125;&#125; AppForInstanceBook类运行： 1234567public class AppForInstanceBook &#123; public static void main(String[] args) &#123; BookDao bookDao = BookDaoFactory.getBookDao(); bookDao.save(); &#125;&#125;//运行成功 通过配置文件使用静态工厂实例化bean： Spring配置文件中： factory-method属性：选择工厂里的bean实例方法 12&lt;bean id=&quot;bookDao&quot; class=&quot;com.spring.factory.BookDaoFactory&quot; factory-method=&quot;getBookDao&quot;/&gt; AppForInstanceBook类运行： 12345678public class AppForInstanceBook &#123; public static void main(String[] args) &#123; ApplicationContext ac = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); BookDao bookDao = (BookDao) ac.getBean(&quot;bookDao&quot;); bookDao.save(); &#125;&#125; 1234运行结果：factory is runningBookDaoImpl构造函数BookDao~~~~~ 7.3 实例工厂实例化bean(非静态工厂 了解) BookDaoFactory类中，将方法改为非静态方法 123456public class BookDaoFactory &#123; public BookDao getBookDao()&#123; System.out.println(&quot;factory is running~~~~~&quot;); return new BookDaoImpl(); &#125;&#125; AppForInstanceBook类运行： 1234567public class AppForInstanceBook &#123; public static void main(String[] args) &#123; BookDaoFactory bookDaoFactory = new BookDaoFactory(); BookDao bookDao = bookDaoFactory.getBookDao(); bookDao.save(); &#125;&#125; 1234运行结果：factory is running~~~~~BookDaoImpl构造函数BookDao~~~~~ 通过配置文件使用静态工厂实例化bean： Spring配置文件中： 12345&lt;!-- 先要造出工厂的bean --&gt;&lt;bean id=&quot;bookDaoFactory&quot; class=&quot;com.spring.factory.BookDaoFactory&quot;/&gt;&lt;bean id=&quot;bookDao&quot; factory-bean=&quot;bookDaoFactory&quot; factory-method=&quot;getBookDao&quot; /&gt; AppForInstanceBook类运行： 12345678public class AppForInstanceBook &#123; public static void main(String[] args) &#123; ApplicationContext ac = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); BookDao bookDao = (BookDao) ac.getBean(&quot;bookDao&quot;); bookDao.save(); &#125;&#125; 1234运行结果：factory is running~~~~~BookDaoImpl构造函数BookDao~~~~~ 配置文件中beanbookDaoFactory只是为了配合使用，实际没有意义。 Spring对这种实例化bean方法进行了改良： 4.通过FactoryBean实例化bean(实用) 创建BookDaoFactoryBean类实现接口FactoryBean&lt;T&gt; 123456789101112public class BookDaoFactoryBean implements FactoryBean&lt;BookDao&gt; &#123; //代替原始实例工厂中创建对象的方法 @Override public BookDao getObject() throws Exception &#123; return new BookDaoImpl(); &#125; @Override public Class&lt;?&gt; getObjectType() &#123; return BookDao.class; &#125;&#125; Spring配置文件中： 1&lt;bean id=&quot;bookDao&quot; class=&quot;com.spring.factory.BookDaoFactoryBean&quot;/&gt; AppForInstanceBook类运行： 12345678public class AppForInstanceBook &#123; public static void main(String[] args) &#123; ApplicationContext ac = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); BookDao bookDao = (BookDao) ac.getBean(&quot;bookDao&quot;); bookDao.save(); &#125;&#125; 123运行结果：BookDaoImpl构造函数BookDao~~~~~ 并且BookDaoFactoryBean类中可以重写isSinglenton方法： 1234567891011121314151617181920212223242526272829&lt;table&gt; &lt;th align=&quot;center&quot;&gt; &lt;td rowspan=&quot;2&quot;&gt;Key&lt;/td&gt; &lt;td colspan=&quot;2&quot;&gt;Value&lt;/td&gt; &lt;/th&gt; &lt;tr align=&quot;center&quot;&gt; &lt;td&gt;field&lt;/td&gt; &lt;td&gt;value&lt;/td&gt; &lt;/tr&gt; &lt;tr align=&quot;center&quot;&gt; &lt;td rowspan=&quot;2&quot;&gt;REQUIRES_NEW&lt;/td&gt; &lt;td&gt;开启T&lt;/td&gt; &lt;td&gt;新建T2&lt;/td&gt; &lt;/tr&gt; &lt;tr align=&quot;center&quot;&gt; &lt;td&gt;无&lt;/td&gt; &lt;td&gt;新建T2&lt;/td&gt; &lt;/tr&gt; &lt;tr align=&quot;center&quot;&gt; &lt;td rowspan=&quot;2&quot;&gt;SUPPORTS&lt;/td&gt; &lt;td&gt;开启T&lt;/td&gt; &lt;td&gt;加入T&lt;/td&gt; &lt;/tr&gt; &lt;tr align=&quot;center&quot;&gt; &lt;td&gt;无&lt;/td&gt; &lt;td&gt;无&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt; 8.bean的生命周期 bean生命周期：bean从创建到销毁的整体过程 bean生命周期控制：在bean创建后到销毁前做一些事 在BookDaoImpl类中，创建init和destroy方法 1234567891011121314public class BookDaoImpl implements BookDao &#123; public void save() &#123; System.out.println(&quot;BookDao~~~~~&quot;); &#125; public void init()&#123; System.out.println(&quot;init~~~&quot;); &#125; public void destroy()&#123; System.out.println(&quot;destroy~~~&quot;); &#125;&#125; 在Spring配置文件中： init-method和destroy-method属性 12&lt;bean id=&quot;bookDao&quot; class=&quot;com.spring.dao.impl.BookDaoImpl&quot; init-method=&quot;init&quot; destroy-method=&quot;destroy&quot;/&gt; 调用主函数： 123456789public class App &#123; public static void main(String[] args) &#123; //获取ICO容器 ApplicationContext ac = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); //获取bean BookDao bookDao = (BookDao) ac.getBean(&quot;bookDao&quot;); bookDao.save(); &#125;&#125; 123运行结果：init~~~BookDao~~~~~ 控制台并没有输出destroy~~~； 因为销毁函数还没有来得及调用，程序就被杀死了； 所以需要进行手动关闭； 我们调用主函数中的ac中的close()方法，但是ApplicationContext接口中并没有提供close()方法，所以我们要改用ClassPathXmlApplicationContext类。 12345678910public class App &#123; public static void main(String[] args) &#123; //获取ICO容器 ClassPathXmlApplicationContext ac = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); //获取bean BookDao bookDao = (BookDao) ac.getBean(&quot;bookDao&quot;); bookDao.save(); ac.close(); &#125;&#125; 12345运行结果：init~~~BookDao~~~~~destroy~~~ 成功！！！！ 容器还提供另外一种方式关闭容器：设置关闭钩子 调用ac的registerShutdownHook()方法 1234567891011public class App &#123; public static void main(String[] args) &#123; //获取ICO容器 ClassPathXmlApplicationContext ac = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); //获取bean BookDao bookDao = (BookDao) ac.getBean(&quot;bookDao&quot;); bookDao.save(); ac.registerShutdownHook(); &#125;&#125; 1234运行结果：init~~~BookDao~~~~~destroy~~~ close()和registerShutdownHook()的区别 将registerShutdownHook()放到上面： 12345678910public class App &#123; public static void main(String[] args) &#123; //获取ICO容器 ClassPathXmlApplicationContext ac = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); ac.registerShutdownHook(); //获取bean BookDao bookDao = (BookDao) ac.getBean(&quot;bookDao&quot;); bookDao.save(); &#125;&#125; 1234运行成功：init~~~BookDao~~~~~destroy~~~ 将close()放到上面： 12345678910public class App &#123; public static void main(String[] args) &#123; //获取ICO容器 ClassPathXmlApplicationContext ac = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); ac.close(); //获取bean BookDao bookDao = (BookDao) ac.getBean(&quot;bookDao&quot;); bookDao.save(); &#125;&#125; 123456运行结果：init~~~destroy~~~报错：BeanFactory not initialized or already closed - call &#x27;refresh&#x27; before accessing beans via the ApplicationContext BeanFactory没有被初始化或者已经被关闭了 运行失败！！ 或者通过接口的方式实现： BookServiceImpl类实现接口InitializingBean和DisposableBean的方法 1234567891011121314151617181920212223public class BookServiceImpl implements BookService, InitializingBean, DisposableBean &#123; private BookDao bookDao; public void setBookDao(BookDao bookDao) &#123; System.out.println(&quot;BookDao set~~~&quot;); this.bookDao = bookDao; &#125; public void save() &#123; bookDao.save(); &#125; @Override public void destroy() throws Exception &#123; System.out.println(&quot;service destroy~~~~&quot;); &#125; @Override public void afterPropertiesSet() throws Exception &#123; System.out.println(&quot;service init~~~~&quot;); &#125;&#125; 配置文件： 123456&lt;bean id=&quot;bookDao&quot; class=&quot;com.spring.dao.impl.BookDaoImpl&quot; init-method=&quot;init&quot; destroy-method=&quot;destroy&quot;/&gt;&lt;bean id=&quot;bookService&quot; class=&quot;com.spring.service.impl.BookServiceImpl&quot;&gt;&lt;property name=&quot;bookDao&quot; ref=&quot;bookDao&quot;/&gt;&lt;/bean&gt; 主函数运行： 12345678910public class App &#123; public static void main(String[] args) &#123; //获取ICO容器 ClassPathXmlApplicationContext ac = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); //获取bean BookDao bookDao = (BookDao) ac.getBean(&quot;bookDao&quot;); bookDao.save(); ac.registerShutdownHook(); &#125;&#125; 1234567运行结果：init~~~BookDao set~~~service init~~~~BookDao~~~~~service destroy~~~~destroy~~~ BookServiceImpl类中destroy()方法和afterPropertiesSet()方法被调用 并且setBookDao()方法之后才调用的afterPropertiesSet()方法 9.依赖注入方式向一个类传递数据的方式有：set方法、构造方法 9.1 setter注入 引用类型 在bean中定义引用类型属性并提供可访问的set方法 BookServiceImpl类中： 1234567public class BookServiceImpl implements BookService &#123; private BookDao bookDao; //提供相应的set的方法 public void setBookDao(BookDao bookDao) &#123; this.bookDao = bookDao; &#125;&#125; 在配置文件中使用property标签ref属性注入引用类型对象 12345&lt;bean id=&quot;bookDao&quot; class=&quot;com.spring.dao.impl.BookDaoImpl&quot;/&gt;&lt;bean id=&quot;bookService&quot; class=&quot;com.spring.service.impl.BookServiceImpl&quot;&gt; &lt;property name=&quot;bookDao&quot; ref=&quot;bookDao&quot;/&gt;&lt;/bean&gt; 简单类型 在bean中定义引用类型属性并提供可访问的set方法 BookDaoImpl类中： 1234567891011121314public class BookDaoImpl implements BookDao &#123; private String name; private int age; public void setName(String name) &#123; this.name = name; &#125; public void setAge(int age) &#123; this.age = age; &#125; public void save() &#123; System.out.println(&quot;BookDao~~~~~&quot;+&quot;姓名：&quot;+name+&quot;年龄：&quot;+age); &#125;&#125; 配置文件中，在property标签value属性注入简单类型数据 1234&lt;bean id=&quot;bookDao&quot; class=&quot;com.spring.dao.impl.BookDaoImpl&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;DaHuang&quot;/&gt; &lt;property name=&quot;age&quot; value=&quot;18&quot;/&gt;&lt;/bean&gt; 运行主函数： 12345678910public class App &#123; public static void main(String[] args) &#123; //获取ICO容器 ClassPathXmlApplicationContext ac = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); //获取bean BookDao bookDao = (BookDao) ac.getBean(&quot;bookDao&quot;); bookDao.save(); ac.registerShutdownHook(); &#125;&#125; 12运行结果：BookDao~~~~~姓名：DaHuang年龄：18 9.2 构造器注入 引用类型 在bean中定义引用类型属性并提供可访问的构造方法 12345678public class BookServiceImpl implements BookService &#123; private BookDao bookDao; public BookServiceImpl(BookDao bookDao) &#123; System.out.println(&quot;BookServiceImpl构造器运行~~~&quot;); this.bookDao = bookDao; &#125;&#125; 配置文件中，使用constructor-arg标签中的ref属性注入引用类型对象 12345678&lt;bean id=&quot;bookDao&quot; class=&quot;com.spring.dao.impl.BookDaoImpl&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;DaHuang&quot;/&gt; &lt;property name=&quot;age&quot; value=&quot;18&quot;/&gt; &lt;/bean&gt;&lt;bean id=&quot;bookService&quot; class=&quot;com.spring.service.impl.BookServiceImpl&quot;&gt; &lt;constructor-arg name=&quot;bookDao&quot; ref=&quot;bookDao&quot;/&gt;&lt;/bean&gt; 运行主函数： 123456789public class App &#123; public static void main(String[] args) &#123; //获取ICO容器 ClassPathXmlApplicationContext ac = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); //获取bean BookDao bookDao = (BookDao) ac.getBean(&quot;bookDao&quot;); bookDao.save(); &#125;&#125; 12运行结果：BookServiceImpl构造器运行~~~ 简单类型 BookDaoImpl类中： 123456789public class BookDaoImpl implements BookDao &#123; private String name; private int age; public BookDaoImpl(String name, int age) &#123; this.name = name; this.age = age; &#125;&#125; 配置文件中： 1234&lt;bean id=&quot;bookDao&quot; class=&quot;com.spring.dao.impl.BookDaoImpl&quot;&gt; &lt;constructor-arg name=&quot;name&quot; value=&quot;DaHei&quot;/&gt; &lt;constructor-arg name=&quot;age&quot; value=&quot;20&quot;/&gt;&lt;/bean&gt; 如果要更改BookDaoImpl类中的形参名字，还要更改配置文件中的name属性的名字； 存在形参与name属性名不耦合的问题。 constructor-arg标签还有type和index属性 type：形参的数据类型(存在多个同数据类型的形参，无法使用) index：形参的位置顺序 在配置文件中，使用index属性设置按形参位置顺序注入 1234&lt;bean id=&quot;bookDao&quot; class=&quot;com.spring.dao.impl.BookDaoImpl&quot;&gt; &lt;constructor-arg index=&quot;0&quot; value=&quot;DaHei&quot;/&gt; &lt;constructor-arg index=&quot;1&quot; value=&quot;20&quot;/&gt;&lt;/bean&gt; 运行主函数： 123456789public class App &#123; public static void main(String[] args) &#123; //获取ICO容器 ClassPathXmlApplicationContext ac = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); BookDao bookDao = (BookDao) ac.getBean(&quot;bookDao&quot;); bookDao.save(); &#125;&#125; 12运行结果：BookDao~~~~~姓名：DaHei年龄：20 9.3 依赖注入方式的选择 强制依赖使用构造器注入，使用setter注入有概率不注入导致null对象出现。 bean必须要的东西，要用构造器注入。因为构造器必须被执行，必须注入，否则报错 而setter方法可以执行也可以不执行，如果没有进行setter注入，会导致null对象 可选依赖使用setter注入进行，灵活性强。 setter注入可以执行也可以不执行 Spring框架倡导使用构造器。 第三方框架大多采用构造器注入的形式初始化数据，更加严谨 setter注入和构造器注入可以同时使用。 使用构造器完成强制依赖注入，使用setter注入完成可选依赖注入 自己开发的模块推荐使用setter注入 10.依赖自动装配IOC容器根据bean都依赖的资源在容器中自动查找并注入到bean中的过程称为自动装配 自动装配的方式： 按类型(常用) 按名称 按构造方法(不推荐) 不启用自动装配 10.1 按类型需要提供相应的setter方法 123456789public class BookServiceImpl implements BookService &#123; private BookDao bookDao; public void setBookDao(BookDao bookDao) &#123; System.out.println(&quot;BookDao set~~~&quot;); this.bookDao = bookDao; &#125;&#125; 配置文件中，要提前写好bookDao的bean否则无法装配， autowire属性设置为byTpye 通过类型自动装配 1234&lt;bean id=&quot;bookDao&quot; class=&quot;com.spring.dao.impl.BookDaoImpl&quot;/&gt;&lt;bean id=&quot;bookService&quot; class=&quot;com.spring.service.impl.BookServiceImpl&quot; autowire=&quot;byType&quot; /&gt; 主函数： 123456789public class App &#123; public static void main(String[] args) &#123; ClassPathXmlApplicationContext ac = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); BookService bookService = (BookService) ac.getBean(&quot;bookService&quot;); bookService.save(); &#125;&#125; 12运行结果：BookDao set~~~ 如果出现一下这种情况： 12345&lt;bean id=&quot;bookDao1&quot; class=&quot;com.spring.dao.impl.BookDaoImpl&quot;/&gt;&lt;bean id=&quot;bookDao2&quot; class=&quot;com.spring.dao.impl.BookDaoImpl&quot;/&gt;&lt;bean id=&quot;bookService&quot; class=&quot;com.spring.service.impl.BookServiceImpl&quot; autowire=&quot;byType&quot; /&gt; 出现了两个BookDao的bean，导致Spring无法区分了，这时就需要按名称装配 10.2 按名称123456789public class BookServiceImpl implements BookService &#123; private BookDao bookDao; public void setBookDao(BookDao bookDao) &#123; System.out.println(&quot;BookDao set~~~&quot;); this.bookDao = bookDao; &#125;&#125; 配置文件中，autowire属性设置为byName 通过名称自动装配 是通过BookServiceImpl类的变量名bookDao与配置文件的bean中id相同名称的进行绑定 12345&lt;bean id=&quot;bookDao&quot; class=&quot;com.spring.dao.impl.BookDaoImpl&quot;/&gt;&lt;bean id=&quot;bookDao2&quot; class=&quot;com.spring.dao.impl.BookDaoImpl&quot;/&gt;&lt;bean id=&quot;bookService&quot; class=&quot;com.spring.service.impl.BookServiceImpl&quot; autowire=&quot;ByName&quot; /&gt; 10.3 总结 自动装配用于引用类型依赖注入，不能对简单类型进行操作 使用按类型装配byType，必须保障容器中相同类型的bean唯一，推荐使用 使用按名称装配byName，必须保障容器中具有指定名称的bean，变量名要与配置耦合， 不推荐使用 自动装配优先级低于setter注入和构造器注入，同时出现时自动装配配置失效 11.集合注入123456789101112131415161718192021222324252627public class BookDaoImpl implements BookDao &#123; private int[] array; private List&lt;String&gt; list; private Set&lt;String&gt; set; private Map&lt;String, String&gt; map; private Properties properties; public void setArray(int[] array) &#123;this.array = array;&#125; public void setList(List&lt;String&gt; list) &#123;this.list = list;&#125; public void setSet(Set&lt;String&gt; set) &#123;this.set = set;&#125; public void setMap(Map&lt;String, String&gt; map) &#123;this.map = map;&#125; public void setProperties(Properties properties) &#123;this.properties = properties;&#125; public void save() &#123; System.out.println(&quot;BookDaoImpl&#123;&quot; + &quot;\\narray=&quot; + Arrays.toString(array) + &quot;, \\nlist=&quot; + list + &quot;, \\nset=&quot; + set + &quot;, \\nmap=&quot; + map + &quot;, \\nproperties=&quot; + properties + &#x27;&#125;&#x27;); &#125;&#125; 配置文件中： 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;bean id=&quot;bookDao&quot; class=&quot;com.spring.dao.impl.BookDaoImpl&quot;&gt; &lt;property name=&quot;array&quot; &gt; &lt;array&gt; &lt;value&gt;100&lt;/value&gt; &lt;value&gt;200&lt;/value&gt; &lt;value&gt;300&lt;/value&gt; &lt;/array&gt; &lt;/property&gt; &lt;property name=&quot;list&quot; &gt; &lt;list&gt; &lt;value&gt;唱&lt;/value&gt; &lt;value&gt;跳&lt;/value&gt; &lt;value&gt;Rap&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;property name=&quot;set&quot; &gt; &lt;set&gt; &lt;value&gt;唱&lt;/value&gt; &lt;value&gt;跳&lt;/value&gt; &lt;value&gt;Rap&lt;/value&gt; &lt;value&gt;Rap&lt;/value&gt; &lt;/set&gt; &lt;/property&gt; &lt;property name=&quot;map&quot; &gt; &lt;map&gt; &lt;entry key=&quot;county&quot; value=&quot;china&quot;/&gt; &lt;entry key=&quot;province&quot; value=&quot;tianjin&quot;/&gt; &lt;entry key=&quot;city&quot; value=&quot;baodi&quot;/&gt; &lt;/map&gt; &lt;/property&gt; &lt;property name=&quot;properties&quot;&gt; &lt;props&gt; &lt;prop key=&quot;county&quot;&gt;china&lt;/prop&gt; &lt;prop key=&quot;province&quot;&gt;tianjin&lt;/prop&gt; &lt;prop key=&quot;city&quot;&gt;baodi&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt; &lt;/bean&gt; 运行主函数： 12345678public class App &#123; public static void main(String[] args) &#123; ClassPathXmlApplicationContext ac = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); BookDao bookDao = (BookDao) ac.getBean(&quot;bookDao&quot;); bookDao.save(); &#125;&#125; 1234567运行结果：BookDaoImpl&#123;array=[100, 200, 300], list=[唱, 跳, Rap], set=[唱, 跳, Rap], map=&#123;county=china, province=tianjin, city=baodi&#125;, properties=&#123;province=tianjin, city=baodi, county=china&#125;&#125; 12.数据源对象管理在pom.xml导入druid坐标 12345678910&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.2.8&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8.0.28&lt;/version&gt;&lt;/dependency&gt; 配置文件中，管理DruidDataSouurce对象 123456&lt;bean id=&quot;dataSource&quot; class=&quot;com.alibaba.druid.pool.DruidDataSource&quot;&gt; &lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/demo&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;123456&quot;/&gt;&lt;/bean&gt; 运行主函数： 12345678910public class App &#123; public static void main(String[] args) &#123; //获取ICO容器 ClassPathXmlApplicationContext ac = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); DataSource dataSource = (DataSource) ac.getBean(&quot;dataSource&quot;); System.out.println(dataSource); &#125;&#125; 123456789101112运行结果：&#123; CreateTime:&quot;2022-06-24 22:27:03&quot;, ActiveCount:0, PoolingCount:0, CreateCount:0, DestroyCount:0, CloseCount:0, ConnectCount:0, Connections:[ ]&#125; 13.加载properties配置信息在rescource资源包中创建jdbc.properties文件： 1234567jdbc.driver=com.mysql.jdbc.Driverjdbc.url=jdbc:mysql://localhost:3306/demojdbc.username=rootjdbc.password=123456username=dahuangage=18 配置文件中: 在beans标签中开启context命名空间 使用context空间加载properties文件 12345678910111213141516171819202122232425262728293031&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot; http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt; &lt;!-- 1.开启context命名空间 --&gt; &lt;!-- 2.使用context空间加载properties文件 --&gt; &lt;context:property-placeholder location=&quot;jdbc.properties&quot; system-properties-mode=&quot;NEVER&quot;/&gt; &lt;bean id=&quot;dataSource&quot; class=&quot;com.alibaba.druid.pool.DruidDataSource&quot;&gt; &lt;!-- 使用占位符$&#123;&#125;读取properties中的属性 --&gt; &lt;property name=&quot;driverClassName&quot; value=&quot;$&#123;jdbc.driver&#125;&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;$&#123;jdbc.url&#125;&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;$&#123;jdbc.username&#125;&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot;/&gt; &lt;/bean&gt; &lt;bean id=&quot;bookDao&quot; class=&quot;com.spring.dao.impl.BookDaoImpl&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;$&#123;username&#125;&quot;/&gt; &lt;property name=&quot;age&quot; value=&quot;$&#123;age&#125;&quot;/&gt; &lt;/bean&gt;&lt;/beans&gt; 加载properties文件格式： 不加载系统属性： 12&lt;context:property-placeholder location=&quot;jdbc.properties&quot; system-properties-mode=&quot;NEVER&quot;/&gt; 加载多个properties文件： 1&lt;context:property-placeholder location=&quot;jdbc.properties, jdbc2.properties&quot;/&gt; 加载所有properties文件： 1&lt;context:property-placeholder location=&quot;*.properties&quot;/&gt; 加载properties文件标准格式： 1&lt;context:property-placeholder location=&quot;classpath:*.properties&quot;/&gt; 从类路径或jar包中搜索加载properties文件： 1&lt;context:property-placeholder location=&quot;classpath*:*.properties&quot;/&gt; 14.容器14.1 创建容器的几种方式 类路径下的加载配置文件 1ApplicationContext ac = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); 文件系统下加载的配置文件 1ApplicationContext ac = new ClassPathXmlApplicationContext(&quot;E:\\Java_Web\\Spring\\spring_01_IOC\\src\\main\\resources\\applicationContext.xml&quot;); 加载多个配置文件： 1ApplicationContext ac = new ClassPathXmlApplicationContext(&quot;applicationContext1.xml&quot;,&quot;applicationContext2.xml&quot;); 14.2 获取bean的几种方式 使用bean名称获取 1BookDao bookDao = (BookDao) ac.getBean(&quot;bookDao&quot;); 使用bean名称获取并指定类型 1BookDao bookDao = ac.getBean(&quot;bookDao&quot;,BookDao.class); 使用bean类型获取 1BookDao bookDao = ac.getBean(BookDao.class);//对应的容器中只能有一个该类型，唯一 14.3 容器类层次结构使用ctrl+H打开容器类的层次结构图： BeanFactory：是IOC容器的顶层接口，初始化BeanFactory对象时，加载的bean延迟加载 ApplicationContext：是Spring容器的核心接口，初始化时bean立即加载 ​ 提供基础的bean操作相关的方法，通过其他接口扩展其功能 ConfigurableApplicationContext：提供关闭容器功能 ClassPathXmlApplicationContext：常用实现类 14.4 BeanFactory初始化类路径加载配置文件： 12345678public class App &#123; public static void main(String[] args) &#123; Rescoure rescoure = new ClassPathRescoure(&quot;applicationContext.xml&quot;); BeanFactory bf = new XmlBeanFactory(rescoure); BookDao bookDao = bf.getBean(&quot;bookDao&quot;,BookDao.class); bookDao.save(); &#125;&#125; BeanFactory创建完毕后，所有bean均为延迟加载 15.注解开发*15.1 用注释定义bean123456@component(&quot;bookDao&quot;) //等价于&lt;bean id=&quot;bookDao&quot; class=&quot;com.spring.dao.impl.BookDaoImpl&quot;/&gt;public class BookDaoImpl implements BookDao &#123; public void save() &#123; System.out.println(&quot;BookDao~~~~~&quot;); &#125;&#125; 123456@Component //没有写bean名，要通过类型获取beanpublic class BookServiceImpl implements BookService &#123; public void save() &#123; System.out.println(&quot;BookService~~~~&quot;); &#125;&#125; 但是，Spring怎么感知到注释呢？ 配置文件中，需要添加扫描组件： 123456789101112&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot; http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt; &lt;!-- 扫描@component组件 --&gt; &lt;!-- base-package为扫描的位置 --&gt; &lt;context:component-scan base-package=&quot;com.spring&quot;/&gt;&lt;/beans&gt; 主函数： 123456789101112public class App &#123; public static void main(String[] args) &#123; //获取ICO容器 ClassPathXmlApplicationContext ac = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); //获取bean BookDao bookDao = (BookDao) ac.getBean(&quot;bookDao&quot;); bookDao.save(); //因为@component，并没有写bean名，所以要用类型获取bean BookService bookService = ac.getBean(BookService.class); bookService.save(); &#125;&#125; 123运行结果：BookDao~~~~~BookService~~~~ Spring提供@component注解的三个衍生注解 @Repository：用于数据层bean定义(Dao层) ​ 也可以加括号来指定bean名，如：@Repository(“bookDao2”) @Service：用于业务层bean定义(Service层) @Controller：用于表现层bean定义(Controller层) @Service,@Repository不能写在接口上,需要写在接口的实现类上 1234@Repositorypublic class BookDaoImpl implements BookDao &#123; &#125; 1234@Servicepublic class BookServiceImpl implements BookService &#123;&#125; 1234@Controllerpublic class BookController &#123;&#125; 15.2 纯注释开发新建一个SpringConfig类，用来替代配置文件。 其位置：com.spring.config.SpringConfig.java com包 spring包 config包 SpringConfig.java @Configuration ：用于设定当前类为配置类@ComponentScan(&quot;com.spring&quot;) ：用用于设定扫描路径，此注释只能添加一次，多个数据用数组格式 123456//用来替代 &lt;context:component-scan base-package=&quot;com.spring&quot;/&gt;@Configuration //用于设定当前类为配置类@ComponentScan(&quot;com.spring&quot;) //用用于设定扫描路径，此注释只能添加一次，多个数据用数组格式public class SpringConfig &#123; &#125; 主函数： 1234567891011public class AppForAnnotation &#123; public static void main(String[] args) &#123; //改用注释配置初始化容器 ApplicationContext ac = new AnnotationConfigApplicationContext(SpringConfig.class); BookDao bookDao = ac.getBean(BookDao.class); bookDao.save(); BookService bookService = ac.getBean(BookService.class); bookService.save(); &#125;&#125; 123运行结果：BookDao~~~~~BookService~~~~ 15.3 bean管理 作用范围 @Scope(&quot;singleton&quot;)：单例，默认单例 @Scope(&quot;prototype&quot;)：多例 bean生命周期控制 @PostConstruct注解：init @PreDestroy注解：destory 123456789101112@Repository@Scope(&quot;prototype&quot;) //多例public class BookDaoImpl implements BookDao &#123; @PostConstruct public void init()&#123; System.out.println(&quot;init~~~&quot;); &#125; @PreDestroy public void destroy()&#123; System.out.println(&quot;destroy~~~&quot;); &#125;&#125; 15.4 依赖注入1.引用类型 1234567891011@Servicepublic class BookServiceImpl implements BookService &#123; @Autowired private BookDao bookDao; public void save() &#123; System.out.println(&quot;BookService~~~~&quot;); bookDao.save(); &#125;&#125; 主函数： 12345678public class AppForAnnotation &#123; public static void main(String[] args) &#123; ApplicationContext ac = new AnnotationConfigApplicationContext(SpringConfig.class); BookService bookService = ac.getBean(BookService.class); bookService.save(); &#125;&#125; 123运行结果：BookService~~~~ //在创建好BookService的bean,并注入BookDaoBookDao~~~~~ //调用BookDao的方法save(); 123@Repository(&quot;bookDao&quot;)public class BookDaoImpl implements BookDao &#123;&#125; 123@Repository(&quot;bookDao2&quot;)public class BookDaoImpl2 implements BookDao &#123;&#125; 当有多个同类型的bean，使用@Qualifier(&quot;bookDao2&quot;)来指定bean名 并且需要@Autowired和@Qualifier(&quot;bookDao2&quot;)一起使用 1234567891011@Servicepublic class BookServiceImpl implements BookService &#123; @Autowired @Qualifier(&quot;bookDao2&quot;) private BookDao bookDao; public void save() &#123; System.out.println(&quot;BookService~~~~&quot;); bookDao.save(); &#125;&#125; 注意： 自动装配基于反射设计创建对象并暴力反射对应属性为私有属性初始化数据，无需提供setter方法 自动装配建议使用无参构造方法创建对象，如果不提供对应的构造方法，请提供唯一的构造方法 @Qualifier注解无法单独使用，必须配合@Autowired注解使用 2.简单类型 123456789@Repositorypublic class BookDaoImpl implements BookDao &#123; @Value(&quot;dahuang&quot;) private String name; public void save()&#123; System.out.println(&quot;BookDao~~~~~&quot;+&quot;姓名：&quot;+name); &#125;&#125; 主函数： 1234567public class AppForAnnotation &#123; public static void main(String[] args) &#123; ApplicationContext ac = new AnnotationConfigApplicationContext(SpringConfig.class); BookDao bookDao = ac.getBean(BookDao.class); bookDao.save(); &#125;&#125; 12运行结果：BookDao~~~~~姓名：dahaung 但是，我们为什么不直接赋值，为什么要用@Value注解呢？ 我们可以用properties文件，向其传值。 3.读取properties文件 通过创建一个jdbc.properties文件： 1name=dahei 在配置类中新加注解@PropertySource()，括号中指定文件名： 如：@PropertySource(&quot;jdbc.properties&quot;)或者@PropertySource(&quot;classpath:jdbc.properties&quot;) 也可以指定多个文件： 如：@PropertySource(&#123;&quot;jdbc.properties&quot;,&quot;jdbc1.properties&quot;,&quot;jdbc2.properties&quot;&#125;) 12345@Configuration@ComponentScan(&quot;com.spring&quot;)@PropertySource(&quot;jdbc.properties&quot;)public class SpringConfig &#123;&#125; 在BookDaoImpl中将注解改为：@Value(&quot;$&#123;&#125;&quot;)，在&#123;&#125;中填入properties文件中的属性 如：@Value(&quot;$&#123;name&#125;&quot;) 123456789@Repositorypublic class BookDaoImpl implements BookDao &#123; @Value(&quot;$&#123;name&#125;&quot;) private String name; public void save()&#123; System.out.println(&quot;BookDao~~~~~&quot;+&quot;姓名：&quot;+name); &#125;&#125; 15.5 第三方bean管理1.使用独立的配置管理第三方bean 1234567891011121314@Configurationpublic class SpringConfig &#123; //定义一个方法获得想要管理的bean @Bean // 表示当前方法返回值是一个bean public DruidDataSource dataSource()&#123; DruidDataSource ds = new DruidDataSource(); //相关配置 ds.setDriverClassName(&quot;com.mysql.jdbc.Driver&quot;); ds.setUrl(&quot;jdbc:mysql://localhost:3306/demo&quot;); ds.getUsername(&quot;root&quot;); ds.setPassword(&quot;123456&quot;); return ds; &#125;&#125; 但是不建议将独立配置直接写在核心配置类中： 方法一：导入式(建议使用) 在config包创建一个JdbcConfig.java配置类： 12345678910111213public class JdbcConfig &#123; //定义一个方法获得想要管理的bean @Bean // 表示当前方法返回值是一个bean public DruidDataSource dataSource()&#123; DruidDataSource ds = new DruidDataSource(); //相关配置 ds.setDriverClassName(&quot;com.mysql.jdbc.Driver&quot;); ds.setUrl(&quot;jdbc:mysql://localhost:3306/demo&quot;); ds.setUsername(&quot;root&quot;); ds.setPassword(&quot;123456&quot;); return ds; &#125;&#125; 在SpringConfig.java核心配置类中导入： 使用注解@Import()在括号中添加要导入的配置类的类型 如：@Import(JdbcConfig.class) 此注解只能添加一次，导入多个配置类，可以使用数组格式导入 如：@Import(&#123;JdbcConfig.class, XXXConfig.class, XXXConfig.calss&#125;) 12345@Configuration@Import(JdbcConfig.class) //导入JdbcConfigpeipublic class SpringConfig &#123; &#125; 方式二：扫描式(不建议使用) 注意：使用扫描式需要在独立的配置类加入注解@Configuration 1234567891011121314@Configurationpublic class JdbcConfig &#123; //定义一个方法获得想要管理的bean @Bean // 表示当前方法返回值是一个bean public DataSource dataSource()&#123; DruidDataSource ds = new DruidDataSource(); //相关配置 ds.setDriverClassName(&quot;com.mysql.jdbc.Driver&quot;); ds.setUrl(&quot;jdbc:mysql://localhost:3306/demo&quot;); ds.setUsername(&quot;root&quot;); ds.setPassword(&quot;123456&quot;); return ds; &#125;&#125; 在SpringConfig.java核心配置类中扫描： 使用注解@ComponentScan()在括号中添加要扫描的路径 如：@@ComponentScan(&quot;com.spring.config&quot;) 扫描多个路径，可以使用数组格式导入 如：@Import(&#123;&quot;com.spring.config&quot;,&quot;com.spring.dao&quot;&#125;) 12345@Configuration@ComponentScan(&quot;com.spring.config&quot;)public class SpringConfig &#123; &#125; 2.第三方bean注入资源 简单类型依赖注入(成员变量)： 利用注解@PropertySource(&quot;jdbc.properties&quot;)和@Import(JdbcConfig.class)导入核心主配置文件中 123456@Configuration@ComponentScan(&quot;com.spring&quot;)@PropertySource(&quot;jdbc.properties&quot;)@Import(JdbcConfig.class)public class SpringConfig &#123;&#125; 利用注解@Value(&quot;$&#123;&#125;&quot;)注入数据 12345678910111213141516171819202122public class JdbcConfig &#123; @Value(&quot;$&#123;jdbc.driver&#125;&quot;) private String driver; @Value(&quot;$&#123;jdbc.url&#125;&quot;) private String url; @Value(&quot;$&#123;jdbc.username&#125;&quot;) private String userName; @Value(&quot;$&#123;jdbc.password&#125;&quot;) private String password; //定义一个方法获得想要管理的bean @Bean // 表示当前方法返回值是一个bean public DataSource dataSource()&#123; DruidDataSource ds = new DruidDataSource(); ds.setDriverClassName(driver); ds.setUrl(url); ds.setUsername(userName); ds.setPassword(password); return ds; &#125;&#125; 引入类型依赖注入(方法形参)： 引用类型注入只需要为bean定义的方法设置形参，容器会根据类型自动装配对象 123456789//定义一个方法获得想要管理的bean @Bean // 表示当前方法返回值是一个bean public DataSource dataSource(BookDao bookDao)&#123; System.out.println(&quot;已引用：&quot;+bookDao); DruidDataSource ds = new DruidDataSource(); //对ds进行相关设置 return ds; &#125; 15.6 总结XML配置与注解配置的比较： 功能 XML配置 注解 定义bean bean标签：&gt;id属性&gt;class属性 @Component &gt;@Controller &gt;@Service &gt;@Repository@ComponentScan 设置依赖注入 setter注入(set方法)&gt;引用&#x2F;简单构造器注入(构造方法)&gt;自动装配 @Autowird&gt;@Qualifier@Value 配置第三方bean bean标签&gt;静态工厂&gt;实例工厂&gt;FactoryBean @Bean 作用范围 scope属性 @Scope 生命周期 标准接口&gt;init-method&gt;destory-method @PostConstructor@PreDestroy 16.AOP16.1 AOP简介 AOP(Aspect Oriented Programming)面向切面编程，一种编程范式，指导开发者如何组织程序结构 OOP(Object Oriented Programing)面向对象编程 作用：在不惊动原始设计的基础上为其进行功能增强 Spring理念：无入侵式&#x2F;无侵入式 执行save()方法 运行结果： 打印出一万次的book dao save … 和消耗的时间 执行update()方法没有图中蓝色区域的代码， 但是，运行结果： 仍会打印打印出一万次的book dao update … 和消耗的时间 连接点(JoinPoint)：程序执行过程中的任意位置，粒度为执行方法，抛出异常，设置变量等(代表所有的方法) 在SpringAOP中，理解方法的执行 切入点(Pointcut)：匹配连接点的式子(代表要追加功能的方法) 在SpringAOP中，一个切入点只描述一个具体方法，也可以匹配多个方法 一个具体方法：com.spring.dao包下的BookDao接口中的五星参无返回值的save()方法 匹配多个方法：所有save方法，所有的get开头的方法，所有以Dao结尾的接口中的任意方法，所有带有一个形参的方法 通知(Advice)：在切入点执行的操作，也就是共性功能(代表追加的功能) 在SpringAOP中，功能最终以方法的形式呈现 通知类：定义通知的类 切面(Aspect)：描述通知与切入的对应关系 16.2 AOP入门 案例设定：测试接口执行效率 简化设定：在接口执行当前输出当前的系统时间 开发模式：XML or 注解(此入门案例采用注解的方式) 思路分析： 导入坐标(pom.xml) 制作连接点方法(原始操作，Dao接口与实现类) 制作共性功能(通知类与通知) 定义切入点 绑定切入点与通知关系(切面) pom.xml： 1234567891011&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;5.3.18&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;version&gt;1.9.9.1&lt;/version&gt;&lt;/dependency&gt; 创建一个MyAdivice.java类 其位置：com.spring.aop.MyAdivice.java @Component注解：定义为Spring加载的bean @Aspect注解：把当前类标识为⼀个切⾯供容器读取 @Pointcut(&quot;execution()&quot;)注解：定义切入点，⽅法签名必须是public及void型。 @Before(&quot;pt()&quot;)注解：标识⼀个前置增强⽅法 切入点pt()的定义依托一个不具有实际意义的方法进行，即无参数、无返回值、方法无实际逻辑 1234567891011@Component@Aspectpublic class MyAdvice &#123; @Pointcut(&quot;execution(void com.spring.dao.BookDao.update())&quot;) private void pt()&#123;&#125; @Before(&quot;pt()&quot;) public void method()&#123; System.out.println(System.currentTimeMillis()); &#125;&#125; @EnableAspectJAutoProxy注解：开启AOP代理自动配置 123456@Configuration@ComponentScan(&quot;com.spring&quot;)@EnableAspectJAutoProxypublic class SpringConfig &#123;&#125; 主函数： 1234567public class App &#123; public static void main(String[] args) &#123; ApplicationContext ac = new AnnotationConfigApplicationContext(SpringConfig.class); BookDao bookDao = ac.getBean(BookDao.class); bookDao.update(); &#125;&#125; 123运行结果：1656341601464book dao update~~~ 16.3 AOP工作流程 Spring容器启动 读取所有切面配置中的切入点 初始化bean，判定bean对应的类中的方法是否匹配到任意切入点 匹配失败，创建对象 获取bean，调用方法并执行，完成操作 匹配成功，调用方法并执行，完成操作 获取的bean是代理对象时，根据代理对象的运行模式运行原始方法与增强内容，完成操作 AOP核心本质：代理模式 目标对象(Target)：原始功能去掉共性功能对应的类产生的对象，这种对象是无法直接完成最终工作的 代理(proxy)：目标对象无法直接完成工作，需要进行功能回填，通过原始对象的代理对象实现 代码依旧是入门案例的 但是将主函数修改，打印bookDao的类型： 12345678public class App &#123; public static void main(String[] args) &#123; ApplicationContext ac = new AnnotationConfigApplicationContext(SpringConfig.class); BookDao bookDao = ac.getBean(BookDao.class); System.out.println(bookDao); System.out.println(bookDao.getClass()); &#125;&#125; 123运行结果：com.spring.dao.impl.BookDaoImpl@d23e042class jdk.proxy2.$Proxy20 System.out.println(bookDao)打印出com.spring.dao.impl.BookDaoImpl@d23e042 是因为AOP对BookDao的toString()方法进行了重写 class jdk.proxy2.$Proxy20：最终用的是代理的对象 16.4 AOP切入点表达式切入点：要进行增强的方法 切入点表达式：要进行增强的方法的描述方法 1.语法格式 切入点标准格式：动作关键字(访问修饰符 返回值 包名.接口/类名.方法(参数) 异常名) 12execution(public User com.spring.service.UserService.findById(int))execution(public User com.spring.service.impl.UserServiceImpl.findById(int)) 动作关键字：描述切入点行为动作，如execution表示执行到指定切入点 访问修饰符：public，private等，可以省略 返回值 包名 接口&#x2F;类名：接口名或者类名都可以 方法名 参数 异常名：方法定义中抛出指定异常，可以省略 2.通配符 可以使用通配符描述切入点，快速描述 *：单个独立的任意符号，可以独立出现，也可以作为前缀或者后缀的匹配符出现 1execution(public * com.spring.*.UserService.find*(*)) 解释：匹配com.spring包下的任意包中含有UserService类或接口中所有含有find开头的带有任意一个参数的方法 ..：多个连续的任意符号，可以独立出现，常用于简化包名与参数的书写 1execution(public User com..UserService.findById(..)) 解释：匹配com包中的任意包中的UserService类或接口中的所有名称为findById的方法 +：专用于匹配子类类型 1execution(* *..*Service+.*(..)) 解释：匹配·任意包下的以Service结尾的类或接口的子类中业务层的所有方法 常用写法 1execution(* com.spring.*.*Service.save(..)) 解释：匹配业务层所有的名为save的方法 3.书写技巧 所有代码按照标准规范开发，否则一下技巧全部失效 描述切入点通常描述接口，而不描述实现类 访问控制修饰符针对接口开发均采用public描述(可省略) 返回值类型对应增删改类使用精准类型加速匹配，对于查询类返回值使用*通配符快速描述 包名书写尽量不使用..匹配，效率过低，常用*做单个包描述匹配，或精准匹配 接口名&#x2F;类名书写名称与模块的采用*匹配 如：UserService书写成*Service，绑定业务层接口名 方法名书写以动词进行精准匹配，名词采用*匹配 如：getById书写成getBy*，selectAll书写成selectAll 参数规则较为复杂，根据业务方法灵活调整 通常不使用异常作为匹配规则 16.5 AOP通知类型AOP通知描述了抽取的共性功能，根据共性功能抽取的位置不同，最终运行代码时要将其加入到合理的位置 AOP通知共分为5钟类型 前置通知 1234567891011@Component@Aspectpublic class MyAdvice &#123; @Pointcut(&quot;execution(void com.spring.dao.BookDao.update())&quot;) private void pt()&#123;&#125; @Before(&quot;pt()&quot;) public void method()&#123; System.out.println(&quot;before~~~&quot;); &#125;&#125; 123运行结果：before~~~book dao update~~~ 后置通知 ​ 1234567891011@Component@Aspectpublic class MyAdvice &#123; @Pointcut(&quot;execution(void com.spring.dao.BookDao.update())&quot;) private void pt()&#123;&#125; @Before(&quot;pt()&quot;) public void method()&#123; System.out.println(&quot;after~~~&quot;); &#125;&#125; 123运行结果：book dao update~~~after~~~ 环绕通知(重点) 1.无返回值 1234567891011121314@Component@Aspectpublic class MyAdvice &#123; @Pointcut(&quot;execution(void com.spring.dao.BookDao.update())&quot;) private void pt()&#123;&#125; @Around(&quot;pt()&quot;) public void method(ProceedingJoinPoint pjp) throws Throwable &#123; System.out.println(&quot;before~~~&quot;); //表示对原始操作的调用 pjp.proceed(); System.out.println(&quot;after~~~&quot;); &#125;&#125; 1234运行结果：before~~~book dao update~~~after~~~ 2.有返回值 在BookDaoImpl中新写一个有返回值的select方法 12345678@Repositorypublic class BookDaoImpl implements BookDao &#123; @Override public int select() &#123; System.out.println(&quot;book dao select~~~&quot;); return 100; &#125;&#125; 123456789101112131415@Component@Aspectpublic class MyAdvice &#123; @Pointcut(&quot;execution(void com.spring.dao.BookDao.select())&quot;) private void pt()&#123;&#125; @Around(&quot;pt()&quot;) public Object method(ProceedingJoinPoint pjp) throws Throwable &#123; System.out.println(&quot;before~~~&quot;); //表示对原始操作的调用，并获得返回值 Object ret = pjp.proceed(); System.out.println(&quot;after~~~&quot;); return ret; &#125;&#125; 主函数： 12345678public class App &#123; public static void main(String[] args) &#123; ApplicationContext ac = new AnnotationConfigApplicationContext(SpringConfig.class); BookDao bookDao = ac.getBean(BookDao.class); int num = bookDao.select(); System.out.println(num); &#125;&#125; 12345运行结果：before~~~book dao select~~~after~~~100 并且有无返回值都建议这样的写法： 1234567@Around(&quot;pt()&quot;) public Object method(ProceedingJoinPoint pjp) throws Throwable &#123; System.out.println(&quot;before~~~&quot;); Object ret = pjp.proceed(); System.out.println(&quot;after~~~&quot;); return ret; &#125; @Around注意事项 环绕通知必须依赖形参ProceedingJoinPoint才能实现对原始方法的调用 ,进而实现原始方法调用前后同时添加通知 通知中如果未使用ProceedingJoinPoint对原始方法进行调用将跳过原始方法的执行 对原始方法的调用可以不接收返回值 ,通知方法设置成void即可, 如果接收返回值, 必须设定为Object类型 原始方法的返回值如果 是void类型,通知方法的返回值类型可以设置成void ,也可以设置成Object 由于无法预知原始方法运行后是否会抛出异常 ,因此环绕通知方法必须抛出Throwable对象 返回后通知(了解) 1234567891011@Component@Aspectpublic class MyAdvice &#123; @Pointcut(&quot;execution(int com.spring.dao.BookDao.select())&quot;) private void pt()&#123;&#125; @AfterReturning(&quot;pt()&quot;) public void method()&#123; System.out.println(&quot;afterReturn~~~&quot;); &#125;&#125; 1234运行结果：book dao select~~~afterReturn~~~100 @after和@AfterReturning的区别： 原始方法有异常时： @after也会打印通知的方法 @AfterReturning不会打印通知的方法 抛出异常后通知(了解) 1234567891011@Component@Aspectpublic class MyAdvice &#123; @Pointcut(&quot;execution(int com.spring.dao.BookDao.select())&quot;) private void pt()&#123;&#125; @AfterThrowing(&quot;pt()&quot;) public void method()&#123; System.out.println(&quot;afterThrowing~~~&quot;); &#125;&#125; 123运行结果：book dao select~~~100 @AfterThrowing注解：只有原始方法抛出异常，才会执行通知的方法 16.6 AOP通知获取数据 获取切入点方法的参数 JoinPoint：适用于前置、后置、返回后、抛出异常后通知 ProceedJointPoint：适用于环绕通知 获取切入点方法返回值 返回后通知 环绕通知 获取切入点方法运行异常信息 抛出异常后通知 环绕通知 123456789@Repositorypublic class BookDaoImpl implements BookDao &#123; @Override public int select(int id, String name) &#123; System.out.println(&quot;book dao select~~~&quot;); System.out.println(&quot;id:&quot;+id+&quot; name:&quot;+name); return 100; &#125;&#125; AOP通知获取参数数据 joinPoint对象描述了连接点方法的运行状态，可以获取到原始方法的调用参数 1234567891011121314@Component@Aspectpublic class MyAdvice &#123; @Pointcut(&quot;execution(int com.spring.dao.BookDao.select(..))&quot;) private void pt()&#123;&#125; @Before(&quot;pt()&quot;) public void method(JoinPoint jp)&#123; Object[] args = jp.getArgs(); System.out.println(Arrays.toString(args)); &#125;&#125; 主函数调用select方法： 1234567public class App &#123; public static void main(String[] args) &#123; ApplicationContext ac = new AnnotationConfigApplicationContext(SpringConfig.class); BookDao bookDao = ac.getBean(BookDao.class); bookDao.select(100, &quot;dahuang&quot;); &#125;&#125; 123运行结果：[100, dahuang]book dao select~~~ ProceedingJoinPoint是JoinPoint的子类 12345678@Around(&quot;pt()&quot;) public Object method(ProceedingJoinPoint pjp) throws Throwable &#123; Object[] args = pjp.getArgs(); System.out.println(Arrays.toString(args)); args[0] = 666; Object ret = pjp.proceed(args); return ret; &#125; 1234运行结果：[100, dahuang]book dao select~~~id:666 name:dahuang AOP通知获取返回数据 抛出异常后通知可以获取切入点方法中出现的异常信息，使用形参可以接收对应的异常对象 1234@AfterReturning(value = &quot;pt()&quot;, returning = &quot;ret&quot;)public void method(JoinPoint jp, int ret)&#123; System.out.println(&quot;afterReturn~~~&quot;+ret);&#125; 环绕通知中可以手工书写对原始方法的调用，得到的结果即为原始方法的返回值 12345@Around(&quot;pt()&quot;) public Object method(ProceedingJoinPoint pjp) throws Throwable &#123; Object ret = pjp.proceed(); return ret; &#125; AOP通知获取异常数据(了解) 抛出异常后通知可以获取切入点方法中出现的异常信息，使用形参可以接收对应的异常对象 1234@AfterThrowing(value = &quot;pt()&quot;, throwing = &quot;t&quot;)public void method(JoinPoint jp, Throwable t)&#123; System.out.println(&quot;afterThrowing~~~&quot;+t);&#125; 抛出异常后通知可以获取切入点方法运行的异常信息，使用形参可以接收运行时抛出的异常对象 1234567891011@Around(&quot;pt()&quot;) public Object method(ProceedingJoinPoint pjp) throws Throwable &#123; Object ret = null; try&#123; ret = pjp.proceed(); &#125; catch(Throwable t)&#123; t.printStackTrace(); &#125; return ret; &#125; 16.7 AOP总结1.基本概念： 概念：AOP(Aspect Oriented Programming) 面向切面编程，一种编程范式 作用：在不惊动原始设计的基础上为方法进行功能增强 核心概念 代理(Proxy)：SpringAOP的核心本质是采用代理模式实现的 连接点(JoinPoint )：在SpringAOP中 ,理解为任意方法的执行 切入点( Pointcut )：匹配连接点的式子,也是具有共性功能的方法描述 通知(Advice)：若干个方法的共性功能,在切入点处执行,最终体现为-一个方法 切面( Aspect )：描述通知与切入点的对应关系 目标对象 ( Target )：被代理的原始对象成为目标对象 2.切入点： 切入点表达式标准格式： 动作关键字(访问修饰符 返回值 包名.类&#x2F;接口名.方法名(参数) 异常名) execution(* com.spring.service.*Service.*(..)) 切入点表达式描述通配符： 作用: 用于快速描述,范围描述 *：匹配任意符号(常用) ..：匹配多个连续的任意符号(常用) +：匹配子类类型 切入点表达式书写技巧 按标准规范开发 查询操作的返回值建议使用*匹配 减少使用..的形式描述包 对接口进行描述,使用*表示模块名,例如UserService的匹配描述为*Service 方法名书写保留动词,例如get ,使用*表示名词,例如getById匹配描述为getBy* 参数根据实际情况灵活调整 3.通知类型： 前置通知 后置通知 环绕通知(重点) 环绕通知依赖形参ProceedingJoinPoint才能实现对原始方法的调用 环绕通知可以隔离原始方法的调用执行 环绕通知返回值设置为0bject类型 环绕通知中可以对原始方法调用过程中出现的异常进行处理 返回后通知 抛出异常后通知 4.通知获取数据： 获取切入点方法的参数 JoinPoint：适用于前置、后置、返回后、抛出异常后通知,设置为方法的第一个形参 ProceedJointPoint：适用于环绕通知 获取切入点方法返回值 返回后通知 . 环绕通知 获取切入点方法运行异常信息 抛出异常后通知 环绕通知 17.Spring事务17.1 Spring事务简介事务作用：在数据层保障一系列的数据库操作同成功同失败 Spring事务作用：在数据层或业务层保障一系列的数据库操作同成功同失败 案例：银行转账 需求:实现任意两个账户间转账操作 需求微缩: A账户减钱, B账户加钱 分析: ①数据层提供基础操作, 指定账户减钱( outMoney ) , 指定账户加钱( inMoney ) ②业务层提供转账操作( transfer ) , 调用减钱与加钱的操作 ③提供2个账号和操作金额执行转账操作 ④基于Spring整合MyBatis环境搭建上述操作 JDK版本：8 项目结构： pom.xml 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;5.2.10.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.1.16&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.5.6&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.47&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;5.2.10.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt; &lt;version&gt;1.3.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;5.2.10.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; com.spring.config包下： JdbcConfig 12345678910111213141516171819202122232425262728public class JdbcConfig &#123; @Value(&quot;$&#123;jdbc.driver&#125;&quot;) private String driver; @Value(&quot;$&#123;jdbc.url&#125;&quot;) private String url; @Value(&quot;$&#123;jdbc.username&#125;&quot;) private String userName; @Value(&quot;$&#123;jdbc.password&#125;&quot;) private String password; @Bean public DataSource dataSource()&#123; DruidDataSource ds = new DruidDataSource(); ds.setDriverClassName(driver); ds.setUrl(url); ds.setUsername(userName); ds.setPassword(password); return ds; &#125; //配置事务管理器，mybatis使用的是jdbc事务 @Bean public PlatformTransactionManager transactionManager(DataSource dataSource)&#123; DataSourceTransactionManager transactionManager = new DataSourceTransactionManager(); transactionManager.setDataSource(dataSource); return transactionManager; &#125;&#125; MybatisConfig 1234567891011121314151617public class MybatisConfig &#123; @Bean public SqlSessionFactoryBean sqlSessionFactory(DataSource dataSource)&#123; SqlSessionFactoryBean ssfb = new SqlSessionFactoryBean(); ssfb.setTypeAliasesPackage(&quot;com.itheima.p&quot;); ssfb.setDataSource(dataSource); return ssfb; &#125; @Bean public MapperScannerConfigurer mapperScannerConfigurer()&#123; MapperScannerConfigurer msc = new MapperScannerConfigurer(); msc.setBasePackage(&quot;com.itheima.dao&quot;); return msc; &#125;&#125; 核心配置类：SpringConfig 12345678@Configuration@ComponentScan(&quot;com.itheima&quot;)@PropertySource(&quot;classpath:jdbc.properties&quot;)@Import(&#123;JdbcConfig.class,MybatisConfig.class&#125;)//开启注解式事务驱动@EnableTransactionManagementpublic class SpringConfig &#123;&#125; Account 123456789101112131415161718192021222324252627282930313233343536373839public class Account implements Serializable &#123; private Integer id; private String name; private Double money; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public Double getMoney() &#123; return money; &#125; public void setMoney(Double money) &#123; this.money = money; &#125; @Override public String toString() &#123; return &quot;Account&#123;&quot; + &quot;id=&quot; + id + &quot;, name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &quot;, money=&quot; + money + &#x27;&#125;&#x27;; &#125;&#125; com.spring.dao包下： AccountDao 12345678public interface AccountDao &#123; @Update(&quot;update demo.account set money = money + #&#123;money&#125; where name = #&#123;name&#125;&quot;) void inMoney(@Param(&quot;name&quot;) String name, @Param(&quot;money&quot;) Double money); @Update(&quot;update demo.account set money = money - #&#123;money&#125; where name = #&#123;name&#125;&quot;) void outMoney(@Param(&quot;name&quot;) String name, @Param(&quot;money&quot;) Double money);&#125; AccountService 12345public interface AccountService &#123; //配置当前接口方法具有事务 @Transactional public void transfer(String out,String in ,Double money) ;&#125; AccountServiceImpl 12345678910@Servicepublic class AccountServiceImpl implements AccountService &#123; @Autowired private AccountDao accountDao; public void transfer(String out,String in ,Double money) &#123; accountDao.outMoney(out,money); accountDao.inMoney(in,money); &#125;&#125; 测试类：AccountServiceTest 1234567891011@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(classes = SpringConfig.class)public class AccountServiceTest &#123; @Autowired private AccountService accountService; @Test public void testTransfer() throws IOException &#123; accountService.transfer(&quot;Tom&quot;,&quot;Jerry&quot;,100D); &#125;&#125; 17.2 Spring事务角色事务角色 事务管理员：发起事务方，在Spring中通常代指业务层开启事务的方法 事务协调员：加入事务方，在Spring中通常代指数据层方法，也可以是业务层的方法 17.3 Spring事务属性 属性 作用 示例 readOnly 设置是否为只读事务 readOnly&#x3D;true 只读事务 timeout 设置事务超时时间 timeout&#x3D;-1 永不超时 rollbackFor 设置事务回滚异常(class) rollbackFor&#x3D;{NullPointException.class} rollbackForClassName 设置事务回滚异常(String) 同上字符串格式 noRollbackFor 设置事务不回滚异常(class) norollbackFor&#x3D;{NullPointException.class} noRollbackForClassName 设置事务不回滚异常(String) 同上字符串格式 propagation 设置事务传播行为 ….. 12345678910111213@Servicepublic class AccountServiceImpl implements AccountService &#123; @Autowired private AccountDao accountDao; @Override public void transfer(String out, String in, Double money) throws IOException &#123; accountDao.outMoney(out,money); //添加IOException类型错误 if(true) throw new IOException(); accountDao.inMoney(in,money); &#125;&#125; 运行后，报错，outMoney方法执行了，但inMoney方法没有执行。 并不是所有错误类型都会回滚， 我们希望transfer方法，调用的事务同失败。 在@Transactional注解中的属性rollbackFor添加错误的类型： 12345public interface AccountService &#123; @Transactional(rollbackFor = &#123;IOException.class&#125;) void transfer(String out, String in, Double money) throws IOException;&#125; 再次运行后，报错，outMoney和inMoney方法都没有执行 案例：转账业务追加日志 需求:实现任意两个账户间转账操作,并对每次转账操作在数据库进行留痕 需求微缩: A账户减钱, B账户加钱,数据库记录日志 分析: ①:基于转账操作案例添加日志模块,实现数据库中记录日志 ②:业务层转账操作( transfer ) ,调用减钱、加钱与记录日志功能 实现效果预期： ​ 无论转账操作是否成功,均进行转账操作的日志留痕 123456789101112131415161718192021@Servicepublic class AccountServiceImpl implements AccountService &#123; @Autowired private AccountDao accountDao; @Autowired private LogService logService; @Override public void transfer(String out, String in, Double money) throws IOException &#123; try&#123; accountDao.outMoney(out,money); int i = 1/0; accountDao.inMoney(in,money); &#125; finally&#123; logService.log(out,in,money); &#125; &#125;&#125; 运行后，outMoney方法和inMoney方法进行回滚，同时log方法也进行了回滚，未将日志记录到数据库中 存在问题： 日志的记录与转账操作隶属同一个事务，同成功同失败 事务传播行为：事务协调员对事物管理员所携带事务的处理态度 在业务层接口添加Spring事务， @Transactional注解中的propagation属性设置事务传播行为REQIRES_NEW(需要新事务) 123456@Servicepublic interface LogService &#123; //设置为新事务 @Transactional(propagation=Propagation.REQIRES_NEW) public void log(String out, String in, Double money);&#125; 运行后，outMoney方法和inMoney方法进行回滚，事务成功。 log方法执行，将日志记录到数据库中 传播属性 事务管理员 事务协调员 REQUIRED(默认) 开启T 加入T 无 新建T2 REQUIRES_NEW 开启T 新建T2 无 新建T2 SUPPORTS 开启T 加入T 无 无 NOT_SUPPORTED 开启T 无 无 无 MANDATORY 开启T 加入T 无 ERROR NEVER 开启T ERROR 无 无 NESTED 设置savePoint，一旦事务回滚，事务将回滚到savePoint处，交由客户端提交/回滚 ​ 18.结语你竟然看完了(不敢相信！！)，真的人会看吗！真的吗！ゞ◎Д◎ヾ 本人也是初学Spring，笔记中如果有什么遗漏或错误的地方欢迎大佬指正（≧∀≦） 本人QQ：2691936018 备注：Spring 另外关于Spring框架，如果有新的内容需要补充，本人也会进行更新的 本笔记的学习视频：黑马2022最新SSM框架 我们SpringMVC见！！(还是不太相信能有人看╮(╯▽╰)╭)","categories":[{"name":"Java","slug":"Java","permalink":"http://example.com/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"},{"name":"框架","slug":"框架","permalink":"http://example.com/tags/%E6%A1%86%E6%9E%B6/"}]},{"title":"SpringMVC框架的学习笔记","slug":"Java/SpringMCV框架","date":"2022-08-06T11:11:16.322Z","updated":"2022-07-07T06:25:56.557Z","comments":true,"path":"2022/08/06/Java/SpringMCV框架/","link":"","permalink":"http://example.com/2022/08/06/Java/SpringMCV%E6%A1%86%E6%9E%B6/","excerpt":"","text":"1.初认SpringMVC1.1 SpringMVC简介 SpringMVC技术与Servlet技术功能等同，均属于web层开发技术 SpringMVC是一种基于java实现MVC模型的轻量级Web框架 优点： 使用简单，开发便捷(相比与Servlet) 灵活性强 项目结构： 1.2 SpringMVC入门1.使用SpringMVC技术需要先导入SpringMVC坐标与Servlet 不需要导入spring-context包，spring-webmvc包中包含spring-context包 2.导入Tomcat插件 12345678910111213141516171819202122232425&lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;version&gt;3.1.0&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;!-- 和Tomcat有冲突 --&gt; &lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;5.2.10.RELEASE&lt;/version&gt; &lt;/dependency&gt;&lt;!--Tomcat插件--&gt;&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.tomcat.maven&lt;/groupId&gt; &lt;artifactId&gt;tomcat7-maven-plugin&lt;/artifactId&gt; &lt;version&gt;2.1&lt;/version&gt; &lt;configuration&gt; &lt;port&gt;8888&lt;/port&gt; &lt;!--端口可任意只要没有被占用--&gt; &lt;path&gt;/&lt;/path&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; 3.创建SpringMVC控制器类(等同于Servlet功能) 1234567891011@Controllerpublic class UserController &#123; //设置当前控制器方法的请求路径 @RequestMapping(&quot;/save&quot;) //设置当前控制器方法响应内容为当前返回值，无需解析 @ResponseBody public String save()&#123; System.out.println(&quot;user is saving~~&quot;); return &quot;&#123;&#x27;info&#x27;:&#x27;springmvc&#x27;&#125;&quot;; &#125;&#125; 4.初始化SpringMVC环境(同Spring环境)，设定SpringMVC加载对应的bean 12345//创建SpringMVC的配置文件，加载controller对应的bean@Configuration@ComponentScan(&quot;com.springmvc.controller&quot;)public class SpringMvcConfig &#123;&#125; 5.初始化Servlet容器，加载SpringMVC环境，并设置SpringMVC技术处理的请求 123456789101112131415161718192021//定义一个servlet容器启动的配置类，在里面加载Spring的配置public class ServletContainerInitConfig extends AbstractDispatcherServletInitializer &#123; //加载SpringMVC容器的配置 @Override protected WebApplicationContext createServletApplicationContext() &#123; AnnotationConfigWebApplicationContext acwac = new AnnotationConfigWebApplicationContext(); acwac.register(SpringMvcConfig.class); return acwac; &#125; //设定SpringMVC对应的请求的映射路径 @Override protected String[] getServletMappings() &#123; //设置为/表示拦截所有请求，任意请求都将转入到SpringMVC中进行处理 return new String[]&#123;&quot;/&quot;&#125;; &#125; //加载Spring容器配置，现在不需要 @Override protected WebApplicationContext createRootApplicationContext() &#123; return null; &#125;&#125; 右键找到Run Maven再找到tomcat7:run点击运行，打开浏览器打开http://localhost:8888/save 页面即可出现内容： 1&#123;&#x27;info&#x27;:&#x27;springmvc&#x27;&#125; 此时控制台打印出： 1user is saving~~ 1.3 入门总结 SpringMVC入门程序开发总结(1+N) 一次性工作 创建工程, 设置服务器，加载工程 导入坐标 创建web容器启动类, 加载SpringMVC配置， 并设置SpringMVC请求拦截路径 SpringMVC核心配置类 (设置配置类,扫描controller包, 加载Controller控制器bean) 多次工作 定义处理请求的控制器类 定义处理请求的控制器方法， 并配置映射路径@RequestMapping与返回json数据@ResponseBody 1.4 工作流程入门案例工作流程分析 启动服务器初始化过程 服务器启动, 执行ServletContainersInitConfig类,初始化web容器 执行createServletApplicationContext方法，创建了WebApplicationContext对象 加载SpringMvcConfig配置文件 执行@ComponentScan加载对应的bean 加载UserController, 每个@RequestMapping的名称对应一 个具体的方法 执行getServletMappings方法, 定义所有的请求都通过SpringMVC 单次请求过程 发送请求http:localhost:8888/save web容器发现所有请求都经过SpringMVC, 将请求交给SpringMVC处理 解析请求路径&#x2F;save 由&#x2F;save匹配执行对应的方法save() 执行save() 检测到有@ResponseBody直接将save()方法的返回值作为响应求体返回给请求方 1.5 bean加载控制 com springmvc config controller service dao Controller加载控制业务与业务bean加载控制 SpringMVC相关bean 表现层bean(Controller) Spring控制的bean 业务bean(Service) 功能bean(DataSourse等) SpringMVC相关的bean加载控制 SpringMVC加载的bean对应的包均在com.springnvc.controller包内 Spring相关bean加载控制 Spring加载的bean设定范围为com.springmvc，排除controller包内的bean Spring加载的bean设定范围为精准范围，如：com.springmvc.dao、com.springmvc.service等(常用) 不区分Spring与SpringMVC的环境，加载到同一个环境中 方式一(常用)： 1234@Configuration@ComponentScan(&#123;&quot;com.springmvc.dao&quot;,&quot;com.springmvc.service&quot;&#125;)public class SpringConfig &#123;&#125; 方式二： 123456789@Configuration@ComponentScan(value = &quot;com.springmvc&quot;, excludeFilters = @ComponentScan.Filter( type = FilterType.ANNOTATION, //按照注解排除 classes = Controller.class //需要排除的注解类型 ))public class SpringConfig &#123;&#125; 加载SpringMVC和Spring配置 123456789101112131415161718192021public class ServletContainerInitConfig extends AbstractDispatcherServletInitializer &#123; //加载SpringMVC配置 @Override protected WebApplicationContext createServletApplicationContext() &#123; AnnotationConfigWebApplicationContext acwac = new AnnotationConfigWebApplicationContext(); acwac.register(SpringMvcConfig.class); return acwac; &#125; @Override protected String[] getServletMappings() &#123; return new String[]&#123;&quot;/&quot;&#125;; &#125; //加载SpringMVC配置 @Override protected WebApplicationContext createRootApplicationContext() &#123; AnnotationConfigWebApplicationContext acwac = new AnnotationConfigWebApplicationContext(); acwac.register(SpringConfig.class); return acwac; &#125;&#125; 简化操作(常用)： 1234567891011121314151617public class ServletContainerInitConfig extends AbstractAnnotationConfigDispatcherServletInitializer &#123; @Override protected Class&lt;?&gt;[] getRootConfigClasses() &#123; return new Class[]&#123;SpringConfig.class&#125;; &#125; @Override protected Class&lt;?&gt;[] getServletConfigClasses() &#123; return new Class[]&#123;SpringMvcConfig.class&#125;; &#125; @Override protected String[] getServletMappings() &#123; return new String[]&#123;&quot;/&quot;&#125;; &#125;&#125; 2.请求与响应2.1 请求映射路径项目结构： BookController： 123456789@Controllerpublic class BookController &#123; @RequestMapping(&quot;/save&quot;) @ResponseBody public String save()&#123; System.out.println(&quot;book is saving~~&quot;); return &quot;&#123;&#x27;info&#x27;:&#x27;springmvc&#x27;&#125;&quot;; &#125;&#125; UserController： 123456789@Controllerpublic class UserController &#123; @RequestMapping(&quot;/save&quot;) @ResponseBody public String save()&#123; System.out.println(&quot;user is saving~~&quot;); return &quot;&#123;&#x27;info&#x27;:&#x27;springmvc&#x27;&#125;&quot;; &#125;&#125; 运行程序后报错，无法启动。 因为路径都为/save的话，在网页请求/save，程序会不知道调用哪个控制器方法 改进： BookController： 123456789@Controllerpublic class BookController &#123; @RequestMapping(&quot;/book/save&quot;) @ResponseBody public String save()&#123; System.out.println(&quot;book is saving~~&quot;); return &quot;&#123;&#x27;info&#x27;:&#x27;springmvc&#x27;&#125;&quot;; &#125;&#125; UserController： 123456789@Controllerpublic class UserController &#123; @RequestMapping(&quot;/user/save&quot;) @ResponseBody public String save()&#123; System.out.println(&quot;user is saving~~&quot;); return &quot;&#123;&#x27;info&#x27;:&#x27;springmvc&#x27;&#125;&quot;; &#125;&#125; 还可以更加精简，增加模块的请求路径前缀： @RequestMapping注解： 设置在控制器方法上：请求访问路径 设置在类上：统一设置当前类中控制器方法请求路径前缀 BookController： 12345678910@Controller@RequestMapping(&quot;/book&quot;)public class BookController &#123; @RequestMapping(&quot;/save&quot;) @ResponseBody public String save()&#123; System.out.println(&quot;book is saving~~&quot;); return &quot;&#123;&#x27;info&#x27;:&#x27;springmvc&#x27;&#125;&quot;; &#125;&#125; UserController： 12345678910@Controller@RequestMapping(&quot;/user&quot;)public class UserController &#123; @RequestMapping(&quot;/save&quot;) @ResponseBody public String save()&#123; System.out.println(&quot;user is saving~~&quot;); return &quot;&#123;&#x27;info&#x27;:&#x27;springmvc&#x27;&#125;&quot;; &#125;&#125; 2.2 请求方式 Get请求 Post请求 所要访问的控制器方法： 1234567891011@Controller@RequestMapping(&quot;/user&quot;)public class UserController &#123; @RequestMapping(&quot;/save&quot;) @ResponseBody public String save(String name, int age)&#123; System.out.println(&quot;user is saving~~&quot;); System.out.println(&quot;name=&quot;+name+&quot; age=&quot;+age); return &quot;&#123;&#x27;info&#x27;:&#x27;springmvc&#x27;&#125;&quot;; &#125;&#125; get请求： url地址传参，地址参数要与形参变量名相同，定义形参几个接收参数 访问链接：http://localhost:8888/user/save?name=dahuang&amp;age=18 控制台打印： 12user is saving~~name=dahuang age=18 post请求： form表单post请求传参，表单参数名要与形参变量名相同，定义形参几个接收参数 访问链接：http://localhost:8888/user/save 提交数据形式：x-www-form-urlencoded 控制台打印： 12user is saving~~name=dahei age=20 如果参数为中文呢？ 控制台打印，会乱码： 12user is saving~~name=å¤§é» age=20 Post请求中文乱码处理： 在ServletContainerInitConfig配置文件中重写getServletFilters()方法 为web容器添加过滤器并指定字符集，Spring-web包中提供了专用的字符过滤器 123456@Overrideprotected Filter[] getServletFilters() &#123; CharacterEncodingFilter aef = new CharacterEncodingFilter(); aef.setEncoding(&quot;UTF-8&quot;); return new Filter[]&#123;aef&#125;;&#125; 再次运行后，控制台打印： 12user is saving~~name=大黄 age=20 2.3 5种类型参数传递 参数种类 普通参数 POJO参数 嵌套POJO参数 数组类型参数 集合类型参数 普通参数：请求参数名与形参变量名不同，使用@RequestParam注解绑定参数关系 1234567891011@Controller@RequestMapping(&quot;/user&quot;)public class UserController &#123; @RequestMapping(&quot;/save&quot;) @ResponseBody public String save(@RequestParam(&quot;name&quot;) String userName, int age)&#123; System.out.println(&quot;user is saving~~&quot;); System.out.println(&quot;name=&quot;+userName+&quot; age=&quot;+age); return &quot;&#123;&#x27;info&#x27;:&#x27;springmvc&#x27;&#125;&quot;; &#125;&#125; POJO参数：请求参数名与形参对象名相同，定义POJO类型形参即可接收参数 创建一个实体类User 1234567891011121314151617public class User &#123; private String name; private int age; public String getName() &#123;return name;&#125; public void setName(String name) &#123;this.name = name;&#125; public int getAge() &#123;return age;&#125; public void setAge(int age) &#123;this.age = age;&#125; @Override public String toString() &#123; return &quot;User&#123;&quot; + &quot;name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &quot;, age=&quot; + age + &#x27;&#125;&#x27;; &#125;&#125; UserController中： 1234567891011@Controller@RequestMapping(&quot;/user&quot;)public class UserController &#123; @RequestMapping(&quot;/save&quot;) @ResponseBody public String save(User user)&#123; System.out.println(&quot;user is saving~~&quot;); System.out.println(user.toString()); return &quot;&#123;&#x27;info&#x27;:&#x27;springmvc&#x27;&#125;&quot;; &#125;&#125; get请求： url地址：http://localhost:8888/user/save?name=dahei&amp;age=16 控制台打印： 12user is saving~~User&#123;name=&#x27;dahei&#x27;, age=16&#125; 嵌套POJO参数：POJO对象中包含POJO对象 创建一个新实体类Address： 1234567891011121314151617public class Address &#123; private String province; private String city; public String getProvince() &#123;return province;&#125; public void setProvince(String province) &#123;this.province = province;&#125; public String getCity() &#123;return city;&#125; public void setCity(String city) &#123;this.city = city;&#125; @Override public String toString() &#123; return &quot;Address&#123;&quot; + &quot;province=&#x27;&quot; + province + &#x27;\\&#x27;&#x27; + &quot;, city=&#x27;&quot; + city + &#x27;\\&#x27;&#x27; + &#x27;&#125;&#x27;; &#125;&#125; 将Address对象加入到User对象中： 123456789101112131415161718192021public class User &#123; private String name; private int age; private Address address; public Address getAddress() &#123;return address;&#125; public void setAddress(Address address) &#123;this.address = address;&#125; public String getName() &#123;return name;&#125; public void setName(String name) &#123;this.name = name;&#125; public int getAge() &#123;return age;&#125; public void setAge(int age) &#123;this.age = age;&#125; @Override public String toString() &#123; return &quot;User&#123;&quot; + &quot;name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &quot;, age=&quot; + age + &quot;, address=&quot; + address + &#x27;&#125;&#x27;; &#125;&#125; get请求： url地址：http://localhost:8888/user/save?name=dahuang&amp;age=20&amp;address.province=tianjin&amp;address.city=baodi 控制台打印： 12user is saving~~User&#123;name=&#x27;dahuang&#x27;, age=20, address=Address&#123;province=&#x27;tianjin&#x27;, city=&#x27;baodi&#x27;&#125;&#125; 数组参数： 1234567891011@Controller@RequestMapping(&quot;/user&quot;)public class UserController &#123; @RequestMapping(&quot;/save&quot;) @ResponseBody public String save(String[] hobbies)&#123; System.out.println(&quot;user is saving~~&quot;); System.out.println(Arrays.toString(hobbies)); return &quot;&#123;&#x27;info&#x27;:&#x27;springmvc&#x27;&#125;&quot;; &#125;&#125; get请求： url地址：http://localhost:8888/user/save?hobbies=TV&amp;hobbies=game&amp;hobbies=food 控制台打印： 12user is saving~~[TV, game, food] 集合参数： 1234567891011@Controller@RequestMapping(&quot;/user&quot;)public class UserController &#123; @RequestMapping(&quot;/save&quot;) @ResponseBody public String save(@RequestParam List&lt;String&gt; hobbies)&#123; System.out.println(&quot;user is saving~~&quot;); System.out.println(hobbies.toString()); return &quot;&#123;&#x27;info&#x27;:&#x27;springmvc&#x27;&#125;&quot;; &#125;&#125; get请求： url地址：http://localhost:8888/user/save?hobbies=TV&amp;hobbies=game&amp;hobbies=food 控制台打印： 12user is saving~~[TV, game, food] 2.4 传递json数据*导入jackson坐标： 12345&lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;2.9.0&lt;/version&gt;&lt;/dependency&gt; json有两种格式： 对象格式：&#123;&quot;key1&quot;:obj,&quot;key2&quot;:obj,&quot;key3&quot;:obj...&#125; 数组&#x2F;集合格式：[obj,obj,obj...] 在SpringMvcConfig配置文件中，添加注解@EnableWebMvc： @EnableWebMvc注解：开启json数据转换成对象的功能 12345@Configuration@ComponentScan(&quot;com.springmvc.controller&quot;)@EnableWebMvcpublic class SpringMvcConfig &#123;&#125; 集合参数：json格式 @RequestBody注解：将请求中请求体所包含的数据传递给请求参数，此注解一个处理器方法只能使用一次 1234567891011@Controller@RequestMapping(&quot;/user&quot;)public class UserController &#123; @RequestMapping(&quot;/save&quot;) @ResponseBody public String save(@RequestBody List&lt;String&gt; hobbies)&#123; System.out.println(&quot;user is saving~~&quot;); System.out.println(hobbies.toString()); return &quot;&#123;&#x27;info&#x27;:&#x27;springmvc&#x27;&#125;&quot;; &#125;&#125; 控制台打印： 12user is saving~~[TV, game, food] POJO参数：json格式 1234567891011@Controller@RequestMapping(&quot;/user&quot;)public class UserController &#123; @RequestMapping(&quot;/save&quot;) @ResponseBody public String save(@RequestBody User user)&#123; System.out.println(&quot;user is saving~~&quot;); System.out.println(user.toString()); return &quot;&#123;&#x27;info&#x27;:&#x27;springmvc&#x27;&#125;&quot;; &#125;&#125; 控制台打印： 12user is saving~~User&#123;name=&#x27;dahuang&#x27;, age=20, address=Address&#123;province=&#x27;tianjin&#x27;, city=&#x27;baodi&#x27;&#125;&#125; 集合对象参数：json格式 1234567891011@Controller@RequestMapping(&quot;/user&quot;)public class UserController &#123; @RequestMapping(&quot;/save&quot;) @ResponseBody public String save(@RequestBody List&lt;User&gt; list)&#123; System.out.println(&quot;user is saving~~&quot;); System.out.println(list.toString()); return &quot;&#123;&#x27;info&#x27;:&#x27;springmvc&#x27;&#125;&quot;; &#125;&#125; 控制台打印： 12user is saving~~[User&#123;name=&#x27;dahei&#x27;, age=20, address=Address&#123;province=&#x27;tianjin&#x27;, city=&#x27;baodi&#x27;&#125;&#125;, User&#123;name=&#x27;dahuang&#x27;, age=20, address=Address&#123;province=&#x27;guizhou&#x27;, city=&#x27;zunyi&#x27;&#125;&#125;] @RequestBody与@RequestParam的区别： 区别 @RequestParam用于url地址传参，表单传参 application/x-www-form-urlencoded @RequestBody用于接收json数据 application/json 应用 后期开发，发送json格式数据为主，@RequestBody拥有较广 如果发送非json格式数据，选用@RequestParam接收请求参数 2.5 日期类型参数传递日期类型数据基于系统不同格式也不尽相同 2022-07-04 2022&#x2F;07&#x2F;04 07&#x2F;04&#x2F;2022 接收形参时，根据不同的日期格式设置不同的接收方式 @DataTimeFormat注解中的pattern属性来自定义日期时间型数据格式 1234567891011121314@Controller@RequestMapping(&quot;/user&quot;)public class UserController &#123; @RequestMapping(&quot;/date&quot;) @ResponseBody public String save(Date date1, @DateTimeFormat(pattern = &quot;yyyy-mm-dd&quot;) Date date2, @DateTimeFormat(pattern = &quot;yyyy/mm/dd HH:mm:ss&quot;) Date date3)&#123; System.out.println(&quot;date1==&gt;&quot;+date1); System.out.println(&quot;date2==&gt;&quot;+date2); System.out.println(&quot;date3==&gt;&quot;+date3); return &quot;&#123;&#x27;info&#x27;:&#x27;springmvc&#x27;&#125;&quot;; &#125;&#125; 控制台打印： 123date1==&gt;Mon Jul 04 00:00:00 CST 2022date2==&gt;Tue Jan 04 00:07:00 CST 2022date3==&gt;Tue Jan 04 23:10:00 CST 2022 类型转换器： Converter接口 1234public interface Converter&lt;S, T&gt; &#123; @Nullable T convert(S val);&#125; 请求参数年龄数据(String&#x3D;&#x3D;&gt;Integer) 日期格式转换(String&#x3D;&#x3D;&gt;Date) @EnableWebMvc注解作用之一：根据类型匹配对应的类型转换器 2.6 响应数据 响应页面 响应数据 文本数据 json数据 响应页面： 在webapp资源包中新建文件：page.jsp 12345&lt;html&gt;&lt;body&gt;&lt;h2&gt;Hello SpringMVC!&lt;/h2&gt;&lt;/body&gt;&lt;/html&gt; 页面跳转： 123456789@Controllerpublic class UserController &#123; @RequestMapping(&quot;/jumpPage&quot;) public String jumpPage()&#123; System.out.println(&quot;页面跳转&quot;); return &quot;page.jsp&quot;; &#125;&#125; url地址：http://localhost:8888/jumpPage 会自动跳转到page.jsp页面 响应文本数据： 123456789@Controllerpublic class UserController &#123; @RequestMapping(&quot;/toText&quot;) @ResponseBody public String toText()&#123; System.out.println(&quot;返回纯文本数据&quot;); return &quot;hello SpringMVC&quot;; &#125;&#125; url地址：http://localhost:8888/toText 页面数据： 1hello SpringMVC 响应POJO对象： 123456789101112@Controllerpublic class UserController &#123; @RequestMapping(&quot;/toPojo&quot;) @ResponseBody public User toPojo()&#123; System.out.println(&quot;返回POJO数据&quot;); User user = new User(); user.setName(&quot;大黄&quot;); user.setAge(18); return user; &#125;&#125; url地址：http://localhost:8888/toPojo 页面数据： 12345&#123; &quot;name&quot;: &quot;大黄&quot;, &quot;age&quot;: 18, &quot;address&quot;: null&#125; 其中是jackson自动将对象转换成json数据 所以一定要导入jackson坐标 响应POJO集合对象： 123456789101112131415161718@Controllerpublic class UserController &#123; @RequestMapping(&quot;/toPojoList&quot;) @ResponseBody public List&lt;User&gt; toPojoList()&#123; System.out.println(&quot;返回POJO集合对象数据&quot;); User user1 = new User(); user1.setName(&quot;大黄&quot;); user1.setAge(18); User user2 = new User(); user2.setName(&quot;大黑&quot;); user2.setAge(20); List&lt;User&gt; list = new ArrayList&lt;&gt;(); list.add(user1); list.add(user2); return list; &#125;&#125; url地址：http://localhost:8888/toPojoList 页面数据： 123456789101112[ &#123; &quot;name&quot;: &quot;大黄&quot;, &quot;age&quot;: 18, &quot;address&quot;: null &#125;, &#123; &quot;name&quot;: &quot;大黑&quot;, &quot;age&quot;: 20, &quot;address&quot;: null &#125;] @ResponseBody注解： 设置当前控制器返回值作为响应体 控制器方法返回值数据类型为String，则返回文本数据 控制器方法返回值数据类型为对象，则自动将对象转换成json数据 类型转换器： web请求专用类型转换器：HttpMessageConverter接口 3.REST风格3.1 REST简介 REST(Representational State Transfer)：表现形式状态转换 传统风格资源描述形式 http://localhost:8888/user/getById?id=1 http://localhost:8888/user/saveUser REST风格描述形式 http://localhost:8888/user/1 http://localhost:8888/user 优点： 隐藏资源的访问行为，无法通过地址得知对资源是如何操作 书写简化 按照REST风格访问资源时使用行为动作区分对资源进行了何种操作 http://localhost:8888/users 查询全部用户信息(get) http://localhost:8888/users/1 查询指定用户信息(post) http://localhost:8888/users 添加用户信息(post) http://localhost:8888/users 修改用户信息(put) http://localhost:8888/users/1 删除用户信息(delete) 描述模块的名称通常使用复数，也就是加s的格式描述，表示此类资源，而非单个资源。 例如：users、books…. 根据REST风格对资源进行访问称为RESTFul 3.2 REST入门@RequestMapping注解中method属性可以设定http请求地址，例如：GET、POST、PUT、DELETE… @PathVariable注解：绑定路径参数与处理器方法形参间的关系，要求路径参数名与形参名一一对应 12345678910111213141516171819202122232425262728293031323334353637@Controllerpublic class UserController &#123; @RequestMapping(value = &quot;/users&quot;, method = RequestMethod.POST) @ResponseBody public String save()&#123; System.out.println(&quot;save~~&quot;); return &quot;save success&quot;; &#125; @RequestMapping(value = &quot;/users&quot;, method = RequestMethod.PUT) @ResponseBody public String update()&#123; System.out.println(&quot;update~~&quot;); return &quot;update success&quot;; &#125; @RequestMapping(value = &quot;/users/&#123;id&#125;&quot;, method = RequestMethod.DELETE) @ResponseBody public String delete(@PathVariable Integer id)&#123; //路径变量 System.out.println(&quot;delete~~&quot;); return &quot;delete success&quot;; &#125; @RequestMapping(value = &quot;/users&quot;, method = RequestMethod.GET) @ResponseBody public String getAll()&#123; System.out.println(&quot;getAll~~&quot;); return &quot;getAll success&quot;; &#125; @RequestMapping(value = &quot;/users/&#123;id&#125;&quot;, method = RequestMethod.POST) @ResponseBody public String getById(@PathVariable Integer id)&#123; System.out.println(&quot;getById~~&quot;); return &quot;getById success&quot;; &#125;&#125; @RequestBody @RequestParam @PathVariable 区别 @RequestParam用于接收url地址传参或表单传参 @RequestBody用于接收json数据 @PathVariab1e用于接收路径参数, 使用{参数名称}描述路径参数 应用 后期开发中，发送请求参数超过1个时，以json格式为主, @RequestBody应用较广 如果发送非json格式数据 ,选用@RequestParam接收请求参数 采用RESTful进行开发，当参数数量较少时，例如1个， 可以采用@PathVariable接收请求路径变量，通常用于传递id值 3.3 REST快速开发@ResponseBody： 设置当前控制器类为RESTful风格，等同于@Controller与@ResponseBody两个注解组合功能 标准请求动作映射： @GetMapping：对应GET请求 @PostMapping：对应POST请求 @PutMapping：对应PUT请求 @DeleteMapping：对应DELETE请求 12345678910111213141516171819202122232425262728293031323334//@ResponseBody + @Controller ==&gt; @RestController@RestController@RequestMapping(&quot;/users&quot;)public class UserController &#123; @PostMapping public String save()&#123; System.out.println(&quot;save~~&quot;); return &quot;save success&quot;; &#125; @PutMapping public String update()&#123; System.out.println(&quot;update~~&quot;); return &quot;update success&quot;; &#125; @DeleteMapping(&quot;/&#123;id&#125;&quot;) public String delete(@PathVariable Integer id)&#123; //路径变量 System.out.println(&quot;delete~~&quot;); return &quot;delete success&quot;; &#125; @GetMapping public String getAll()&#123; System.out.println(&quot;getAll~~&quot;); return &quot;getAll success&quot;; &#125; @PostMapping(&quot;/&#123;id&#125;&quot;) public String getById(@PathVariable Integer id)&#123; System.out.println(&quot;getById~~&quot;); return &quot;getById success&quot;; &#125;&#125; 4.SSM整合5.拦截器5.1 拦截器的概念 拦截器(Interceptor)是一种动态拦截方法调用的机制，再SpringMVC中动态拦截控制器方法的执行 作用： 在指定的方法调用前后执行预先设定的代码 阻止原始方法的执行 拦截器与过滤器的区别： 归属不同：Filter属于Servlet技术，Interceptor属于SpringMVC技术 拦截内容不同：Filter对所有访问进行数据增强，Interceptor仅针对SpringMVC的访问进行增强 5.2 拦截器入门 制作拦截器功能类 配置拦截器的执行位置 项目结构： ProjectInterceptor： 此时preHandle方法的返回值为true：执行请求的方法 123456789101112131415161718@Componentpublic class ProjectInterceptor implements HandlerInterceptor &#123; @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; System.out.println(&quot;preHandle~~~&quot;); return true; &#125; @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123; System.out.println(&quot;postHandle~~~&quot;); &#125; @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123; System.out.println(&quot;afterCompletion~~~&quot;); &#125;&#125; SpringMvcSupport： 12345678910@Configurationpublic class SpringMvcSupport extends WebMvcConfigurationSupport &#123; @Autowired private ProjectInterceptor projectInterceptor; @Override protected void addInterceptors(InterceptorRegistry registry) &#123; registry.addInterceptor(projectInterceptor).addPathPatterns(&quot;/users&quot;); &#125;&#125; SpringMvcConfig中添加扫描路径”com.springmvc.config” 12345@Configuration@ComponentScan(&#123;&quot;com.springmvc.controller&quot;,&quot;com.springmvc.config&quot;&#125;)@EnableWebMvcpublic class SpringMvcConfig &#123;&#125; UserController： 123456789101112131415161718192021222324252627282930313233@RestController@RequestMapping(&quot;/users&quot;)public class UserController &#123; @PostMapping public String save()&#123; System.out.println(&quot;save~~&quot;); return &quot;save success&quot;; &#125; @PutMapping public String update()&#123; System.out.println(&quot;update~~&quot;); return &quot;update success&quot;; &#125; @DeleteMapping(&quot;/&#123;id&#125;&quot;) public String delete(@PathVariable Integer id)&#123; //路径变量 System.out.println(&quot;delete~~&quot;); return &quot;delete success&quot;; &#125; @GetMapping public String getAll()&#123; System.out.println(&quot;getAll~~&quot;); return &quot;getAll success&quot;; &#125; @PostMapping(&quot;/&#123;id&#125;&quot;) public String getById(@PathVariable Integer id)&#123; System.out.println(&quot;getById~~&quot;); return &quot;getById success&quot;; &#125;&#125; 页面展示： 1getAll success 控制台打印： 1234preHandle~~~getAll~~postHandle~~~afterCompletion~~~ 如果preHandle方法的返回值为false：不会执行请求的方法 123456789101112131415161718@Componentpublic class ProjectInterceptor implements HandlerInterceptor &#123; @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; System.out.println(&quot;preHandle~~~&quot;); return false; &#125; @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123; System.out.println(&quot;postHandle~~~&quot;); &#125; @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123; System.out.println(&quot;afterCompletion~~~&quot;); &#125;&#125; 页面无内容，被拦截 控制台打印： 1preHandle~~~ 所以可以通过if语句进行某种判断，返回true或false，来是否执行请求的方法 5.3 拦截器参数前置处理： 1234567@Overridepublic boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; System.out.println(&quot;preHandle~~~&quot;); return true;&#125; 参数： request：请求对象 response：响应对象 handle：被调用的处理器对象，本质为一个方法对象，对反射技术中的Method对象进行了再包装 返回值： 返回值为false，被拦截的处理将不执行 返回值为true，被拦截的处理将会执行 后置处理： 1234567@Overridepublic void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123; System.out.println(&quot;postHandle~~~&quot;);&#125; 参数： modelAndView：如果处理器执行完成具有返回结果，可以读取到对应数据与页面信息，并进行调整(了解即可) 完成后处理： 1234567@Overridepublic void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123; System.out.println(&quot;afterCompletion~~~&quot;);&#125; 参数： ex：如果处理执行过程中出现异常对象，可以针对异常情况进行单独处理(了解即可) 5.4 拦截器链配置(了解) 当配置多个拦截器时，形成拦截链 拦截器链的运行顺序： preHandle：与配置顺序相同，必定运行 postHandle：与配置顺序相反，可能不运行 afterCompletion：与配置顺序相反，可能不运行 但拦截器出现对原始处理器的拦截，后面的拦截器均终止运行 当拦截器运行中断，仅运行配置再前面的拦截器的afterCompletion操作 通常开发项目时，很少会用到拦截器链，一般一个拦截器就可以解决问题 按照1、2、3的顺序配置 12345678910111213141516@Configurationpublic class SpringMvcSupport extends WebMvcConfigurationSupport &#123; @Autowired private ProjectInterceptor1 projectInterceptor1; @Autowired private ProjectInterceptor2 projectInterceptor2; @Autowired private ProjectInterceptor3 projectInterceptor3; @Override protected void addInterceptors(InterceptorRegistry registry) &#123; registry.addInterceptor(projectInterceptor1).addPathPatterns(&quot;/users&quot;); registry.addInterceptor(projectInterceptor2).addPathPatterns(&quot;/users&quot;); registry.addInterceptor(projectInterceptor3).addPathPatterns(&quot;/users&quot;); &#125;&#125; 全部的preHandle方法返回值都为true： graph LR; pre1-->pre2-->pre3-->c(controller)-->post3-->post2-->post1-->after3-->after2-->after1; 3的preHandle方法返回值为false： graph LR; pre1-->pre2-->pre3-->after2-->after1; 2的preHandle方法返回值为false： graph LR; pre1-->pre2-->after1; 1的preHandle方法返回值为false： graph LR; pre1;","categories":[{"name":"Java","slug":"Java","permalink":"http://example.com/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"},{"name":"框架","slug":"框架","permalink":"http://example.com/tags/%E6%A1%86%E6%9E%B6/"}]},{"title":"SpringCloud框架的学习笔记","slug":"Java/SpringCloud框架","date":"2022-08-06T11:11:16.320Z","updated":"2022-09-27T14:18:51.088Z","comments":true,"path":"2022/08/06/Java/SpringCloud框架/","link":"","permalink":"http://example.com/2022/08/06/Java/SpringCloud%E6%A1%86%E6%9E%B6/","excerpt":"","text":"微服务技术栈： 实用篇1.微服务治理1.1 认识微服务单体架构： 单体架构：将业务的所有功能集中在一个项目开发，打成一个包部署 优点： 架构简单 部署成本低 缺点： 耦合度高 特点： 简单方便、高度耦合、拓展性差、适合小型项目 分布式架构： 分布式架构：根据业务功能对系统进行拆分，每个业务模块作为独立项目开发，称为一个服务 优点： 降低服务耦合 有利于服务升级拓展 分布式架构所要考虑的问题： 服务拆分粒度如何？ 服务集群地址如何维护？ 服务之间如何实现远程调用？ 服务健康状态如何感知？ 特点： 松耦合、拓展性好，但架构复杂、难度大，适合大型互联网项目 微服务特点： 微服务是一种经过良好架构设计的分布式架构 微服务架构特征： 单一职责： 微服务拆分粒度更小，每一个服务都对应唯一的业务能力，做到单一职责，避免单一职责，避免重复开发 面向服务： 微服务对外暴露业务接口 自治： 团队独立、技术独立、数据独立、部署独立 隔离性强： 服务调用做好隔离、容错、降级、避免出现级联问题 优点： 拆分粒度更小、服务更独立、耦合度更低 缺点： 架构非常复杂、运维、监控、部署难度更高 微服务技术： 微服务这种方案需要技术落地，全球的互联网公司都在积极尝试自己的微服务落地技术 在国内最知名的就是SpringCloud和阿里巴巴的Dubbo 微服务技术对比： Dubbo SpringCloud SpringCloudAlibaba 注册中心 zookeeper、Redis Eureka、Consul Nacos、Eureka 服务远程调用 Dubbo协议(RFC协议) Feign(http协议) Dubbo、Feign 配置中心 无 SpringCloudConfig SpringCloudConfig、Nacos 服务网关 无 SpringCloudGateway、Zuul SpringCloudGatway、Zuul 服务监控和保护 dubbo-admin(功能弱) Hystrix Sentinel 企业需求： SpringCloud+Feign 使用SpringCloud技术栈 服务接口采用Restful风格 服务调用采用Feign方式 SpringCloudAlibaba+Feign 使用SpringCloudAlibaba技术栈 服务接口采用Restful风格 服务调用采用Feign方式 SpringCloudAlibaba+Dubbo 使用SpringCloudAlibaba技术栈 服务接口采用Dubbo协议标准 服务调用采用Dubbo方式 Dubbo原始模式 基于Dubbo老旧技术体系 服务接口采用Dubbo协议标准 服务调用采用Dubbo方式 SpringCloud： SpringCloud是目前国内使用最广泛的微服务框架 SpringCloud集成了各种微服务功能组件，并基于SpringBoot实现了这些组件的自动装配，从而提供了良好的开箱即用体验： SpringCloud与SpringBoot的存在版本兼容关系 本次学习采用的版本为 Hoxton.SR10，因此对应的SpringBoot版本为2.3.x版本 1.2 分布式服务架构案例服务拆分注意事项： 不同微服务，不要重复开发相同业务 微服务数据独立，不要访问其他微服务的数据库 微服务可以将自己的业务暴露为接口，供其他的服务调用 1.3 服务拆分服务拆分注意事项： 1.不同微服务，不要重复开发相同业务 2.微服务数据独立，不要访问其它微服务的数据库 3.微服务可以将自己的业务暴露为接口，供其他微服务调用 案例：根据订单id查询订单功能 需求：根据订单id查询订单的同时，把订单所属的用户信息一起返回 查询订单信息：http://localhost:8080/order/101 1234567&#123; &quot;id&quot;:101, &quot;price&quot;:699900, &quot;name&quot;:&quot;Apple 苹果 iPhone 12 &quot;, &quot;num&quot;:1,&quot;userId&quot;:1, &quot;user&quot;:null&#125; user信息为null，我们需要在查询订单信息的同时，也可以获得订单所属用户信息 我们可以调用user服务的接口 在order-service服务的OrderApplication中注册RestTemplate： 1234567891011121314@MapperScan(&quot;cn.itcast.order.mapper&quot;)@SpringBootApplicationpublic class OrderApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(OrderApplication.class, args); &#125; //创建RestTemplate对象并注入Spring容器 @Bean public RestTemplate restTemplate()&#123; return new RestTemplate(); &#125;&#125; OrderService中添加http请求： 12345678910111213141516171819202122@Servicepublic class OrderService &#123; @Autowired private OrderMapper orderMapper; @Autowired private RestTemplate restTemplate; public Order queryOrderById(Long orderId) &#123; // 1.查询订单 Order order = orderMapper.findById(orderId); // 2.利用restTemplate向user服务发送http请求 String url = &quot;http://localhost:8081/user/&quot; + order.getUserId(); User user = restTemplate.getForObject(url, User.class); order.setUser(user); // 3.返回 return order; &#125;&#125; 重新查询订单信息：http://localhost:8080/order/101 123456789101112&#123; &quot;id&quot;:101, &quot;price&quot;:699900, &quot;name&quot;:&quot;Apple 苹果 iPhone 12 &quot;, &quot;num&quot;:1, &quot;userId&quot;:1, &quot;user&quot;:&#123; &quot;id&quot;:1, &quot;username&quot;:&quot;柳岩&quot;, &quot;address&quot;:&quot;湖南省衡阳市&quot; &#125;&#125; 成功获得user信息！ 3.Eureka3.1 提供者与消费者 服务提供者：一次业务，被其他微服务调用的服务(提供接口给其他微服务) 服务消费者：一次业务，调用其他微服务的服务(调用其他微服务提供的接口) 服务A调用了服务B，服务B又调用服务C，服务B属于什么？ 相对于A，就是消费者；相对于C，就是提供者 提供者与消费者其实是相对的 3.2 Eureka原理分析在OrderService中： 1String url = &quot;http://localhost:8081/user/&quot; + order.getUserId(); 如果每次更改服务端口，都需要重新修改代码吗？ 如果有多个user服务实例，但是总是调用一个端口，其余的user服务怎么办？ 服务消费者该如何获取服务提供者的地址信息呢？ 如果有多个服务提供者，消费者该如何选择呢？ 消费者如何得到服务提供者的健康状态呢？ Eureka的作用： 服务消费者该如何获取服务提供者的地址信息呢？ 服务提供者启动时间向Eureka注册自己的信息 Eureka保存这些信息 消费者根据服务名称向Eureka拉取提供者信息 如果有多个服务提供者，消费者该如何选择呢？ 服务消费者利用负载均衡算法，从服务列表中挑选一个 消费者如何得到服务提供者的健康状态呢？ 服务提供者会每隔30秒向EurekaServer发送心跳请求，报告健康状况 Eureka会更新记录服务列表信息，心跳不会正常会被踢出 消费者就可以拉取到最新的信息 在Eureka架构中，微服务角色有两类： EurekaServer：服务端，注册中心 记录服务信息 心跳监控 EurekaClient： 客户端 provider：服务提供省，例如案例中的 user-service 注册自己的信息到EurekaServer 每隔30秒向Eureka Server发送心跳 consumer：服务消费者，例如案例中的 order-service 根据服务名称从Eurekaserver拉取服务列表 基于服务列表做负载均衡，选中一个微服务后发起远程调用 3.3 搭建Eureka服务 创建项目，引入spring-cloud-starter-netflix-eureka-server依赖 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;/artifactId&gt;&lt;/dependency&gt; 编写启动类，添加@EnableEurekaServer注解 1234567@EnableEurekaServer@SpringBootApplicationpublic class EurekaApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(EurekaApplication.class, args); &#125;&#125; 添加applcation.yaml文件，配置信息： 123456789server: port: 10086 #服务端口spring: application: name: eurekaserver #eureka的服务名称eureka: client: service-url: #eureka的地址信息 defaultZone: http://127.0.0.1:10086/eureka 3.4 服务注册注册user-service服务注册到EurekaServer： 在user-service项目引入spring-cloud-starter-netflix-eureka-client的依赖 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;&lt;/dependency&gt; 在application.yaml文件，添加下面的配置： 1234567spring: application: name: userserviceeureka: client: service-url: defaultZone: http://localhost:10086/eureka 注册多个user-service服务： 在idea中，找到user-service服务，右键选择复制配置： 第一个user-service服务的端口为8081， 我将第二个user-service服务的端口设置为8082(可随意设置，但不要使用占用的端口) 3.5 服务发现在order-service完成服务拉取 服务拉取基于服务名称获取服务列表，然后在对服务列表做负载均衡 修改OrderService的代码，修改访问的url路径，用服务名替代ip、端口： 1String url = &quot;http://userservice/user/&quot; + order.getUserId(); 完整代码： 12345678910111213141516171819202122@Servicepublic class OrderService &#123; @Autowired private OrderMapper orderMapper; @Autowired private RestTemplate restTemplate; public Order queryOrderById(Long orderId) &#123; // 1.查询订单 Order order = orderMapper.findById(orderId); //利用restTemplate向user服务发送http请求 String url = &quot;http://userservice/user/&quot; + order.getUserId(); User user = restTemplate.getForObject(url, User.class); order.setUser(user); // 4.返回 return order; &#125;&#125; 在order-service项目的启动类OrderApplication中RestTemplate添加负载均衡注解： 12345@Bean@LoadBalanced //负载均衡注解public RestTemplate restTemplate()&#123; return new RestTemplate();&#125; 完整代码： 1234567891011121314@MapperScan(&quot;cn.itcast.order.mapper&quot;)@SpringBootApplicationpublic class OrderApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(OrderApplication.class, args); &#125; @Bean @LoadBalanced public RestTemplate restTemplate()&#123; return new RestTemplate(); &#125;&#125; 3.6 总结 搭建EurekaServer注册中心 引入eureka-server依赖 添加@EnableEurekaServer注解 在application.yaml中配置eureka地址 服务注册 引入eureka-client依赖 在application.yaml中添加eureka地址 服务发现 引入eureka-client依赖 在application.yaml中添加eureka地址 给RestTemplate配置bean中添加@LoadBalanced注解 用服务提供者在eureka注册的服务名称远程调用 4.Ribbon4.1 负载均衡原理负载均衡流程： graph LR A[order-service] B{Ribbon负载均衡} C(eureka-service) D[user-service:8081] E[user-service:8082] A--1.发起请求http://userservice/user/1-->B B--2.拉取userservice-->C C--3.返回服务列表localhost:8081localhost:8082-->B B--4.轮询到8081-->D B-->E 负载均衡原理： graph LR A[order-service] B[RibbonLoadBalancerClient] C[DynamicServerListLoadBalancer] D(eureka-service) E[IRule] F[user-service:8081] G[user-service:8082] A--1.发起请求http://userservice/user/1-->B C--3.拉取userservice-->D D--4.返回服务列表localhost:8081localhost:8082-->C subgraph LoadBalancerInterceptor负载均衡拦截器 B--2.获取url中的服务iduserservice-->C C--5.服务负载均衡localhost:8081localhost:8082-->E E--6.选择某个服务localhost:8081-->B end subgraph 请求 B-->F B-.->G end 4.2 负载均衡策略(IRule)Ribbon的负载均衡是一个叫做IRule的接口来定义的，每一个子接口都是一种规则： classDiagram IRule A A-.非临时实例nacos主动询问.->C A--主动推送变更信息push-->B 在nacos里创建的实例默认为临时实例 服务注册到Nacos时，可以选择注册为临时或非临时实例，通过下面的配置来设置： 1234567spring: application: name: orderservice cloud: nacos: discovery: ephemeral: false #flase为非临时实例，默认为true临时实例 总结： Nacos与eureka的共同点 都支持服务注册和服务拉取 都支持服务提供者心跳方式做健康检测 Nacos与Eureka的区别 Nacos支持服务端主动检测提供者状态：临时实例采用心跳模式，非临时实例采用主动检测模式 临时实例心跳不正常会被剔除，非临时实例则不会被剔除 Nacos支持服务列表变更的消息推送模式，服务列表更新更及时 Nacos集群默认采用AP方式，当集群中存在非临时实例时，采用CP模式；Eureka采用AP方式 6.Nacos配置管理6.1 Nacos实现配置管理统一配置管理 配置更改热更新： 新建配置： 打开Nacos控制台，点击配置管理-&gt;配置列表，点击右边的+ 号 填入配置： 配置文件id名：[服务名称]-[profile].[后缀名] 后缀名与配置格式一致 分组：默认即可 配置格式：推荐使用yaml格式 示例： 获取配置步骤： graph LR A{项目启动} B(读取本地配置文件application.yaml) C(创建Spring容器) D(加载bean) E(读取nacos中的配置文件) A--naocs地址bootstrap.yaml-->E E-->B-->C-->D 引入Nacos的配置管理客户端依赖： 在user-service项目引入依赖： 1234&lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-config&lt;/artifactId&gt;&lt;/dependency&gt; 在配置文件同级文件包中新建bootstrap.yaml，并删除application.yaml中的nacos的相关配置 bootstrap.yaml内容如下： 12345678910spring: application: name: userservice #服务名称 profiles: active: dev #环境 cloud: nacos: server-addr: 43.142.167.75:8848 #nacos地址 config: file-extension: yaml #文件后缀为yaml 在UserController中，测试读取Nacos中的配置： 123456789101112@RestController@RequestMapping(&quot;/user&quot;)public class UserController &#123; //注入nacos中的配置属性 @Value(&quot;$&#123;pattern.dateformat&#125;&quot;) private String dateformat; //通过dateformat的时间格式，返回格式化的时间 @GetMapping(&quot;/now&quot;) public String getDateformat()&#123; return LocalDateTime.now().format(DateTimeFormatter.ofPattern(dateformat)); &#125;&#125; 总结： 将配置交给Nacos管理的步骤： 在Nacos中添加配置文件 在微服务中引入nacos的config依赖 在微服务中添加bootstrap.yml， 配置nacos地址当前环境、服务名称、文件后缀名。这些决定了程序启动时去nacos读取哪个文件 6.2 配置热更新Nacos中都配置文件变更后，微服务无需重启就可以感知。不过需要通过两种配置实现： 方式一：在@Value注入的变量所在类上添加注解@RefreshScope 123456789101112@RestController@RequestMapping(&quot;/user&quot;)@RefreshScopepublic class UserController &#123; @Value(&quot;$&#123;pattern.dateformat&#125;&quot;) private String dateformat; @GetMapping(&quot;/now&quot;) public String getDateformat()&#123; return LocalDateTime.now().format(DateTimeFormatter.ofPattern(dateformat)); &#125;&#125; 方式二：使用@ConfigurationProperties(prefix = &quot;&quot;)注解 新建config包，创建PatternProperties类： 123456@Data@Component //交给spring管理@ConfigurationProperties(prefix = &quot;pattern&quot;)public class PatternProperties &#123; private String dateformat;&#125; 在UserController注入PatternProperties： 123456789101112@RestController@RequestMapping(&quot;/user&quot;)public class UserController &#123; //注入PatternProperties @Autowired private PatternProperties patternProperties; @GetMapping(&quot;/now&quot;) public String getDateformat()&#123; return LocalDateTime.now().format(DateTimeFormatter.ofPattern(patternProperties.getDateformat())); &#125;&#125; 总结： Nacos配置更改后，微服务可以实现热更新，方式如下： 通过@value注解注入，结合@Refreshscope来刷新 通过@ConfiqurationProperties注入，自动刷新 注意事项： 不是所有的配置都适合放到配置中心，维护起来比较麻烦 建议将一些关键参数，需要运行时调整的参数放到nacos配置中心，一般都是自定义配置 6.3 多环境配置共享微服务启动会从nacos读取多个配置文件： [spring.application.name]-[spring.profile.active].yaml，例如：userservice-dev.yaml [spring.application.name].yaml，例如：userservice.yaml 无论profile如何变化，[spring.application.name].yaml这个文件一定会加载的，因此可以多环境共享配置可以写入这个文件 多配置的优先级： 服务名-profile.yaml &gt; 服务名.yaml &gt; 本地配置 总结： 微服务会从nacos读取的配置文件： [服务名]-[spring-profile.active].yaml，环境配置 [服务名].yaml，默认配置，多环境共享 优先级 [服务名]-[环境].yaml &gt; [服务名].yaml＞本地配置 6.4 Nacos集群搭建Nacos生产环境下一定要部署为集群状态 graph TB A(Nacosclient) B[Nginx] C(Nacosnode1) D(Nacosnode2) E(Nacosnode3) F[(MySQL主)] G[(MySQL从)] H[(MySQL从)] A-->B B-->C-->F B-->D-->F B-->E-->F subgraph . F-.-G F-.-H end 7.Feign7.1 远程调用RestTemplate方式存在的问题： RestTemplate发起远程调用，示例代码： 123//利用restTemplate向user服务发送http请求String url = &quot;http://userservice/user/&quot; + order.getUserId();User user = restTemplate.getForObject(url, User.class); 存在问题： 代码可读性差，编程体验不统一 参数复杂，URL难以维护 不够优雅！！！ 优雅的Feign 介绍： Feign是一个声明式的http客户端。 其作用就是帮助我们优雅的实现http请求的发送，解决上面提到的问题。 使用Feign步骤： 引入依赖 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt;&lt;/dependency&gt; 在order-service的启动管理类添加开启Feign功能的注解@EnableFeignClients： 123456789@EnableFeignClients@MapperScan(&quot;cn.itcast.order.mapper&quot;)@SpringBootApplicationpublic class OrderApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(OrderApplication.class, args); &#125;&#125; 新建clients包，包中创建UserClient，来编写Feign客户端： 123456@FeignClient(&quot;userservice&quot;)public interface UserClient &#123; @GetMapping(&quot;/user/&#123;id&#125;&quot;) User findById(@PathVariable Long id);&#125; 使用Feign进行远程调用 1234567891011121314151617181920@Servicepublic class OrderService &#123; @Autowired private OrderMapper orderMapper; @Autowired private UserClient userClient; public Order queryOrderById(Long orderId) &#123; // 1.查询订单 Order order = orderMapper.findById(orderId); //使用Feign远程调用 User user = userClient.findById(order.getUserId()); order.setUser(user); // 4.返回 return order; &#125;&#125; 总结： Feign的使用步骤： 引入依赖 添加@EnableFeignClients注解 编写FeignClient接口 使用FiegnClient中定义的方法代替RestTemplate 7.2 自定义配置Feign运行自定义配置来覆盖默认配置，可以修改的配置如下： 类型 作用 说明 feign.Logger.Level 修改日志级别 包含四种不同的级别：NONE、BASIC、HEADERS、FULL feign.codec.Decoder 响应结果的解析器 http远程调用的结果做解析，例如解析json字符串为java对象 feign.codec.Encoder 请求参数编码 将请求参数编码，便于通过http请求发送 feign.Contract 请求参数编码 默认是SpringMVC的注解 feign.Retryer 失败重试机制 请求失败的重试机制，默认是没有，不过会使用Ribbon的重试 一般我们需要配置的就是日志级别 配置Feign日志的两种方式： 方式一：配置文件方式 全局生效： 12345feign: client: config: default: #default就是全局配置，如果写的是服务名称，就是针对此服务的配置 loggerLevel: FULL #日志级别 局部生效 12345feign: client: config: userservice: #default就是全局配置，如果写的是服务名称，就是针对此服务的配置 loggerLevel: FULL #日志级别 方式二：注解方式 先声明一个Bean： 123456public class FeignClientConfig &#123; @Bean public Logger.Level feignLogLevel() &#123; return Logger.Level.BASIC; &#125;&#125; 全局配置，将bean放到@EnableFeignClients注解中： 1@EnableFeignClients(defaultConfiguration = FeignClientConfig.class) 局部配置，将bean放到@FeignClient注解中： 1@FeignClient(value = &quot;userservice&quot;, configuration = FeignClientConfig.class) 总结： Feign的日志配置： 方式一是配置文件，feign.client.config.xxx.loggerLevel 如果xxx是default则代表全局 如果xxx是服务名称，例如userservice则代表某服务 方式二是java代码配置Logger.Level这个Bean 如果在@EnableFeignClients注解声明则代表全局 如果在@FeignClient注解中声明则代表某服务 7.3 性能优化Feign底层的客户端实现： URLConnection：默认实现，不支持连接池 Apache HttpClient：支持连接池 OKHttp：支持连接池 因此优化Feign的性能主要包括： 使用连接池代替默认的URLConnection 日志级别，最好为basic或none Feign添加HttpClient的支持： 引入依赖 1234&lt;dependency&gt; &lt;groupId&gt;io.github.openfeign&lt;/groupId&gt; &lt;artifactId&gt;feign-httpclient&lt;/artifactId&gt;&lt;/dependency&gt; 配置连接池： 12345feign: httpclient: enabled: true #开启feign对HttpClient的支持 max-connections: 200 #最大连接数 max-connections-per-route: 50 #每个路径的最大连接数 总结： Feign的优化： 日志级别尽量用basic 使用HttpClient或OKHttp代替URLConnection 引入feign-httpclient依赖 配置文件开启httpClient功能，设置连接池参数 7.4 最佳实践Feign的最佳实践 方式一：继承 给消费者的FeignClient和提供者的Controller定义统一的父接口作为标准 2.Docker3.异步通信4.分布式搜索0","categories":[{"name":"Java","slug":"Java","permalink":"http://example.com/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"},{"name":"框架","slug":"框架","permalink":"http://example.com/tags/%E6%A1%86%E6%9E%B6/"}]},{"title":"SpringBoot框架的学习笔记","slug":"Java/SpringBoot框架","date":"2022-08-06T11:11:16.318Z","updated":"2022-09-27T14:17:53.588Z","comments":true,"path":"2022/08/06/Java/SpringBoot框架/","link":"","permalink":"http://example.com/2022/08/06/Java/SpringBoot%E6%A1%86%E6%9E%B6/","excerpt":"","text":"1.热部署2.配置高级2.1 自定义bean属性绑定导入lombok坐标： 1234&lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt;&lt;/dependency&gt; application.yaml配置中： 1234servers: ipAddress: 127.0.0.1 port: 2345 timeout: -1 ServerConfig类中： @ConfigurationProperties注解将application.yaml配置中的属性进行绑定 12345678@Component@Data@ConfigurationProperties(prefix = &quot;servers&quot;)public class ServerConfig &#123; private String ipAddress; private int port; private long timeout;&#125; 测试： 12345678910@SpringBootTestclass ApplicationTests &#123; @Autowired private ServerConfig serverConfig; @Test void testGetServer() &#123; System.out.println(serverConfig); &#125;&#125; 2.2 第三方bean属性绑定导入druid坐标： 12345&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.1.16&lt;/version&gt;&lt;/dependency&gt; application.yaml中： 12dataSource: driverClassName: com.mysql.jdbc.driver123 配置bean： 123456789101112@Configurationpublic class DataSourceConfig &#123; @Bean @ConfigurationProperties(prefix = &quot;datasource&quot;) public DruidDataSource dataSource() &#123; DruidDataSource dataSource = new DruidDataSource(); //使用配置文件中的属性进行注入 //dataSource.setDriverClassName(&quot;com.mysql.jdbc.driver&quot;); return dataSource; &#125;&#125; 测试： 12345678910@SpringBootTestclass ApplicationTests &#123; @Autowired private DruidDataSource dataSource; @Test void testDataSource() &#123; System.out.println(dataSource.getDriverClassName()); &#125;&#125; @EnableConfigurationProperties注解： 开启属性绑定并设置对应的目标 可以将使用的@ConfigurationProperties注解对应的类加入Spring容器 @EnableConfigurationProperties注解与@Component注解不能同时使用 123456789101112@Configuration@EnableConfigurationProperties(ServerConfig.class)public class DataSourceConfig &#123; @Bean @ConfigurationProperties(prefix = &quot;datasource&quot;) public DruidDataSource dataSource() &#123; DruidDataSource dataSource = new DruidDataSource(); //dataSource.setDriverClassName(&quot;123456&quot;); return dataSource; &#125;&#125; 此时要将ServerConfig中的@Component注释删除： 如果不删除@Component注释，则会造成bean加载两次，报错 12345678//@Component@Data@ConfigurationProperties(prefix = &quot;servers&quot;)public class ServerConfig &#123; private String ipAddress; private int port; private long timeout;&#125; 如果idea出现Spring Boot Configuration Annotation Processor not configured问题： 导入坐标即可： 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt;&lt;/dependency&gt; 2.3 松散绑定@ConfigurationProperties注解：绑定属性支持属性名宽松绑定 12345678@Component@Data@ConfigurationProperties(prefix = &quot;servers&quot;)public class ServerConfig &#123; private String ipAddress; private int port; private long timeout;&#125; 支持多种格式： 12345678servers: #ipAddress: 127.0.0.1 #驼峰格式 #ipaddress: 127.0.0.1 #ip_address: 127.0.0.1 #unline格式 #IPADDRESS: 127.0.0.1 #IP_ADDRESS: 127.0.0.1 #常量格式 #IP_ADD_RE_SS: 127.0.0.1 ip-address: 127.0.0.1 #烤肉串格式 注意：宽松绑定不支持@value 注解引用单个属性的方式 @ConfigurationProperties注解：绑定属性支持属性名宽松绑定 绑定前缀规范： 指的是：prefix = &quot;datasource&quot;中的datasource 仅能用使用小写字母、数字、中划线作为合法字符 1234567@Bean@ConfigurationProperties(prefix = &quot;datasource&quot;)public DruidDataSource dataSource() &#123; DruidDataSource dataSource = new DruidDataSource(); //dataSource.setDriverClassName(&quot;123456&quot;); return dataSource;&#125; 2.4 常用计量单位的应用123456servers: ipAddress: 127.0.0.1 #驼峰格式 port: 2345 timeout: -1 serverTimeout: 3 dataSize: 10 指定单位： 123456789101112@Component@Data@ConfigurationProperties(prefix = &quot;servers&quot;)public class ServerConfig &#123; private String ipAddress; private int port; private long timeout; //long类型描述时间单位为毫秒 @DurationUnit(ChronoUnit.HOURS) //指定描述时间单位为小时 private Duration serverTimeout; @DataSizeUnit(DataUnit.MEGABYTES) //指定内存大小单位为MB private DataSize dataSize;&#125; 2.4 bean属性校验导入JSR303规范接口的坐标： 1234&lt;dependency&gt; &lt;groupId&gt;javax.validation&lt;/groupId&gt; &lt;artifactId&gt;validation-api&lt;/artifactId&gt;&lt;/dependency&gt; 导入使用hibernate框架提供的校验器做实现类的坐标： 1234&lt;dependency&gt; &lt;groupId&gt;org.hibernate.validator&lt;/groupId&gt; &lt;artifactId&gt;hibernate-validator&lt;/artifactId&gt;&lt;/dependency&gt; @Validated注解为开启bean的校验功能： @Min注解为设置最小值，并设置提示信息 @Max注解为设置最大值，并设置提示信息 等等还有很多… 123456789@Component@Data@ConfigurationProperties(prefix = &quot;servers&quot;)@Validatedpublic class ServerConfig &#123; @Min(value = 1000, message = &quot;最小值不能超过1000&quot;) @Max(value = 8888, message = &quot;最大值不能超过8888&quot;) private int port;&#125; 2.5 进制数据转换规则配置文件的dataSource中的password设置为012345： 123dataSource: driverClassName: com.mysql.jdbc.driver123 password: 012345 测试： 123456789@SpringBootTestclass ApplicationTests &#123; @Autowired private DruidDataSource dataSource; @Test void testDataSource() &#123; System.out.println(dataSource.getPassword()); &#125;&#125; 获取的passord为5347，明显与设置的密码不符 这是因为0开头的密码被当成八进制进行处理了 将密码用改用字符串形式，用双引号包裹： 123dataSource: driverClassName: com.mysql.jdbc.driver123 password: &quot;012345&quot; yaml语法规则 字面值表达方式： 12345678boolean: TRUE #TRUE true True FALSE False false均可float: 3.14 #支持科学计数法 6.5201314e+5int: 123 #支持二进制 八进制 十六进制null: ~ #使用 ~ 表示nullstring1: HelloWord #字符串可以直接书写string2: &quot;Hello Word&quot; #可以使用双引号包裹特殊字符data: 2022-07-27 #日期格式必须使用yyyy-MM-dd格式datatime: 2022-07-27T20:37:30+08:00 #日期与时间之间使用T连接，最后使用+代表时区 3.测试3.1 加载测试专用属性application.yaml配置文件中： 12test: prop: testVal 测试，读取prop值： 1234567891011@SpringBootTestpublic class PropertiesAndArgsTest &#123; @Value(&quot;$&#123;test.prop&#125;&quot;) private String val; @Test void testProperties() &#123; System.out.println(val); &#125;&#125; 运行结果：testVal 第一种方式：properties属性 可以使用@SpringBootTest注解中： properties属性可以为当前测试用例添加临时的属性配置 并且可以覆盖主配置文件的属性配置 优点：比多环境开发中的测试环境影响范围更小，仅对当前测试类有效 1234567891011@SpringBootTest(properties = &#123;&quot;test.prop=test1&quot;&#125;)public class PropertiesAndArgsTest &#123; @Value(&quot;$&#123;test.prop&#125;&quot;) private String val; @Test void testProperties() &#123; System.out.println(val); &#125;&#125; 运行结果：test1 第二种方式：args属性 可以使用@SpringBootTest注解中： args属性可以为当前测试用例添加临时命令行参数 并且可以覆盖主配置文件的属性配置 1234567891011@SpringBootTest(args = &#123;&quot;--test.prop=test2&quot;&#125;)public class PropertiesAndArgsTest &#123; @Value(&quot;$&#123;test.prop&#125;&quot;) private String val; @Test void testProperties() &#123; System.out.println(val); &#125;&#125; 运行结果：test2 第三种方式：同时使用properties属性以及args属性 1234567891011@SpringBootTest(properties = &#123;&quot;test.prop=test1&quot;&#125;, args = &#123;&quot;--test.prop=test2&quot;&#125;)public class PropertiesAndArgsTest &#123; @Value(&quot;$&#123;test.prop&#125;&quot;) private String val; @Test void testProperties() &#123; System.out.println(val); &#125;&#125; 运行结果：test2 所以，优先级为命令行参数args属性 &gt; properties属性 &gt; application.yaml配置文件 3.2 加载测试专用配置在test包下创建MsgConfig配置类： 仅服务于测试下的，不能定义在main包下，如果定义到main包下就属于源码级别了 导入第三方bean太麻烦，简单的定义一个bean 1234567@Configurationpublic class MsgConfig &#123; @Bean public String Msg()&#123; return &quot;bean msg&quot;; &#125;&#125; 使用@Import注解加载当前测试类专用的配置： 1234567891011@SpringBootTest@Import(&#123;MsgConfig.class&#125;)public class ConfigTest &#123; @Autowired private String Msg; @Test void testGetMsg() &#123; System.out.println(Msg); &#125;&#125; 3.3 测试类启动Web环境导入坐标： 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt; 创建一个UserController： 12345678910@RestController@RequestMapping(&quot;/users&quot;)public class UserController &#123; @GetMapping public String getById()&#123; System.out.println(&quot;getById is running&quot;); return &quot;UserId&quot;; &#125;&#125; 测试： webEnvironment属性： SpringBootTest.WebEnvironment.NONE为默认关闭web环境 SpringBootTest.WebEnvironment.DEFINED_PORT为配置文件中定义的端口 SpringBootTest.WebEnvironment.RANDOM_PORT为随机端口 1234567@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)public class MvcTest &#123; @Test void testRandomPort() &#123; &#125;&#125; 虚拟发送请求： 12345678910111213@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.DEFINED_PORT)@AutoConfigureMockMvc //开启虚拟Mvc的调用public class MvcTest &#123; @Test //注入虚拟Mvc调用对象 void testWeb(@Autowired MockMvc mockMvc) throws Exception &#123; //创建虚拟请求，当前访问/books，get请求 MockHttpServletRequestBuilder builder = MockMvcRequestBuilders.get(&quot;/users&quot;); //执行请求 mockMvc.perform(builder); &#125;&#125; 3.4 虚拟请求匹配响应虚拟请求状态匹配： 12345678910111213141516@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.DEFINED_PORT)@AutoConfigureMockMvcpublic class MvcTest &#123; @Test void testStatus(@Autowired MockMvc mockMvc) throws Exception &#123; MockHttpServletRequestBuilder builder = MockMvcRequestBuilders.get(&quot;/users&quot;); ResultActions actions = mockMvc.perform(builder); //定义本次调用的预期值 StatusResultMatchers status = MockMvcResultMatchers.status(); //预计本次调用成功，状态为200 ResultMatcher ok = status.isOk(); //添加预计值到本次调用中进行比较 actions.andExpect(ok); &#125;&#125; 虚拟请求体匹配： 12345678910111213141516@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.DEFINED_PORT)@AutoConfigureMockMvcpublic class MvcTest &#123; @Test void testBody(@Autowired MockMvc mockMvc) throws Exception &#123; MockHttpServletRequestBuilder builder = MockMvcRequestBuilders.get(&quot;/users&quot;); ResultActions actions = mockMvc.perform(builder); //定义本次调用的预期值 ContentResultMatchers content = MockMvcResultMatchers.content(); //预计本次调用成功，响应值为&quot;UserId&quot; ResultMatcher result = content.string(&quot;UserId&quot;); //添加预计值到本次调用中进行比较 actions.andExpect(result); &#125;&#125; 虚拟请求体(Json)匹配： 导入坐标： 123456789&lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;cn.hutool&lt;/groupId&gt; &lt;artifactId&gt;hutool-all&lt;/artifactId&gt; &lt;version&gt;5.7.17&lt;/version&gt;&lt;/dependency&gt; 创建User实体类： 123456@Datapublic class User &#123; private int id; private String name; private int age;&#125; UserController中： 1234567891011121314@RestController@RequestMapping(&quot;/users&quot;)public class UserController &#123; @GetMapping public User getById()&#123; System.out.println(&quot;getById is running&quot;); User user = new User(); user.setId(1); user.setAge(18); user.setName(&quot;大黄&quot;); return user; &#125;&#125; 测试： 123456789101112131415161718192021@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.DEFINED_PORT)@AutoConfigureMockMvc //开启虚拟Mvc的调用public class MvcTest &#123; @Test void testJson(@Autowired MockMvc mockMvc) throws Exception &#123; MockHttpServletRequestBuilder builder = MockMvcRequestBuilders.get(&quot;/users&quot;); ResultActions actions = mockMvc.perform(builder); //定义本次调用的预期值 ContentResultMatchers content = MockMvcResultMatchers.content(); //预计本次调用成功，返回的值 User user = new User(); user.setId(1); user.setAge(18); user.setName(&quot;大黄&quot;); String userJson = JSONUtil.toJsonStr(user); //转换成Json ResultMatcher result = content.json(userJson); //添加预计值到本次调用中进行比较 actions.andExpect(result); &#125;&#125; 虚拟请求头匹配： 测试： 12345678910111213141516@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.DEFINED_PORT)@AutoConfigureMockMvc //开启虚拟Mvc的调用public class MvcTest &#123; @Test void testContentType(@Autowired MockMvc mockMvc) throws Exception &#123; MockHttpServletRequestBuilder builder = MockMvcRequestBuilders.get(&quot;/users&quot;); ResultActions actions = mockMvc.perform(builder); //定义本次调用的预期值 HeaderResultMatchers header = MockMvcResultMatchers.header(); //预计本次调用成功，返回的值 ResultMatcher contentType = header.string(&quot;Content-Type&quot;, &quot;application/json&quot;); //添加预计值到本次调用中进行比较 actions.andExpect(contentType); &#125;&#125; 通常测试，会写到一起： 123456789101112131415161718192021222324252627@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.DEFINED_PORT)@AutoConfigureMockMvc //开启虚拟Mvc的调用public class MvcTest &#123; @Test void testGetById(@Autowired MockMvc mockMvc) throws Exception &#123; MockHttpServletRequestBuilder builder = MockMvcRequestBuilders.get(&quot;/users&quot;); ResultActions actions = mockMvc.perform(builder); StatusResultMatchers status = MockMvcResultMatchers.status(); ResultMatcher ok = status.isOk(); actions.andExpect(ok); HeaderResultMatchers header = MockMvcResultMatchers.header(); ResultMatcher contentType = header.string(&quot;Content-Type&quot;, &quot;application/json&quot;); actions.andExpect(contentType); ContentResultMatchers content = MockMvcResultMatchers.content(); User user = new User(); user.setId(1); user.setAge(18); user.setName(&quot;大黄&quot;); String userJson = JSONUtil.toJsonStr(user); //转换成Json ResultMatcher result = content.json(userJson); actions.andExpect(result); &#125;&#125; 3.5 业务层测试事务回滚导入坐标： 12345678910111213141516&lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt; &lt;version&gt;3.5.2&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.2.11&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;&lt;/dependency&gt; 配置文件： 1234567891011121314151617spring: datasource: druid: driver-class-name: com.mysql.cj.jdbc.Driver url: jdbc:mysql://localhost:3306/demo?serverTimezone=UTC username: root password: 123456mybatis-plus: global-config: db-config: table-prefix: tbl_ #将id设为自动增长 id-type: auto configuration: #开启日志，标准输出：将数据打印到控制台 log-impl: org.apache.ibatis.logging.stdout.StdOutImpl Dao层： 1234@Mapperpublic interface BookDao extends BaseMapper&lt;Book&gt;&#123;&#125; Service层： 123public interface BookService extends IService&lt;Book&gt; &#123; boolean saveBook(Book book);&#125; 12345678@Servicepublic class BookServiceImpl extends ServiceImpl&lt;BookDao, Book&gt; implements BookService &#123; @Override public boolean saveBook(Book book) &#123; return save(book); &#125;&#125; 测试： @Transactional：为测试用例添加事务，SpringBoot会对测试用例对应的事务提交操作进行回滚@Rollback：默认为true(可不写此注释)，改为false为提交事务，不回滚 1234567891011121314151617@SpringBootTest@Transactional //开启SpringBoot事务@Rollback(value = true) //默认value值为true，开启回滚(可不写)；value值为false，关闭回滚public class DaoTest &#123; @Autowired private BookService bookService; @Test void testSave() &#123; Book book = new Book(); book.setName(&quot;springboot&quot;); book.setType(&quot;java&quot;); book.setDescription(&quot;这是书&quot;); bookService.saveBook(book); &#125;&#125; 3.6 测试用例设置随机数据在配置文件中添加： 123456testcase: book: id: $&#123;random.int&#125; name: 用户$&#123;random.value&#125; #可加前缀 uuid: $&#123;random.uuid&#125; time: $&#123;random.long&#125; 测试： 1234@Testvoid testBookCase(@Autowired BookCase bookCase) &#123; System.out.println(bookCase);&#125; 多次运行： 1BookCase(id=-1723189530, name=用户36fc0553fae0662a1398f194a79d702c, uuid=c4f742bf-85b8-4416-836d-ab656e20c050, time=9037975923279012585) 1BookCase(id=1758479696, name=用户4952f34e3caadde83261a58b5c9a439f, uuid=4a5747f7-80ff-4161-8771-8dfdce6c470a, time=-2080170540354815861) 1BookCase(id=1773052492, name=用户88777f3bd07cb35dfe29b18b4873e7ed, uuid=3bd7d980-d5d6-46f2-bbf3-c190cdfe28ec, time=-4024744750514505719) 测试通常采用随机值进行测试，使用SpringBoot提供的随机数为其赋值： 12345678testcase: book: id: $&#123;random.int&#125; # 随机整数 id2: $&#123;random.int(10)&#125; # 10以内的整数 id3: $&#123;random.int(5,10)&#125; # 5~10之间的整数 name: 用户$&#123;random.value&#125; # 随机字符串，MD5字符串，32位 可加前缀 uuid: $&#123;random.uuid&#125; # 随机uuid time: $&#123;random.long&#125; # 随机整数，long范围 其中，random.int(5,10)的括号()可以是任意字符，如[]、@@、!!等均可 4.数据层解决方案现有数据层解决方案技术选型： Druid + MyBatis-Plus + MySQL 数据源：DruidDataSource 持久化技术：MyBatis / MyBatis-Plus 数据库：MySQL 4.1 内置数据源数据源配置格式： 格式一： 1234567spring: datasource: druid: driver-class-name: com.mysql.cj.jdbc.Driver url: jdbc:mysql://localhost:3306/demo?serverTimezone=UTC username: root password: 123456 格式二： 1234567spring: datasource: driver-class-name: com.mysql.cj.jdbc.Driver url: jdbc:mysql://localhost:3306/demo?serverTimezone=UTC username: root password: 123456 type: com.alibaba.druid.pool.DruidDataSource 以上两种格式都指定数据源为druid， 如果未指定数据源呢？ 123456spring: datasource: driver-class-name: com.mysql.cj.jdbc.Driver url: jdbc:mysql://localhost:3306/demo?serverTimezone=UTC username: root password: 123456 运行后，采用的数据源依旧是druid 因为导入druid-spring-boot-starter的坐标，会自动配置数据源： 12345&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.2.11&lt;/version&gt;&lt;/dependency&gt; 将druid-spring-boot-starter坐标注释或删除，不提供数据源， SpringBoot会提供3种内嵌的数据源对象供开发者选择： HikariCP：默认内置数据源对象 Tomcat提供DataSource：HikariCP在不可用的情况下，且在Web环境中，将使用Tomcat服务器配置的数据源对象 Commons DBCP：HikariCP和Tomcat数据源都不可用，将使用dbcp数据源 HikariCP数据源配置： 12345678spring: datasource: url: jdbc:mysql://localhost:3306/demo?serverTimezone=UTC hikari: driver-class-name: com.mysql.cj.jdbc.Driver username: root password: 123456 maximum-pool-size: 8 4.2 JdbcTemplateSpringBoot内置JdbcTemplate持久化解决方案： 导入坐标： 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt;&lt;/dependency&gt; 此外，MyaBtis-Plus坐标已经包含了上面的坐标 测试： 123456789101112131415161718192021222324252627282930313233343536@SpringBootTestpublic class JdbcTest &#123; @Autowired private JdbcTemplate jdbcTemplate; @Test void testQueryForList() &#123; String sql = &quot;select * from tbl_book where id = 1&quot;; List&lt;Map&lt;String, Object&gt;&gt; books = jdbcTemplate.queryForList(sql); System.out.println(&quot;books = &quot; + books); &#125; @Test void testQuery() &#123; RowMapper&lt;Book&gt; rm = new RowMapper&lt;Book&gt;() &#123; @Override public Book mapRow(ResultSet resultSet, int i) throws SQLException &#123; Book book = new Book(); book.setId(resultSet.getInt(&quot;id&quot;)); book.setName(resultSet.getString(&quot;name&quot;)); book.setType(resultSet.getString(&quot;type&quot;)); book.setDescription(resultSet.getString(&quot;description&quot;)); return book; &#125; &#125;; String sql = &quot;select * from tbl_book&quot;; List&lt;Book&gt; books = jdbcTemplate.query(sql, rm); System.out.println(&quot;books = &quot; + books); &#125; @Test void testSave() &#123; String sql = &quot;insert into tbl_book values (null, &#x27;sss&#x27;, &#x27;aaa&#x27;, &#x27;bbb&#x27;)&quot;; jdbcTemplate.update(sql); &#125;&#125; JdbcTemplate配置： 123456spring: jdbc: template: fetch-size: -1 # 缓存行数 query-timeout: -1 # 查询超时时间 max-rows: -1 # 最大行数 4.3 内嵌数据库SpringBoot提供了3种内嵌数据库供开发者选择，提高开发测试效率： H2 HSQL Derby 以H2数据库为例： 导入坐标： 123456789&lt;dependency&gt; &lt;groupId&gt;com.h2database&lt;/groupId&gt; &lt;artifactId&gt;h2&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;&lt;/dependency&gt; 同时还需要Web环境，所以还要导入坐标： 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt; 配置文件： 1234567server: port: 8080spring: h2: console: path: /h2 enabled: true 访问用户名为sa，默认密码为123456 在浏览器请求链接：http://localhost:8080/h2 点击连接，第一次连接会报错，需要初始化添加上面的相关配置 添加H2数据库配置： 12345678910111213server: port: 8080spring: h2: console: path: /h2 enabled: true datasource: url: jdbc:h2:~/test hikari: driver-class-name: org.h2.Driver username: sa password: 123456 连接成功后： 在上方的空白框中执行下面的语句，创建表： 1create table tbl_book (id int, type varchar, name varchar, description varchar) 查询语句： 1select * from tbl_book 需要停止SpringBoot项目服务，才可以进行测试 测试： 1234567891011121314151617181920212223242526272829303132@SpringBootTestpublic class JdbcTest &#123; @Autowired private JdbcTemplate jdbcTemplate; @Test void testQuery() &#123; //查询所有 RowMapper&lt;Book&gt; rm = new RowMapper&lt;Book&gt;() &#123; @Override public Book mapRow(ResultSet resultSet, int i) throws SQLException &#123; Book book = new Book(); book.setId(resultSet.getInt(&quot;id&quot;)); book.setName(resultSet.getString(&quot;name&quot;)); book.setType(resultSet.getString(&quot;type&quot;)); book.setDescription(resultSet.getString(&quot;description&quot;)); return book; &#125; &#125;; String sql = &quot;select * from tbl_book&quot;; List&lt;Book&gt; books = jdbcTemplate.query(sql, rm); System.out.println(&quot;books = &quot; + books); &#125; @Test void testSave() &#123; //插入 String sql = &quot;insert into tbl_book values (2, &#x27;sss&#x27;, &#x27;aaa&#x27;, &#x27;bbb&#x27;)&quot;; jdbcTemplate.update(sql); &#125;&#125; 改用MyBatis-Plus技术也是可以的，并且无缝衔接，只需导入MyBatis-Plus坐标： 12345&lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt; &lt;version&gt;3.5.2&lt;/version&gt;&lt;/dependency&gt; 添加MyBatis-Plus的配置： 123456789mybatis-plus: global-config: db-config: table-prefix: tbl_ #将id设为自动增长 id-type: auto configuration: #开启日志，标准输出：将数据打印到控制台 log-impl: org.apache.ibatis.logging.stdout.StdOutImpl 测试： 1234567891011@SpringBootTestpublic class DaoTest &#123; @Autowired private BookService bookService; @Test void testSelectAll() &#123; List&lt;Book&gt; list = bookService.list(); System.out.println(&quot;list = &quot; + list); &#125;&#125; H2数据库控制台仅用于开发阶段，线上项目请务必关闭控制台功能： 将enabled改为false 1234567server: port: 8080spring: h2: console: path: /h2 enabled: false 5.整合第三方技术6.监控","categories":[{"name":"Java","slug":"Java","permalink":"http://example.com/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"},{"name":"框架","slug":"框架","permalink":"http://example.com/tags/%E6%A1%86%E6%9E%B6/"}]},{"title":"Redis的学习笔记","slug":"Java/Redis","date":"2022-08-06T11:11:16.304Z","updated":"2023-02-06T13:48:39.866Z","comments":true,"path":"2022/08/06/Java/Redis/","link":"","permalink":"http://example.com/2022/08/06/Java/Redis/","excerpt":"","text":"基础篇1.初识Redis1.1 认识NoSql键值数据库是一种NoSql数据库 key value 1001 { “id”:1001, “name”:”张三”, “age”:20,} SQL：关系型数据库 NoSQL：非关系型数据库 SQL与NoSQl的比较： SQL NoSQL 数据结构 结构化 非结构化：1.键值类型(Redis)2.文档类型(MongoDB)3.列类型(HBase)4.Graph类型(Neo4j) 数据关联 关联的(数据有关联) 无关联的 查询方式 SQL查询(SQL语法通用) 非SQL(语法不统一) 事务特性 ACID BASE 存储方式 磁盘 内存 扩展性 垂直 水平 使用场景 1.数据结构固定2.相关业务数据安全性、一致性要求较高 1.数据结构不固定2.相关业务数据安全性、一致性要求不高3.对性能要求 1.2 认识RedisRedis诞生于2009年全称时Remote Dictionary Server，远程词典服务器，是一个基于内存的键值型NoSQL数据库。 特征： 键值(key-value)型：value支持多种不同数据结构，功能丰富 单线程：每个命令具备原子性 低延迟、速度快：基于内存、IO多路复用、良好的编码(C语言开发) 支持数据持久化 支持主从集群、分片集群 支持多语言客户端 1.3 Redis的安装及其配置(不要看这个教程安装，有问题) ​ 大多企业都是基于Linux服务器来部署项目，而且Redis官方也没有提供Windows版本的安装包。因此会使用基于Linux系统来安装Redis。 Redis官网：Redis Linux版本为：CentOS7 注意：下面的安装Redis方法不适用于Ubuntu 打开命令行，依次输入一下内容： 123456789101112131415#转换成root权限su - #输入密码#安装gcc依赖yum install -y gcc tcl#进入到src目录cd /usr/local/src#下载redis-6.2.6.tar.gzwget https://download.redis.io/releases/redis-6.2.6.tar.gz#解压redis-6.2.6.tar.gztar -zxvf redis-6.2.6.tar.gz#进入redis-6.2.6cd redis-6.2.6#运行编译命令make &amp;&amp; make install 默认安装路径为/usr/local/bin目录下： 1ll /usr/local/bin 看到这个样子安装基本成功了 Redis的配置文件： 重新打开命令行： 12345678su -#输入密码#进入到redis-6.2.6目录cd /usr/local/src/redis-6.2.6#备份redis.confcp redis.conf redis.conf.bck#打开redis.conf配置文件vi redis.conf 修改redis.conf文件的一些配置： 123456#bind 127.0.0.1 -::会导致只能在本地访问，修改为0.0.0.0就可以在任意ip访问，生产环境不要设置为0.0.0.0bind 0.0.0.0#守护进程，修改为yes即可后台运行daemonize yes#设置密码为123456requirepass 123456 查找：/+所要查找的字符串；按n向下查找，按N向上查找 输入i即可修改数据，修改完成后按ESC退出编辑 :wq为保存并退出 退出后： 12345redis-server redis.conf#查看redis进程ps -ef|grep redis #杀死进程kill -9 端口号 接着设置开机自启： 12#新建一个系统服务文件vi /etc/systemd/system/redis.service 将下面内容全部复制到redis.service文件中： 1234567891011[Unit]Description=redis-serverAfter=network.target[Service]Type=forkingExecStart=/usr/local/bin/redis-server /usr/local/src/redis-6.2.6/redis.confPrivateTmp=true[Install]WantedBy=multi-user.target 保存退出后， 接着: 12345678910#重载系统服务systemctl daemon-reload#启动redissystemctl start redis#查看redis状态systemctl status redis#停止redissystemctl stop redis#redis开机自启systemctl enable redis 2.Redis命令2.1 Redis数据结构介绍Redis是一个key-value的数据库，key一般是String类型，不过value的类型多种多样： 数据类型 格式 String hello Redis Hash {name: “jack”, age: 21} List [A -&gt; B -&gt; C -&gt; D] Set {A, B, C} SortSet {A: 1, B: 2, C: 3} GEO(地理坐标) {A: (120.3, 30.5)} BitMap 0101001001100101011001000110100101110011 HyperLog 0101001001100101011001000110100101110011 基本类型：String、Hash、List、Set、SortSet 特殊类型：GEO、BitMap、HyperLog 2.2 Redis通用命令 命令 解释 举例 KEYS 查看符合模板的所有key，不建议在生产环境设备上使用(效率低) KEYS *：查看所有keyKEYS n*：查看所有n开头的key DEL 删除一个指定key DEL name：删除name EXISTS 判断key是否存在 EXISTS name：存在返回1，否则返回0 EXPIRE 给一个key设置有效期，有效期到期key会被自动删除 EXPIRE name 20：设置name的有效期为20秒 TTL 查看一个key的剩余有效期 TTL name：查看name的有效期，如果返回-2，则说明到期了如果返回-1，则说明永久有效 2.3 String类型String类型、也就是字符串类型，是Redis中最简单的存储类型 其value是字符串，不过根据字符串的格式不同，又可以分类为3类： string：普通字符串 int：整数类型，可以做自增、自减操作 float：浮点类型，可以做自增、自减操作 不管是哪种格式，底层都是字节数组形式存储，字符串类型的最大空间不能超过512m Key Value msg hello Redis num 10 score 98.5 String类型常见命令： 命令 SET key value 添加或修改已经存在的一个String类型的键值对 SET name Jerry：把name的value设置为Jerry GET key 根据key获取String类型的value GET name：获取到value为”Jerry” MSET 批量添加多个String类型的键值对 MSET score 12.5 age 18：添加多个键值对 MGET 根据多个key获取多个String类型的value MGET name score age：得到多个value为”Jreey” “12.5” “18” INCR 让一个整型的key自增1 INCR age：age的value加1，由18变为19 INCRBY 让一个整型的key自增并指定步长 INCRBY age 2：age的value加2，由19变为21 INCRBYFLOAT 让一个浮点类型的数字自增并指定步长 INCRBYFLOAT score 0.5：score的value加0.5，由12.5变为13.0 SETNX 添加一个String类型的键值对，前提是这个key不存在，否则不执行(新增效果) SETNX name Tom：不执行，返回0SETNX k1 v1：执行，返回1 SETEX 添加一个String类型的键值对，并且指定有效期 SETEX name 10 jerry ：添加键值对，并将有效期设置为10秒 2.4 Key的层级格式Redis没有类似于MySQL中的Table表的概念 Redis的Key允许有多个单词形成层级结构，多个单词之间用:隔开，格式(不固定)如下： 项目名:业务名:类型:id 例如项目名叫demo，有user和book两种不同类型的数据，我们可以这样定义Key： user相关的Key：demo:user:1 book相关的Key：demo:book:1 如果Value是一个java对象，例如一个User对象，则可以将对象序列化为json字符串后存储： Key Value demo:user:1 {“id”: 1, “name”: “Jerry”, “age”: 18} demo:book:1 {“id”: 1, “name”: “BOOK”, “price”: 15} 插入操作(注意：Value值要加&#39;&#39;)： set demo:user:1 &#39;&#123;&quot;id&quot;: 1, &quot;name&quot;: &quot;Jerry&quot;, &quot;age&quot;: 18&#125;&#39; set demo:book:1 &#39;&#123;&quot;id&quot;: 1, &quot;name&quot;: &quot;BOOK&quot;, &quot;price&quot;: 15&#125;&#39; 打开图形界面客户端查看： 2.5 Hash类型Hash类型，也叫散列，其value是一个无序字典，类似于java中的HashMap结构 String结构是将对象序列化为json字符串后存储，当需要修改对象某个字段时很不方便(需要修改整个字符串)： Key Value demo:user:1 {“id”: 1, “name”: “Jerry”, “age”: 18} demo:user:2 {“id”: 2, “name”: “Tom”, “price”: 20} 而Hash结构可以将对象中每个字段独立存储，可以针对单个字段做CRUD： Key Value field value demo:user:1 name Jerry age 18 demo:user:2 name Tom age 20 Hash类型常见命令： 命令 HSET key field value 添加或修改hash类型key的field的值 HSET demo:user:2 name LiHua：把name的value设置为Lihua HGET key field 获取一个hash类型key的field的值 HGET demo:user:2 name：获取到value为”LiHua” HMSET 批量添加多个hash类型key的field的值 HMSET demo:user:3 name LiLei age 22：添加多个field的值 HMGET 批量获取根据多个hash类型key的field的值 HMGET demo:user:3 name age：得到多个field的值为”LiLei” “22” HGETALL 获取一个hash类型的key中的所有的field和value HGETALL demo:user:3：获取到key中所有的field和value HKEYS 获取一个hash类型的key中的所有的field HKEYS demo:user:3：获取key中所有的field HVALS 获取一个hash类型的key中的所有的value HVALS demo:user:3：获取key中所有的value HINCRBY 让一个hash类型的key的字段自增并指定步长 HINCRBY demo:user:3 age 2：age的value加2，由22变为24 HSETNX 添加一个hash类型的key的field值，前提是这个field不存在，否则不执行(新增效果) HSETNX demo:user:3 name XXX：存在field值不执行，返回0HSETNX demo:user:3 sex man：不存在field值执行，返回1 2.6 List类型Redis中的List类型与java中的LinkList类似，可以看作是一个双向链表结构，既可以支持正向检索也可以支持反向检索。 特征与LinkList也类似： 有序 元素可以重复 插入和删除快 查询速度一般 常用来存储一个有序数据，如：评论列表、点赞列表等 List类型的常见命令： LPUSH key element 向列表左侧插入一个或多个元素 LPUSH user 1 2 3：表中从第一位依次为 “3” “2” “1” LPOP key 移除并返回列表左侧的第一个元素，没有则返回nil LPOP user 1 RPUSH key element 向列表右侧插入一个或多个元素 RPUSH user 4 5 6：表中从第一位依次为 “4” “5” “6” RPOP key 移除并返回列表右侧的第一个元素 LRANGE key star end 返回一段角标范围内的所有元素 LRANGE 1 star 2：从0开始，获取到1~2之间的元素 BLPOP 与LPOP类似，只不过在没有元素时等待指定时间，而不是直接返回nil BLPOP user2 1 100：移除并返回到左侧的第一个元素，没有则等待100秒，超时返回nil BRPOP 与RPOP类似，只不过在没有元素时等待指定时间，而不是直接返回nil List结构模拟一个栈 入口和出口在同一边 如：LPUSH和LPOP或者 RPUSH和RPOP List结构模拟一个队列 入口和出口不在同一边 如：LPUSH和RPOP 或者 RPUSH和LPOP List结构模拟一个阻塞队列 入口和出口不在同一边 出队采用BLPOP或者BRPOP 如：LPUSH和BRPOP 或者 RPUSH和BLPOP 2.7 Set类型Redis的Set结构与Java中的Hashset类似，可以看做是一个value为null的HashMap。因为也是一个hash表，因此具备与Hashset类似的特征： 无序 元素不可重复 查找快 支持交集、并集、差集等功能 Set类型的常见命令： SADD key member 向set中添加一个或多个元素 SADD s1 a b c SREM key member 移除set中的指定元素 SREM s1 a SCARD key 返回set中元素的个数 SCARD s1 SISMEMBER key member 判断一个元素是否存在于set中 SISMEMBER s1 a SMEMBERS 获取set中的所有元素 SMEMBERS SINTER key1 key2 求key1与key2的交集 SDIFF key1 key2 求key1与key2的差集 SUNION key1 key2 求key1与key2的并集 2.8 SortedSet类型Redis的SortedSet是一个可排序的set集合，与java中的TreeSet有些类似，但底层数据结构却差别很大Sortedset中的每一个元素都带有一个score属性，可以基于score属性对元素排序，底层的实现是一个跳表(SkipList)加hash表。SortedSet具备下列特性： 可排序 元素不重复 查询速度快 因为Sortedset的可排序特性，经常被用来实现排行榜这样的功能。 SortedSet类型的常见命令： ZADD key score member 添加一个或多个元素到sorted set，如果已经存在则更新其score值 ZADD SSet 85 Tom 98 Jerry 77 Rose 78 Jack：向SSet中添加元素，并按照升序排列 ZREM key member 删除sorted set中的一个指定元素 ZREM SSet Tom：删除Tom ZSCORE key member 获取sorted set中的指定元素的score值 ZRANK key member 获取sorted set 中的指定元素升序的排名 ZRANK SSet Rose：按照升序的序列，从0开始，返回Rose的排名 ZREVRANK key member 获取sorted set 中的指定元素降序的排名 ZRANK SSet Rose：按照降序的序列，从0开始，返回Rose的排名 ZCARD key 获取sorted set中的元素个数 ZCOUNT key min max 统计score值在给定范国内的所有元素的个数 ZINCRBY key increment member 让sorted set中的指定元素自增，步长为指定的increment值 ZRANGE key min max 按照score升序排序后，获取指定排名范围内的元素 ZCOUNT SSet 0 2：按照升序的情况，获取0~2范围的元素 ZREVRANGE key min max 按照score的降序排序后，获取指定排名范围内的元素 ZCOUNT SSet 0 2：按照降序的情况，获取0~2范围的元素 ZRANGEBYSCORE key min max 按照score排序后，获取指定score范国内的元素 ZRANGEBYSCORE SSet 0 80：返回0~80分数的元素 ZDIFF、ZINTER、ZUNION 求差集、交集、并集 注意：所有排名默认都是升序，如果降序则在命令的Z后面添加REV即可 例如：ZREVRANK 3.Redis的java客户端Redis官网中提供了各种语言的客户端 Java： Jedis：以Redis命令作为方法名称，学习成本低，简单实用但是Jedis实例是线程不安全的，多线程环境下需要基于连接池来使用 Lettuce：基于Netty实现的，支持同步、异步和响应式编程方式，并且是线程安全的。支持Redis的哨兵模式、集群模式和管道模式 Redisson：是一个基于Redis实现的分布式、可伸缩的Java数据结构集合。包含了诸如Map、Queue、LockSemaphore、Atomiclong等强大功能 其中Spring整合了Jedis和Lettuce，只需导入坐标Spring Data Redis 3.1 Jedis快速入门Jedis：Jedis官网 引入jedis依赖： 12345&lt;dependency&gt; &lt;groupId&gt;redis.clients&lt;/groupId&gt; &lt;artifactId&gt;jedis&lt;/artifactId&gt; &lt;version&gt;3.7.0&lt;/version&gt;&lt;/dependency&gt; 完整依赖： 123456789101112131415&lt;dependencies&gt; &lt;!-- jedis依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;redis.clients&lt;/groupId&gt; &lt;artifactId&gt;jedis&lt;/artifactId&gt; &lt;version&gt;3.7.0&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 测试依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.junit.jupiter&lt;/groupId&gt; &lt;artifactId&gt;junit-jupiter&lt;/artifactId&gt; &lt;version&gt;5.7.0&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 以下在Test中进行： 建立连接 123456789@BeforeEach //在测试方法执行之前执行的方法 void setUp() &#123; //建立连接 jedis = new Jedis(&quot;127.0.0.1&quot;,6379); //设置密码 jedis.auth(&quot;123456&quot;); //选择库 jedis.select(0); &#125; 测试String类型 12345@Testvoid testString() &#123; jedis.set(&quot;name&quot;,&quot;Tom&quot;); System.out.println(jedis.get(&quot;name&quot;));&#125; 释放资源 123456@AfterEach //在测试方法执行之后执行的方法void tearDown() &#123; if (jedis != null)&#123; jedis.close(); &#125;&#125; 完整测试： 12345678910111213141516171819202122232425262728293031323334public class JedisTest &#123; private Jedis jedis; @BeforeEach //在测试方法执行之前执行的方法 void setUp() &#123; //建立连接 jedis = new Jedis(&quot;127.0.0.1&quot;,6379); //设置密码 jedis.auth(&quot;123456&quot;); //选择库 jedis.select(0); &#125; @Test void testString() &#123; jedis.set(&quot;name&quot;,&quot;Tom&quot;); System.out.println(jedis.get(&quot;name&quot;)); &#125; @Test void testHash() &#123; jedis.hset(&quot;demo:user:2&quot;,&quot;name&quot;,&quot;Jerry&quot;); jedis.hset(&quot;demo:user:2&quot;,&quot;age&quot;,&quot;18&quot;); Map&lt;String, String&gt; map = jedis.hgetAll(&quot;demo:user:2&quot;); System.out.println(map); &#125; @AfterEach //在测试方法执行之后执行的方法 void tearDown() &#123; if (jedis != null)&#123; jedis.close(); &#125; &#125;&#125; jedis使用的基本步骤： 引入依赖 创建jedis对象，建立连接 使用jedis的方法名与Redis命令一致 释放资源 3.2 Jedis的连接池Jedis本身线程是不安全的，并且频繁的创建和销毁连接会有性能损耗，因此推荐使用Jedis连接池替代Jedis的直连方法 创建JedisConnectionFactory工具类： 12345678910111213141516171819202122232425262728public class JedisConnectionFactory &#123; private static final JedisPool jedisPool; static &#123; //配置连接池 JedisPoolConfig jedisPoolConfig = new JedisPoolConfig(); //最大连接数 jedisPoolConfig.setMaxTotal(8); //最大空闲连接 jedisPoolConfig.setMaxIdle(8); //最小空闲连接 jedisPoolConfig.setMinIdle(0); //等待时长 jedisPoolConfig.setMaxWaitMillis(1000); //创建连接池对象 jedisPool = new JedisPool(jedisPoolConfig, &quot;127.0.0.1&quot;, 6379, 1000, &quot;123456&quot;); &#125; public static Jedis getJedis()&#123; return jedisPool.getResource(); &#125;&#125; 测试类中： 123456789101112131415161718192021222324252627public class JedisTest &#123; private Jedis jedis; @BeforeEach //在测试方法执行之前执行的方法 void setUp() &#123; //建立连接 jedis = JedisConnectionFactory.getJedis(); //选择库 jedis.select(0); &#125; @Test void testHash() &#123; jedis.hset(&quot;demo:user:2&quot;,&quot;name&quot;,&quot;Jerry&quot;); jedis.hset(&quot;demo:user:2&quot;,&quot;age&quot;,&quot;18&quot;); Map&lt;String, String&gt; map = jedis.hgetAll(&quot;demo:user:2&quot;); System.out.println(map); &#125; @AfterEach //在测试方法执行之后执行的方法 void tearDown() &#123; if (jedis != null)&#123; //close方法当检测到是连接池时，并不是真正的关闭连接，而是将对象归还给连接池 jedis.close(); &#125; &#125;&#125; 3.3 初识SpringDataRedisSpringData是Spring中数据操作的模块，包含对各种数据库的集成，其中对Redis的集成模块就叫做SpringDataRedis 提供了对不同Redis客户端的整合 （Lettuce和Jedis） 提供了RedisTemplate统一API来操作Redis 支持Redis的发布订阅模型 支持Redis哨兵和Redis集群 支持基于Lettuce的响应式编程 支持基于JDK、JSON、字符串、Spring对象的数据序列化及反序列化 支持基于Redis的JDKCollection实现 SpringDataRedis中提供了RedisTemplate工具类，其中封装了各种对Redis的操作。并且将不同数据类型的操作API封装到了不同的类型中： API 返回值类型 解释 redisTemplate.opsForValue() ValueOperations 操作String类型数据 redisTemplate.opsForHash() HashOperations 操作Hash类型数据 redisTemplate.opsForList() ListOperations 操作List类型数据 redisTemplate.opsForSet() SetOperations 操作Set类型数据 redisTemplate.opsForZSet() ZSetOperations 操作SortedSet类型数据 redisTemplate 通用命令 3.4 SpringDataRedis快速入门SpringBoot已经提供了对SpringDataRedis的支持，其中Spring默认支持Lettuce，如需使用Jedis需要额外导入依赖 导入依赖 12345678910&lt;!-- Redis依赖 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!-- 连接池依赖 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.commons&lt;/groupId&gt; &lt;artifactId&gt;commons-pool2&lt;/artifactId&gt;&lt;/dependency&gt; 配置文件 1234567891011spring: redis: host: 127.0.0.1 port: 6379 password: 123456 lettuce: pool: max-active: 8 # 最大连接数 max-idle: 8 #最大空闲连接数 min-idle: 0 #最小空闲连接数 max-wait: 100ms # 连接等待时间 注入RedisTemplate，进行测试： 12345678910111213@SpringBootTestpublic class RedisTemplateTest &#123; @Autowired private RedisTemplate redisTemplate; @Test void testString() &#123; //插入一条String类型的数据 redisTemplate.opsForValue().set(&quot;name&quot;,&quot;dahuang&quot;); //获取String类型的数据 System.out.println(redisTemplate.opsForValue().get(&quot;name&quot;)); &#125;&#125; SpringDataRedis的使用步骤： 引入spring-boot-starter-data-redis依赖 在application.yml配置Redis以及连接池信息 注入RedisTemplate 3.5 SpringDataRedis的序列化方式RedisTemplate可以接收任意Object作为值写入Redis，只不过写入前会把Object序列化为字节形式，默认采用JDK序列化，刚才存入的数据的结果是这样： 缺点： 可读性差 内存占用较大 需要导入jackson依赖： 1234&lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;&lt;/dependency&gt; 可以自定义RedisTemplate的序列化方式： 123456789101112131415161718192021@Configurationpublic class RedisConfig &#123; @Bean public RedisTemplate&lt;String, Object&gt; redisTemplate(RedisConnectionFactory redisConnectionFactory)&#123; //创建RedisTemplate RedisTemplate&lt;String,Object&gt; redisTemplate = new RedisTemplate&lt;&gt;(); //设置连接工厂 redisTemplate.setConnectionFactory(redisConnectionFactory); //设置json序列化 GenericJackson2JsonRedisSerializer gjjrs = new GenericJackson2JsonRedisSerializer(); //设置key的序列化 redisTemplate.setKeySerializer(RedisSerializer.string()); redisTemplate.setHashKeySerializer(RedisSerializer.string()); //设置value的序列化 redisTemplate.setValueSerializer(gjjrs); redisTemplate.setHashValueSerializer(gjjrs); return redisTemplate; &#125;&#125; 创建一个实体类： 123456789101112@Datapublic class User &#123; private String name; public Integer age; public User()&#123;&#125; public User(String name, Integer age) &#123; this.name = name; this.age = age; &#125;&#125; 进行测试： 123456@Testvoid testString() &#123; redisTemplate.opsForValue().set(&quot;demo:user:3&quot;,new User(&quot;dahuang&quot;,18)); User u = (User) redisTemplate.opsForValue().get(&quot;demo:user:3&quot;); System.out.println(&quot;u = &quot; + u);&#125; 控制台打印： 1u = User(name=dahuang, age=18) Redis中的数据： 12345&#123; &quot;@class&quot;: &quot;com.redis.pojo.User&quot;, &quot;name&quot;: &quot;dahuang&quot;, &quot;age&quot;: 18&#125; 3.6 StringRedisTemplate 尽管json的序列化方式可以满足需求，但仍然存在一些问题 为了在反序列化时知道对象的类型，json序列化器会将类的class类型写入json结果中，存入Redis，会带来额外的内存开销 为了节省空间，并不会使用json序列化器来处理value，而是统一使用String序列化器，要求只能存储String类型的key和value 当存储java对象时，手动完成对象的序列化和反序列化 graph LR; 实体类 --> |手动序列化|json字符串 --> |插入|Redis Redis -->|获取| json字符串 --> |手动反序列化|实体类 Spring默认提供了一个SpringRedisTemplate类，它的key和value的序列化方式默认就是String方式。省去了自定义RedisTemplate的过程： 12345678910111213141516171819202122@SpringBootTestpublic class StringRedisTemplateTest &#123; @Autowired private StringRedisTemplate stringRedisTemplate; //json工具 private static final ObjectMapper mapper = new ObjectMapper(); @Test void testStringTemplate() throws JsonProcessingException &#123; User user = new User(&quot;dahei&quot;, 22); //手动序列化 String json = mapper.writeValueAsString(user); //插入数据 stringRedisTemplate.opsForValue().set(&quot;demo:user:5&quot;,json); //获取数据 String val = stringRedisTemplate.opsForValue().get(&quot;demo:user:5&quot;); //手动反序列化 User u = mapper.readValue(val, User.class); //打印user System.out.println(&quot;u = &quot; + u); &#125;&#125; RedisTemplate的两种序列化实践方案： 方案一： 自定义RedisTemplate 修改RedisTemplate的序列化器为GenericJackson2JsonRedisSerializer 方案二： 使用StringRedisTemplate 写入Redis时，需手动把对象序列化为json 读取Redis时，手动把读取到的json反序列化为对象 3.7 RedisTemplate操作Hash类型12345678@Testvoid testHash() &#123; stringRedisTemplate.opsForHash().put(&quot;user:6&quot;,&quot;name&quot;,&quot;dahei&quot;); stringRedisTemplate.opsForHash().put(&quot;user:6&quot;,&quot;age&quot;,&quot;22&quot;); Map&lt;Object, Object&gt; entries = stringRedisTemplate.opsForHash().entries(&quot;user:6&quot;); System.out.println(&quot;entries = &quot; + entries);&#125; 实战篇 此项目为黑马点评，如需，请搜索黑马程序员获取资源 项目结构： application.yaml的配置： 123456789101112131415161718192021222324252627server: port: 8081spring: application: name: hmdp datasource: driver-class-name: com.mysql.jdbc.Driver url: jdbc:mysql://localhost:3306/hmdp?useSSL=false&amp;serverTimezone=UTC username: root password: 123456 redis: host: 127.0.0.1 port: 6379 password: 123456 lettuce: pool: max-active: 10 max-idle: 10 min-idle: 1 time-between-eviction-runs: 10s jackson: default-property-inclusion: non_null # JSON处理时忽略非空字段mybatis-plus: type-aliases-package: com.hmdp.entity # 别名扫描包logging: level: com.hmdp: debug 1.短信登录1.1 基于Session实现短信登录流程 1.2 实现发送短信验证码IUserService： 1234public interface IUserService extends IService&lt;User&gt; &#123; Result sendCode(String phone, HttpSession session);&#125; UserServiceImpl中实现sendCode方法： 12345678910111213141516@Overridepublic Result sendCode(String phone, HttpSession session) &#123; //校验手机号 if (RegexUtils.isPhoneInvalid(phone)) &#123; //不符合，返回错误信息 return Result.fail(&quot;手机号格式错误&quot;); &#125; //符合，生成验证码 String code = RandomUtil.randomNumbers(6); //保存验证码到Session session.setAttribute(&quot;code&quot;,code); //发送验证码，模拟一下 log.debug(&quot;发送验证码成功，验证码为：&quot;+code); //返回OK return Result.ok();&#125; UserController： 12345@PostMapping(&quot;code&quot;)public Result sendCode(@RequestParam(&quot;phone&quot;) String phone, HttpSession session) &#123; //发送短信验证码并保存验证码 return userService.sendCode(phone, session);&#125; 日志打印： 1发送验证码成功，验证码为：608824 1.3 实现短信验证登录与注册1234public interface IUserService extends IService&lt;User&gt; &#123; Result sendCode(String phone, HttpSession session); Result login(LoginFormDTO loginForm, HttpSession session);&#125; 1234567891011121314151617181920212223242526272829303132@Overridepublic Result login(LoginFormDTO loginForm, HttpSession session) &#123; //校验手机号 if (RegexUtils.isPhoneInvalid(loginForm.getPhone())) &#123; //不符合，返回错误信息 return Result.fail(&quot;手机号格式错误&quot;); &#125; //校验验证码 String code = (String) session.getAttribute(&quot;code&quot;); if (code == null || !code.equals(loginForm.getCode())) &#123; //不一致，返回错误信息 return Result.fail(&quot;验证码错误&quot;); &#125; //一致，查询手机号是否存在 User user = query().eq(&quot;phone&quot;, loginForm.getPhone()).one(); if (user == null) &#123; //不存在，插入到数据库，完成注册 user = createUserByPhone(loginForm.getPhone()); &#125; //保存用户到Session session.setAttribute(&quot;user&quot;,user); //每个session都有唯一的id，不需要登陆凭证 return Result.ok();&#125;private User createUserByPhone(String phone) &#123; User user = new User(); user.setPhone(phone); user.setNickName(USER_NICK_NAME_PREFIX + RandomUtil.randomNumbers(10)); save(user); return user;&#125; 12345@PostMapping(&quot;/login&quot;)public Result login(@RequestBody LoginFormDTO loginForm, HttpSession session)&#123; //实现登录功能 return userService.login(loginForm,session);&#125; 1.4 实现登录校验拦截器隐藏用户敏感信息： 调用/user/me接口获取用户信息时，响应中包含了手机号、密码等敏感信息，并且发送的多余信息增加了服务器的压力。所以我们只需要用户昵称、头像和id等的部分信息。 定义一个UserDto： 123456@Datapublic class UserDTO &#123; private Long id; //id private String nickName;//昵称 private String icon;//头像&#125; 将UserServiceImpl的login方法中存入session的User转换成UserDto类型： 1session.setAttribute(&quot;user&quot;, BeanUtil.copyProperties(user, UserDTO.class)); 新建LoginInterceptor拦截器： 12345678910111213141516171819202122232425public class LoginInterceptor implements HandlerInterceptor &#123; @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; //获取session HttpSession session = request.getSession(); //获取用户信息 UserDTO user = (UserDTO) session.getAttribute(&quot;user&quot;); //不存在，拦截 if (user == null)&#123; //返回状态码401，未授权 response.setStatus(401); return false; &#125; //存在，保存到TheadLocal UserHolder.saveUser(user); //放行 return true; &#125; @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123; //移除用户 UserHolder.removeUser(); &#125;&#125; 新建MvcConfig配置类，添加拦截器并添加排序路径： 12345678910111213141516@Configurationpublic class MvcConfig implements WebMvcConfigurer &#123; @Override public void addInterceptors(InterceptorRegistry registry) &#123; registry.addInterceptor(new LoginInterceptor()) .excludePathPatterns( //排除路径 &quot;/user/login&quot;, &quot;/user/code&quot;, &quot;/shop/**&quot;, &quot;/shop-type/**&quot;, &quot;/blog/hot&quot;, &quot;/upload/**&quot;, &quot;/voucher/**&quot; ); &#125;&#125; UserController中实现获取用户信息： 123456@GetMapping(&quot;/me&quot;)public Result me()&#123; //获取当前登录的用户并返回 UserDTO user = UserHolder.getUser(); return Result.ok(user);&#125; 1.5 Session共享问题分析session共享问题：多台Tomcat不能共享session存储空间，当请求切换到不同的Tomcat服务器时导致数据对是问题 session的替代方案应该满足： 数据共享 内存存储 key、value结构 Redis都能解决以上问题，并且延时低 1.6 基于Redis实现共享Session登录流程 可以采用String数据类型存储： key value 手机号 验证码 保存登录用户信息，可以使用String结构，以json字符串来保存，比较直观 Hash结构可以将对象中的每一个字段独立存储，可以针对单个字段做CRUD，并且内存占用少(推荐) 保存用户到Redis： key value 随机token为key存储用户数据 {name:Tom} 校验登录状态： 1.7 基于Redis实现短信登录*修改UserServiceImpl中的sendCode方法： 12345678910111213141516171819202122@Resourceprivate StringRedisTemplate stringRedisTemplate;@Overridepublic Result sendCode(String phone, HttpSession session) &#123; //校验手机号 if (RegexUtils.isPhoneInvalid(phone)) &#123; //不符合，返回错误信息 return Result.fail(&quot;手机号格式错误&quot;); &#125; //符合，生成验证码 String code = RandomUtil.randomNumbers(6); //保存验证码到Redis，设置有效期 stringRedisTemplate.opsForValue().set(RedisConstants.LOGIN_CODE_KEY +phone, //key code, //value RedisConstants.LOGIN_CODE_TTL, // 2 TimeUnit.MINUTES);//指定单位为分钟 //发送验证码，模拟一下 log.debug(&quot;发送验证码成功，验证码为：&quot;+code); //返回OK return Result.ok();&#125; 修改UserServiceImpl中的login方法： 1234567891011121314151617181920212223242526272829303132333435363738394041@Resourceprivate StringRedisTemplate stringRedisTemplate;@Overridepublic Result login(LoginFormDTO loginForm, HttpSession session) &#123; //校验手机号 if (RegexUtils.isPhoneInvalid(loginForm.getPhone())) &#123; //不符合，返回错误信息 return Result.fail(&quot;手机号格式错误&quot;); &#125; //校验验证码 String code = stringRedisTemplate.opsForValue().get(RedisConstants.LOGIN_CODE_KEY + loginForm.getPhone()); if (code == null || !code.equals(loginForm.getCode())) &#123; //不一致，返回错误信息 return Result.fail(&quot;验证码错误&quot;); &#125; //一致，查询手机号是否存在 User user = query().eq(&quot;phone&quot;, loginForm.getPhone()).one(); if (user == null) &#123; //不存在，插入到数据库，完成注册 user = createUserByPhone(loginForm.getPhone()); &#125; //随机生成登录令牌token， String token = UUID.randomUUID().toString(true); //将User对象转成UserDto在转换成Map数据类型 UserDTO userDTO = BeanUtil.copyProperties(user, UserDTO.class); //map数据类型的键值对都需要是String类型的 Map&lt;String, Object&gt; userMap = BeanUtil.beanToMap(userDTO, new HashMap&lt;&gt;(), CopyOptions.create().setIgnoreNullValue(true) //忽略空的值 .setFieldValueEditor((fieldName, fieldValue) -&gt; fieldValue.toString()));//所有value值转换为String //保存用户到Redis String key = RedisConstants.LOGIN_USER_KEY + token; stringRedisTemplate.opsForHash().putAll(key, userMap); //设置有效期30分钟 stringRedisTemplate.expire(key, //key RedisConstants.LOGIN_USER_TTL, // 30 TimeUnit.MINUTES); //分钟 //返回token return Result.ok(token); &#125; MVcConfig配置类中注入StringRedisTemplate： 12345678910111213141516171819@Configurationpublic class MvcConfig implements WebMvcConfigurer &#123; @Resource private StringRedisTemplate stringRedisTemplate; @Override public void addInterceptors(InterceptorRegistry registry) &#123; registry.addInterceptor(new LoginInterceptor(stringRedisTemplate)) .excludePathPatterns( //排除路径 &quot;/user/login&quot;, &quot;/user/code&quot;, &quot;/shop/**&quot;, &quot;/shop-type/**&quot;, &quot;/blog/hot&quot;, &quot;/upload/**&quot;, &quot;/voucher/**&quot; ); &#125;&#125; LoginInterceptor中获取Redis中的数据： 12345678910111213141516171819202122232425262728293031323334353637383940414243public class LoginInterceptor implements HandlerInterceptor &#123; private StringRedisTemplate stringRedisTemplate; public LoginInterceptor(StringRedisTemplate stringRedisTemplate) &#123; this.stringRedisTemplate = stringRedisTemplate; &#125; @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; //获取token，前端会将token放入到请求头中 String token = request.getHeader(&quot;authorization&quot;); if (StrUtil.isBlank(token)) &#123; //返回状态码401，未授权 response.setStatus(401); return false; &#125; //获取用户信息 Map&lt;Object, Object&gt; userMap = stringRedisTemplate.opsForHash().entries(RedisConstants.LOGIN_USER_KEY + token); //不存在，拦截 if (userMap.isEmpty())&#123; //返回状态码401，未授权 response.setStatus(401); return false; &#125; //将map转换成UserDto UserDTO user = BeanUtil.fillBeanWithMap(userMap,new UserDTO(),false); //存在，保存到TheadLocal UserHolder.saveUser(user); //刷新有效期 stringRedisTemplate.expire(RedisConstants.LOGIN_USER_KEY + token, //key RedisConstants.LOGIN_USER_TTL, // 30 TimeUnit.MINUTES); //分钟 //放行 return true; &#125; @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123; //移除用户 UserHolder.removeUser(); &#125;&#125; 1.8 解决状态登录刷新问题*拦截器 获取token 查询Redis的用户信息 不存在，则拦截 存在，则继续 保存到ThreadLocal 刷新token的有效期 放行 拦截器只会拦截登录的路径，从而刷新token有效期。 但是其他的一些不需要登录也可以查看的页面，比如首页，则不会刷新token有效期。 有可能长时间查看其他页面，导致在查看需要登录的路径，token过了有效期，需要重新登录的问题 sequenceDiagram 用户-->>拦截器1:发送请求 note over 拦截器1:拦截一切路径1. 获取token2. 查询Redis的用户3. 保存到ThreadLocal4. 刷新token的有效期5. 放行 拦截器1->>拦截器2:进入 note over 拦截器2:拦截需要登录的路径查看token存在，则拦截不存在，则继续 拦截器2->>UserController:进入 RefreshTokenInterceptor中： 12345678910111213141516171819202122232425262728293031323334353637383940public class RefreshTokenInterceptor implements HandlerInterceptor &#123; private StringRedisTemplate stringRedisTemplate; public RefreshTokenInterceptor(StringRedisTemplate stringRedisTemplate) &#123; this.stringRedisTemplate = stringRedisTemplate; &#125; @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; //获取token String token = request.getHeader(&quot;authorization&quot;); //token不存在，直接放行，不添加到ThreadLocal if (StrUtil.isBlank(token)) &#123; return true; &#125; //获取用户信息 Map&lt;Object, Object&gt; userMap = stringRedisTemplate.opsForHash().entries(RedisConstants.LOGIN_USER_KEY + token); //用户信息不存在，直接放行，不添加到ThreadLocal if (userMap.isEmpty())&#123; return true; &#125; //将map转换成UserDto UserDTO user = BeanUtil.fillBeanWithMap(userMap,new UserDTO(),false); //保存到TheadLocal UserHolder.saveUser(user); //刷新有效期 stringRedisTemplate.expire(RedisConstants.LOGIN_USER_KEY + token, //key RedisConstants.LOGIN_USER_TTL, // 30 TimeUnit.MINUTES); //分钟 //放行 return true; &#125; @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123; //移除用户 UserHolder.removeUser(); &#125;&#125; LoginInterceptor中： 1234567891011121314public class LoginInterceptor implements HandlerInterceptor &#123; @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; //判断ThreadLocal是否存在用户 if (UserHolder.getUser() == null)&#123; //没有，拦截，设置状态码 response.setStatus(401); return false; &#125; //有用户放行 return true; &#125;&#125; MvcConfig配置类中： 先进行token刷新拦截，刷新用户有效期； 再进行登录拦截，判断token是否有效 123456789101112131415161718192021222324@Configurationpublic class MvcConfig implements WebMvcConfigurer &#123; @Resource private StringRedisTemplate stringRedisTemplate; @Override public void addInterceptors(InterceptorRegistry registry) &#123; //token刷新拦截器 registry.addInterceptor(new RefreshTokenInterceptor(stringRedisTemplate)) .addPathPatterns(&quot;/**&quot;) //拦截所有路径 .order(0); // 注册顺序为0 //登录拦截器 registry.addInterceptor(new LoginInterceptor()) .excludePathPatterns( //排除路径 &quot;/user/login&quot;, &quot;/user/code&quot;, &quot;/shop/**&quot;, &quot;/shop-type/**&quot;, &quot;/blog/hot&quot;, &quot;/upload/**&quot;, &quot;/voucher/**&quot; ).order(1); //注册顺序为1 &#125;&#125; 2.商户查询缓存2.1 什么是缓存缓存就是数据交换的缓冲区(称作Cache)，是贮存数据的临时地方，一般读写性能较高 graph LR 浏览器缓存 --> Tomcat应用层缓存 --> 数据库缓存 --> CPU缓存 数据库缓存 --> 磁盘缓存 缓存的作用 降低后端的负载 提高读写效率，降低响应时间 缓存的成本 数据一致性成本 代码维护成本 运维成本 2.2 添加Redis缓存缓存的作用模型： sequenceDiagram 客户端->>Redis:请求 Redis->>客户端:命中(分支1) Redis->>数据库:未命中(分支2) 数据库->>Redis:写缓存 数据库->>客户端:响应 根据id查询商铺缓存的流程： IShopService创建一个queryById方法： 1234public interface IShopService extends IService&lt;Shop&gt; &#123; // ctrl+b转到实现类 Result queryById(Long id);&#125; 在ShopServiceImpl中实现queryById方法，从而实现商铺信息缓存： 这里选择获取和存储Redis的数据类型为String 12345678910111213141516171819202122232425@Resourceprivate StringRedisTemplate stringRedisTemplate;@Overridepublic Result queryById(Long id) &#123; String key = RedisConstants.CACHE_SHOP_KEY + id; //从Redis查询商铺缓存，Redis数据类型为String String shopJson = stringRedisTemplate.opsForValue().get(key); //判断是否存在，不为null if (StrUtil.isNotBlank(shopJson)) &#123; //存在，返回信息 Shop shop = JSONUtil.toBean(shopJson, Shop.class); return Result.ok(shop); &#125; //为null不存在，根据id查询 Shop shop = getById(id); //id不存在，返回错误信息 if (shop == null) &#123; return Result.fail(&quot;店铺不存在&quot;); &#125; //id存在，将数据写入Redis stringRedisTemplate.opsForValue().set(key, JSONUtil.toJsonStr(shop)); //返回商铺信息 return Result.ok(shop);&#125; ShopController中： 12345@GetMapping(&quot;/&#123;id&#125;&quot;)public Result queryShopById(@PathVariable(&quot;id&quot;) Long id) &#123; //通过id获取商铺信息 return shopService.queryById(id);&#125; 这里选择获取和存储Redis的数据类型为Hash 2.3 缓存更新策略 内存淘汰 超时剔除 主动更新 说明 不用自己维护，利用Redis的内存淘汰机制，当内存不足时自动淘汰部分数据。下次查询时更新缓存。 给缓存数据添加TTL时间，到期后自动删除缓存。下次查询时更新缓存。 编写业务逻辑，在修改数据库的同时，更新缓存。 一致性 差 一般 好 维护成本 无 低 高 业务场景： 低一致性需求： 使用内存淘汰机制。例如：店铺类型的查询缓存 高一致性需求： 主动更新，并以超时剔除为兜底方案。例如：店铺详情查询的缓存 主动更新策略： 方案一：Cache Aside Pattern(可控性高，企业开发常用) 由缓存的调用者，在更新数据库的同时更新缓存。 方案二：Read&#x2F;Write Through Pattern 缓存与数据库整合为一个服务，由服务来维护一致性。调用者调用该服务，无需关心缓存一致性问题。 方案三：Write Behind Caching Pattern 调用者只操作缓存，由其它线程异步的将缓存数据持久化到数据库，保证最终一致。 说明： 可以多次修改缓存中的数据，在将缓存的数据一次性更新到数据库中 如果缓存中的数据未更新到数据库时，出现宕机数据就会完全丢失 :cherry_blossom:方案一：Cache Aside Pattern 操作缓存和数据库时有三个问题需要考虑： 删除缓存还是更新缓存？ 更新缓存：每次更新数据库都要更新缓存，无效写操作较多:negative_squared_cross_mark: 删除缓存：更新数据库时让缓存失效，查询时在更新缓存:white_check_mark: 如何保证缓存与数据库的操作的同时成功或失败？ 单体系，将缓存与数据库的操作放在一个事务 分布式系统，利用TTC等分布式事务方案 先操作缓存还是先操作数据库？(数据库的数据操作相比Redis的数据操作慢) 先删除缓存，在操作数据库 异常情况：(出现情况高) 线程1删除缓存后，线程2查询缓存未命中，再查询数据库。将数据库中的旧数据又写入了缓存后，线程1才将数据库的数据进行了更新。导致线程2之前拿到的数据库的数据为旧数据。 先操作数据库，在删除缓存:cherry_blossom:(胜出) 异常情况：(出现情况低) 线程1查询缓存未命中，再查询数据库获取到旧数据后，线程2这时更新了数据库的数据，删除了缓存后，线程1才开始写入缓存。导致线程1之前拿到的数据库的数据为旧数据。 总结： 缓存更新策略的最佳实践方案 低一致性需求：使用Redis自带的内存淘汰机制 高一致性需求：主动更新，并以超时剔除为兜底方案 读操作： 缓存命中直接返回 缓存未命中则查询数据库，并写入缓存，设置超时时间 写操作： 先写数据库，然后再删除缓存 要确保数据库与缓存操作的原子性 2.4 添加缓存更新策略给查询商铺的缓存添加超时剔除和主动更新的策略 修改ShopController中的业务逻辑，满足一下的需求： 根据id查询店铺时，如果缓存未命中，则查询数据库，将数据库的结果写入缓存，并设置超时时间 根据id修改店铺时，先修改数据库，在删除缓存 修改ShopServiceImpl中的queryById方法，将写入Redis的数据设置有效期： 12345678910111213141516171819202122232425262728@Resourceprivate StringRedisTemplate stringRedisTemplate;@Overridepublic Result queryById(Long id) &#123; String key = RedisConstants.CACHE_SHOP_KEY + id; //从Redis查询商铺缓存 String shopJson = stringRedisTemplate.opsForValue().get(key); //判断是否存在，不为null if (StrUtil.isNotBlank(shopJson)) &#123; //存在，返回信息 Shop shop = JSONUtil.toBean(shopJson, Shop.class); return Result.ok(shop); &#125; //为null不存在，根据id查询 Shop shop = getById(id); //id不存在，返回错误信息 if (shop == null) &#123; return Result.fail(&quot;店铺不存在&quot;); &#125; //id存在，将数据写入Redis，设置有效期 stringRedisTemplate.opsForValue().set(key, //key JSONUtil.toJsonStr(shop), // value RedisConstants.CACHE_SHOP_TTL, // 30 TimeUnit.MINUTES); //分钟 //返回商铺信息 return Result.ok(shop);&#125; IShopService中创建update方法： 123456public interface IShopService extends IService&lt;Shop&gt; &#123; // ctrl+b转到实现类 Result queryById(Long id); Result update(Shop shop);&#125; ShopServiceImpl中,实现update方法： 12345678910111213141516171819@Resourceprivate StringRedisTemplate stringRedisTemplate;@Override@Transactionalpublic Result update(Shop shop) &#123; Long id = shop.getId(); //判断商铺是否存在 if (id == null) &#123; //返回错误信息 return Result.fail(&quot;商铺id不能为空&quot;); &#125; //更新数据库 updateById(shop); //删除缓存，下次用再取 stringRedisTemplate.delete(RedisConstants.CACHE_SHOP_KEY + id); //返回成功信息 return Result.ok();&#125; ShopController中： 12345@PutMappingpublic Result updateShop(@RequestBody Shop shop) &#123; //更新数据 return shopService.update(shop);&#125; 2.5 缓存穿透缓存穿透是指客户端请求的数据在缓存中和数据库中都不存在，这样缓存永远不会生效，这些请求到会多次打到数据库。(多次查询不存在的信息，频繁请求数据库，有可能导致数据库崩溃) 常见的解决方案有两种： 缓存空对象 优点：实现简单，维护方便 缺点： 额外的内存消耗 可能造成短期的不一致 (查询一个id未命中，Redis写入一个空对象，此时数据库插入这个id，导致信息不一致) sequenceDiagram 客户端->>Redis:请求 note left of Redis:未命中 Redis->>数据库:请求 note left of 数据库:未命中 数据库->>Redis:缓存null设置TTL 布隆过滤 优点：内存占用较少，没有多余的key 缺点： 实现复杂 存在误判可能 sequenceDiagram 客户端->>布隆过滤:请求 布隆过滤->>客户端:拒绝 note left of 布隆过滤:不存在 布隆过滤->>Redis:放行，请求 note left of Redis:存在 Redis->>客户端:返回 note over Redis,客户端:命中 Redis->>数据库:请求 note left of 数据库:未命中 数据库->>Redis:缓存数据 数据库->>客户端:返回数据 2.6 缓存空对象解决缓存穿透*就是将之前判断商铺不存在时，返回404信息改为将空值写入Redis ShopServiceImpl中的queryById方法： 123456789101112131415161718192021222324252627282930313233343536373839@Resourceprivate StringRedisTemplate stringRedisTemplate;@Overridepublic Result queryById(Long id) &#123; String key = RedisConstants.CACHE_SHOP_KEY + id; //从Redis查询商铺缓存 String shopJson = stringRedisTemplate.opsForValue().get(key); //判断是否存在，不为null和空字符串&quot;&quot;的情况 if (StrUtil.isNotBlank(shopJson)) &#123; //存在，返回信息 Shop shop = JSONUtil.toBean(shopJson, Shop.class); return Result.ok(shop); &#125; //命中的是否为空字符串 if (&quot;&quot;.equals(shopJson)) &#123; //返回错误信息 return Result.fail(&quot;店铺不存在&quot;); &#125; //为null不存在，根据id查询 Shop shop = getById(id); //id不存在，返回错误信息 if (shop == null) &#123; //将空值写入Redis stringRedisTemplate.opsForValue().set(key,//key &quot;&quot;, //空值 RedisConstants.CACHE_NULL_TTL,// 2 TimeUnit.MINUTES); //分钟 //返回错误信息 return Result.fail(&quot;店铺不存在&quot;); &#125; //id存在，将数据写入Redis，设置有效期 stringRedisTemplate.opsForValue().set(key, //key JSONUtil.toJsonStr(shop), // value RedisConstants.CACHE_SHOP_TTL, // 30 TimeUnit.MINUTES); //分钟 //返回商铺信息 return Result.ok(shop);&#125; 缓存穿透产生的原因是什么？ 用户请求的数据再缓存和数据库中都不存在，不断发起这样的请求，给数据库带来了巨大压力 缓存穿透的解决方案有哪些？ 缓存null值 布隆过滤 增加id的复杂度，避免被猜到id规律 做好数据的基础格式校验 2.7 缓存雪崩缓存雪崩是指同一时间大量的缓存key同时失效或者Redis服务宕机，导致大量请求到达数据库，带来压力。 sequenceDiagram 客户端->>Redis:请求 note over Redis:宕机或大量缓存同时失效 Redis->>数据库:大量请求 note left of 数据库:带来巨大压力 数据库->>客户端:返回 解决方案： 给不同的key的TTL添加随机值 利用Redis集群提高服务的可用性 给缓存业务添加降级限流策略 给业务添加多级缓存 2.8 缓存击穿缓存击穿问题也叫热点Ky问题，就是一个被高并发访问并且缓存重建业务较复杂的key突然失效了，无数的请求访问会在瞬间给数据库带来巨大的冲击。(有一个key失效，导致大量同时的多个请求访问数据库) 解决方案： 互斥锁 逻辑过期 给热点key设置一个逻辑时效(不在设置TTL，而是在value中添加一个时效字段expire) KEY VALUE heima:user:1 {name:”Jack”, age: “21”, expire:15214223} 解决方案 优点 缺点 互斥锁 没有额外的内存消耗保证一致性实现简单 线程需要等待，性能受影响可能有死锁风险 逻辑过期 线程无需等待，性能较好 不保证一致性有额外内存消耗(需要维护expire字段)实现复杂 2.9基于互斥锁解决缓存击穿*需求：修改根据d查询商铺的业务，基于互斥锁方式来解决缓存击穿问题 使用Redis中的setnx实现互斥锁 1234//上锁，只有在key值不存在时，才可以被设置;设置锁时，一般会加上有效期,避免产生死锁setnx lock 1//解锁del lock ShopServiceImpl中的queryById方法： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283@Resourceprivate StringRedisTemplate stringRedisTemplate;@Overridepublic Result queryById(Long id) &#123; Shop shop = querySolveCacheBreakdownByMutex(id); //返回商铺信息 if (shop == null)&#123; return Result.fail(&quot;店铺不存在&quot;); &#125; return Result.ok(shop);&#125;//解决缓存击穿，通过互斥锁解决private Shop querySolveCacheBreakdownByMutex(Long id)&#123; String key = RedisConstants.CACHE_SHOP_KEY + id; //从Redis查询商铺缓存 String shopJson = stringRedisTemplate.opsForValue().get(key); //判断是否存在，不为null和空字符串&quot;&quot;的情况 if (StrUtil.isNotBlank(shopJson)) &#123; //存在，返回信息 return JSONUtil.toBean(shopJson, Shop.class); &#125; //命中的是否为空字符串 if (&quot;&quot;.equals(shopJson)) &#123; //返回错误信息 return null; &#125; Shop shop = null; String lock = RedisConstants.LOCK_SHOP_KEY + id; try &#123; //尝试获取互斥锁 boolean isLock = tryLock(lock); //获取失败 if (!isLock)&#123; Thread.sleep(50); //递归，直到能够获取到shop return querySolveCacheBreakdownByMutex(id); &#125; //为null不存在，根据id查询 shop = getById(id); //id不存在，返回错误信息 if (shop == null) &#123; //将空值写入Redis stringRedisTemplate.opsForValue().set(key,//key &quot;&quot;, //空值 RedisConstants.CACHE_NULL_TTL,// 2 TimeUnit.MINUTES); //分钟 //返回空信息 return null; &#125; //id存在，将数据写入Redis，设置有效期 stringRedisTemplate.opsForValue().set(key, //key JSONUtil.toJsonStr(shop), // value RedisConstants.CACHE_SHOP_TTL, // 30 TimeUnit.MINUTES); //分钟 &#125; catch (InterruptedException e) &#123; throw new RuntimeException(e); &#125; finally &#123; //释放锁，finally的执行早于try里面的return unlock(lock); &#125; return shop;&#125;private boolean tryLock(String key)&#123; //尝试获取互斥锁，设置有效时间 Boolean flag = stringRedisTemplate.opsForValue().setIfAbsent(key, &quot;1&quot;, 10, //设置10秒 TimeUnit.SECONDS); //判断是否获取锁 return BooleanUtil.isTrue(flag);&#125;private void unlock(String key)&#123; //解锁，删除key stringRedisTemplate.delete(key);&#125; 2.10 利用逻辑过期解决缓存击穿*需求：修改根据d查询商铺的业务，利用逻辑过期解决缓存击穿问题 Shop类中并没有expireTime字段，在Shop类中添加此字段也是可以的，但是这样就对原来的业务逻辑做了修改。 可以新建一个RedisData类，添加expireTime字段： 12345@Datapublic class RedisData &#123; private LocalDateTime expireTime; private Object data;&#125; ShopServiceImpl中的queryById方法： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485@Resourceprivate StringRedisTemplate stringRedisTemplate;@Overridepublic Result queryById(Long id) &#123; Shop shop = querySolveCacheBreakdownByExpireTime(id); //返回商铺信息 if (shop == null)&#123; return Result.fail(&quot;店铺不存在&quot;); &#125; return Result.ok(shop);&#125;//解决缓存击穿，通过逻辑过期解决private Shop querySolveCacheBreakdownByExpireTime(Long id)&#123; String key = RedisConstants.CACHE_SHOP_KEY + id; //从Redis查询商铺缓存 String redisDataShopJson = stringRedisTemplate.opsForValue().get(key); //判断是否存在，为null和空字符串&quot;&quot;的情况 if (StrUtil.isBlank(redisDataShopJson)) &#123; //不存在，就不是热点key，一般热点商铺都会提前存入Redis，返回错误信息 return null; &#125; //json转对象 RedisData redisData = JSONUtil.toBean(redisDataShopJson, RedisData.class); Shop shop = JSONUtil.toBean((JSONObject) redisData.getData(), Shop.class); //判断是否过期 if(!LocalDateTime.now().isAfter(redisData.getExpireTime()))&#123; //未过期，返回 return shop; &#125; String lock = RedisConstants.LOCK_SHOP_KEY + id; //获取互斥锁成功 if(tryLock(lock))&#123; CACHE_REBUILD_EXECUTOR.submit(() -&gt; &#123; try &#123; //注意！需要进行双重检查，因为线程b在线程a重建缓存前，判断shop过期 //在线程a释放锁后，因为某种原因线程b才开始获取互斥锁，导致重复重建缓存 //我懒 //重建缓存 addShop2Redis(shop.getId(), 30L); &#125; catch (Exception e) &#123; throw new RuntimeException(e); &#125; finally &#123; //释放锁 unlock(lock); &#125; &#125;); &#125; //无论是否过期都返回 return shop;&#125;//创建线程池private static final ExecutorService CACHE_REBUILD_EXECUTOR = Executors.newFixedThreadPool(10);private void addShop2Redis(Long id, Long expireSeconds)&#123; //查询shop信息 Shop shop = getById(id); //封装过期时间 RedisData redisData = new RedisData(); redisData.setData(shop); redisData.setExpireTime(LocalDateTime.now().plusSeconds(expireSeconds)); //写入Redis stringRedisTemplate.opsForValue().set( RedisConstants.CACHE_SHOP_KEY + id, JSONUtil.toJsonStr(redisData));&#125;private boolean tryLock(String key)&#123; //尝试获取互斥锁，设置有效时间 Boolean flag = stringRedisTemplate.opsForValue().setIfAbsent(key, &quot;1&quot;, 10, //设置10秒 TimeUnit.SECONDS); //判断是否获取锁 return BooleanUtil.isTrue(flag);&#125;private void unlock(String key)&#123; //解锁，删除key stringRedisTemplate.delete(key);&#125; 2.11 缓存工具封装*基于StringRedisTemplate封装一个缓存工具类，满足下列需求： 将任java对象序列化为json并存在string类型的key中，并且可以设置TTL过期时同 将任意java对象序列化为json并存在string类型的key中，并且可以设置逻辑过期时同，用于处理缓存击穿问题 根据指定的key查询缓存，并反序列化为指定类型，利用缓存空值的方式解决缓存穿透问题 根据指定的key查询缓存，并反序列化为指定类型，需要利用逻辑过期解决缓存击穿问题 创建CacheClient类封装缓存工具： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159@Slf4j@Componentpublic class CacheClient &#123; private final StringRedisTemplate stringRedisTemplate; private static final ExecutorService CACHE_REBUILD_EXECUTOR = Executors.newFixedThreadPool(10); public CacheClient(StringRedisTemplate stringRedisTemplate) &#123; this.stringRedisTemplate = stringRedisTemplate; &#125; public void set(String key, Object value, Long time, TimeUnit timeUnit)&#123; stringRedisTemplate.opsForValue().set(key, JSONUtil.toJsonStr(value), time, timeUnit); &#125; public void setWithExpire(String key, Object value, Long time, TimeUnit timeUnit)&#123; //设置逻辑过期 RedisData redisData = new RedisData(); redisData.setData(value); redisData.setExpireTime(LocalDateTime.now().plusSeconds(timeUnit.toSeconds(time))); //写入Redis stringRedisTemplate.opsForValue().set(key, JSONUtil.toJsonStr(redisData)); &#125; //缓存穿透 public &lt;T, I&gt; T queryWithPenetration(String keyPrefix, I id, Class&lt;T&gt; type, Function&lt;I, T&gt; dbFallback, Long time, TimeUnit timeUnit)&#123; String key = keyPrefix + id; String json = stringRedisTemplate.opsForValue().get(key); //不为null和&quot;&quot; if (StrUtil.isNotBlank(json))&#123; return JSONUtil.toBean(json, type); &#125; //为&quot;&quot; if (&quot;&quot;.equals(json))&#123; return null; &#125; //数据库查询 T t = dbFallback.apply(id); //不存在，写入空值 if (t == null)&#123; this.set(key, &quot;&quot;, RedisConstants.CACHE_NULL_TTL, TimeUnit.MINUTES); return null; &#125; //存在 this.set(key, t, time, timeUnit); return t; &#125; //缓存击穿基于互斥锁 public &lt;T, I&gt; T queryWithBreakdownByMutex(String keyPrefix, I id, Class&lt;T&gt; type, Function&lt;I, T&gt; dbFallback, Long time, TimeUnit timeUnit)&#123; String key = keyPrefix + id; //从Redis查询商铺缓存 String json = stringRedisTemplate.opsForValue().get(key); //判断是否存在，不为null和空字符串&quot;&quot;的情况 if (StrUtil.isNotBlank(json)) &#123; return JSONUtil.toBean(json, type); &#125; //命中的是否为空字符串 if (&quot;&quot;.equals(json)) &#123; return null; &#125; T t = null; String lock = RedisConstants.LOCK_SHOP_KEY + id; try &#123; //尝试获取互斥锁 boolean isLock = tryLock(lock); //获取失败 if (!isLock)&#123; Thread.sleep(50); //递归，直到能够获取到shop return queryWithBreakdownByMutex(keyPrefix, id, type, dbFallback, time, timeUnit); &#125; //为null不存在，根据id查询 t = dbFallback.apply(id); //id不存在，返回错误信息 if (t == null) &#123; //将空值写入Redis this.set(key, &quot;&quot;, RedisConstants.CACHE_NULL_TTL, TimeUnit.MINUTES); return null; &#125; //id存在，将数据写入Redis，设置有效期 this.set(key, JSONUtil.toJsonStr(t), time, timeUnit); &#125; catch (InterruptedException e) &#123; throw new RuntimeException(e); &#125; finally &#123; //释放锁，finally的执行早于try里面的return unlock(lock); &#125; return t; &#125; //缓存击穿利用逻辑过期 public &lt;T, I&gt; T queryWithBreakdownByExpireTime(String keyPrefix, I id, Class&lt;T&gt; type, Function&lt;I, T&gt; dbFallback, Long addTime, TimeUnit timeUnit)&#123; String key = keyPrefix + id; //从Redis查询商铺缓存 String redisDataShopJson = stringRedisTemplate.opsForValue().get(key); //判断是否存在，为null和空字符串&quot;&quot;的情况 if (StrUtil.isBlank(redisDataShopJson)) &#123; //不存在，就不是热点key，一般热点商铺都会提前存入Redis，返回错误信息 return null; &#125; //json转对象 RedisData redisData = JSONUtil.toBean(redisDataShopJson, RedisData.class); T t = JSONUtil.toBean((JSONObject) redisData.getData(), type); //判断是否过期 if(!LocalDateTime.now().isAfter(redisData.getExpireTime()))&#123; //未过期，返回 return t; &#125; String lock = RedisConstants.LOCK_SHOP_KEY + id; //获取互斥锁成功 if(tryLock(lock))&#123; CACHE_REBUILD_EXECUTOR.submit(() -&gt; &#123; try &#123; //注意！需要进行双重检查，因为线程b在线程a重建缓存前，判断shop过期 //在线程a释放锁后，因为某种原因线程b才开始获取互斥锁，导致重复重建缓存 //重建缓存 this.setWithExpire(key, dbFallback.apply(id), addTime, timeUnit); &#125; catch (Exception e) &#123; throw new RuntimeException(e); &#125; finally &#123; //释放锁 unlock(lock); &#125; &#125;); &#125; //无论是否过期都返回 return t; &#125; private boolean tryLock(String lockKey)&#123; //尝试获取互斥锁，设置有效时间 Boolean flag = stringRedisTemplate.opsForValue().setIfAbsent(lockKey, &quot;1&quot;, 10, //设置10秒 TimeUnit.SECONDS); //判断是否获取锁 return BooleanUtil.isTrue(flag); &#125; private void unlock(String lockKey)&#123; //解锁，删除key stringRedisTemplate.delete(lockKey); &#125;&#125; ShopServiceImpl中的queryById方法中，直接调用CacheClient 的方法即可： 1234567891011121314151617181920212223242526272829303132333435@Resourceprivate CacheClient cacheClient;@Overridepublic Result queryById(Long id) &#123; //缓存穿透 /*Shop shop = cacheClient.queryWithPenetration( RedisConstants.CACHE_SHOP_KEY, id, Shop.class, this::getById, 30L, TimeUnit.MINUTES);*/ //缓存击穿基于互斥锁 /*Shop shop = cacheClient.queryWithBreakdownByMutex( RedisConstants.CACHE_SHOP_KEY, id, Shop.class, this::getById, 30L, TimeUnit.SECONDS);*/ //缓存击穿利用逻辑过期时间 Shop shop = cacheClient.queryWithBreakdownByExpireTime( RedisConstants.CACHE_SHOP_KEY, id, Shop.class, this::getById, 30L, TimeUnit.SECONDS); //返回商铺信息 if (shop == null)&#123; return Result.fail(&quot;店铺不存在&quot;); &#125; return Result.ok(shop);&#125; 3.优惠券秒杀3.1 全局唯一ID每个店铺都可以发布优惠券； 当用户抢购时，就会生成订单并保存到tb_voucher_order这张表中，而订单表如果使用数据库自增ID就存在一些问题： id的规律性太明显 受单表数据量的限制 全局D生成器，是一种在分布式系统下用来生成全局唯一ID的工具，一般要满足下列特性： 唯一性 高可用 高性能 递增性 安全性 为了增加ID的安全性，我们可以不直接使用Redis自增的数值，而是拼接一些其它信息： ID的组成部分： 符号位：1bit，永远为0 时间戳：31bt，以秒为单位，可以使用69年 序列号：32bit，秒内的计数器，支持每秒产生2^32个不同ID 3.2 Redis实现全局唯一ID*创建RedisIdWorker类实现全局唯一ID： 123456789101112131415161718192021222324252627282930@Componentpublic class RedisIdWorker &#123; //起始时间戳为2023/1/1 00:00:00 private static final long START_TIMESTAMP = 1672531200L; //序列号位数 private static final int SN = 32; private final StringRedisTemplate stringRedisTemplate; public RedisIdWorker(StringRedisTemplate stringRedisTemplate) &#123; this.stringRedisTemplate = stringRedisTemplate; &#125; public long nextId(String keyPrefix)&#123; LocalDateTime now = LocalDateTime.now(); //获取当前时间戳 long current = now.toEpochSecond(ZoneOffset.UTC); //获取时间戳 long timestamp = current - START_TIMESTAMP; //获取今天的日期 String date = now.format(DateTimeFormatter.ofPattern(&quot;yyyy:MM:dd&quot;)); //Redis自增，生成今天的序列号 String key = &quot;inc:&quot; + keyPrefix + &quot;:&quot; + date; Long increment = stringRedisTemplate.opsForValue().increment(key); //拼接时间戳和序列号 return timestamp &lt;&lt; SN | increment; &#125;&#125; 全局唯一D生成策略： UUID Redis自增 snowflake算法 数据库自增 Redis自增ID策略： 每天一个key，方便统计订单量 ID构造为时间戳+序列号 3.3 添加优惠券每个店铺都可以发布优惠券，分为平价券和特价券。平价券(折扣小)可以任意购买，而特价券(折扣大)需要秒杀抢购： 表关系如下： tb_voucher：优惠券的基本信息，优惠金额、使用规则等 tb_seckill_voucher：优惠券的库存、开始抢购时间，结束抢购时间。特价优惠券才需要填写这些信息 添加特价优惠券业务逻辑： 1234567891011121314151617181920@Servicepublic class VoucherServiceImpl extends ServiceImpl&lt;VoucherMapper, Voucher&gt; implements IVoucherService &#123; @Resource private ISeckillVoucherService seckillVoucherService; @Override @Transactional public void addSeckillVoucher(Voucher voucher) &#123; // 保存优惠券，mybatis-plus在执行save方法后自动返回ID save(voucher); // 保存秒杀信息 SeckillVoucher seckillVoucher = new SeckillVoucher(); seckillVoucher.setVoucherId(voucher.getId()); seckillVoucher.setStock(voucher.getStock()); seckillVoucher.setBeginTime(voucher.getBeginTime()); seckillVoucher.setEndTime(voucher.getEndTime()); seckillVoucherService.save(seckillVoucher); &#125;&#125; 添加特价优惠券需要后台添加，可以使用postman模拟： 3.4 实现优惠券秒杀下单下单时需要判断两点： 秒杀是否开始或结束，如果尚未开始或已经结束则无法下单 库存是否充足，不足则无法下单 实现VoucherOrderServiceImpl中的seckillVoucher方法： 123456789101112131415161718192021222324252627282930313233343536373839404142@Servicepublic class VoucherOrderServiceImpl extends ServiceImpl&lt;VoucherOrderMapper, VoucherOrder&gt; implements IVoucherOrderService &#123; @Resource private ISeckillVoucherService seckillVoucherService; @Resource private RedisIdWorker redisIdWorker; @Override @Transactional public Result seckillVoucher(Long voucherId) &#123; //查询优惠券 SeckillVoucher voucher = seckillVoucherService.getById(voucherId); //判断时间 LocalDateTime now = LocalDateTime.now(); if(now.isBefore(voucher.getBeginTime()) || now.isAfter(voucher.getEndTime()) )&#123; return Result.fail(&quot;未在规定时间内&quot;); &#125; //检查库存 if (voucher.getStock() &lt; 1)&#123; return Result.fail(&quot;库存不足&quot;); &#125; //减扣库存 boolean success = seckillVoucherService.update() .setSql(&quot;stock = stock - 1&quot;) .eq(&quot;voucher_id&quot;, voucherId) .update(); if (!success)&#123; return Result.fail(&quot;库存不足&quot;); &#125; //创建订单 VoucherOrder voucherOrder = new VoucherOrder(); long orderId = redisIdWorker.nextId(&quot;order&quot;); voucherOrder.setId(orderId); voucherOrder.setVoucherId(voucherId); voucherOrder.setUserId(UserHolder.getUser().getId()); save(voucherOrder); //返回订单id return Result.ok(orderId); &#125;&#125; 3.5 库存超卖问题分析在高并发的场景下，或可能会导致库存数量变为负数，发生库存超卖的情况： 超卖问题是典型的多线程安全问题，针对这一问题的常见解决方案就是加锁： 悲观锁：认为线程安全问题一定会发生，因此在操作数据之前先获取锁，确保线程串行执行。 例如Synchronized、Lock都属于悲观锁 乐观锁：认为线程安全问题不一定会发生，因此不加锁，只是在更新数据时去判断有没有其它线程对数据做了修改。 如果没有修改则认为是安全的，自己才更新数据。 如果已经被其它线程修改说明发生了安全问题，此时可以重试或异常。 CAS法： 修改sql语句即可： 1set stock = stock - 1 where voucher_id = ? and stock = ? 3.6 乐观锁解决超卖问题*修改VoucherOrderServiceImpl中的seckillVoucher方法： 12345678910111213141516171819202122232425262728293031323334@Override@Transactionalpublic Result seckillVoucher(Long voucherId) &#123; //查询优惠券 SeckillVoucher voucher = seckillVoucherService.getById(voucherId); //判断时间 LocalDateTime now = LocalDateTime.now(); if(now.isBefore(voucher.getBeginTime()) || now.isAfter(voucher.getEndTime()) )&#123; return Result.fail(&quot;未在规定时间内&quot;); &#125; //检查库存 if (voucher.getStock() &lt; 1)&#123; return Result.fail(&quot;库存不足&quot;); &#125; //减扣库存 //set stock = stock-1 where voucher_id = ? and stock = ? boolean success = seckillVoucherService.update() .setSql(&quot;stock = stock - 1&quot;) .eq(&quot;voucher_id&quot;, voucherId) .eq(&quot;stock&quot;, voucher.getStock()) .update(); if (!success)&#123; return Result.fail(&quot;库存不足&quot;); &#125; //创建订单 VoucherOrder voucherOrder = new VoucherOrder(); long orderId = redisIdWorker.nextId(&quot;order&quot;); voucherOrder.setId(orderId); voucherOrder.setVoucherId(voucherId); voucherOrder.setUserId(UserHolder.getUser().getId()); save(voucherOrder); //返回订单id return Result.ok(orderId);&#125; 但是这样做，在高并发的情况下，例如：库存有100个、此时有100线程同时秒杀，会导致只有一个线程秒杀成功，其余99个线程均失败，失败率过高 可以改为： 1set stock = stock - 1 where voucher_id = ? and stock &gt; 0 再次修改VoucherOrderServiceImpl中的seckillVoucher方法： 12345678910111213141516171819202122232425262728293031323334@Override@Transactionalpublic Result seckillVoucher(Long voucherId) &#123; //查询优惠券 SeckillVoucher voucher = seckillVoucherService.getById(voucherId); //判断时间 LocalDateTime now = LocalDateTime.now(); if(now.isBefore(voucher.getBeginTime()) || now.isAfter(voucher.getEndTime()) )&#123; return Result.fail(&quot;未在规定时间内&quot;); &#125; //检查库存 if (voucher.getStock() &lt; 1)&#123; return Result.fail(&quot;库存不足&quot;); &#125; //减扣库存 //set stock = stock-1 where voucher_id = ? and stock &gt; 0 boolean success = seckillVoucherService.update() .setSql(&quot;stock = stock - 1&quot;) .eq(&quot;voucher_id&quot;, voucherId) .gt(&quot;stock&quot;, 0) .update(); if (!success)&#123; return Result.fail(&quot;库存不足&quot;); &#125; //创建订单 VoucherOrder voucherOrder = new VoucherOrder(); long orderId = redisIdWorker.nextId(&quot;order&quot;); voucherOrder.setId(orderId); voucherOrder.setVoucherId(voucherId); voucherOrder.setUserId(UserHolder.getUser().getId()); save(voucherOrder); //返回订单id return Result.ok(orderId);&#125; 超卖这样的线程安全问题，解决方案： 悲观锁：添加同步锁，让线程串行执行 优点：简单粗暴 缺点：性能一般 乐观锁：不加锁，在更新时判断是否有其它线程在修改 优点：性能好 缺点：存在成功率低的问题 3.7 实现一人一单功能*需求：修改秒杀业务，要求同一个优惠券，一个用户只能下一单 添加依赖： 1234&lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt;&lt;/dependency&gt; 添加注解，开启暴露代理： 12345678910@EnableAspectJAutoProxy(exposeProxy = true)@MapperScan(&quot;com.hmdp.mapper&quot;)@SpringBootApplicationpublic class HmDianPingApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(HmDianPingApplication.class, args); &#125;&#125;、 修改VoucherOrderServiceImpl的seckillVoucher方法： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566@Servicepublic class VoucherOrderServiceImpl extends ServiceImpl&lt;VoucherOrderMapper, VoucherOrder&gt; implements IVoucherOrderService &#123; @Resource private ISeckillVoucherService seckillVoucherService; @Resource private RedisIdWorker redisIdWorker; @Override public Result seckillVoucher(Long voucherId) &#123; //查询优惠券 SeckillVoucher voucher = seckillVoucherService.getById(voucherId); //判断时间 LocalDateTime now = LocalDateTime.now(); if(now.isBefore(voucher.getBeginTime()) || now.isAfter(voucher.getEndTime()) )&#123; return Result.fail(&quot;未在规定时间内&quot;); &#125; //检查库存 if (voucher.getStock() &lt; 1)&#123; return Result.fail(&quot;库存不足&quot;); &#125; Long userId = UserHolder.getUser().getId(); //intern()方法:如果字符串常量池中已经存在一个等于此String对象的字符串，就直接从常量池中返回这个字符串对象的引用 //字符串常量池中不存在这个字符串对象，那么就新建并添加这个字符串对象到字符串常量池中，并返回新建的字符串对象的引用 //锁住userId相同地请求，应该先提交事务，再释放锁 synchronized (userId.toString().intern()) &#123; //this调用会导致事务不生效，可以通过AopContext获取到Proxy对象,从而实现代理. IVoucherOrderService proxy = (IVoucherOrderService) AopContext.currentProxy(); return proxy.createVoucherOrder(voucherId); &#125; &#125; @Override @Transactional public Result createVoucherOrder(Long voucherId) &#123; //检查一人一单 Long userId = UserHolder.getUser().getId(); int count = query().eq(&quot;user_id&quot;, userId) .eq(&quot;voucher_id&quot;, voucherId).count(); if (count &gt; 0)&#123; return Result.fail(&quot;用户已经购买过了&quot;); &#125; //减扣库存 //set stock = stock-1 where voucher_id = ? and stock &gt; 0 boolean success = seckillVoucherService.update() .setSql(&quot;stock = stock - 1&quot;) .eq(&quot;voucher_id&quot;, voucherId) .gt(&quot;stock&quot;, 0) .update(); if (!success)&#123; return Result.fail(&quot;库存不足&quot;); &#125; //创建订单 VoucherOrder voucherOrder = new VoucherOrder(); long orderId = redisIdWorker.nextId(&quot;order&quot;); voucherOrder.setId(orderId); voucherOrder.setVoucherId(voucherId); voucherOrder.setUserId(userId); save(voucherOrder); //返回订单id return Result.ok(orderId); &#125;&#125; 3.8 一人一单的并发安全问题通过加锁可以解决在单机情况下的一人一单安全问题，但是在集群模式下就不行了。 我们将服务启动两份，端口分别为8081和8082 然后修改nginx的conf目录下的nginx.conf文件，配置反向代理和负载均衡： 1234upstream backend &#123; server 127.0.0.1:8081 max_fails=5 fail_timeout=10s weight=1; server 127.0.0.1:8082 max_fails=5 fail_timeout=10s weight=1;&#125; 用户请求会在这两个节点上负载均衡，再次测试下是否存在线程安全问题。 两个服务(两个进程)，导致锁失效： 4.分布式锁4.1 分布式锁的基本原理 分布式锁：满足分布式系统或集群模式下多进程可见并且互斥的锁。 多进程可见 互斥 高可用 高性能 安全性 分布式锁的核心是实现多进程之间互斥，而满足这一点的方式有很多，常见的有三种： MySQL Redis Zookeeper 互斥 利用mysql本身的互斥锁机制 利用setnxi这样的互斥命令 利用节点的唯一性和有序性实现互斥 高可用 好 好 好 高性能 一般 好 一般 安全性 断开连接，自动释放锁 利用锁超时时间，到期释放 临时节点，断开连接自动释放 4.2 Redis分布式锁实现思路实现分布式锁时需要实现的两个基本方法： 获取锁： 互斥：确保只能有一个线程获取锁 非阻塞：尝试一次，成功返回true，失败返回false 123456#流加锁，利用setnx的互斥特性SETNX lock thread1#添加锁过期时间，避免服务宕机引起的死锁EXPIRE lock 10#==&gt;SET lock thread1 NX EX 10 释放锁： 手动释放 12#释放锁，删除即可DEL key 超时释放：获取锁时添加一个超时时间 4.3 实现Redis分布式锁需求：定义一个类，实现下面接口，利用Redis实现分布式锁功能。 123456public interface ILock &#123; //尝试获取锁，设置过期时间 boolean tryLock(long timeoutSec); //释放锁 void unlock();&#125; 实现ILock接口： 12345678910111213141516171819202122232425public class SimpleRedisLock implements ILock&#123; private static final String KEY_PREFIX = &quot;lock:&quot;; //业务名称 private final String businessName; private final StringRedisTemplate stringRedisTemplate; public SimpleRedisLock(String businessName, StringRedisTemplate stringRedisTemplate) &#123; this.businessName = businessName; this.stringRedisTemplate = stringRedisTemplate; &#125; @Override public boolean tryLock(long timeoutSec) &#123; //获取线程标识 long value = Thread.currentThread().getId(); Boolean flag = stringRedisTemplate.opsForValue() .setIfAbsent(KEY_PREFIX + businessName, String.valueOf(value), timeoutSec, TimeUnit.SECONDS); return BooleanUtil.isTrue(flag); &#125; @Override public void unlock() &#123; stringRedisTemplate.delete(KEY_PREFIX + businessName); &#125;&#125; 修改VoucherOrderServiceImpl中的seckillVoucher方法业务逻辑： 12345678910111213141516171819202122232425262728293031323334@Overridepublic Result seckillVoucher(Long voucherId) &#123; //查询优惠券 SeckillVoucher voucher = seckillVoucherService.getById(voucherId); //判断时间 LocalDateTime now = LocalDateTime.now(); if(now.isBefore(voucher.getBeginTime()) || now.isAfter(voucher.getEndTime()) )&#123; return Result.fail(&quot;未在规定时间内&quot;); &#125; //检查库存 if (voucher.getStock() &lt; 1)&#123; return Result.fail(&quot;库存不足&quot;); &#125; Long userId = UserHolder.getUser().getId(); //创建锁对象 SimpleRedisLock isLock = new SimpleRedisLock(&quot;order:&quot; + userId, stringRedisTemplate); //尝试获取锁 boolean flag = isLock.tryLock(5); if (!flag)&#123; //获取锁失败，返回错误 return Result.fail(&quot;不允许重复下单&quot;); &#125; //获取锁成功 try &#123; //this调用会导致事务不生效，可以通过AopContext获取到Proxy对象,从而实现代理. IVoucherOrderService proxy = (IVoucherOrderService) AopContext.currentProxy(); //生成一人一单的订单 return proxy.createVoucherOrder(voucherId); &#125; finally &#123; //释放锁 isLock.unlock(); &#125;&#125; 4.4 Redis分布式锁误删问题 需求：修改之前的分布式锁实现，满足： 在获取锁时存入线程标示(可以用UUID表示) 在释放锁时先获取锁中的线程标示，判断是否与当前线程标示一致 如果一致则释放锁 如果不一致则不释放锁 修改SimpleRedisLock类，添加线程标示： 123456789101112131415161718192021222324252627282930313233public class SimpleRedisLock implements ILock&#123; private static final String KEY_PREFIX = &quot;lock:&quot;; private static final String ID_PREFIX = UUID.randomUUID().toString(true) + &quot;-&quot;; //业务名称 private final String businessName; private final StringRedisTemplate stringRedisTemplate; public SimpleRedisLock(String businessName, StringRedisTemplate stringRedisTemplate) &#123; this.businessName = businessName; this.stringRedisTemplate = stringRedisTemplate; &#125; @Override public boolean tryLock(long timeoutSec) &#123; //获取线程标识 String value = ID_PREFIX + Thread.currentThread().getId(); Boolean flag = stringRedisTemplate.opsForValue() .setIfAbsent(KEY_PREFIX + businessName, value, timeoutSec, TimeUnit.SECONDS); return BooleanUtil.isTrue(flag); &#125; @Override public void unlock() &#123; //获取当前线程标示 String value = ID_PREFIX + Thread.currentThread().getId(); //获取value值 String result = stringRedisTemplate.opsForValue().get(KEY_PREFIX + businessName); //判断是否为当前线程的锁 if(value.equals(result))&#123; stringRedisTemplate.delete(KEY_PREFIX + businessName); &#125; &#125;&#125; 4.5 分布式锁的原子性问题 在释放锁时，判断是否一致时，因为某种原因导致阻塞，经过一段时间后才释放锁，产生的原子性问题 判断是否一致时和释放锁，应该绑定在一起执行 4.6 lua脚本解决多条命令原子性问题Redis:提供了Lua脚本功能，在一个脚本中编写多条Redisi命令，确保多条命令执行时的原子性。Lua是一种编程语言，它的基本语法大家可以参考网站：Lua教程|菜鸟教程 这里重点介绍Redis提供的调用函数，语法如下： 12--执行redis命令redis.call(&#x27;命令名称&#x27;, &#x27;key&#x27;, &#x27;其它参数&#x27;, ...) 例如：我们要执行set name jack，则脚本是这样： 12--执行set name jackredis.call(&#x27;set&#x27;, &#x27;name&#x27;, &#x27;jack&#x27;) 例如，我们要先执行set name Rose，再执行get name，则脚本如下： 123456--先执行set name jackredis.call(&#x27;set&#x27;, &#x27;name&#x27;, &#x27;jack&#x27;)--再执行get namelocal name redis.call(&#x27;get&#x27;, &#x27;name&#x27;)--返回return name 写好脚本以后，需要用Redis命令来调用脚本，调用脚本的常见命令如下： 12345127.0.0.1:6379&gt;help @scriptingEVAL script numkeys key [key ...] arg [arg ...]summary: Execute a Lua script server sidesince: 2.6.0 例如，我们要执行redis.call(&#39;set&#39;, &#39;name&#39;, &#39;jack&#39;)这个脚本，语法如下： 12#调用脚本，脚本内容、需要key参数的个数EVAL &quot;return redis.call(&#x27;set&#x27;,&#x27;name&#x27;,&#x27;jack&#x27;)&quot; 0 如果脚本中的key、value不想写死，可以作为参数传递。key类型参数会放入KEYS数组，其它参数会放入ARGV数组，在脚本中可以从KEYS和ARGV数组获取这些参数： 12#调用脚本EVAL &quot;return redis.call(&#x27;set&#x27;,KEYS[1],ARGV[1])&quot; 1 name Rose 释放锁的业务流程： 获取锁中的线程标示 判断是否与指定的标示(当前线程标示)一致 如果一致则释放锁(删除) 如果不一致则什么都不做 用Lua脚本实现： 12345678--这里的KEYS[1]就是锁的key，这里的ARGV[1]就是当前线程标示--获取锁中的标示，判断是否与当前线程标示一致if (redis.call(&#x27;GET&#x27;,KEYS[1]) == ARGV[1]) then --一致，则删除锁 return redis.call(&#x27;DEL&#x27;,KEYS[1])end--不一致，则直接返回return 0 4.7 java调用lua脚本改进分布式锁需求：基于Lua脚本实现分布式锁的释放锁逻辑 提示：RedisTemplate调用Lua脚本的API如下： 123public &lt;T&gt; T execute(RedisScript&lt;T&gt; script, List&lt;K&gt; keys, Object... args) &#123; return this.scriptExecutor.execute(script, keys, args); &#125; 在resources资源包中创建lua脚本unlock.lua： 12345678--这里的KEYS[1]就是锁的key，这里的ARGV[1]就是当前线程标示--获取锁中的标示，判断是否与当前线程标示一致if (redis.call(&#x27;GET&#x27;,KEYS[1]) == ARGV[1]) then --一致，则删除锁 return redis.call(&#x27;DEL&#x27;,KEYS[1])end--不一致，则直接返回return 0 再次改进SimpleRedisLock类中的unlock方法 123456789101112131415161718192021222324252627282930313233343536373839public class SimpleRedisLock implements ILock&#123; private static final String KEY_PREFIX = &quot;lock:&quot;; private static final String ID_PREFIX = UUID.randomUUID().toString(true) + &quot;-&quot;; //初始化lua脚本 private static final DefaultRedisScript&lt;Long&gt; UNLOCK_SCRIPT; static &#123; UNLOCK_SCRIPT = new DefaultRedisScript&lt;&gt;(); UNLOCK_SCRIPT.setLocation(new ClassPathResource(&quot;lua/unlock.lua&quot;)); UNLOCK_SCRIPT.setResultType(Long.class); &#125; //业务名称 private final String businessName; private final StringRedisTemplate stringRedisTemplate; public SimpleRedisLock(String businessName, StringRedisTemplate stringRedisTemplate) &#123; this.businessName = businessName; this.stringRedisTemplate = stringRedisTemplate; &#125; @Override public boolean tryLock(long timeoutSec) &#123; //获取线程标识 String value = ID_PREFIX + Thread.currentThread().getId(); Boolean flag = stringRedisTemplate.opsForValue() .setIfAbsent(KEY_PREFIX + businessName, value, timeoutSec, TimeUnit.SECONDS); return BooleanUtil.isTrue(flag); &#125; @Override public void unlock() &#123; //获取当前线程标示 String value = ID_PREFIX + Thread.currentThread().getId(); //调用lua脚本 stringRedisTemplate.execute( UNLOCK_SCRIPT, Collections.singletonList(KEY_PREFIX + businessName), value); &#125;&#125; 基于Redis的分布式锁实现思路： 利用set nx ex获取锁，并设置过期时间，保存线程标示 释放锁时先判断线程标示是否与自己一致，一致则删除锁 特性： 利用set nx满足互斥性 利用set ex保证故障时锁依然能释放，避免死锁，提高安全性 利用Redis集群保证高可用和高并发特性 4.8 Redisson功能介绍基于setnx实现的分布式锁存在下面的问题： 不可重入 同一个线程无法多次获取同一把锁 不可重试 获取锁只尝试一次就返回false，没有重试机制 超时释放 锁超时释放虽然可以避免死锁，但如果是业务执行耗时较长，也会导致锁释放，存在安全隐思 主从一致性 如果Redis提供了主从集群，主从同步存在延迟，当主机宕机时，如果从并同步主中的锁数据，则会出现锁实现 Redisson是一个在Redis的基础上实现的java驻内存数据网格(In-Memory Data Grid)。它不仅提供了一系列的分布式的java常用对象，还提供了许多分布式服务，其中就包含了各种分布式锁的实现。 分布式锁(Lock)和同步器(Synchronizer)： 可重入锁(Reentrant Lock) 公平锁(Fair Lock) 联锁(MultiLock) 红锁(RedLock) 读写锁(ReadWriteLock) 信号量(Semaphore) 可过期性信号量(PermitExpirableSemaphore) 闭锁(CountDownLatch) 4.9 Redisson快速入门 引入依赖 12345&lt;dependency&gt; &lt;groupId&gt;org.redisson&lt;/groupId&gt; &lt;artifactId&gt;redisson&lt;/artifactId&gt; &lt;version&gt;3.19.1&lt;/version&gt;&lt;/dependency&gt; 配置Redisson客户端 1234567891011121314@Configurationpublic class RedisConfig &#123; @Bean public RedissonClient redissonClient() &#123; //配置类 Config config = new Config(); //添加redis地址，这里添加了单点的地址，也可以使用config.useClusterServers()添加集群地址 config.useSingleServer() .setAddress(&quot;redis://192.168.150.101:6379&quot;) .setPassword(&quot;123321&quot;); //创建客户端 return Redisson.create(config); &#125;&#125; 测试，使用Redisson的分布式锁 12345678910111213141516171819@Resourceprivate RedissonClient redissonClient;@Testvoid testRedisson() throws InterruptedException &#123; //获取锁（可重入），指定锁的名称 RLock lock = redissonClient.getLock(&quot;anyLock&quot;); //尝试获取锁，参数分别是：获取锁的最大等待时间（期间会重试），锁自动释放时间，时间单位 boolean isLock = lock.tryLock(1,10, TimeUnit.SECONDS); //判断释放获取成功 if(isLock) &#123; try &#123; System.out.println(&quot;执行业务&quot;); &#125; finally &#123; //释放锁 lock.unlock(); &#125; &#125;&#125; 再次修改VoucherOrderServiceImpl的seckillVoucher方法 12345678910111213141516171819202122232425262728293031323334353637383940@Resourceprivate ISeckillVoucherService seckillVoucherService;@Resourceprivate RedissonClient redissonClient;@Overridepublic Result seckillVoucher(Long voucherId) &#123; //查询优惠券 SeckillVoucher voucher = seckillVoucherService.getById(voucherId); //判断时间 LocalDateTime now = LocalDateTime.now(); if(now.isBefore(voucher.getBeginTime()) || now.isAfter(voucher.getEndTime()) )&#123; return Result.fail(&quot;未在规定时间内&quot;); &#125; //检查库存 if (voucher.getStock() &lt; 1)&#123; return Result.fail(&quot;库存不足&quot;); &#125; Long userId = UserHolder.getUser().getId(); //创建锁对象 RLock isLock = redissonClient.getLock(&quot;lock:order:&quot; + userId); //尝试获取锁 boolean flag = isLock.tryLock(); if (!flag)&#123; //获取锁失败，返回错误 return Result.fail(&quot;不允许重复下单&quot;); &#125; //获取锁成功 try &#123; //this调用会导致事务不生效，可以通过AopContext获取到Proxy对象,从而实现代理. IVoucherOrderService proxy = (IVoucherOrderService) AopContext.currentProxy(); //生成一人一单的订单 return proxy.createVoucherOrder(voucherId); &#125; finally &#123; //释放锁 isLock.unlock(); &#125;&#125; 4.10 Redisson可重入锁原理可重入锁采用的数据结构为hash： KEY VALUE VALUE field value lock Thread1 0 获取锁的Lua脚本： 1234567891011121314151617181920local key = KEYS[1]; --锁的keylocal threadId = ARGV[1]; --线程唯一标识local releaseTime = ARGV[2]; --锁的自动释放时阅--判断是否存在if(redis.call(&#x27;exists&#x27;,key) == 0) then --不存在，获取锁 redis.call(&#x27;hset&#x27;,key,threadId,&#x27;1&#x27;); --设置有效期 redis.call(&#x27;expire&#x27;,key,releaseTime); return 1;--返回结果end;--锁已经存在，判断hreadId,是否是自己if(redis.call(&#x27;hexists&#x27;,key,threadId) == 1) then --不存在，获取锁重入次数+1 redis.call(&#x27;hincrby&#x27;,key,threadId,&#x27;1&#x27;); --设置有效期 redis.call(&#x27;expire&#x27;,key,releaseTime); return 1;--返回结果end;return 0;--代码走到这里，说明获取锁的不是自己，获取锁失败 释放锁的Lua脚本： 123456789101112131415161718local key = KEYS[1]; --keylocal threadId = ARGV[1]; --线程唯-标识local releaseTime = ARGV[2]; --锁的自动释放时间--判断当前锁是否还是被自己特有if (redis.call(&#x27;HEXISTS&#x27;,key,threadId) == 0) then return nil;--如果已经不是自己，则直接返回end;--是自己的锁，则重入次数-1Local count redis.call(&#x27;HINCRBY&#x27;,key,threadId,-1);--判断是否重入次数是否已经为0if (count &gt; 0) then --大于0说明不能释放锁，重置有效期然后返回 redis.call(EXPIRE&#x27;,key,releaseTime); return nil;else --等于0说明可以释放锁，直接删除 redis.call(&#x27;DEL&#x27;,key); return nil;end; 可重入锁原理测试： 1234567891011121314151617181920212223242526272829303132333435//创建锁对象RLock lock = redissonClient.getLock(&quot;Lock&quot;);//业务1@Testvoid method1()&#123; boolean isLock lock.tryLock(); if(!isLock) &#123; log.error(&quot;获取锁失败，1&quot;); return; try &#123; log.info(&quot;获取锁成功，1&quot;); //执行业务2 method2(); &#125; finally &#123; log.info(&quot;释放锁，1&quot;); lock.unlock(); &#125; &#125;&#125;//业务2void method2()&#123; boolean isLock lock.tryLock(); if(!isLock)&#123; log.error(&quot;获取锁失败，2&quot;); return; &#125; try &#123; log.info(&quot;获取锁成功，2&quot;); &#125; finally &#123; log.info(&quot;释放锁，2&quot;); lock.unlock(); &#125;&#125; 执行业务1，检查Redis中所是否存在ThreadId 如果存在，则ThreadId对应的Value值+1，此时变为1 如果不存在，创建TheadId，再将ThreadId对应的Value值+1，此时变为1 之后调用业务2，Redis中所对应的ThreadId的Value值+2，此时变为2 同时业务1完成，释放锁，Redis中所对应的ThreadId的Value值-1，此时又变为1 之后业务2完成，释放锁，Redis中所对应的ThreadId的Value值-1，此时又变为0 如果变为0，则删除此key 4.11 Redisson锁重试和WatchDog机制？？？？？？ 4.12 Redisson的MultiLock原理 在主从集群下，对所有结点获取锁，如果有某个结点宕机，就会导致锁消失，但别的结点仍然存在锁，就不会有重复获取锁问题 在RedisConfig配置多个Redis： 1234567891011121314151617181920212223242526272829303132333435363738@Configurationpublic class RedisConfig &#123; @Bean public RedissonClient redissonClient() &#123; //配置类 Config config = new Config(); //添加redis地址，这里添加了单点的地址，也可以使用config.useClusterServers()添加集群地址 config.useSingleServer() .setAddress(&quot;redis://192.168.150.101:6379&quot;) .setPassword(&quot;123321&quot;); //创建客户端 return Redisson.create(config); &#125; @Bean public RedissonClient redissonClient2() &#123; //配置类 Config config = new Config(); //添加redis地址，这里添加了单点的地址，也可以使用config.useClusterServers()添加集群地址 config.useSingleServer() .setAddress(&quot;redis://192.168.150.101:6380&quot;) .setPassword(&quot;123321&quot;); //创建客户端 return Redisson.create(config); &#125; @Bean public RedissonClient redissonClient3() &#123; //配置类 Config config = new Config(); //添加redis地址，这里添加了单点的地址，也可以使用config.useClusterServers()添加集群地址 config.useSingleServer() .setAddress(&quot;redis://192.168.150.101:6381&quot;) .setPassword(&quot;123321&quot;); //创建客户端 return Redisson.create(config); &#125;&#125; 测试联锁： 12345678910111213141516171819202122232425262728293031323334353637383940@SpringBootTest@RunWith(SpringRunner.class)class HmDianPingApplicationTests &#123; @Resource private RedissonClient redissonClient; @Resource private RedissonClient redissonClient2; @Resource private RedissonClient redissonClient3; private RLock lock; //当前类中的每个@Test方法之前执行注解方法 @BeforeEach void setUp() &#123; RLock lock1 = redissonClient.getLock(&quot;lock&quot;); RLock lock2 = redissonClient2.getLock(&quot;lock&quot;); RLock lock3 = redissonClient3.getLock(&quot;lock&quot;); //创建联锁 multiLock lock = redissonClient.getMultiLock(lock1, lock2, lock3); &#125; @Test void testRedisson() throws InterruptedException &#123; //尝试获取锁，参数分别是：获取锁的最大等待时间（期间会重试），锁自动释放时间，时间单位 boolean isLock = lock.tryLock(1, 10, TimeUnit.SECONDS); //判断释放获取成功 if(isLock) &#123; try &#123; System.out.println(&quot;执行业务&quot;); &#125; finally &#123; //释放锁 lock.unlock(); &#125; &#125; &#125;&#125; 4.13 总结不可重入Redis分布式锁： 原理：利用setnx的互斥性；利用ex避免死锁；释放锁时判断线程标示 缺陷：不可重入、无法重试、锁超时失效 可重入的Redis分布式锁： 原理：利用hash结构，记录线程标示和重入次数；利用watchDog延续锁时间；利用信号量控制锁重试等待 缺陷：redis宕机引起锁失效问题 Redisson的multiLock: 原理：多个独立的Redis节点，必须在所有节点都获取重入锁，才算获取锁成功 缺陷：运维成本高、实现复杂 5.Redis秒杀优化5.1 Redis异步秒杀思路 将秒杀优惠券库存放入Redis中： KEY VALUE stock:vid:10 100 将下单的用户id放入也放入到Redis的set集合中： KEY VALUE order:vid:10 1, 2, 3, 4, 5, 6 5.2 基于Redis完成秒杀资格判断改进秒杀业务，提高并发性能 需求： 新增秒杀优惠券的同时，将优惠券信息保存到Redis中 基于lua脚本，判断秒杀库存、一人一单，决定用户是否抢购成功 如果抢购成功，将优惠券d和用户id封装后存入阻塞队列 开启线程任务，不断从阻塞队列中获取信息，实现异步下单功能 在VoucherServiceImpl中修改addSeckillVoucher方法向Redis中添加优惠券： 1234567891011121314151617181920212223@Resourceprivate ISeckillVoucherService seckillVoucherService;@Resourceprivate StringRedisTemplate stringRedisTemplate;@Override@Transactionalpublic void addSeckillVoucher(Voucher voucher) &#123; // 保存优惠券，mybatis-plus在执行save方法后自动返回ID save(voucher); // 保存秒杀信息 SeckillVoucher seckillVoucher = new SeckillVoucher(); seckillVoucher.setVoucherId(voucher.getId()); seckillVoucher.setStock(voucher.getStock()); seckillVoucher.setBeginTime(voucher.getBeginTime()); seckillVoucher.setEndTime(voucher.getEndTime()); seckillVoucherService.save(seckillVoucher); //保存秒杀库存到Redis stringRedisTemplate.opsForValue() .set(RedisConstants.SECKILL_STOCK_KEY + voucher.getId(), voucher.getStock().toString());&#125; 创建seckill.lua脚本，判断库存、一人一单： 12345678910111213141516171819202122local voucherId = ARGV[1]; --优惠券idlocal userId = ARGV[2]; --用户id--拼接keylocal stockKey = &#x27;seckill:stock:&#x27; .. voucherId;local orderKey = &#x27;seckill:order:&#x27; .. voucherId;--判断库存是否充足if (tonumber(redis.call(&#x27;get&#x27;, stockKey)) &lt;= 0) then --库存不足，返回1 return 1;end--判断用户是否已经下单if (redis.call(&#x27;sismember&#x27;, orderKey, userId) == 1) then --用户已经下单，返回2 return 2;end--减扣库存redis.call(&#x27;incrby&#x27;, stockKey, -1);--将用户id插入到set合集中redis.call(&#x27;sadd&#x27;, orderKey, userId);return 0; 重写VoucherOrderServiceImpl的seckillVoucher方法： 12345678910111213141516171819202122232425262728293031323334353637@Servicepublic class VoucherOrderServiceImpl extends ServiceImpl&lt;VoucherOrderMapper, VoucherOrder&gt; implements IVoucherOrderService &#123; @Resource private StringRedisTemplate stringRedisTemplate; @Resource private RedisIdWorker redisIdWorker; //初始化lua脚本 private static final DefaultRedisScript&lt;Long&gt; SECKILL_SCRIPT; static &#123; SECKILL_SCRIPT = new DefaultRedisScript&lt;&gt;(); //设置脚本位置 SECKILL_SCRIPT.setLocation(new ClassPathResource(&quot;lua/seckill.lua&quot;)); //设置返回值类型 SECKILL_SCRIPT.setResultType(Long.class); &#125; @Override public Result seckillVoucher(Long voucherId) &#123; //执行lua脚本 Long userId = UserHolder.getUser().getId(); Long result = stringRedisTemplate.execute( SECKILL_SCRIPT, Collections.emptyList(), voucherId.toString(), userId.toString()); //异常信息，返回失败 if (result != 0)&#123; return Result.fail(result == 1 ? &quot;库存不足&quot; : &quot;不能重复下单&quot;); &#125; //模拟，生成订单号 long order = redisIdWorker.nextId(&quot;order&quot;); return Result.ok(order); &#125;&#125; 5.3 基于阻塞队列实现秒杀异步下单123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129@Slf4j@Servicepublic class VoucherOrderServiceImpl extends ServiceImpl&lt;VoucherOrderMapper, VoucherOrder&gt; implements IVoucherOrderService &#123; @Resource private StringRedisTemplate stringRedisTemplate; @Resource private ISeckillVoucherService seckillVoucherService; //全局唯一ID @Resource private RedisIdWorker redisIdWorker; //redisson分布式锁 @Resource private RedissonClient redissonClient; //代理对象 private IVoucherOrderService proxy; //初始化lua脚本 private static final DefaultRedisScript&lt;Long&gt; SECKILL_SCRIPT; static &#123; SECKILL_SCRIPT = new DefaultRedisScript&lt;&gt;(); //设置脚本位置 SECKILL_SCRIPT.setLocation(new ClassPathResource(&quot;lua/seckill.lua&quot;)); //设置返回值类型 SECKILL_SCRIPT.setResultType(Long.class); &#125; //初始化阻塞队列 private final BlockingQueue&lt;VoucherOrder&gt; orderTasks = new ArrayBlockingQueue&lt;&gt;(1024*1024); //初始化单线程池 private static final ExecutorService SECKILL_ORDER_EXECUTOR = Executors.newSingleThreadExecutor(); //在spring容器初始化的时候执行该方法 @PostConstruct private void init() &#123; SECKILL_ORDER_EXECUTOR.submit(new VoucherOrderHandler()); &#125; private class VoucherOrderHandler implements Runnable &#123; @Override public void run() &#123; while (true) &#123; try &#123; //获取队列的订单信息，没有订单则阻塞等待 VoucherOrder voucherOrder = orderTasks.take(); //处理订单 handleVoucherOrder(voucherOrder); &#125; catch (Exception e) &#123; log.error(&quot;处理订单异常&quot;, e); &#125; &#125; &#125; &#125; //主方法 @Override public Result seckillVoucher(Long voucherId) &#123; //执行lua脚本 Long userId = UserHolder.getUser().getId(); Long result = stringRedisTemplate.execute( SECKILL_SCRIPT, Collections.emptyList(), voucherId.toString(), userId.toString()); //异常信息，返回失败 if (result != 0)&#123; return Result.fail(result == 1 ? &quot;库存不足&quot; : &quot;不能重复下单&quot;); &#125; //获取主线程代理对象 proxy = (IVoucherOrderService) AopContext.currentProxy(); //创建订单 VoucherOrder voucherOrder = new VoucherOrder(); long orderId = redisIdWorker.nextId(&quot;order&quot;); voucherOrder.setId(orderId); voucherOrder.setVoucherId(voucherId); voucherOrder.setUserId(userId); //加入到阻塞队列中 orderTasks.add(voucherOrder); return Result.ok(orderId); &#125; //再次进行逻辑判断，互斥的处理订单 private void handleVoucherOrder(VoucherOrder voucherOrder) &#123; Long userId = voucherOrder.getUserId(); RLock isLock = redissonClient.getLock(&quot;lock:order:&quot; + userId); //尝试获取锁 boolean flag = isLock.tryLock(); if (!flag)&#123; log.error(&quot;不能重复下单&quot;); return; &#125; //获取锁成功 try &#123; //生成一人一单的订单 proxy.createVoucherOrder(voucherOrder); &#125; finally &#123; //释放锁 isLock.unlock(); &#125; &#125; //操作数据库，生成订单 @Override @Transactional public void createVoucherOrder(VoucherOrder voucherOrder) &#123; //检查一人一单 Long userId = voucherOrder.getUserId(); int count = query().eq(&quot;user_id&quot;, userId) .eq(&quot;voucher_id&quot;, voucherOrder.getVoucherId()).count(); if (count &gt; 0)&#123; log.error(&quot;用户已经购买过一次&quot;); return; &#125; //减扣库存 //set stock = stock-1 where voucher_id = ? and stock &gt; 0 boolean success = seckillVoucherService.update() .setSql(&quot;stock = stock - 1&quot;) .eq(&quot;voucher_id&quot;, voucherOrder.getVoucherId()) .gt(&quot;stock&quot;, 0) .update(); if (!success)&#123; log.error(&quot;库存不足&quot;); return; &#125; //从数据库生成订单 save(voucherOrder); &#125;&#125; 秒杀业务的优化思路是什么？ 先利用Redis完成库存余量、一人一单判断，完成抢单业务 再将下单业务放入阻塞队列，利用独立线程异步下单 基于阻塞队列的异步秒杀存在哪些问题？ 内存限制问题 数据安全问题 6.Redis消息队列6.1 消息队列消息队列(Message Queue)，字面意思就是存放消息的队列。 最简单的消息队列模型包括3个角色： 消息队列：存储和管理消息，也被称为消息代理(Message Broker) 生产者：发送消息到消息队列 消费者：从消息队列获取消息并处理消息 Redis提供了三种不同的方式来实现消息队列： list结构：基于List结构模拟消息队列 PubSub：基本的点对点消息模型 Stream：比较完善的消息队列模型 List PubSub Stream 消息持久化 支持 不支持 支持 阻塞读取 支持 支持 支持 消息堆积处理 受限于内存空间，可以利用多消费者加快处理 受限于消费者缓冲区 受限于队列长度，可以利用消费者组提高消费速度，减少堆积 消息确认机制 不支持 不支持 支持 消息回溯 不支持 不支持 支持 6.2 基于List实现消息队列消息队列(Message Queue)，字面意思就是存放消息的队列。 而Redis的list数据结构是一个双向链表，很容易模拟出队列效果。 队列是入口和出口不在一边，因此我们可以利用：LPUSH结合RPOP 或者 RPUSH结合LPOP来实现。 不过要注意的是，当队列中没有消息时RPOP或LPOP操作会返回null，并不像JVM的阻塞队列那样会阻塞并等待消息。 因此这里应该使用BRPOP或者BLPOP来实视阻塞效果。 基于List的消息队列的优缺点： 优点： 利用Redis存储，不受限于JVM内存上限 基于Redis的持久化机制，数据安全性有保证 可以满足消息有序性 缺点： 无法避免消息丢失：移除队列后，会删除数据。如果此时宕机，造成数据丢失 只支持单消费者 6.3 PubSub实现消息队列PubSub(发布订阅)是Redis2.0版本引入的消息传递模型。顾名思义，消费者可以订阅一个或多个channel，生产者向对应channel发送消息后，所有订阅者都能收到相关消息。 SUBSCRIBE channel[channel]：订阅一个或多个频道 PUBLISH channel msg：向一个频道发送消息 PSUBSCRIBE pattern[pattern]：订阅与pattern格式匹配的所有频道 基于PubSub的消息队列有哪些优缺点？ 优点： 采用发布订阅模型，支持多生产、多消费 缺点： 不支持数据持久化 无法避免消息丢失 消息堆积有上限，超出时数据丢失 6.4 Stream的单消费模式Stream是Redis5.0引入的一种新数据类型，可以实现一个功能非常完善的消息队列。 发送消息的命令： 1xadd key [nomkstream] [maxlen|minid [=|~] threshold [limit count]] *|ID field value [nomkstream]：如果队列不存在，是否自动创建队列，默认是自动创建 [maxlen|minid [=|~] threshold [limit count]]：设置消息队列的最大消息数量 *|ID：消息的唯一Id，*代表由Redis自动生成。格式是”时间戳-递增数字”，例如”1644804662707-0” field value：发送到队列中的消息，称为Entry。格式就是多个key-value键值对 例如： 123##创建名为users的队列，并向其中发送一个消息，内容是：&#123;name=jack,age=21&#125;，并且使用那redis自动生成id127.0.0.1:6379&gt; XADD users name jack age 21&quot;1644805700523-0&quot; 读取消息：XREAD 1xread [COUNT count] [BLOCK milliseconds] STREAMS key [key ...] ID [ID ...] [COUNT count]：每次读取消息的最大数量 [BLOCK milliseconds]：当没有消息时，是否阻塞、阻塞时长 STREAMS key [key ...]：要从哪个队列读取消息，key就是队列名 ID [ID ...]：起始id，只返回大于该ID的消息 0：代表从第一个消息开始 $：代表从最新的消息开始 例如，使用XREAD读取第一个消息： 1234567127.0.0.1:6379&gt; XREAD COUNT 1 STREAMS users 01) 1) &quot;users&quot; 2) 1) 1) &quot;1644805700523-0&quot; 2) 1) &quot;name 2) &quot;jack&quot; 3) &quot;age&quot; 4) &quot;21&quot; XREAD阻塞方式，读取最新的消息： 123127.0.0.1:6379&gt; XREAD COUNT 1 BLOCK 1000 STREAMS users $(nil)(1.07s) 在业务开发中，我们可以循环的调用XREAD阻塞方式来查询最新消息，从而实现持续监听队列的效果，伪代码如下： 123456789while(true)&#123; //尝试读取队列中的消息，最多阻塞2秒 Object msg = redis.xecute(&quot;XREAD COUNT 1 BLOCK 2000 STREAMS users $&quot;); if(msg == null)&#123; continue; &#125; //处理消息 handleMessage(msg);&#125; 注意，当我们指定起始ID为$时，代表读取最新的消息，如果我们处理一条消息的过程中，又有超过1条以上的消息到达队列，则下次获取时也只能获取到最新的一条，会出现漏读消息的问题。 STREAM类型消息队列的XREAD命令特点： 消息可回潮 一个消息可以被多个消费者读取 可以阻塞读取 有消息漏读的风险 6.5 Stream的消费者组模式消费者组(Consumer Group)：将多个消费者划分到一个组中，监听同一个队列。 具备下列特点： 消息分流 队列中的消息会分流给组内的不同消费者，而不是重复消费，从而加快消息处理的速度 消息标示 消费者组会维护一个标示，记录最后一个被处理的消息，哪怕消费者宕机重启，还会从标示之后读取消息。确保每一个消息都会被消费 消息确认 消费者获取消息后，消息处于pending状态，并存入一个pending-list。当处理完成后需要通过XACK来确认消息，标记消息为已处理，才会从pending-List移除。 创建消费者组： 1XGROUP CREATE key groupName ID [MKSTREAM] key：队列名称 groupName：消费者组名称 ID：起始ID标示，$代表队列中最后一个消息，0则代表队列中第一个消息 MKSTREAM：队列不存在时自动创建队列 其它常见命令： 123456#删除指定的消费者组XGROUP DESTORY key groupName#给指定的消费者组添加消费者XGROUP CREATECONSUMER key groupname consumername#删除消费者组中的指定消费者XGROUP DELCONSUMER key groupname consumername 从消费者组读取消息： 1XREADGROUP GROUP group consumer [COUNT count] [BLOCK milliseconds] [NOACK] STREAMS key [key ...] ID [ID ...] group：消费组名称 consumer：消费者名称，如果消费者不存在，会自动创建一个消费者 count：本次查询的最大数量 BLOCK milliseconds：当没有消息时最长等待时间 NOACK：无需手动ACK,获取到消息后自动确认 STREAMS key：指定队列名称 ID：获取消息的起始ID: &quot;&gt;&quot;：从下一个未消费的消息开始 其它：根据指定id从pending-list中获取已消费但未确认的消息，例如0，是从pending-List中的第一个消息开始 ACK，消息确认： 1SACK stream.orders g1 id 消费者监听消息的基本思路： 123456789101112131415161718192021222324252627while(true) &#123; //尝试监听队列，使用阻塞模式，最长等待2000毫秒 Object msg = redis.call(&quot;XREADGROUP GROUP g1 c1 COUNT 1 BLOCK 2000 STREAMS s1 &gt;&quot;) if(msg == null) &#123; //null说明没有消息，继续下一次 continue; &#125; try &#123; //处理消息，完成后一定要ACK handleMessage(msg); &#125; catch(Exception e) &#123; while(true) &#123; object msg = redis.call(&quot;XREADGROUP GROUP g1 c1 COUNT 1 STREAMS s1 0&quot;); if(msg == nu11) &#123; //null说明没有异常消息，所有消息都已确认，结束循环 break; &#125; try &#123; //说明有异常消息，再沈处理 handleMessage(msg)； &#125; catch(Exception e) &#123; //再次出现异常，记灵日志，继续循环 continue; &#125; &#125; &#125; &#125; STREAM类型消息队列的XREADGROUP命令特点： 消息可回溯 可以多消费者争抢消息，加快消费速度 可以阻塞读取 没有消息漏读的风险 有消息确认机制，保证消息至少被消费一次 6.6 基于Stream消息队列实现异步秒杀需求： 创建一个Stream类型的消息队列，名为stream.orders 修改之前的秒杀下单Lua脚本，在认定有抢购资格后，直接向stream.orders中添加消息，内容包含voucherld、userld、orderld 项目启动时，开启一个线程任务，尝试获取stream.orders中的消息，完成下单 创建名为stream.orders消息队列： 1XGROUP CREATE stream.orders g1 0 MKSTREAM 创建seckillStream的Lua脚本： 123456789101112131415161718192021222324252627local voucherId = ARGV[1]; --优惠券idlocal userId = ARGV[2]; --用户idlocal orderId = ARGV[3]; --订单id--拼接keylocal stockKey = &#x27;seckill:stock:&#x27; .. voucherId;local orderKey = &#x27;seckill:order:&#x27; .. voucherId;--判断库存是否充足if (tonumber(redis.call(&#x27;get&#x27;, stockKey)) &lt;= 0) then --库存不足，返回1 return 1;end--判断用户是否已经下单if (redis.call(&#x27;sismember&#x27;, orderKey, userId) == 1) then --用户已经下单，返回2 return 2;end--减扣库存redis.call(&#x27;incrby&#x27;, stockKey, -1);--将用户id插入到set合集中redis.call(&#x27;sadd&#x27;, orderKey, userId);--发送消息到队列中，XADD stream.orders * k1 v1 k2 v2 ···redis.call(&#x27;xadd&#x27;, &#x27;stream.orders&#x27;, &#x27;*&#x27;, &#x27;userId&#x27;, userId, &#x27;voucherId&#x27;, voucherId, &#x27;id&#x27;, orderId)return 0; 继续改进VoucherOrderServiceImpl类中的 seckillVoucher方法： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180@Slf4j@Servicepublic class VoucherOrderServiceImpl extends ServiceImpl&lt;VoucherOrderMapper, VoucherOrder&gt; implements IVoucherOrderService &#123; @Resource private StringRedisTemplate stringRedisTemplate; @Resource private ISeckillVoucherService seckillVoucherService; //全局唯一ID @Resource private RedisIdWorker redisIdWorker; //redisson分布式锁 @Resource private RedissonClient redissonClient; //代理对象 private IVoucherOrderService proxy; //初始化lua脚本 private static final DefaultRedisScript&lt;Long&gt; SECKILL_SCRIPT; static &#123; SECKILL_SCRIPT = new DefaultRedisScript&lt;&gt;(); //设置脚本位置 SECKILL_SCRIPT.setLocation(new ClassPathResource(&quot;lua/seckillStream.lua&quot;)); //设置返回值类型 SECKILL_SCRIPT.setResultType(Long.class); &#125; //初始化单线程池 private static final ExecutorService SECKILL_ORDER_EXECUTOR = Executors.newSingleThreadExecutor(); //在spring容器初始化的时候执行该方法 @PostConstruct private void init() &#123; SECKILL_ORDER_EXECUTOR.submit(new VoucherOrderHandler()); &#125; private class VoucherOrderHandler implements Runnable &#123; private final String queueName = &quot;stream.orders&quot;; @Override public void run() &#123; while (true) &#123; try &#123; //获取消息队列中的订单信息，没有订单则阻塞等待2秒 //XREADGROUP GROUP c1 COUNT 1 BLOCK 2000 STREAMS streams.order &gt; List&lt;MapRecord&lt;String, Object, Object&gt;&gt; list = stringRedisTemplate.opsForStream().read( Consumer.from(&quot;g1&quot;, &quot;c1&quot;), StreamReadOptions.empty().count(1).block(Duration.ofSeconds(2)), StreamOffset.create(queueName, ReadOffset.lastConsumed()) ); //判断消息是否获取成功 if (list == null || list.isEmpty()) &#123; //获取失败，进入下次循环 continue; &#125; //解析消息中的订单信息 MapRecord&lt;String, Object, Object&gt; record = list.get(0); Map&lt;Object, Object&gt; value = record.getValue(); VoucherOrder voucherOrder = BeanUtil.fillBeanWithMap(value, new VoucherOrder(), true); //获取成功，则处理订单 handleVoucherOrder(voucherOrder); //完成ACK确认 //SACK stream.orders g1 id stringRedisTemplate.opsForStream().acknowledge(queueName, &quot;g1&quot;, record.getId()); &#125; catch (Exception e) &#123; log.error(&quot;处理订单异常&quot;, e); handlePendingList(); &#125; &#125; &#125; //pending-list检查 private void handlePendingList() &#123; while (true) &#123; try &#123; //获取pending-list中的订单信息 //XREADGROUP GROUP c1 COUNT 1 STREAMS streams.order 0 List&lt;MapRecord&lt;String, Object, Object&gt;&gt; list = stringRedisTemplate.opsForStream().read( Consumer.from(&quot;g1&quot;, &quot;c1&quot;), StreamReadOptions.empty().count(1), StreamOffset.create(queueName, ReadOffset.from(&quot;0&quot;)) ); //判断消息是否获取成功 if (list == null || list.isEmpty()) &#123; //获取失败，pending-list中没有异常消息，结束循环 break; &#125; //解析消息中的订单信息 MapRecord&lt;String, Object, Object&gt; record = list.get(0); Map&lt;Object, Object&gt; value = record.getValue(); VoucherOrder voucherOrder = BeanUtil.fillBeanWithMap(value, new VoucherOrder(), true); //获取成功，处理异常的订单 handleVoucherOrder(voucherOrder); //完成ACK确认 //SACK stream.orders g1 id stringRedisTemplate.opsForStream().acknowledge(queueName, &quot;g1&quot;, record.getId()); &#125; catch (Exception e) &#123; log.error(&quot;处理pending-list订单异常&quot;, e); try &#123; Thread.sleep(20); &#125; catch (InterruptedException ex) &#123; ex.printStackTrace(); &#125; &#125; &#125; &#125; &#125; //主方法 @Override public Result seckillVoucher(Long voucherId) &#123; Long userId = UserHolder.getUser().getId(); long orderId = redisIdWorker.nextId(&quot;order&quot;); //执行lua脚本 Long result = stringRedisTemplate.execute( SECKILL_SCRIPT, Collections.emptyList(), voucherId.toString(), userId.toString(), String.valueOf(orderId)); //异常信息，返回失败 if (result != 0)&#123; return Result.fail(result == 1 ? &quot;库存不足&quot; : &quot;不能重复下单&quot;); &#125; //获取主线程代理对象 proxy = (IVoucherOrderService) AopContext.currentProxy(); return Result.ok(orderId); &#125; //再次进行逻辑判断，互斥的处理订单 private void handleVoucherOrder(VoucherOrder voucherOrder) &#123; Long userId = voucherOrder.getUserId(); RLock isLock = redissonClient.getLock(&quot;lock:order:&quot; + userId); //尝试获取锁 boolean flag = isLock.tryLock(); if (!flag)&#123; log.error(&quot;不能重复下单&quot;); return; &#125; //获取锁成功 try &#123; //生成一人一单的订单 proxy.createVoucherOrder(voucherOrder); &#125; finally &#123; //释放锁 isLock.unlock(); &#125; &#125; //操作数据库，生成订单 @Override @Transactional public void createVoucherOrder(VoucherOrder voucherOrder) &#123; //检查一人一单 Long userId = voucherOrder.getUserId(); int count = query().eq(&quot;user_id&quot;, userId) .eq(&quot;voucher_id&quot;, voucherOrder.getVoucherId()).count(); if (count &gt; 0)&#123; log.error(&quot;用户已经购买过一次&quot;); return; &#125; //减扣库存 //set stock = stock-1 where voucher_id = ? and stock &gt; 0 boolean success = seckillVoucherService.update() .setSql(&quot;stock = stock - 1&quot;) .eq(&quot;voucher_id&quot;, voucherOrder.getVoucherId()) .gt(&quot;stock&quot;, 0) .update(); if (!success)&#123; log.error(&quot;库存不足&quot;); return; &#125; //从数据库生成订单 save(voucherOrder); &#125;&#125; 6.达人探店6.1 发布探店笔记探店笔记类似点评网站的评价，往往是图文结合。对应的表有两个： tb_blog：探店笔记表，包含笔记中的标题、文字、图片等 tb_blog_comments：其他用户对探店笔记的评价 图片上传： 12345678910111213141516171819202122@Slf4j@RestController@RequestMapping(&quot;upload&quot;)public class UploadController &#123; @PostMapping(&quot;blog&quot;) public Result uploadImage(@RequestParam(&quot;file&quot;) MultipartFile image) &#123; try &#123; // 获取原始文件名称 String originalFilename = image.getOriginalFilename(); // 生成新文件名 String fileName = createNewFileName(originalFilename); // 保存文件 image.transferTo(new File(SystemConstants.IMAGE_UPLOAD_DIR, fileName)); // 返回结果 log.debug(&quot;文件上传成功，&#123;&#125;&quot;, fileName); return Result.ok(fileName); &#125; catch (IOException e) &#123; throw new RuntimeException(&quot;文件上传失败&quot;, e); &#125; &#125;&#125; 保存blog： 123456789101112131415161718@RestController@RequestMapping(&quot;/blog&quot;)public class BlogController &#123; @Resource private IBlogService blogService; @PostMapping public Result saveBlog(@RequestBody Blog blog) &#123; // 获取登录用户 UserDTO user = UserHolder.getUser(); blog.setUserId(user.getId()); // 保存探店博文 blogService.save(blog); // 返回id return Result.ok(blog.getId()); &#125;&#125; 6.2 查看探店笔记BlogController： 1234567891011121314151617@RestController@RequestMapping(&quot;/blog&quot;)public class BlogController &#123; @Resource private IBlogService blogService; //获取热点笔记列表 @GetMapping(&quot;/hot&quot;) public Result queryHotBlog(@RequestParam(value = &quot;current&quot;, defaultValue = &quot;1&quot;) Integer current) &#123; return blogService.queryHotBlog(current); &#125; //通过id获取笔记 @GetMapping(&quot;/&#123;id&#125;&quot;) public Result queryBlogById(@PathVariable(&quot;id&quot;) Long id) &#123; return blogService.queryBlogById(id); &#125;&#125; BlogServiceImpl： 12345678910111213141516171819202122232425262728293031323334353637383940@Servicepublic class BlogServiceImpl extends ServiceImpl&lt;BlogMapper, Blog&gt; implements IBlogService &#123; @Resource private IUserService userService; @Override public Result queryHotBlog(Integer current) &#123; // 根据用户查询 Page&lt;Blog&gt; page = query() .orderByDesc(&quot;liked&quot;) .page(new Page&lt;&gt;(current, SystemConstants.MAX_PAGE_SIZE)); // 获取当前页数据 List&lt;Blog&gt; records = page.getRecords(); // 查询用户 records.forEach(blog -&gt;&#123; Long userId = blog.getUserId(); User user = userService.getById(userId); blog.setName(user.getNickName()); blog.setIcon(user.getIcon()); &#125;); return Result.ok(records); &#125; @Override public Result queryBlogById(Long id) &#123; Blog blog = getById(id); if (blog == null)&#123; return Result.fail(&quot;笔记不存在&quot;); &#125; Long userId = blog.getUserId(); User user = userService.getById(userId); blog.setName(user.getNickName()); blog.setIcon(user.getIcon()); return Result.ok(blog); &#125;&#125; 6.3 点赞功能需求： 同一个用户只能点赞一次，再次点击则取消点赞 如果当前用户已经点赞，则点赞按钮高亮显示（前端已实现，判断字段Blog类的isLike属性） 实现步骤： 给Blog类中添加一个isLike字段，标示是否被当前用户点赞 修改点赞功能，利用Redis的set集合判断是否点赞过，未点赞过则点赞数+1，已点赞过则点赞数-1 修改根据id查询Blog的业务，判断当前登录用户是否点赞过，赋值给isLike字段 修改分页查询Blog业务，判断当前登录用户是否点赞过，赋值给isLike字段 修改BlogServiceImpl，添加blog是否已点赞功能： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061@Servicepublic class BlogServiceImpl extends ServiceImpl&lt;BlogMapper, Blog&gt; implements IBlogService &#123; @Resource private IUserService userService; @Resource private StringRedisTemplate stringRedisTemplate; @Override public Result queryHotBlog(Integer current) &#123; // 根据用户查询 Page&lt;Blog&gt; page = query() .orderByDesc(&quot;liked&quot;) .page(new Page&lt;&gt;(current, SystemConstants.MAX_PAGE_SIZE)); // 获取当前页数据 List&lt;Blog&gt; records = page.getRecords(); // 查询用户 records.forEach(blog -&gt;&#123; Long userId = blog.getUserId(); User user = userService.getById(userId); blog.setName(user.getNickName()); blog.setIcon(user.getIcon()); //设置当前blog是否已经点赞 isLikedBlog(blog); &#125;); return Result.ok(records); &#125; @Override public Result queryBlogById(Long id) &#123; Blog blog = getById(id); if (blog == null)&#123; return Result.fail(&quot;笔记不存在&quot;); &#125; Long userId = blog.getUserId(); User user = userService.getById(userId); blog.setName(user.getNickName()); blog.setIcon(user.getIcon()); //设置查询的blog是否已经点赞 isLikedBlog(blog); return Result.ok(blog); &#125; private void isLikedBlog(Blog blog) &#123; UserDTO user = UserHolder.getUser(); //需要判断，没有登录拦截器拦截路径 if (user == null)&#123; return; &#125; Long userId = user.getId(); //从Redis中查询是否点赞过 String key = RedisConstants.BLOG_LIKED_KEY + blog.getId(); Boolean isMember = stringRedisTemplate.opsForSet().isMember(key, userId.toString()); blog.setIsLike(BooleanUtil.isTrue(isMember)); &#125;&#125; 添加点赞功能： 1234567891011121314151617181920212223242526272829303132333435363738394041@Servicepublic class BlogServiceImpl extends ServiceImpl&lt;BlogMapper, Blog&gt; implements IBlogService &#123; @Resource private StringRedisTemplate stringRedisTemplate; @Override public Result likeBlog(Long id) &#123; //不需要判断，因为有登录拦截器拦截路径 Long userId = UserHolder.getUser().getId(); //从Redis中查询是否点赞过 String key = RedisConstants.BLOG_LIKED_KEY + id; Boolean isMember = stringRedisTemplate.opsForSet().isMember(key, userId.toString()); //如果未点赞，则点赞 if (BooleanUtil.isFalse(isMember))&#123; //更新数据库中blog的点赞量 boolean isSuccess = update() .setSql(&quot;liked = liked + 1&quot;) .eq(&quot;id&quot;, id).update(); //如果更新成功 if (isSuccess)&#123; //将userId放入到Redis的set集合中 stringRedisTemplate.opsForSet().add(key, userId.toString()); &#125; &#125; //如果已经点赞，则取消点赞 else &#123; //更新数据库中blog的点赞量 boolean isSuccess = update() .setSql(&quot;liked = liked - 1&quot;) .eq(&quot;id&quot;, id).update(); //如果更新成功 if (isSuccess)&#123; //从Redis的set集合中移除userId stringRedisTemplate.opsForSet().remove(key, userId.toString()); &#125; &#125; return Result.ok(); &#125;&#125; 6.4 点赞排行榜在探店笔记的详情页面，应该把给该笔记点赞的人显示出来，比如最早点赞的TOP5，形成点赞排行榜： 需求：按照点赞时间先后排序，返回Top5的用户 List Set SortedSet 排序方式 按添加顺序排序 无法排序 根据score值排序 唯一性 不唯一 唯一 唯一 查找方式 按索引查找或首尾查找 根据元素查找 根据元素查找 Sortedset的可排序特性，可以用来实现排行榜这样的功能。 添加点赞用户： 1zadd key vlaue score 获取score前五名的用户： 1zscore key 0 4 从set集合改进为SortSet集合： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596@Servicepublic class BlogServiceImpl extends ServiceImpl&lt;BlogMapper, Blog&gt; implements IBlogService &#123; @Resource private IUserService userService; @Resource private StringRedisTemplate stringRedisTemplate; @Override public Result queryHotBlog(Integer current) &#123; // 根据用户查询 Page&lt;Blog&gt; page = query() .orderByDesc(&quot;liked&quot;) .page(new Page&lt;&gt;(current, SystemConstants.MAX_PAGE_SIZE)); // 获取当前页数据 List&lt;Blog&gt; records = page.getRecords(); // 查询用户 records.forEach(blog -&gt;&#123; Long userId = blog.getUserId(); User user = userService.getById(userId); blog.setName(user.getNickName()); blog.setIcon(user.getIcon()); //设置当前blog是否已经点赞 isLikedBlog(blog); &#125;); return Result.ok(records); &#125; @Override public Result queryBlogById(Long id) &#123; Blog blog = getById(id); if (blog == null)&#123; return Result.fail(&quot;笔记不存在&quot;); &#125; Long userId = blog.getUserId(); User user = userService.getById(userId); blog.setName(user.getNickName()); blog.setIcon(user.getIcon()); //设置查询的blog是否已经点赞 isLikedBlog(blog); return Result.ok(blog); &#125; @Override public Result likeBlog(Long id) &#123; //不需要判断，因为有登录拦截器拦截路径 Long userId = UserHolder.getUser().getId(); //从Redis中查询是否点赞过 String key = RedisConstants.BLOG_LIKED_KEY + id; Double score = stringRedisTemplate.opsForZSet().score(key, userId.toString()); //如果未点赞，则点赞 if (score == null)&#123; //更新数据库中blog的点赞量 boolean isSuccess = update() .setSql(&quot;liked = liked + 1&quot;) .eq(&quot;id&quot;, id).update(); //如果更新成功 if (isSuccess)&#123; //将userId放入到Redis的sortedSet集合中,以时间戳为score stringRedisTemplate.opsForZSet().add(key, userId.toString(), System.currentTimeMillis()); &#125; &#125; //如果已经点赞，则取消点赞 else &#123; //更新数据库中blog的点赞量 boolean isSuccess = update() .setSql(&quot;liked = liked - 1&quot;) .eq(&quot;id&quot;, id).update(); //如果更新成功 if (isSuccess)&#123; //从Redis的set集合中移除userId stringRedisTemplate.opsForZSet().remove(key, userId.toString()); &#125; &#125; return Result.ok(); &#125; private void isLikedBlog(Blog blog) &#123; UserDTO user = UserHolder.getUser(); //需要判断，没有登录拦截器拦截路径 if (user == null)&#123; return; &#125; Long userId = user.getId(); //从Redis中查询是否点赞过 String key = RedisConstants.BLOG_LIKED_KEY + blog.getId(); Double score = stringRedisTemplate.opsForZSet().score(key, userId.toString()); blog.setIsLike(score != null); &#125;&#125; 在 BlogServiceImpl 添加点赞排行榜功能： 123456789101112131415161718192021222324252627282930313233343536373839@Servicepublic class BlogServiceImpl extends ServiceImpl&lt;BlogMapper, Blog&gt; implements IBlogService &#123; @Resource private IUserService userService; @Resource private StringRedisTemplate stringRedisTemplate; @Override public Result queryBlogLikes(Long id) &#123; String key = RedisConstants.BLOG_LIKED_KEY + id; //查询点赞前5的userId Set&lt;String&gt; top5 = stringRedisTemplate.opsForZSet().range(key, 0L, 4L); //判断是否为null或者为空，则返回空列表 if (top5 == null || top5.isEmpty()) &#123; return Result.ok(Collections.emptyList()); &#125; //解析userId List&lt;Long&gt; userIds = top5 .stream() .map(Long::valueOf) .collect(Collectors.toList()); String join = StrUtil.join(&quot;,&quot;, userIds); //获取userDto信息，获取的信息应该也要按照先后顺序 //WHERE id IN 5,1 ORDER BY FIELD(id,5,1) List&lt;UserDTO&gt; top5List = userService.query() .in(&quot;id&quot;, userIds) .last(&quot;ORDER BY FIELD(id,&quot; + join + &quot;)&quot;).list() .stream() .map(user -&gt; BeanUtil.copyProperties(user, UserDTO.class)) .collect(Collectors.toList()); return Result.ok(top5List); &#125;&#125; 7.好友关注7.1 关注和取关在探店图文的详情页面中，可以关注发布笔记的作者： 尝试关注用户 是否已经关注用户 需求：基于该表数据结构，实现两个接口： 关注和取关接口 判断是否关注的接口 关注是User之间的关系，是博主与粉丝的关系，数据库中有一张tb_follow表来标示 在FollowServiceImpl中实现关注和取消关注： 1234567891011121314151617181920212223242526272829303132333435@Servicepublic class FollowServiceImpl extends ServiceImpl&lt;FollowMapper, Follow&gt; implements IFollowService &#123; @Override public Result isFollow(Long followUserId) &#123; Long userId = UserHolder.getUser().getId(); //select count(*) from tb_follow where user_id = ? and follow_user_id = ? Integer count = query().eq(&quot;follow_user_id&quot;, followUserId) .eq(&quot;user_id&quot;, userId).count(); //判断是否大于0 return Result.ok(count &gt; 0); &#125; @Override public Result follow(Long followUserId, Boolean isFollow) &#123; Long userId = UserHolder.getUser().getId(); if (BooleanUtil.isTrue(isFollow)) &#123; Follow follow = new Follow(); follow.setUserId(userId); follow.setFollowUserId(followUserId); //保存 save(follow); &#125; else &#123; //delete from tb_follow where userId = ? and follow_user_id = ? remove(new QueryWrapper&lt;Follow&gt;() .eq(&quot;follow_user_id&quot;, followUserId) .eq(&quot;user_id&quot;, userId)); &#125; return Result.ok(); &#125;&#125; 7.2 共同关注需求：利用Redis中恰当的数据结构，实现共同关注功能。在博主个人页面展示出当前用户与博主的共同好友。 Redis中的set集合支持交集，我们需要把之前的关注和取关以及是否已经关注，进行改进 在 FollowServiceImpl中isFollow() 和 follow()方法，将关注列表添加到Redis的set集合中： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061@Servicepublic class FollowServiceImpl extends ServiceImpl&lt;FollowMapper, Follow&gt; implements IFollowService &#123; @Resource private StringRedisTemplate stringRedisTemplate; @Override public Result isFollow(Long followUserId) &#123; Long userId = UserHolder.getUser().getId(); //先从Redis中查找是否已经关注了 Boolean isMember = stringRedisTemplate.opsForSet() .isMember(RedisConstants.FOLLOW_KEY + userId, followUserId.toString()); if (BooleanUtil.isTrue(isMember))&#123; return Result.ok(true); &#125; //select count(*) from tb_follow where user_id = ? and follow_user_id = ? Integer count = query().eq(&quot;follow_user_id&quot;, followUserId) .eq(&quot;user_id&quot;, userId).count(); //判断是否大于0 if (count &gt; 0) &#123; //从Redis添加关注 stringRedisTemplate.opsForSet() .add(RedisConstants.FOLLOW_KEY + userId, followUserId.toString()); &#125; return Result.ok(count &gt; 0); &#125; @Override public Result follow(Long followUserId, Boolean isFollow) &#123; Long userId = UserHolder.getUser().getId(); if (BooleanUtil.isTrue(isFollow)) &#123; Follow follow = new Follow(); follow.setUserId(userId); follow.setFollowUserId(followUserId); //保存 boolean isSuccess = save(follow); if (isSuccess) &#123; //从Redis添加关注 stringRedisTemplate.opsForSet() .add(RedisConstants.FOLLOW_KEY + userId, followUserId.toString()); &#125; &#125; else &#123; //delete from tb_follow where userId = ? and follow_user_id = ? boolean isSuccess = remove(new QueryWrapper&lt;Follow&gt;() .eq(&quot;follow_user_id&quot;, followUserId) .eq(&quot;user_id&quot;, userId)); if (isSuccess) &#123; //从Redis中移除关注 stringRedisTemplate.opsForSet() .remove(RedisConstants.FOLLOW_KEY + userId, followUserId.toString()); &#125; &#125; return Result.ok(); &#125;&#125; 在 FollowServiceImpl 实现共同关注： 12345678910111213141516171819202122232425262728293031323334353637@Servicepublic class FollowServiceImpl extends ServiceImpl&lt;FollowMapper, Follow&gt; implements IFollowService &#123; @Resource private StringRedisTemplate stringRedisTemplate; @Resource private IUserService userService; @Override public Result commonFollow(Long followUserId) &#123; Long userId = UserHolder.getUser().getId(); Set&lt;String&gt; common = stringRedisTemplate.opsForSet().intersect( RedisConstants.FOLLOW_KEY + userId, RedisConstants.FOLLOW_KEY + followUserId); //判断是否为null或者为空，则返回空列表 if (common == null || common.isEmpty()) &#123; return Result.ok(Collections.emptyList()); &#125; //解析userId List&lt;Long&gt; userIds = common .stream() .map(Long::valueOf) .collect(Collectors.toList()); //获取userDto信息 List&lt;UserDTO&gt; commonList = userService.listByIds(userIds) .stream() .map(user -&gt; BeanUtil.copyProperties(user, UserDTO.class)) .collect(Collectors.toList()); return Result.ok(commonList); &#125;&#125; 7.3 关注推送Feed流实现分析关注推送也叫做Feed流，直译为投喂。为用户持续的提供“沉浸式”的体验，通过无限下拉刷新获取新的信息。 Feed流产品有两种常见模式： Timeline：不做内容筛选，简单的按照内容发布时间排序，常用于好友或关注。例如朋友圈 优点：信息全面，不会有缺失。并且实现也相对简单 缺点：信息噪音较多，用户不一定感兴趣，内容获取效率低 智能排序：利用智能算法屏蔽掉违规的、用户不感兴趣的内容。推送用户感兴趣信息来吸引用户 优点：投喂用户感兴趣信息，用户粘度很高，容易沉迷 缺点：如果算法不精准，可能起到反作用 本例中的个人页面，是基于关注的好友来做Feed流，因此采用Timeline的模式。该模式的实现方案有三种： 拉模式：也叫做读扩散。 推模式：也叫做写扩散。 推拉结合：也叫做读写混合，兼具推和拉两种模式的优点。 拉模式 推模式 推拉结合 写比例 低 高 中 读比例 高 低 中 用户读取延迟 高 低 低 实现难度 复杂 简单 很复杂 使用场景 很少使用 用户量少，没有大V 过千万的用户量，有大V 7.4 推送到粉丝收件箱需求： 修改新增探店笔记的业务，在保存blog到数据库的同时，推送到粉丝的收件箱(推模式) 收件箱满足可以根据时间戳排序，必须用Redis的数据结构实现 查询收件箱数据时，可以实现分页查询 Feed流中的数据会不断更新，所以数据的角标也在变化，因此不能采用传统的分页模式。 Feed流的滚动分页： 保存blog到数据库，将blog的id放入粉丝收件箱： 1234567891011121314151617181920212223242526272829303132@Servicepublic class BlogServiceImpl extends ServiceImpl&lt;BlogMapper, Blog&gt; implements IBlogService &#123; @Resource private StringRedisTemplate stringRedisTemplate; @Resource private IFollowService followService; @Override public Result saveBlog(Blog blog) &#123; Long userId = UserHolder.getUser().getId(); blog.setUserId(userId); //将blog保存到数据库 boolean isSuccess = save(blog); if (!isSuccess) &#123; return Result.fail(&quot;新增图书失败&quot;); &#125; //查询到所有粉丝 List&lt;Follow&gt; followList = followService.query().eq(&quot;follow_user_id&quot;, userId).list(); //遍历将blog的id放入到粉丝的Redis的sortedset集合中 for (Follow follow : followList) &#123; Long id = follow.getUserId(); stringRedisTemplate.opsForZSet() .add(RedisConstants.FEED_KEY + id, blog.getId().toString(), System.currentTimeMillis()); &#125; return Result.ok(blog.getId()); &#125;&#125; 7.5 滚动分页查询收件箱思路需求：在个人主页的“关注”卡片中，查询并展示推送的Blog信息： Redis的sortedSet集合的滚动分页命令： 1ZREVRANGEBYSCORE feed:userId max min WITHSCORES LIMIT offset count 分页查询参数： max：上一次查询的最小时间戳 | 当前时间(score) min：最小时间戳，固定为0 offset：上一次的结果中，与最小值一样的元素的个数(偏移量) count：分页大小，固定为3 7.6 实现滚动分页查询封装滚动分页数据： 123456@Datapublic class ScoreResult &#123; private List&lt;?&gt; list; private Integer offset; private Long minTime;&#125; BlogServiceImpl中实现获取推文： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384@Servicepublic class BlogServiceImpl extends ServiceImpl&lt;BlogMapper, Blog&gt; implements IBlogService &#123; @Resource private IUserService userService; @Resource private StringRedisTemplate stringRedisTemplate; @Override public Result queryBlogOfFollow(Integer offset, Long maxTime) &#123; Long userId = UserHolder.getUser().getId(); //获取滚动分页数据 Set&lt;ZSetOperations.TypedTuple&lt;String&gt;&gt; typedTuples = stringRedisTemplate.opsForZSet() .reverseRangeByScoreWithScores( RedisConstants.FEED_KEY + userId, 0, maxTime, offset, 3); //判断是否为null或者为空，则返回空列表 if (typedTuples == null || typedTuples.isEmpty()) &#123; return Result.ok(); &#125; //解析出blogId列表、minTime最小时间戳、offset偏移量 List&lt;Long&gt; blogIds = new ArrayList&lt;&gt;(typedTuples.size()); long minTime = 0; offset = 1; for (ZSetOperations.TypedTuple&lt;String&gt; typedTuple : typedTuples) &#123; String blogIdStr = typedTuple.getValue(); blogIds.add(Long.valueOf(blogIdStr)); long time = typedTuple.getScore().longValue(); if (time == minTime)&#123; offset++; &#125; else&#123; minTime = time; offset = 1; &#125; &#125; String join = StrUtil.join(&quot;,&quot;, blogIds); //根据blogId，获得按照顺序的blogList列表 List&lt;Blog&gt; blogList = query() .in(&quot;id&quot;, blogIds) .last(&quot;ORDER BY FIELD(id,&quot; + join + &quot;)&quot;).list(); //添加是否已点赞，以及名字、头像 for (Blog blog : blogList) &#123; queryUserToBlog(blog); isLikedBlog(blog); &#125; //封装数据，返回 ScoreResult scoreResult = new ScoreResult(); scoreResult.setList(blogList); scoreResult.setOffset(offset); scoreResult.setMinTime(minTime); return Result.ok(scoreResult); &#125; private void isLikedBlog(Blog blog) &#123; UserDTO user = UserHolder.getUser(); //需要判断，没有登录拦截器拦截路径 if (user == null)&#123; return; &#125; Long userId = user.getId(); //从Redis中查询是否点赞过 String key = RedisConstants.BLOG_LIKED_KEY + blog.getId(); Double score = stringRedisTemplate.opsForZSet().score(key, userId.toString()); blog.setIsLike(score != null); &#125; private void queryUserToBlog(Blog blog) &#123; Long userId = blog.getUserId(); User user = userService.getById(userId); blog.setName(user.getNickName()); blog.setIcon(user.getIcon()); &#125;&#125; 8.附近的商户8.1 GEO数据结构GEO就是Geolocation的简写形式，代表地理坐标。 Redis在3.2版本中加入了对GEO的支持，允许存储地理坐标信息，帮助我们根据经纬度来检索数据。常见的命令有： GEOADD：添加一个地理空间信息，包含：经度(longitude)、纬度(latitude)、值(member) GEODIST：计算指定的两个点之间的距离并返回 GEOHASH：将指定member的坐标转为hash字符串形式并返回 GEOPOS：返回指定member的坐标 GEORADIUS：指定圆心、半径，找到该圆内包含的所有member，并按照与圆心之间的距离排序后返回。6.2以后已废弃 GEOSEARCH：在指定范围内搜索member,并按照与指定点之间的距离排序后返回。范围可以是圆形或矩形。6.2.新功能 GEOSEARCHSTORE：与GEOSEARCH功能一致，不过可以把结果存储到一个指定的key。6.2.新功能 练习Redis的GEO功能需求： 添加下面几条数据： 北京南站(116.378248, 39.865275) 北京站(116.42803, 39.903738) 北京西站(116.322287, 39.893729) 计算北京西站到北京站的距离 搜索天安门(116.397904, 39.909005)附近10km内的所有火车站，并按照距离升序排序 添加数据： 1geoadd g1 116.378248 39.865275 bjnz 116.42803 39.903738 bjz 116.322287 39.893729 bjxz 计算北京西站到北京站的距离(km)： 1geodist g1 bjxz bjz km 搜索天安门附近10km内的所有火车站，并按照距离升序排序： 1geosearch g1 fromlonlat 116.397904 39.909005 byradius 10 km withdist 8.2 导入店铺数据到GEO在首页中点击某个频道，即可看到频道下的商户： 按照商户类型做分组，类型相同的商户作为同一组，以typeld为key存入同一个GEO集合中即可 KEY VALUE SCORE shop:geo:1 火锅 … 烧烤 … shop:geo:2 KTV1 … KTV2 … 从数据库中获取shop列表，以typeId为key，商家的id为value，存入经纬度： 123456789101112131415161718192021222324@Testvoid testQueryShop2Redis() &#123; List&lt;Shop&gt; list = shopService.list(); //以typeId将shop分组 Map&lt;Long, List&lt;Shop&gt;&gt; map = list.stream().collect(Collectors.groupingBy(Shop::getTypeId)); //分批完成写入Redis for (Map.Entry&lt;Long, List&lt;Shop&gt;&gt; entry : map.entrySet()) &#123; //获取类型d Long typeId = entry.getKey(); String key = RedisConstants.SHOP_GEO_KEY + typeId; //获取同类型的店铺的集合 List&lt;Shop&gt; value = entry.getValue(); List&lt;RedisGeoCommands.GeoLocation&lt;String&gt;&gt; locations = new ArrayList&lt;&gt;(value.size()); //写入redis for (Shop shop : value) &#123; locations.add(new RedisGeoCommands.GeoLocation&lt;&gt;( shop.getId().toString(), new Point(shop.getX(),shop.getY())) ); &#125; stringRedisTemplate.opsForGeo().add(key, locations); &#125;&#125; 8.3 实现附近商户功能SpringDataRedis的2.3.9版本并不支持Redis6.2提供的GEOSEARCH命令，因此我们需要提示其版本，修改自己的POM文件，内容如下： 1234567891011121314151617181920212223242526&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt; &lt;!-- 排除redis老版本依赖 --&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.springframework.data&lt;/groupId&gt; &lt;artifactId&gt;spring-data-redis&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;exclusion&gt; &lt;groupId&gt;io.lettuce&lt;/groupId&gt; &lt;artifactId&gt;lettuce-core&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt;&lt;/dependency&gt;&lt;!-- 添加redis新版本依赖 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.data&lt;/groupId&gt; &lt;artifactId&gt;spring-data-redis&lt;/artifactId&gt; &lt;version&gt;2.6.2&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;io.lettuce&lt;/groupId&gt; &lt;artifactId&gt;lettuce-core&lt;/artifactId&gt; &lt;version&gt;6.1.6.RELEASE&lt;/version&gt;&lt;/dependency&gt; 在 ShopServiceImpl的 queryShopByType()方法 实现附近商户功能： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263@Servicepublic class ShopServiceImpl extends ServiceImpl&lt;ShopMapper, Shop&gt; implements IShopService &#123; @Resource private StringRedisTemplate stringRedisTemplate; @Override public Result queryShopByType(Integer typeId, Integer current, Double x, Double y) &#123; //如果坐标为null，则直接返回数据 if (x == null || y == null) &#123; Page&lt;Shop&gt; page = query() .eq(&quot;type_id&quot;, typeId) .page(new Page&lt;Shop&gt;(current, SystemConstants.DEFAULT_PAGE_SIZE)); return Result.ok(page.getRecords()); &#125; int from = (current-1) * SystemConstants.DEFAULT_PAGE_SIZE; int end = current * SystemConstants.DEFAULT_PAGE_SIZE; GeoResults&lt;RedisGeoCommands.GeoLocation&lt;String&gt;&gt; results = stringRedisTemplate.opsForGeo() .search( RedisConstants.SHOP_GEO_KEY + typeId, GeoReference.fromCoordinate(x, y), new Distance(5 * 1000), RedisGeoCommands.GeoSearchCommandArgs.newGeoSearchArgs() .includeDistance() .limit(end));//截取0~end个数据 //如果为空的情况 if (results == null) &#123; return Result.ok(Collections.emptyList()); &#125; List&lt;GeoResult&lt;RedisGeoCommands.GeoLocation&lt;String&gt;&gt;&gt; content = results.getContent(); int size = content.size(); //截取的数据有可能为空 if (from &gt;= size)&#123; return Result.ok(Collections.emptyList()); &#125; //截取from~end的数据 List&lt;Long&gt; shopIds = new ArrayList&lt;&gt;(size); List&lt;Double&gt; distances = new ArrayList&lt;&gt;(size); content.stream().skip(from).forEach(result -&gt; &#123; //获取shopId String shopIdStr = result.getContent().getName(); shopIds.add(Long.valueOf(shopIdStr)); //获取距离 double distance = result.getDistance().getValue(); distances.add(distance); &#125;); String join = StrUtil.join(&quot;,&quot;, shopIds); //根据shopId，获得按照顺序的shopList列表 List&lt;Shop&gt; shopList = query() .in(&quot;id&quot;, shopIds) .last(&quot;ORDER BY FIELD(id,&quot; + join + &quot;)&quot;).list(); //将距离放入shop中 for (int i = 0; i &lt; shopList.size(); i++) &#123; shopList.get(i).setDistance(distances.get(i)); &#125; return Result.ok(shopList); &#125;&#125; 9.用户签到9.1 BitMap功能用tb_user_sign表来存储用户签到信息 我们按月来统计用户签到信息，签到记录为1，未签到则记录为0. 把每一个bit位对应当月的每一天，形成了映射关系。用0和1标示业务状态，这种思路就称为位图(BitMap)。 Redis中是利用string类型数据结构实现BitMap，因此最大上限是512M，转换为bit则是$2^{32}$个bit位。 BitMap的操作命令有： SETBIT：向指定位置(offset)存入一个0或1 GETBIT：获取指定位置(offset)的bit值 BITCOUNT：统计BitMap中值为1的bit位的数量 BITFIELD：操作(查询、修改、自增)BitMap中bit数组中的指定位置(offset)的值 BITFIELD_RO：获取BitMap中bit数组，并以十进制形式返回 BTOP：将多个BitMap的结果做位运算(与、或、异或) BITPOS：查找bit数组中指定范围内第一个0或1出现的位置 9.2 实现签到功能1234567891011121314151617181920212223242526@Slf4j@Servicepublic class UserServiceImpl extends ServiceImpl&lt;UserMapper, User&gt; implements IUserService &#123; @Resource private StringRedisTemplate stringRedisTemplate; @Override public Result sign() &#123; Long userId = UserHolder.getUser().getId(); LocalDateTime now = LocalDateTime.now(); //获取年月 String format = now.format(DateTimeFormatter.ofPattern(&quot;:yyyyMM&quot;)); String key = RedisConstants.USER_SIGN_KEY + userId + format; //获取本月的第几天 int day = now.getDayOfMonth(); //判断今天是否已经签到过 Boolean isSuccess = stringRedisTemplate.opsForValue().getBit(key, day - 1); if (BooleanUtil.isTrue(isSuccess))&#123; return Result.fail(&quot;你今天已经签到过了&quot;); &#125; //签到 stringRedisTemplate.opsForValue().setBit(key, day-1, true); return Result.ok(); &#125;&#125; 9.3 统计连续签到连续签到天数：从最后一次签到开始向前统计，直到遇到第一次未签到为止，计算总的签到次数，就是连续签到天数。 实现连续签到统计功能： 1234567891011121314151617181920212223242526272829303132333435363738394041424344@Slf4j@Servicepublic class UserServiceImpl extends ServiceImpl&lt;UserMapper, User&gt; implements IUserService &#123; @Resource private StringRedisTemplate stringRedisTemplate; @Override public Result signCount() &#123; Long userId = UserHolder.getUser().getId(); LocalDateTime now = LocalDateTime.now(); //获取年月 String format = now.format(DateTimeFormatter.ofPattern(&quot;:yyyyMM&quot;)); String key = RedisConstants.USER_SIGN_KEY + userId + format; //获取本月的第几天 int day = now.getDayOfMonth(); //获取本月截至今天为止的所有的签到记录，返回的是一个十进制的数字 //BITFIELD sign:userId:yyyyMM GET day 0 List&lt;Long&gt; values = stringRedisTemplate.opsForValue() .bitField( key, BitFieldSubCommands.create() .get(BitFieldSubCommands.BitFieldType.unsigned(day)) .valueAt(0)); if (values == null || values.isEmpty()) &#123; return Result.ok(0); &#125; //获取bit Long num = values.get(0); if (num == null) &#123; return Result.ok(0); &#125; int count = 0; //从后往前，如果为最后一位为0，则退出循环 while ((num &amp; 1) != 0) &#123; //不为0，说明已签到 count++; //num无符号右移1位 num &gt;&gt;&gt;= 1; &#125; return Result.ok(count); &#125;&#125; 10.UV统计10.1 HyperLogLog的用法UV：全称Unique Visitor，也叫独立访客量，是指通过互联网访问、浏览这个网页的自然人。1天内同一个用户多次访问该网站，只记录1次。 PV：全称Page View，也叫页面访问量或点击量，用户每访问网站的一个页面，记录1次PV,用户多次打开页面，则记录多次PV。往往用来衡量网站的流量。 UV统计在服务端做会比较麻烦，因为要判断该用户是否已经统计过了，需要将统计过的用户信息保存。但是如果每个访问的用户都保存到Redis中，数据量会非常恐怖。 Hyperloglog(HLL)是从Loglog算法派生的概率算法，用于确定非常大的集合的基数，而不需要存储其所有值。 相关算法原理大家可以参考：https://juejin.cn/post/6844903785744056333#heading-0 Redis中的HLL是基于string结构实现的，单个HLL的内存永远小于16kb，内存占用低的令人发指！作为代价，其测量结果是概率性的，有小于0.81%的误差。不过对于UV统计来说，这完全可以忽略。 添加数据： 1pfadd h1 e1 e2 e3 统计UV： 1pfcount h1 10.2 测试百万数据的统计我们直接利用单元测试，向HyperLogLog中添加100万条数据，看看内存占用和统计效果如何： 1234567891011121314151617181920@Testvoid testHyperLogLog() &#123; //准岛数组，装用户数掘 String[] users = new String[1000]; //数组角标 int index = 0; for(int i = 1; i &lt;= 100000; i++)&#123; //赋值 users[index++] = &quot;user_&quot; + i; //每1000条发送一次 if(i%1000 == 0) &#123; index = 0; stringRedisTemplate.opsForHyperLogLog().add(&quot;hll1&quot;,users); &#125; &#125; //统计数量 Long size = stringRedisTemplate.opsForHyperLogLog().size(&quot;hll1&quot;); System.out.println(&quot;size = &quot; + size);&#125; 输出：size &#x3D; 99839","categories":[{"name":"Java","slug":"Java","permalink":"http://example.com/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"},{"name":"数据库","slug":"数据库","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}]},{"title":"","slug":"Java/MyBatis-Plus框架","date":"2022-08-06T11:11:16.302Z","updated":"2023-02-03T03:47:26.590Z","comments":true,"path":"2022/08/06/Java/MyBatis-Plus框架/","link":"","permalink":"http://example.com/2022/08/06/Java/MyBatis-Plus%E6%A1%86%E6%9E%B6/","excerpt":"","text":"1.初识MyBatis-PlusMyBatis-Plus是MyBatis的增强工具，在MyBatis的基础上只做增强不做改变，为了简化开发，提高效率而生 官网：MyBatis-Plus 特性： 无入侵：只做增强不做改变，导入它不会对现有工程产生影响。 损耗小：启动即会自动注入基本CRUD，性能基本不损耗，直接面向对象操作 强大的CRUD操作：内置通用Mapper、通用Service，仅仅通过少量配置即可实现单表大部分CRUD操作，更有强大的条件构造器，满足各类使用需求 支持Lambda形式调用：通过Lambda表达式，方便的编写各类查询条件，无需再担心字段写错 支持多种数据库：支持MySQL、MariaDB、 Oracle、 DB2、 H2、 HSQL、 SQLite、 Postgre、SQL Server等多种数据库 支持主键自动生成：支持多达4种主键策略(内含分布式唯一ID生成器- Sequence)，可自由配置，完美解决主键问题 支持XML热加载：Mapper对应的XML支持热加载，对于简单的CRUD操作，甚至可以无XML启动 支持ActiveRecord模式：支持ActiveRecord形式调用，实体类只需继承Model类即可进行强大的CRUD操作 支持自定义全局通用操作：支持全局通用方法注入(Write once，use anywhere) 支持关键词自动转义：支持数据库关键词( order、 key…. )自动转义，还可自定义关键词 内置代码生成器：采用代码或者Maven插件可快速生成Mapper、 Model、Service、Controller层代码，支持模板引擎，更有超多自定义配置等您来使用 内置分页插件：基于MyBatis物理分页，开发者无需关心具体操作，配置好插件之后，写分页等同于普通List查询 内置性能分析插件：可输出Sql语句以及其执行时间，建议开发测试时启用该功能，能快速揪出慢查询 内置全局拦截插件：提供全表delete、update 操作智能分析阻断，也可自定义拦截规则，预防误操作 内置Sql注入剥离器：支持Sql注入剥离，有效预防Sql注入攻击 2.创建数据库创建数据库： 数据名：mp 字符集：utf-8 创建表： 12345678910-- 创建测试表CREATE TABLE `tb_user` (`id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT &#x27;主键ID&#x27;,`user_name` varchar(20) NOT NULL COMMENT &#x27;用户名&#x27;,`password` varchar(20) NOT NULL COMMENT &#x27;密码&#x27;,`name` varchar(30) DEFAULT NULL COMMENT &#x27;姓名&#x27;,`age` int(11) DEFAULT NULL COMMENT &#x27;年龄&#x27;,`email` varchar(50) DEFAULT NULL COMMENT &#x27;邮箱&#x27;,PRIMARY KEY (`id`)) ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8; 3.Mybatis-Plus快速入门导入所有依赖： 12345678910111213141516171819202122232425262728293031323334353637383940&lt;dependencies&gt; &lt;!-- mybatis-plus插件依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus&lt;/artifactId&gt; &lt;version&gt;3.1.1&lt;/version&gt; &lt;/dependency&gt; &lt;!-- mysql --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.47&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 数据库连接池 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.1.16&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 简化bean代码工具 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;version&gt;1.18.24&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 单元测试插件依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- 日志插件依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt; &lt;version&gt;1.7.36&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; resourses资源包中，新建log4j.properties文件： 1234log4j.rootLogger=DEBUG,A1log4j.appender.A1=org.apache.log4j.ConsoleAppenderlog4j.appender.A1.layout=org.apache.log4j.PatternLayoutlog4j.appender.A1.layout.ConversionPattern=[%t] [%c]-[%p] %m%n 创建User实体类： 1234567891011@Data //生成getter和setterd方法@NoArgsConstructor // 生成无参构造函数@AllArgsConstructor // 生成有参构造函数public class User &#123; private Long id; private String userName; private String password; private String name; private String age; private String email;&#125; 项目结构： 3.1 Mybatis实现查询在resources资源包中，创建mybatis-config.xml文件： 12345678910111213141516171819202122&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt; &lt;environments default=&quot;development&quot;&gt; &lt;environment id=&quot;development&quot;&gt; &lt;transactionManager type=&quot;JDBC&quot;/&gt; &lt;dataSource type=&quot;POOLED&quot;&gt; &lt;property name=&quot;driver&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/mp?useUnicode=true&amp;amp;characterEncoding=utf8&amp;amp;autoReconnect=true&amp;amp;allowMultiQueries=true&amp;amp;useSSL=false&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;123456&quot;/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;mappers&gt; &lt;mapper resource=&quot;UserMapper.xml&quot;/&gt; &lt;/mappers&gt;&lt;/configuration&gt; 创建UserMapper接口： 1234public interface UserMapper &#123; List&lt;User&gt; findAll(); &#125; 在resources资源包创建UserMapper.xml文件:： namespace为UserMapper接口的位置 id为UserMapper中的方法名 resultType为实体类的位置 123456789&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.mybatisp.mapper.UserMapper&quot;&gt; &lt;select id=&quot;findAll&quot; resultType=&quot;com.mybatisp.pojo.User&quot;&gt; select * from tb_user &lt;/select&gt;&lt;/mapper&gt; 单元测试： 1234567891011@Testpublic void testFindAll() throws IOException &#123; InputStream is = Resources.getResourceAsStream(&quot;mybatis-config.xml&quot;); SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(is); SqlSession sqlSession = sqlSessionFactory.openSession(); UserMapper userMapper = sqlSession.getMapper(UserMapper.class); System.out.println(userMapper.findAll());&#125; 控制台打印： 1[User(id=1, userName=null, password=123456, name=张三, age=18, email=test1@itcast.cn), User(id=2, userName=null, password=123456, name=李四, age=20, email=test2@itcast.cn), User(id=3, userName=null, password=123456, name=王五, age=28, email=test3@itcast.cn), User(id=4, userName=null, password=123456, name=赵六, age=21, email=test4@itcast.cn), User(id=5, userName=null, password=123456, name=孙七, age=24, email=test5@itcast.cn)] 3.2 Mybatis+MP实现查询将UserMapper继承BaseMapper，将拥有了BaseMapper中的所有方法： 1234public interface UserMapper extends BaseMapper&lt;User&gt; &#123; List&lt;User&gt; findAll();&#125; 单元测试： 123456789101112@Testpublic void testFindAll2() throws IOException &#123; InputStream is = Resources.getResourceAsStream(&quot;mybatis-config.xml&quot;); //这里使用的是MP中的MybatisSqlSessionFactoryBuilder SqlSessionFactory sqlSessionFactory = new MybatisSqlSessionFactoryBuilder().build(is); SqlSession sqlSession = sqlSessionFactory.openSession(); UserMapper userMapper = sqlSession.getMapper(UserMapper.class); System.out.println(userMapper.findAll()); &#125; 运行成功！ 改用BaseMapper中定义的方法查询所有： 1234567891011@Testpublic void testFindAll2() throws IOException &#123; InputStream is = Resources.getResourceAsStream(&quot;mybatis-config.xml&quot;); SqlSessionFactory sqlSessionFactory = new MybatisSqlSessionFactoryBuilder().build(is); SqlSession sqlSession = sqlSessionFactory.openSession(); UserMapper userMapper = sqlSession.getMapper(UserMapper.class); //System.out.println(userMapper.findAll()); System.out.println(userMapper.selectList(null));&#125; 报错： 1Cause: com.mysql.jdbc.exceptions.jdbc4.MySQLSyntaxErrorException: Table &#x27;mp.user&#x27; doesn&#x27;t exist 报错原因是没有找到user表，因为数据库中的表名为tb_user所以导致没有找到该表。需要指定表： 在User实体类中与数据库中的表进行映射： 123456789101112@Data //生成getter和setter方法@NoArgsConstructor // 生成无参构造函数@AllArgsConstructor // 生成有参构造函数@TableName(&quot;tb_user&quot;) //指定为tb_user表public class User &#123; private Long id; private String userName; private String password; private String name; private String age; private String email;&#125; 再次运行，成功！ 3.3 Spring+Mybatis+MP新建项目： 导入依赖： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;5.2.10.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;5.2.10.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;5.2.10.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus&lt;/artifactId&gt; &lt;version&gt;3.1.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.47&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.1.16&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;version&gt;1.18.24&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt; &lt;version&gt;1.7.36&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 在resources资源包中创建log4j.properties文件： 1234log4j.rootLogger=DEBUG,A1log4j.appender.A1=org.apache.log4j.ConsoleAppenderlog4j.appender.A1.layout=org.apache.log4j.PatternLayoutlog4j.appender.A1.layout.ConversionPattern=[%t] [%c]-[%p] %m%n 在resources资源包中创建jdbc.properties文件： 1234jdbc.driver=com.mysql.jdbc.driverjdbc.url=jdbc:mysql://localhost:3306/mp?useUnicode=true&amp;characterEncoding=utf8&amp;autoReconnect=true&amp;allowMultiQueries=true&amp;useSSL=falsejdbc.username=rootjdbc.password=123456 在resources资源包中创建applicationContext.xml文件 1234567891011121314151617181920212223242526272829&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beanshttp://www.springframework.org/schema/beans/spring-beans.xsdhttp://www.springframework.org/schema/contexthttp://www.springframework.org/schema/context/spring-context.xsd&quot;&gt; &lt;context:property-placeholder location=&quot;classpath*:*.properties&quot;/&gt; &lt;!-- 定义数据源 --&gt; &lt;bean id=&quot;dataSource&quot; class=&quot;com.alibaba.druid.pool.DruidDataSource&quot; destroy-method=&quot;close&quot;&gt; &lt;property name=&quot;url&quot; value=&quot;$&#123;jdbc.url&#125;&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;$&#123;jdbc.username&#125;&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot;/&gt; &lt;property name=&quot;driverClassName&quot; value=&quot;$&#123;jdbc.driver&#125;&quot;/&gt; &lt;property name=&quot;maxActive&quot; value=&quot;10&quot;/&gt; &lt;property name=&quot;minIdle&quot; value=&quot;5&quot;/&gt; &lt;/bean&gt; &lt;!--这里使用MP提供的sqlSessionFactory，完成了Spring与MP的整合--&gt; &lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;com.baomidou.mybatisplus.extension.spring.MybatisSqlSessionFactoryBean&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt; &lt;/bean&gt; &lt;!--扫描mapper接口，使用的依然是Mybatis原生的扫描器--&gt; &lt;bean class=&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt; &lt;property name=&quot;basePackage&quot; value=&quot;com.mybatisp.mapper&quot;/&gt; &lt;/bean&gt;&lt;/beans&gt; 创建User实体类： 123456789101112@Data //生成getter和setter方法@NoArgsConstructor // 生成无参构造函数@AllArgsConstructor // 生成有参构造函数@TableName(&quot;tb_user&quot;)public class User &#123; private Long id; private String userName; private String password; private String name; private String age; private String email;&#125; 创建UerMapper接口： 12public interface UserMapper extends BaseMapper&lt;User&gt; &#123;&#125; 单元测试： 1234567891011@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(locations = &quot;classpath:applicationContext.xml&quot;)public class MybatisTest &#123; @Autowired private UserMapper userMapper; @Test public void testSelectList()&#123; System.out.println(userMapper.selectList(null)); &#125;&#125; 运行成功！ 3.4 SpringBoot+Mybaits+MPxml版 项目结构： 创建springboot项目自动导入依赖： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt; &lt;version&gt;3.4.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.2.11&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.junit.vintage&lt;/groupId&gt; &lt;artifactId&gt;junit-vintage-engine&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt;&lt;/dependencies&gt;&lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-dependencies&lt;/artifactId&gt; &lt;version&gt;$&#123;spring-boot.version&#125;&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/dependencyManagement&gt;&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;version&gt;3.8.1&lt;/version&gt; &lt;configuration&gt; &lt;source&gt;1.8&lt;/source&gt; &lt;target&gt;1.8&lt;/target&gt; &lt;encoding&gt;UTF-8&lt;/encoding&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;version&gt;2.3.7.RELEASE&lt;/version&gt; &lt;configuration&gt; &lt;mainClass&gt;com.mybatisp.SpringbootMpApplication&lt;/mainClass&gt; &lt;/configuration&gt; &lt;executions&gt; &lt;execution&gt; &lt;id&gt;repackage&lt;/id&gt; &lt;goals&gt; &lt;goal&gt;repackage&lt;/goal&gt; &lt;/goals&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; application.yml： 1234567spring: datasource: druid: driver-class-name: com.mysql.cj.jdbc.Driver url: jdbc:mysql://localhost:3306/mp?serverTimezone=UTC username: root password: 123456 User实体类： 123456789101112@Data //生成getter和setter方法@NoArgsConstructor // 生成无参构造函数@AllArgsConstructor // 生成有参构造函数@TableName(&quot;tb_user&quot;)public class User &#123; private Long id; private String userName; private String password; private String name; private String age; private String email;&#125; UserMapper接口： 123@Mapperpublic interface UserMapper extends BaseMapper&lt;User&gt; &#123;&#125; 单元测试： 12345678910@SpringBootTestpublic class UserMapperTest &#123; @Autowired private UserMapper userMapper; @Test public void findAll() &#123; System.out.println(userMapper.selectList(null)); &#125;&#125; 运行成功！ 9.代码生成器创建Springboot项目： 添加下面的依赖： 1234567891011&lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-generator&lt;/artifactId&gt; &lt;version&gt;3.5.2&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.freemarker&lt;/groupId&gt; &lt;artifactId&gt;freemarker&lt;/artifactId&gt; &lt;version&gt;2.3.31&lt;/version&gt;&lt;/dependency&gt; 创建一个测试类： 12345678910111213141516171819202122232425public class FastAutoGeneratorTest &#123; public static void main(String[] args) &#123; FastAutoGenerator.create(&quot;jdbc:mysql://localhost:3306/mp?serverTimezone=UTC&quot;, &quot;root&quot;, &quot;123456&quot;) .globalConfig(builder -&gt; &#123; builder.author(&quot;baomidou&quot;) // 设置作者 //.enableSwagger() // 开启 swagger 模式 .fileOverride() // 覆盖已生成文件 .outputDir(&quot;E:\\\\Java_Web\\\\Mybatis-p\\\\mp_04_generator\\\\src\\\\main\\\\java&quot;); // 指定输出目录 &#125;) .packageConfig(builder -&gt; &#123; builder.parent(&quot;com&quot;) // 设置父包名 .moduleName(&quot;mybatisp&quot;) // 设置父包模块名 .pathInfo(Collections.singletonMap(OutputFile.xml, &quot;E:\\\\Java_Web\\\\Mybatis-p\\\\mp_04_generator\\\\src\\\\main\\\\resources\\\\mapper&quot;)); // 设置mapperXml生成路径 &#125;) .strategyConfig(builder -&gt; &#123; builder.addInclude(&quot;tb_user&quot;) // 设置需要生成的表名 .addTablePrefix(&quot;tb_&quot;, &quot;c_&quot;); // 设置过滤表前缀 &#125;) .templateEngine(new FreemarkerTemplateEngine()) // 使用Freemarker引擎模板，默认的是Velocity引擎模板 .execute(); &#125;&#125; 控制台打印： 12345608:57:51.095 [main] DEBUG com.baomidou.mybatisplus.generator.AutoGenerator - ==========================准备生成文件...==========================08:57:51.521 [main] DEBUG com.baomidou.mybatisplus.generator.config.querys.MySqlQuery - 执行SQL:show table status WHERE 1=1 AND NAME IN (&#x27;tb_user&#x27;)08:57:51.538 [main] DEBUG com.baomidou.mybatisplus.generator.config.querys.MySqlQuery - 返回记录数:1,耗时(ms):1608:57:51.550 [main] DEBUG com.baomidou.mybatisplus.generator.config.querys.MySqlQuery - 执行SQL:show full fields from `tb_user`08:57:51.559 [main] DEBUG com.baomidou.mybatisplus.generator.config.querys.MySqlQuery - 返回记录数:6,耗时(ms):908:57:51.652 [main] DEBUG com.baomidou.mybatisplus.generator.AutoGenerator - ==========================文件生成完成！！！========================== 以下为生成的文件：","categories":[],"tags":[]},{"title":"MongoDB的学习笔记","slug":"Java/MongoDB_","date":"2022-08-06T11:11:16.300Z","updated":"2023-01-31T14:10:00.534Z","comments":true,"path":"2022/08/06/Java/MongoDB_/","link":"","permalink":"http://example.com/2022/08/06/Java/MongoDB_/","excerpt":"","text":"未完待续 1.MongoDB相关概念业务场景 传统的关系型数据库(如：MySQL)，在数据操作的“三高”需求以及应对Web2.0网站需求面前，显得力不从心。 “三高”需求： High performance：对数据库高并发读写的需求 Huge Storage：对海量数据的高效率存储和访问的需求。 High Scalability &amp;&amp; High Availability：对数据库的高可扩展性和高可用性的需求。 而MongoDB可应对”三高”需求，貝体的应用场景如： 社交场景：使用MongoDB 存储存储用户信息，以及用户发表的朋友圖信息，通过地理位置素引1实现附近的人、地点等功能。 游戏场景：使用 MongoDB 存储游戏用户信息，用户的装备、积分等直接以内嵌文档的形式存储，方便查询高效率存储和访问。 物流场员：使用 MongoDB 存储订单信息，订单状态在运送过程中会不断更新，以MongODB 内嵌数组的开式来存储，一次查询就能将订单所有的变更读取出来。 物联网场景：使用MongoDB 存储所有接入的智能设备信息，以及设备汇报的日志信息，并对这些信息进行多维度的分析。 视频直播：使用 MongoDB 存储用户信息、点赞互动信息等。 这些应用场景，对数据操作方面的共同特点是： 数据量大 写入操作频繁(读写很频繁) 价值较低的数据，对事务性要求不高(缺点) 对于这样的数据，我们更适合使用MongoDB来实现数据的存储 何时选择MongoDB？ 在架构选型上，除了上述的三个特点外，如果你还犹豫是否要选择它？可以考忠以下的一些问题： 应用不需要車务及复杂 ioin 支持 新应用，需求会变，数据模型无法确定，想快速迭代开发 应用需要2000-3000以上的读写OPS（更高也可以） 应用需要TB甚至 PB级别数据存储 应用发展迅速，需要能快速水平扩展 应用要求存储的数据不天失 应用需要99.999%高可用 应用需要大量的地理位置查询、文本查询 如果上述有1个符合，可以考虑MongoDB， 2个及以上的符合，选择MongoDB 绝不会后悔。 数据库：articledb 专栏文章评论(表)：comment 字段名称 字段含义 字段类型 备注 _id ID ObjectId或String Mongo的主键的字段 articleid 文章ID String content 评论内容 String userid 评论人ID String nickname 评论人昵称 String createdatetime 评论的日期时间 Date likenum 点赞数 Int32 replynum 回复数 Int32 state 状态 String 0：不可见1：可见 parentid 上级ID String 如果为0表示文章的顶级评论 2.MongoDB的相关命令2.1 数据库的创建与删除 命令 解释 例子 use 数据库名 选择数据库，如果不存在则创建 use articledb show dbs或show databases 查看所有数据库 db 查看当前正在使用的数据库 db.dropDatabase() 删除当前正在的使用的数据库 db.createCollection(name)name: 要创建的集合名称 显示创建集合(了解) db.createCollection(“mycollection”) show collections或show tables 查看当前数据库中的表 db.集合.drop() 删除当前正在的使用的数据库中的集合 db.mycollection.drop() 文档(document)的数据结构与JSON基本一致，所有存储在集合中的数据都是BSON格式 2.2 文档的插入1234567db.collection.insert( &lt;document or array of documents&gt;, &#123; writeConcern: &lt;document&gt;, ordered: &lt;boolean&gt; &#125;) 单个文档插入： 使用insert()或save()方法插入： db.collection.insert(document) 示例： 向comment集合中插入一条数据： 12345678db.comment.insert(&#123; &quot;articleid&quot;:&quot;100000&quot;, &quot;content&quot;:&quot;今天天气真好，阳光明媚&quot;, &quot;userid&quot;:&quot;1001&quot;, &quot;nickname&quot;:&quot;Tom&quot;, &quot;createdatetime&quot;:new Date(), &quot;likenum&quot;:NumberInt(10), &quot;state&quot;:null&#125;) comment集合如果不存在，则会隐式创建 。 mongo中的数字，默认情况下是double类型，如果要存整型，必须使用函数NumberInt(整型数字)，否则取出来就有问题了。 插入当前日期使用 new Date() 插入的数据没有指定 _id ，会自动生成主键值 如果某字段没值，可以赋值为null，或不写该字段。 如果出现：WriteResult(&#123; &quot;nInserted&quot; : 1 &#125;)，说明插入成功。 多条文档插入： db.comment.insertMany([document1,document2,…]) 示例： 向comment集合中插入多条数据： 123456789101112131415161718db.comment.insertMany([ &#123;&quot;_id&quot;:&quot;1&quot;, &quot;articleid&quot;:&quot;100001&quot;, &quot;content&quot;:&quot;我们不应该把清晨浪费在手机上，健康很重要，一杯温水幸福你我他。&quot;, &quot;userid&quot;:&quot;1002&quot;, &quot;nickname&quot;:&quot;相忘于江湖&quot;, &quot;createdatetime&quot;:new Date(&quot;2019-08-05T22:08:15.522Z&quot;), &quot;likenum&quot;:NumberInt(1000), &quot;state&quot;:&quot;1&quot;&#125;, &#123;&quot;_id&quot;:&quot;2&quot;, &quot;articleid&quot;:&quot;100001&quot;, &quot;content&quot;:&quot;我夏天空腹喝凉开水，冬天喝温开水&quot;, &quot;userid&quot;:&quot;1005&quot;, &quot;nickname&quot;:&quot;伊人憔悴&quot;, &quot;createdatetime&quot;:new Date(&quot;2019-08-05T23:58:51.485Z&quot;), &quot;likenum&quot;:NumberInt(888), &quot;state&quot;:&quot;1&quot;&#125;]) 插入时指定了 _id ，则主键就是该值。 如果某条数据插入失败，将会终止插入，但已经插入成功的数据不会回滚掉。 批量插入由于数据较多容易出现失败，因此，可以使用try catch进行异常捕捉处理，测试的时候可以不处理。如（了解）： 12345678910111213141516171819202122try &#123;db.comment.insertMany([ &#123;&quot;_id&quot;:&quot;1&quot;, &quot;articleid&quot;:&quot;100001&quot;, &quot;content&quot;:&quot;我们不应该把清晨浪费在手机上，健康很重要，一杯温水幸福你我他。&quot;, &quot;userid&quot;:&quot;1002&quot;, &quot;nickname&quot;:&quot;相忘于江湖&quot;, &quot;createdatetime&quot;:new Date(&quot;2019-08-05T22:08:15.522Z&quot;), &quot;likenum&quot;:NumberInt(1000), &quot;state&quot;:&quot;1&quot;&#125;, &#123;&quot;_id&quot;:&quot;2&quot;, &quot;articleid&quot;:&quot;100001&quot;, &quot;content&quot;:&quot;我夏天空腹喝凉开水，冬天喝温开水&quot;, &quot;userid&quot;:&quot;1005&quot;, &quot;nickname&quot;:&quot;伊人憔悴&quot;, &quot;createdatetime&quot;:new Date(&quot;2019-08-05T23:58:51.485Z&quot;), &quot;likenum&quot;:NumberInt(888), &quot;state&quot;:&quot;1&quot;&#125;])&#125; catch (e) &#123;print (e);&#125; 2.3 文档的查询1db.collection.find(&lt;query&gt;, [projection]) 查询所有： 查询comment集合的所有文档 12db.comment.find() 或 db.comment.find(&#123;&#125;) 条件查询： 查询询userid为1003的记录 1db.comment.find(&#123;userid:&#x27;1003&#x27;&#125;) 如果只需要返回第一条数据 1db.comment.findOne(&#123;userid:&#x27;1003&#x27;&#125;) 投影查询：查询结果返回部分字段 查询结果显示userid和nickname： 1db.comment.find(&#123;userid:&quot;1003&quot;&#125;,&#123;userid:1,nickname:1&#125;) 结果： 12&#123; &quot;_id&quot; : &quot;4&quot;, &quot;userid&quot; : &quot;1003&quot;, &quot;nickname&quot; : &quot;凯撒&quot; &#125;&#123; &quot;_id&quot; : &quot;5&quot;, &quot;userid&quot; : &quot;1003&quot;, &quot;nickname&quot; : &quot;凯撒&quot; &#125; 默认 _id 会显示。 查询结果只显示userid和nickname，不显示_id： 1db.comment.find(&#123;userid:&quot;1003&quot;&#125;,&#123;userid:1,nickname:1,_id:0&#125;) 结果： 12&#123; &quot;userid&quot; : &quot;1003&quot;, &quot;nickname&quot; : &quot;凯撒&quot; &#125; &#123; &quot;userid&quot; : &quot;1003&quot;, &quot;nickname&quot; : &quot;凯撒&quot; &#125; 2.4 文档的更新1234567891011121314db.collection.update(query, update, options)或db.collection.update(&lt;query&gt;,&lt;update&gt;,&#123;upsert: &lt;boolean&gt;,multi: &lt;boolean&gt;,writeConcern: &lt;document&gt;,collation: &lt;document&gt;,arrayFilters: [ &lt;filterdocument1&gt;, ... ],hint: &lt;document|string&gt; // Available starting in MongoDB 4.2&#125;) 覆盖修改： 修改_id为1的记录，点赞量为1001 1db.comment.update(&#123;_id:&quot;1&quot;&#125;,&#123;likenum:NumberInt(1001)&#125;) 执行后，这条文档除了likenum字段其它字段都不见了 局部修改：们需要使用修改器$set来实现 修改_id为2的记录，点赞量为889 1db.comment.update(&#123;_id:&quot;2&quot;&#125;,&#123;$set:&#123;likenum:NumberInt(889)&#125;&#125;) 批量修改： 更新用户id为1003的用户的昵称为大黄 1234//默认只修改第一条数据db.comment.update(&#123;userid:&quot;1003&quot;&#125;,&#123;$set:&#123;nickname:&quot;大黄&quot;&#125;&#125;)//修改所有符合条件的数据db.comment.update(&#123;userid:&quot;1003&quot;&#125;,&#123;$set:&#123;nickname:&quot;大黄&quot;&#125;&#125;,&#123;multi:true&#125;) 列值增长修改：使用$inc运算符来实现对某列值在原有值的基础上进行增加或减少 对3号数据的点赞数，每次递增1 1db.comment.update(&#123;_id:&quot;3&quot;&#125;,&#123;$inc:&#123;likenum:NumberInt(1)&#125;&#125;) 2.5 文档的删除1db.集合名称.remove(条件) 将数据全部删除：(谨慎使用) 1db.comment.remove(&#123;&#125;) 删除_id&#x3D;1的记录： 1db.comment.remove(&#123;_id:&quot;1&quot;&#125;) 2.6 文档的分页查询统计查询： 1db.collection.count(query, options) 统计所有记录数： 1db.comment.count() 按条件统计记录数： 统计userid为1003的记录条数 1db.comment.count(&#123;userid:&quot;1003&quot;&#125;) 分页列表查询：使用limit()方法来读取指定数量的数据，使用skip()方法来跳过指定数量的数据。 1db.COLLECTION_NAME.find().limit(NUMBER).skip(NUMBER) 返回指定条数的记录，可以在find方法后调用limit来返回结果(TopN)，默认值20 1db.comment.find().limit(3) skip方法同样接受一个数字参数作为跳过的记录条数。（前N个不要）,默认值是0 1db.comment.find().skip(3) 分页查询：需求：每页2个，第二页开始：跳过前两条数据，接着值显示3和4条数据 123456//第一页db.comment.find().skip(0).limit(2)//第二页db.comment.find().skip(2).limit(2)//第三页db.comment.find().skip(4).limit(2) 排序查询： sort() 方法对数据进行排序，sort() 方法可以通过参数指定排序的字段， 并使用 1 和 -1 来指定排序的方式，其中 1 为升序排列，而 -1 是用 于降序排列。 123db.COLLECTION_NAME.find().sort(&#123;KEY:1&#125;)或db.集合名称.find().sort(排序方式) 对userid降序排列，并对访问量进行升序排列 1db.comment.find().sort(&#123;userid:-1,likenum:1&#125;) skip(), limilt(), sort()三个放在一起执行的时候， 执行的顺序：sort()&#x3D;&gt;skip()&#x3D;&gt;limit()，和命令编写顺序无关 2.7 文档的更多查询正则的复杂条件查询： 正则表达式是js的语法，直接量的写法。 123db.collection.find(&#123;field:/正则表达式/&#125;)或db.集合.find(&#123;字段:/正则表达式/&#125;) 查询评论内容包含“开水”的所有文档 1db.comment.find(&#123;content:/开水/&#125;) 查询评论的内容中以“专家”开头的 1db.comment.find(&#123;content:/^专家/&#125;) 比较查询： 12345db.集合名称.find(&#123; &quot;field&quot; : &#123; $gt: value &#125;&#125;) // 大于: field &gt; valuedb.集合名称.find(&#123; &quot;field&quot; : &#123; $lt: value &#125;&#125;) // 小于: field &lt; valuedb.集合名称.find(&#123; &quot;field&quot; : &#123; $gte: value &#125;&#125;) // 大于等于: field &gt;= valuedb.集合名称.find(&#123; &quot;field&quot; : &#123; $lte: value &#125;&#125;) // 小于等于: field &lt;= valuedb.集合名称.find(&#123; &quot;field&quot; : &#123; $ne: value &#125;&#125;) // 不等于: field != value、 查询评论点赞数量大于700的记录 1db.comment.find(&#123;likenum:&#123;$gt:NumberInt(700)&#125;&#125;) 包含查询：包含使用$in操作符，不包含使用$nin操作符 查询评论集合中userid字段包含1003或1004的文档 1db.comment.find(&#123;userid:&#123;$in:[&quot;1003&quot;,&quot;1004&quot;]&#125;&#125;) 查询评论集合中userid字段不包含1003和1004的文档 1db.comment.find(&#123;userid:&#123;$nin:[&quot;1003&quot;,&quot;1004&quot;]&#125;&#125;) 条件连接查询： 查询同时满足两个以上条件，需要使用$and操作符将条件进行关联 1$and:[ &#123; &#125;,&#123; &#125;,&#123; &#125; ] 查询评论集合中likenum大于等于700 并且小于2000的文档 1db.comment.find(&#123;$and:[&#123;likenum:&#123;$gte:NumberInt(700)&#125;&#125;,&#123;likenum:&#123;$lt:NumberInt(2000)&#125;&#125;]&#125;) 两个以上条件之间是或者的关系，我们使用 $or 操作符进行关联 1$or:[ &#123; &#125;,&#123; &#125;,&#123; &#125; ] 查询评论集合中userid为1003，或者点赞数小于1000的文档记录 1db.comment.find(&#123;$or:[ &#123;userid:&quot;1003&quot;&#125; ,&#123;likenum:&#123;$lt:1000&#125; &#125;]&#125;) 2.8 常用命令小结*1234567891011121314151617181920212223242526272829303132//选择切换数据库：use articledb//插入数据：db.comment.insert(&#123;bson数据&#125;)//查询所有数据：db.comment.find();//条件查询数据：db.comment.find(&#123;条件&#125;)//查询符合条件的第一条记录：db.comment.findOne(&#123;条件&#125;)//查询符合条件的前几条记录：db.comment.find(&#123;条件&#125;).limit(条数)//查询符合条件的跳过的记录：db.comment.find(&#123;条件&#125;).skip(条数)//修改数据：db.comment.update(&#123;条件&#125;,&#123;修改后的数据&#125;) 或db.comment.update(&#123;条件&#125;,&#123;$set:&#123;要修改部分的字段:数据&#125;)//修改数据并自增某字段值：db.comment.update(&#123;条件&#125;,&#123;$inc:&#123;自增的字段:步进值&#125;&#125;)//删除数据：db.comment.remove(&#123;条件&#125;)//统计查询：db.comment.count(&#123;条件&#125;)//模糊查询：db.comment.find(&#123;字段名:/正则表达式/&#125;)//条件比较运算：db.comment.find(&#123;字段名:&#123;$gt:值&#125;&#125;)//包含查询：db.comment.find(&#123;字段名:&#123;$in:[值1，值2]&#125;&#125;)或db.comment.find(&#123;字段名:&#123;$nin:[值1，值2]&#125;&#125;)//条件连接查询：db.comment.find(&#123;$and:[&#123;条件1&#125;,&#123;条件2&#125;]&#125;)或db.comment.find(&#123;$or:[&#123;条件1&#125;,&#123;条件2&#125;]&#125;) 3.索引索引支持在MongoDB中高效地执行查询。 如果没有索引，MongoDB必须执行全集合扫描，即扫描集合中的每个文档，以选择与查询语句匹配的文档。 这种扫描全集合的查询效率是非常低的，特别在处理大量的数据时，查询可以要花费几十秒甚至几分钟，这对网站的性能是非常致命的。 索引是特殊的数据结构，它以易于遍历的形式存储集合数据集的一小部分。 索引存储特定字段或一组字段的值，按字段值排序。 索引项的排序支持有效的相等匹配和基于范围的查询操作。 此外，MongoDB还可以使用索引中的排序返回排序结果。 MongoDB索引使用B树数据结构（确切的说是B-Tree，MySQL是B+Tree） 3.1 索引的类型单字段索引： MongoDB支持在文档的单个字段上创建用户定义的升序&#x2F;降序索引，称为单字段索引(Single Field Index) 对于单个字段索引和排序操作，索引键的排序顺序(即升序或降序)并不重要，因为MongoDB可以在任何方向上遍历索引 复合索引： MongoDB还支持多个字段的用户定义索引，即复合索引(Compound Index) 复合索引中列出的字段顺序具有重要意义。 例如，如果复合索引由 { userid: 1, score: -1 } 组成，则索引首先按userid正序排序，然后 在每个userid的值内，再在按score倒序排序。 其他索引： 地理空间索引(Geospatial Index)、文本索引(Text Indexes)、哈希索引(Hashed Indexes)。 地理空间索引(Geospatial Index)： 为了支持对地理空间坐标数据的有效查询，MongoDB提供了两种特殊的索引：返回结果时使用平面几何的二维索引和返回结果时使用球面 几何的二维球面索引。 文本索引(Text Indexes)： MongoDB提供了一种文本索引类型，支持在集合中搜索字符串内容。这些文本索引不存储特定于语言的停止词（例如“the”、“a”、“or”）， 而将集合中的词作为词干，只存储根词。 哈希索引(Hashed Indexes)： 为了支持基于散列的分片，MongoDB提供了散列索引类型，它对字段值的散列进行索引。这些索引在其范围内的值分布更加随机，但只支 持相等匹配，不支持基于范围的查询。 3.2 索引的管理操作索引的查看：返回一个集合中的所有索引的数组 1db.collection.getIndexes() //该语法命令运行要求是MongoDB 3.0+ 例：查看comment集合中所有的索引情况 1db.comment.getIndexes() 结果： 12345678910[ &#123; &quot;v&quot; : 2, &quot;key&quot; : &#123; &quot;_id&quot; : 1 &#125;, &quot;name&quot; : &quot;_id_&quot;, &quot;ns&quot; : &quot;articledb.comment&quot; &#125;] 默认_id索引： MongoDB在创建集合的过程中，在 _id 字段上创建一个唯一的索引，默认名字为 _id_ ，该索引可防止客户端插入两个具有相同值的文 档，不能在_id字段上删除此索引。 注意：该索引是唯一索引，因此值不能重复，即 _id 值不能重复的。在分片集群中，通常使用 _id 作为片键。 索引的创建：在集合上创建索引 1db.collection.createIndex(keys, options) 在3.0.0版本前创建索引方法为db.collection.ensureIndex()，之后的版本使用了 db.collection.createIndex()方法，ensureIndex()还能用，但只是createIndex()的别名 单字段索引示例：对 userid 字段建立索引 1db.comment.createIndex(&#123;userid:1&#125;) 结果： 123456&#123; &quot;createdCollectionAutomatically&quot; : false, //按升序创建索引 &quot;numIndexesBefore&quot; : 1, &quot;numIndexesAfter&quot; : 2, &quot;ok&quot; : 1&#125; 查看索引： 1db.comment.getIndexes() 结果： 123456789101112131415161718[ &#123; &quot;v&quot; : 2, &quot;key&quot; : &#123; &quot;_id&quot; : 1 &#125;, &quot;name&quot; : &quot;_id_&quot;, &quot;ns&quot; : &quot;articledb.comment&quot; &#125;, &#123; &quot;v&quot; : 2, &quot;key&quot; : &#123; &quot;userid&quot; : 1 &#125;, &quot;name&quot; : &quot;userid_1&quot;, &quot;ns&quot; : &quot;articledb.comment&quot; &#125;] 索引的移除：可以移除指定的索引，或移除所有索引 指定索引的移除： 1db.collection.dropIndex(index) 例：删除 comment 集合中 userid 字段上的升序索引 1db.comment.dropIndex(&#123;userid:1&#125;) 所有索引的移除： 1db.collection.dropIndexes() 例：删除集合中所有索引 1db.comment.dropIndexes() //_id的字段的索引是无法删除的，只能删除非_id字段的索引 结果： 12345&#123; &quot;nIndexesWas&quot; : 2, &quot;msg&quot; : &quot;non-_id indexes dropped for collection&quot;, &quot;ok&quot; : 1&#125; 3.3 索引的使用执行计划： 分析查询性能（Analyze Query Performance）通常使用执行计划（解释计划、Explain Plan）来查看查询的情况，如：查询耗费的时间、是 否基于索引查询等。 建立的索引是否有效，效果如何，都需要通过执行计划查看： 1db.collection.find(query,options).explain(options) 例：查看根据userid查询数据的情况 1db.comment.find(&#123;userid:&quot;1003&quot;&#125;).explain() 结果： 1234567891011121314151617181920212223242526272829&#123; &quot;queryPlanner&quot; : &#123; &quot;plannerVersion&quot; : 1, &quot;namespace&quot; : &quot;articledb.comment&quot;, &quot;indexFilterSet&quot; : false, &quot;parsedQuery&quot; : &#123; &quot;userid&quot; : &#123; &quot;$eq&quot; : &quot;1003&quot; &#125; &#125;, &quot;winningPlan&quot; : &#123; &quot;stage&quot; : &quot;COLLSCAN&quot;, //表示全集合扫描 &quot;filter&quot; : &#123; &quot;userid&quot; : &#123; &quot;$eq&quot; : &quot;1003&quot; &#125; &#125;, &quot;direction&quot; : &quot;forward&quot; &#125;, &quot;rejectedPlans&quot; : [ ] &#125;, &quot;serverInfo&quot; : &#123; &quot;host&quot; : &quot;9ef3740277ad&quot;, &quot;port&quot; : 27017, &quot;version&quot; : &quot;4.0.10&quot;, &quot;gitVersion&quot; : &quot;c389e7f69f637f7a1ac3cc9fae843b635f20b766&quot; &#125;, &quot;ok&quot; : 1&#125; 例：对userid建立索引 1db.comment.createIndex(&#123;userid:1&#125;) 结果： 123456&#123; &quot;createdCollectionAutomatically&quot; : false, &quot;numIndexesBefore&quot; : 1, &quot;numIndexesAfter&quot; : 2, &quot;ok&quot; : 1&#125; 再次查看执行计划： 1db.comment.find(&#123;userid:&quot;1013&quot;&#125;).explain() 结果·： 1234567891011121314151617181920212223242526272829303132333435363738394041424344&#123; &quot;queryPlanner&quot; : &#123; &quot;plannerVersion&quot; : 1, &quot;namespace&quot; : &quot;articledb.comment&quot;, &quot;indexFilterSet&quot; : false, &quot;parsedQuery&quot; : &#123; &quot;userid&quot; : &#123; &quot;$eq&quot; : &quot;1013&quot; &#125; &#125;, &quot;winningPlan&quot; : &#123; &quot;stage&quot; : &quot;FETCH&quot;, &quot;inputStage&quot; : &#123; &quot;stage&quot; : &quot;IXSCAN&quot;, //基于索引的扫描 &quot;keyPattern&quot; : &#123; &quot;userid&quot; : 1 &#125;, &quot;indexName&quot; : &quot;userid_1&quot;, &quot;isMultiKey&quot; : false, &quot;multiKeyPaths&quot; : &#123; &quot;userid&quot; : [ ] &#125;, &quot;isUnique&quot; : false, &quot;isSparse&quot; : false, &quot;isPartial&quot; : false, &quot;indexVersion&quot; : 2, &quot;direction&quot; : &quot;forward&quot;, &quot;indexBounds&quot; : &#123; &quot;userid&quot; : [ &quot;[\\&quot;1013\\&quot;, \\&quot;1013\\&quot;]&quot; ] &#125; &#125; &#125;, &quot;rejectedPlans&quot; : [ ] &#125;, &quot;serverInfo&quot; : &#123; &quot;host&quot; : &quot;9ef3740277ad&quot;, &quot;port&quot; : 27017, &quot;version&quot; : &quot;4.0.10&quot;, &quot;gitVersion&quot; : &quot;c389e7f69f637f7a1ac3cc9fae843b635f20b766&quot; &#125;, &quot;ok&quot; : 1&#125; 涵盖的查询： 当查询条件和查询的投影仅包含索引字段时，MongoDB直接从索引返回结果，而不扫描任何文档或将文档带入内存。 这些覆盖的查询可以非常有效 1db.comment.find(&#123;userid:&quot;1003&quot;&#125;,&#123;userid:1,_id:0&#125;) 结果： 12&#123; &quot;userid&quot; : &quot;1003&quot; &#125;&#123; &quot;userid&quot; : &quot;1003&quot; &#125; 1db.comment.find(&#123;userid:&quot;1003&quot;&#125;,&#123;userid:1,_id:0&#125;).explain() 结果： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&#123; &quot;queryPlanner&quot; : &#123; &quot;plannerVersion&quot; : 1, &quot;namespace&quot; : &quot;articledb.comment&quot;, &quot;indexFilterSet&quot; : false, &quot;parsedQuery&quot; : &#123; &quot;userid&quot; : &#123; &quot;$eq&quot; : &quot;1003&quot; &#125; &#125;, &quot;winningPlan&quot; : &#123; &quot;stage&quot; : &quot;PROJECTION&quot;, &quot;transformBy&quot; : &#123; &quot;userid&quot; : 1, &quot;_id&quot; : 0 &#125;, &quot;inputStage&quot; : &#123; &quot;stage&quot; : &quot;IXSCAN&quot;, &quot;keyPattern&quot; : &#123; &quot;userid&quot; : 1 &#125;, &quot;indexName&quot; : &quot;userid_1&quot;, &quot;isMultiKey&quot; : false, &quot;multiKeyPaths&quot; : &#123; &quot;userid&quot; : [ ] &#125;, &quot;isUnique&quot; : false, &quot;isSparse&quot; : false, &quot;isPartial&quot; : false, &quot;indexVersion&quot; : 2, &quot;direction&quot; : &quot;forward&quot;, &quot;indexBounds&quot; : &#123; &quot;userid&quot; : [ &quot;[\\&quot;1003\\&quot;, \\&quot;1003\\&quot;]&quot; ] &#125; &#125; &#125;, &quot;rejectedPlans&quot; : [ ] &#125;, &quot;serverInfo&quot; : &#123; &quot;host&quot; : &quot;bobohost.localdomain&quot;, &quot;port&quot; : 27017, &quot;version&quot; : &quot;4.0.10&quot;, &quot;gitVersion&quot; : &quot;c389e7f69f637f7a1ac3cc9fae843b635f20b766&quot; &#125;, &quot;ok&quot; : 1&#125; 4.文章评论4.1 案例分析案例：实现某头条的文章评论 需要实现一下功能： 基本的增删改查API 根据文章id查询评论 评论点赞 数据库：articledb 专栏文章评论(表)：comment 字段名称 字段含义 字段类型 备注 _id ID ObjectId或String Mongo的主键的字段 articleid 文章ID String content 评论内容 String userid 评论人ID String nickname 评论人昵称 String createdatetime 评论的日期时间 Date likenum 点赞数 Int32 replynum 回复数 Int32 state 状态 String 0：不可见1：可见 parentid 上级ID String 如果为0表示文章的顶级评论 技术选型： mongodb-driver(了解) mongodb-driver是mongo官方推出的java连接mongoDB的驱动包，相当于JDBC驱动 SpringDataMongoDB SpringData家族成员之一，用于操作MongoDB的持久层框架，封装了底层的mongodb-driver。 项目结构： 4.2 文章微服务模块搭建导入坐标： 1234567891011121314151617181920212223242526&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-mongodb&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;aliyun-rds-spring-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.junit.vintage&lt;/groupId&gt; &lt;artifactId&gt;junit-vintage-engine&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 在application.yml中： 123456789spring: #数据源配置 data: mongodb: host: 127.0.0.1 #默认主机地址 database: articledb port: 27017 #默认端口27017 #也可以使用uri连接 #uri: mongodb://localhost:27017/articledb 4.3 文章评论基本的CRUDComment实体类中： 1234567891011121314151617181920212223242526/*把一个java类声明为mongodb的文档，可以通过collection参数指定这个类对应的文档。@Document(collection=&quot;mongodb 对应 collection 名&quot;) 若未加 @Document ，该 bean save 到 mongo 的 comment collection 若添加 @Document ，则 save 到 comment collection复合索引@CompoundIndex( def = &quot;&#123;&#x27;userid&#x27;: 1, &#x27;nickname&#x27;: -1&#125;&quot;) */@Document(collection=&quot;comment&quot;)//可以省略，如果省略，则默认使用类名小写映射集合@Datapublic class Comment &#123; @Id //主键标识，该属性的值会自动对应mongodb的主键字段&quot;_id&quot;，如果该属性名就叫“id”,则该注解可以省略，否则必须写 private String id;//主键 @Field(&quot;content&quot;) //该属性对应mongodb的字段的名字，如果一致，则无需该注解 private String content;//吐槽内容 private Date publishtime;//发布日期 @Indexed //添加了一个单字段的索引 private String userid;//发布人ID private String nickname;//昵称 private LocalDateTime createdatetime;//评论的日期时间 private Integer likenum;//点赞数 private Integer replynum;//回复数 private String state;//状态 private String parentid;//上级ID private String articleid;&#125; CommentRepository中： 123public interface CommentRepository extends MongoRepository&lt;Comment,String&gt; &#123; Page&lt;Comment&gt; findByParentid(String parentid, Pageable pageable);&#125; CommentService中： 1234567891011121314public interface CommentService &#123; //保存一个评论 void saveComment(Comment comment); //更新评论 void updateComment(Comment comment); //根据id删除评论 void deleteCommentById(String id); //查询所有评论 List&lt;Comment&gt; findCommentList(); //根据id查询评论 Comment findCommentById(String id); //根据父id，查询子评论的分页列表 Page&lt;Comment&gt; findCommentListPageByParentid(String parentid, int page, int size);&#125; CommentServiceImpl中： 1234567891011121314151617181920212223242526272829303132333435@Servicepublic class CommentServiceImpl implements CommentService &#123; @Autowired private CommentRepository commentRepository; @Override public void saveComment(Comment comment) &#123; commentRepository.save(comment); &#125; @Override public void updateComment(Comment comment) &#123; commentRepository.save(comment); &#125; @Override public void deleteCommentById(String id) &#123; commentRepository.deleteById(id); &#125; @Override public List&lt;Comment&gt; findCommentList() &#123; return commentRepository.findAll(); &#125; @Override public Comment findCommentById(String id) &#123; return commentRepository.findById(id).get(); &#125; @Override public Page&lt;Comment&gt; findCommentListPageByParentid(String parentid, int page, int size) &#123; return commentRepository.findByParentid(parentid, PageRequest.of(page-1,size)); &#125;&#125; 测试： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152@SpringBootTestpublic class CommentServiceTest &#123; @Autowired private CommentService commentService; @Test void testSave() &#123; Comment comment=new Comment(); comment.setArticleid(&quot;100001&quot;); comment.setContent(&quot;不要吃我&quot;); comment.setCreatedatetime(LocalDateTime.now()); comment.setUserid(&quot;1004&quot;); comment.setNickname(&quot;Jerry&quot;); comment.setState(&quot;1&quot;); comment.setParentid(&quot;62ddfe4c2f8d0c6ca75ba67f&quot;); //父评论id comment.setLikenum(0); comment.setReplynum(0); commentService.saveComment(comment); commentService.saveComment(comment); &#125; @Test void testFindById() &#123;//id查找 System.out.println(commentService.findCommentById(&quot;62ddfe4c2f8d0c6ca75ba67f&quot;)); &#125; @Test void testDeleteById() &#123;//删除 commentService.deleteCommentById(&quot;666&quot;); &#125; @Test void testFindAll() &#123;//查找所有 System.out.println(commentService.findCommentList()); &#125; @Test void testUpdate() &#123; //更新 Comment comment = commentService.findCommentById(&quot;62ddfe4c2f8d0c6ca75ba67f&quot;); comment.setLikenum(666); commentService.updateComment(comment); &#125; @Test void testFindCommentListByParentid() &#123; //分页查找 Page&lt;Comment&gt; commentPage = commentService.findCommentListPageByParentid(&quot;62ddfe4c2f8d0c6ca75ba67f&quot;, 1, 2); System.out.println(&quot;----总记录数：&quot;+commentPage.getTotalElements()); System.out.println(&quot;----当前页数据：&quot;+commentPage.getContent()); &#125;&#125; 4.4 MongoTemplate实现评论点赞以下为点赞的临时示例代码： CommentService 新增updateThumbup方法： 12345public void updateCommentThumbupToIncrementingOld(String id)&#123; Comment comment = CommentRepository.findById(id).get(); comment.setLikenum(comment.getLikenum()+1); CommentRepository.save(comment);&#125; 以上方法虽然实现起来比较简单，但是执行效率并不高 我只需要将点赞数加1就可以了，没必要查询出所有字段修改后再更新所有字段。 可以使用MongoTemplate类来实现对某列的操作。 在CommentService声明一个updateCommentLikenum方法： 1234public interface CommentService &#123; //点赞数+1 void updateCommentLikenum(String id);&#125; CommentServiceImpl中实现updateCommentLikenum方法： 123456789101112131415@Autowiredprivate MongoTemplate mongoTemplate;public void updateCommentLikenum(String id)&#123; //查询对象 Query query = Query.query(Criteria.where(&quot;_id&quot;).is(id)); //更新对象 Update update =new Update(); //局部更新，相当于$set update.set(key,value) //递增$inc update.inc(&quot;likenum&quot;,1) 默认增加1 update.inc(&quot;likenum&quot;); //参数1：查询对象 参数2：更新对象 参数3：集合的名字或实体类的类型Comment.class mongoTemplate.updateFirst(query,update,&quot;comment&quot;);&#125; 测试： 1234@Testvoid testUpdateLikenum() &#123; //点赞加1 commentService.updateCommentLikenum(&quot;62ddfe4c2f8d0c6ca75ba67f&quot;);&#125;","categories":[{"name":"Java","slug":"Java","permalink":"http://example.com/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"},{"name":"数据库","slug":"数据库","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}]},{"title":"","slug":"Java/ELK搜索_","date":"2022-08-06T11:11:16.298Z","updated":"2022-09-21T13:33:04.504Z","comments":true,"path":"2022/08/06/Java/ELK搜索_/","link":"","permalink":"http://example.com/2022/08/06/Java/ELK%E6%90%9C%E7%B4%A2_/","excerpt":"","text":"1.ELK简介ELK是包含但不限于Elasticsearch(简称ES)、Logstash、Kibana三个开源软件的组成的一个整体，这三个软件合成ELK。 本课程从分别对三个组件经行详细介绍： Elasticsearch：因为它是elk的核心。本课程从es底层对文档、索引、 搜索、聚合、集群经行介绍，从搜索和聚合分析实例来展现es的魅力。 Logstash：从内部如何采集数据到指定地方来展现它数据采集的功能。 Kibana：从数据绘图展现数据可视化的功能。 2.Elastic Stack概念随着ELK的发展，又有新成员Beats、elastic cloud的加入，所以就形成了Elastic Stack。 所以说，ELK是旧的称呼，Elastic Stack是新的名字 2.1 Elastic Stack特色 处理方式灵活：Elasticsearch是目前最流行的准实时全文检索引擎，具有高速检索大数据的能力 配置简单：安装ELK的每个组件，仅需配置每个组件的一个配置文件即可，修改处不多，因为大量参数已经默认配在系统中，修改想要修改的选项即可 接口简单：采用json形式RESTFUL APl接受数据并响应，无关语言 性能高效：Elasticsearch基于优秀的全文搜索技术Lucene，采用倒排索引，可以轻易地在百亿级别数据下，搜索出想要的内容，并且是秒级响应 灵活扩展：Elasticsearch和Logstash都可以根据集群规模线性拓展，Elasticsearch内部自动实现集群协作 数据展现华丽：Kibana作为前端展现工具，图表华丽，配置简单 2.2 Elastic Stack组件 Elasticsearch： Elasticsearch 是使用java开发，基于Lucene分布式、通过Restful方式进行交互的近实时搜泰平台框架。它的特点有：分布式，零配置，自动发现，索引自动分片，索引副本机制，restful风格接口，多数据源，自动搜索负载等。 Logstash： Logstash 基于java开发，是一个数据抽取转化工具。一般工作方式为C&#x2F;S架构，client端安装在需要收集信息的主机上，server端负责将收到的各节点日志进行过滤、 修改等操作在一并发往Elasticsearch或其他组件去。 Kibana： Kibana 基于nodejs，也是一个开源和免费的可视化工具，Kibana可以为Logstash和Elasticsearch 提供的日志分析友好的web界面，可以汇总、分析和搜索重要数据日志。 Beats： Beats平台集合了多种单一用途数据采集器。它们从成百上千或成千上万台机器和系统向Logstash或Elasticsearch发送数据。 Beats由如下组成： Packetbeat： 轻量型网络数据采集器，用于深挖网线上传输的数据，了解应用程序动态。Packetbeat 是一款轻量型网络数据包分析器，能够多将数据发送至Logstash 或 Elasticsearch。其支持ICMP (V4 and v6)、DNS、HTTP、MySQL、PostgreSQL、Redis、MongoDB、Memcache等协议。 Filebeat： 轻量型日志采集器， 当您要面对成百上千其至成千上万的的服务器、虚拟机和容器生成的志时，请告别 SSH 吧。Filebeat 将为您提供一种轻量型方法，用于转发和汇总日志与文件，让简单的事情不再繁杂。 Metricbeat： 轻量型指标采集器。Metricbeat 能够多以一种轻量型的方式输送各种系统和服务统计数据，从CPU到内存，从 Redis 到Nginx，不一而足。可定期获取外部系统的监控指标信息，其可以监控、收集 Apache、http、HAProxy、MongoDB、MySQL、Nginx、PostgreSQL、Redis、System、Zookeeper等服务。 Winlogbeat： 轻量型 Windows 事件日志采集器。用于密切监控基于Windows 的基础设施上发生的事件。Winlogbeat 能够多以一种轻量型的方式，将Windows 事件日志实时地流式传输至 Elasticsearch 和 Logstash。 Auditbeat： 轻量型申计日志采集器。收集您 Linux 审计框架的数据，监控文件完整性。Auditbeat 实时采集这些事件，然后发送到 Elastic Stack 其他部分做进一步分析。 Heartbeat： 面向运行状态监测的轻量型采集器。通过主动探测来监测服务的可用性。通过给定 URL列表，Heartbeat 仅仅询问：网站运行正常吗？Heartbeat 会将此信息和响应时间发送至 Elastic 的其他部分，以进行进一步分析。 Elastic cloud： 基于 Elasticsearch 的软件即服务(SaaS)解决方案。通过 Elastic 的官方合作伙伴使用托管的 Elasticsearch 服务。 3.Elasticsearch概念3.1 搜索是什么概念：用户输入想要的关键词，返回含有该关键词的所有信息 场景： 互联网搜索：谷歌、百度 站内搜索(垂直搜索)：搜索商品(淘宝、京东) 3.2 数据库搜索站内搜索(垂直搜索)： 数据量小、简单搜索，可以使用数据库 存在问题： 存储问题。电商网站商品上亿条时，涉及到单表数据过大必须拆分表，数据磁盘占用过大必须分库(mycat)。 性能问题：解决上面问题后，查询”笔记本电脑”等关键词时，上亿条数据的商品名字段逐行扫描，性能跟不上。 不能分词：如搜索&quot;笔记本电脑&quot;，只能搜索完全和关键词一样的数据，那么数据量小时，如果搜索&quot;笔记电脑&quot;，&quot;电脑&quot;数据要不要给用户。 互联网搜索：数据量过大(PB级)，不会使用数据库。 3.3 全文检索倒排索引： 数据存储时 ，经行分词建立term索引库。 倒排索引：源于实际应用中需要根据属性的值来查找记录。这种索引表中的每项都包括一个属性值和具有该属性值的各记录的地址。由于不是由记录来确定属性值，而是由属性值来确定记录的位置，因而称为倒排索引(inverted index)。带有倒排索引的文件我们称为倒排索引文任，简称倒排文任(inverted file)。 Lucene： 就是一个jar包，里面封装了全文检索的引擎、搜索的算法代码。 开发时，引入Lucene的jar包，通过api开发搜索相关业务。底层会在磁盘建立索引库。 3.4 初识ElasticsearchElasticsearch是一个基于Luncene的搜索服务器，并且是一个分布式、RESTful 风格的搜索和数据分析引擎 功能介绍： 分布式的搜索引擎和数据分析引擎 搜索：互联网搜索、电商网站站内搜索、OA系统查询 数据分析：电商网站查询近—周哪些品类的图书销售前十，新国网站，最近3天阅读量最高的十个关键词，舆情分析 全文检索，结构化检索，数据分析 全文检索： 搜索商品名称包含java的图书 select * from books where book_name like &quot;%java%&quot; 结构化检索： 搜索商品分类为spring的图书都有哪些 select * from books where category _id=&#39;spring&#39; 数据分析： 分析每一个分类下有多少种图书 select category _id,count(*) from books group by category_id 对海量数据进行近实时的处理 分布式：ES自动可以将海量数据分散到多台服务器上去存储和检索,经行并行查询，提高搜索效率。相对的，Lucene是单机应用。 近实时：数据库上亿条数据查询，搜索一次耗时几个小时，是批处理(batch-processing）。而ES只需秒级即可查询海量数据，所以叫近实时，秒级。 使用场景： 维基百科：全文搜索、高亮、搜索推荐 GitHub：搜索上千行代码 电商网站：检索商品、搜索推荐 日志数据分析：Logstash采集日志，ES进行复杂的数据分析，Kibana数据可视化 百度搜索：第一次查询使用es OA、ERP系统站内搜索 特点： 可拓展性高： 大型分布式集群（数百台服务器）技术，处理PB级数据，大公司可以使用。小公司数据量小，也可以部署在单机。大数据领域使用广泛。 技术整合： 将全文检索、数据分析、分布式相关技术整合在一起lucene(全文检索)、商用的数据分析软件(BI软件)、分布式数据库(mycat) 部署简单： 开箱即用，很多默认配置不需关心，解压完成直接运行即可，拓展时，只需多部署几个实例即可，负载均衡、分片迁移集群内部自己实施。 接口简单： 使用restful api经行交互，跨语言。 功能强大： Elasticsearch作为传统数据库的一个补充，提供了数据库所不不能提供的很多功能，如全文检索、同义词处理、相关度排名。 Lucene与Elasticsearch的关系： Luncene： 最先进、功能最强大的搜索库，直接基于lucene开发，非常复杂，api复杂 Elasticsearch： 基于lucene，封装了许多lucene底层功能，提供简单易用的restful api接口和许多语言的客户端，如java的高级客户端(Java High Level REST Client)和底层客户端(Java Low Level REST Client ) 3.5 Elasticsearch核心概念 NRT(Near Realtime)：进实时 写入数据时，过1秒才会被搜索到，因为内部在分词、录入索引。 es搜索时：搜索和分析数据需要秒级出结果。 Cluster：集群 包含一个或多个启动着es实例的机器群。通常一台机器起一个es实例。同一网络下，集名一样的多个es实例自动组成集群，自动均衡分片等行为。默认集群名为“elasticsearch”。 Node：节点 每个es实例称为一个节点。节点名自动分配，也可以手动配置。 Index：索引 包含一堆有相似结构的文档数据。 索引创建规则： 仅限小写字母 不能包含\\ / * ? &quot; &lt; &gt; | #以及空格符等特殊符号 从7.0版本开始不再包含冒号 不能以- _ +开头 不能超过255个字节（注意它是字节，因此多字节字符将计入255个限制） Document：文档 es中的最小数据单元。一个document就像数据库中的一条记录。通常以json格式显示。多个document存储于一个索引（Index）中。 12345678book document&#123; &quot;book_id&quot;: &quot;1&quot;, &quot;book_name&quot;: &quot;java编程思想&quot;, &quot;book_desc&quot;: &quot;从Java的基础语法到最高级特性（深入的[面向对象](https://baike.baidu.com/item/面向对象)概念、多线程、自动项目构建、单元测试和调试等），本书都能逐步指导你轻松掌握。&quot;, &quot;category_id&quot;: &quot;2&quot;, &quot;category_name&quot;: &quot;java&quot;&#125; Field：字段 就像数据库中的列（Columns），定义每个document应该有的字段。 Type：类型 每个索引里都可以有一个或多个type，type是index中的一个逻辑数据分类，一个type下的document，都有相同的field。 注意：6.0之前的版本有type（类型）概念，type相当于关系数据库的表，ES官方将在ES9.0版本中彻底删除type。本教程type都为_doc。 Shard：分片 index数据过大时，将index里面的数据，分为多个shard，分布式的存储在各个服务器上面。可以支持海量数据和高并发，提升性能和吞吐量，充分利用多台机器的cpu。 Replica：副本 在分布式环境下，任何一台机器都会随时宕机，如果宕机，index的一个分片没有，导致此index不能搜索。所以，为了保证数据的安全，我们会将每个index的分片经行备份，存储在另外的机器上。保证少数机器宕机es集群仍可以搜索。 能正常提供查询和插入的分片我们叫做主分片(primary shard)，其余的我们就管他们叫做备份的分片 (replica shard)。 es6默认新建索引时，5分片，2副本，也就是一主一备，共10个分片。所以，es集群最小规模为两台。 Elasticsearch与数据库比较： 关系型数据库(MySQL) 非关系型数据库(Elasticsearch) 数据库Database 索引Index 表Table 索引Index(原为Type) 数据行Row 文档Document 数据列Column 字段Field 约束 Schema 约束 Schema 4.ES快速入门4.1 文档(document)的数据格式 应用系统的数据结构都是面向对象的，具有复杂的数据结构 对象存储到数据库，需要将关联的复杂对象属性插到另一张表，查询时再拼接起来。 ES面向文档，文档中存储的数据结构，与对象一致。所以一个对象可以直接存成一个文档。 ES的document用json数据格式来表达。 123456789&#123; &quot;id&quot;:&quot;1&quot;, &quot;name&quot;: &quot;张三&quot;, &quot;last_name&quot;: &quot;zhang&quot;, &quot;classInfo&quot;: &#123; &quot;id&quot;: &quot;1&quot;, &quot;className&quot;: &quot;三年二班&quot;, &#125;&#125; 4.2 简单的集群管理使用kibana的控制台，浏览器访问：http://主机地址:5601/app/dev_tools#/console 检查集群的健康状况： 1GET /_cat/health?v 响应结果： 12epoch timestamp cluster status node.total node.data shards pri relo init unassign pending_tasks max_task_wait_time active_shards_percent1660972717 05:18:37 docker-cluster green 1 1 11 11 0 0 0 0 - 100.0% 健康状况的三种情况： green：每个索引的primary shard和replica shard都是active状态的 yellow：每个索引的primary shard都是active状态的，但是部分replica shard不是active状态，处于不可用的状态 red：不是所有索引的primary shard都是active状态的，部分索引有数据丢失了 查看集群中的索引： 1GET /_cat/indexes?v 响应结果： 123456789health status index uuid pri rep docs.count docs.deleted store.size pri.store.sizegreen open .geoip_databases dGx7TrfoTCuOqVS7y6CTRA 1 0 41 0 38.9mb 38.9mbgreen open .kibana_7.17.5_001 JGFQAr7hRWqaoIfIpo_Liw 1 0 438 2 6.7mb 6.7mbgreen open .apm-custom-link f8HqzrG-TWipwqbNoGLQEA 1 0 0 0 226b 226bgreen open kibana_sample_data_ecommerce -WV4YJoiTaWtfACqobRV9g 1 0 4675 0 4.2mb 4.2mbgreen open .apm-agent-configuration hoLYS7CRRTCooCP3ndNt6Q 1 0 0 0 226b 226bgreen open .kibana_task_manager_7.17.5_001 lSfnkGiSSzKTvesWhYZgaQ 1 0 17 77315 8.2mb 8.2mbgreen open .async-search _bMoH_6WQkKhHkGAcpl1MA 1 0 0 0 249b 249bgreen open .tasks jBJ9hH7TTn2TXtFwmYDjVw 1 0 6 0 23kb 23kb 简单的索引操作： 创建索引： 1PUT /demo_index 响应结果： 12345&#123; &quot;acknowledged&quot; : true, &quot;shards_acknowledged&quot; : true, &quot;index&quot; : &quot;demo_index&quot;&#125; 删除索引： 1DELETE /demo_index 响应结果： 123&#123; &quot;acknowledged&quot; : true&#125; 4.3 案例介绍有一个售卖图书的网站，需要为其基于ES构建一个后台系统，提供以下功能： 对商品信息进行CRUD（增删改查）操作 执行简单的结构化查询 可以执行简单的全文检索，以及复杂的phrase（短语）检索 对于全文检索的结果，可以进行高亮显示 对数据进行简单的聚合分析 4.4 商品的CRUD操作document的CRUD操作 **新建图书索引book**：PUT /index 1PUT /book **新增图书(文档)**：PUT /index/type/id 新增图书1： 12345678910PUT /book/_doc/1&#123;&quot;name&quot;: &quot;Bootstrap开发&quot;,&quot;description&quot;: &quot;Bootstrap是由Twitter推出的一个前台页面开发css框架，是一个非常流行的开发框架，此框架集成了多种页面效果。此开发框架包含了大量的CSS、JS程序代码，可以帮助开发者（尤其是不擅长css页面开发的程序人员）轻松的实现一个css，不受浏览器限制的精美界面css效果。&quot;,&quot;studymodel&quot;: &quot;201002&quot;,&quot;price&quot;:38.6,&quot;timestamp&quot;:&quot;2019-08-25 19:11:35&quot;,&quot;pic&quot;:&quot;group1/M00/00/00/wKhlQFs6RCeAY0pHAAJx5ZjNDEM428.jpg&quot;,&quot;tags&quot;: [ &quot;bootstrap&quot;, &quot;dev&quot;]&#125; 新增图书1： 12345678910PUT /book/_doc/2&#123;&quot;name&quot;: &quot;java编程思想&quot;,&quot;description&quot;: &quot;java语言是世界第一编程语言，在软件开发领域使用人数最多。&quot;,&quot;studymodel&quot;: &quot;201001&quot;,&quot;price&quot;:68.6,&quot;timestamp&quot;:&quot;2019-08-25 19:11:35&quot;,&quot;pic&quot;:&quot;group1/M00/00/00/wKhlQFs6RCeAY0pHAAJx5ZjNDEM428.jpg&quot;,&quot;tags&quot;: [ &quot;java&quot;, &quot;dev&quot;]&#125; 查看所有图书：GET /index/_search **查询图书(检索文档)**：GET /index/type/id 查看图书1 1GET /book/_doc/1 响应结果： 123456789101112131415161718192021&#123; &quot;_index&quot; : &quot;book&quot;, &quot;_type&quot; : &quot;_doc&quot;, &quot;_id&quot; : &quot;1&quot;, &quot;_version&quot; : 1, &quot;_seq_no&quot; : 0, &quot;_primary_term&quot; : 1, &quot;found&quot; : true, &quot;_source&quot; : &#123; &quot;name&quot; : &quot;Bootstrap开发&quot;, &quot;description&quot; : &quot;Bootstrap是由Twitter推出的一个前台页面开发css框架，是一个非常流行的开发框架，此框架集成了多种页面效果。此开发框架包含了大量的CSS、JS程序代码，可以帮助开发者（尤其是不擅长css页面开发的程序人员）轻松的实现一个css，不受浏览器限制的精美界面css效果。&quot;, &quot;studymodel&quot; : &quot;201002&quot;, &quot;price&quot; : 38.6, &quot;timestamp&quot; : &quot;2019-08-25 19:11:35&quot;, &quot;pic&quot; : &quot;group1/M00/00/00/wKhlQFs6RCeAY0pHAAJx5ZjNDEM428.jpg&quot;, &quot;tags&quot; : [ &quot;bootstrap&quot;, &quot;dev&quot; ] &#125;&#125; 修改图书： 全局替换： 12345678910PUT /book/_doc/1&#123; &quot;name&quot;: &quot;Bootstrap开发教程&quot;, &quot;description&quot;: &quot;Bootstrap是由Twitter推出的一个前台页面开发css框架，是一个非常流行的开发框架，此框架集成了多种页面效果。此开发框架包含了大量的CSS、JS程序代码，可以帮助开发者（尤其是不擅长css页面开发的程序人员）轻松的实现一个css，不受浏览器限制的精美界面css效果。&quot;, &quot;studymodel&quot;: &quot;201002&quot;, &quot;price&quot;:38.6, &quot;timestamp&quot;:&quot;2019-08-25 19:11:35&quot;, &quot;pic&quot;:&quot;group1/M00/00/00/wKhlQFs6RCeAY0pHAAJx5ZjNDEM428.jpg&quot;, &quot;tags&quot;: [ &quot;bootstrap&quot;, &quot;开发&quot;]&#125; 替换操作是整体覆盖，要带上所有信息。 每次执行后，返回结果中版本号_version在不断增加，此过程为全量替换。 实质：旧文档的内容不会立即删除，只是标记为deleted。适当的时机，集群会将这些文档删除。 局部替换： POST /index/_update/id或 POST /index/type/id/_update 123456POST /book/_update/1&#123; &quot;doc&quot;: &#123; &quot;name&quot;: &quot; Bootstrap开发教程高级&quot; &#125;&#125; 内部与全量替换是一样的，旧文档标记为删除，新建一个文档。 优点： 大大减少网络传输次数和流量，提升性能 减少并发冲突发生的概率 **删除图书(删除文档)**：DELETE /index/type/id 1DELETE /book/_doc/1 实质：旧文档的内容不会立即删除，只是标记为deleted。适当的时机，集群会将这些文档删除。 5.文档document入门1GET /book/_doc/1 响应结果： 123456789101112131415161718192021&#123; &quot;_index&quot; : &quot;book&quot;, &quot;_type&quot; : &quot;_doc&quot;, &quot;_id&quot; : &quot;1&quot;, &quot;_version&quot; : 1, &quot;_seq_no&quot; : 0, &quot;_primary_term&quot; : 1, &quot;found&quot; : true, &quot;_source&quot; : &#123; &quot;name&quot; : &quot;Bootstrap开发&quot;, &quot;description&quot; : &quot;Bootstrap是由Twitter推出的一个前台页面开发css框架，是一个非常流行的开发框架，此框架集成了多种页面效果。此开发框架包含了大量的CSS、JS程序代码，可以帮助开发者（尤其是不擅长css页面开发的程序人员）轻松的实现一个css，不受浏览器限制的精美界面css效果。&quot;, &quot;studymodel&quot; : &quot;201002&quot;, &quot;price&quot; : 38.6, &quot;timestamp&quot; : &quot;2019-08-25 19:11:35&quot;, &quot;pic&quot; : &quot;group1/M00/00/00/wKhlQFs6RCeAY0pHAAJx5ZjNDEM428.jpg&quot;, &quot;tags&quot; : [ &quot;bootstrap&quot;, &quot;dev&quot; ] &#125;&#125; 5.1 字段解析 _index 含义：此文档属于哪个索引 原则：类似数据放在一个索引中。数据库中表的定义规则。如图书信息放在book索引中，员工信息放在employee索引中。各个索引存储和搜索时互不影响。 定义规则：英文小写。尽量不要使用特殊字符。order user _type 含义：类别。book java node 注意：以后的es9将彻底删除此字段，所以当前版本在不断弱化type。不需要关注。见到_type都为_doc。 _id 含义：文档的唯一标识。就像表的id主键。结合索引可以标识和定义一个文档。 生成：手动（put &#x2F;index&#x2F;_doc&#x2F;id）、自动 5.2 自动生成文档id1234POST /book/_doc&#123; &quot;name&quot;:&quot;ELK&quot;&#125; 响应结果： 1234567891011121314&#123; &quot;_index&quot; : &quot;book&quot;, &quot;_type&quot; : &quot;_doc&quot;, &quot;_id&quot; : &quot;FrnSuoIB-YsVyRxk4XeZ&quot;, &quot;_version&quot; : 1, &quot;result&quot; : &quot;created&quot;, &quot;_shards&quot; : &#123; &quot;total&quot; : 2, &quot;successful&quot; : 1, &quot;failed&quot; : 0 &#125;, &quot;_seq_no&quot; : 3, &quot;_primary_term&quot; : 1&#125; 自动生成的id就为FrnSuoIB-YsVyRxk4XeZ 特点：长度为20个字符，URL安全，base64编码，GUID，分布式生成不冲突 5.3 定制返回字段就像sql一样不是查询所有select * from book，而是select name, price from book 查询id为1的书名以及价格： 1GET /book/_doc/1?_source_includes=name,price 注意：name与price中间只有,不能有空格 响应结果： 12345678910111213&#123; &quot;_index&quot; : &quot;book&quot;, &quot;_type&quot; : &quot;_doc&quot;, &quot;_id&quot; : &quot;1&quot;, &quot;_version&quot; : 2, &quot;_seq_no&quot; : 2, &quot;_primary_term&quot; : 1, &quot;found&quot; : true, &quot;_source&quot; : &#123; &quot;price&quot; : 38.6, &quot;name&quot; : &quot; Bootstrap开发教程高级&quot; &#125;&#125; 5.4 文档的强制替换强制创建：PUT /index/ _doc/id/_create 为防止覆盖原有数据，我们在新增时，设置为强制创建，不会覆盖原有文档。 123456POST /book/_doc/1/_create&#123; &quot;doc&quot;: &#123; &quot;name&quot;: &quot; Bootstrap开发教程高级666&quot; &#125;&#125; 响应结果： 12345678910111213141516171819&#123; &quot;error&quot; : &#123; &quot;root_cause&quot; : [ &#123; &quot;type&quot; : &quot;version_conflict_engine_exception&quot;, &quot;reason&quot; : &quot;[1]: version conflict, document already exists (current version [4])&quot;, &quot;index_uuid&quot; : &quot;_GEFBf0rSxG9GxzJtG8w5A&quot;, &quot;shard&quot; : &quot;0&quot;, &quot;index&quot; : &quot;book&quot; &#125; ], &quot;type&quot; : &quot;version_conflict_engine_exception&quot;, &quot;reason&quot; : &quot;[1]: version conflict, document already exists (current version [4])&quot;, &quot;index_uuid&quot; : &quot;_GEFBf0rSxG9GxzJtG8w5A&quot;, &quot;shard&quot; : &quot;0&quot;, &quot;index&quot; : &quot;book&quot; &#125;, &quot;status&quot; : 409&#125; 5.5 脚本更新es可以内置脚本执行复杂操作。例如painless脚本。 注意：groovy脚本在es6以后就不支持了。原因是耗内存，不安全远程注入漏洞。 内置脚本 需求1：修改文档1的num字段+1。 插入数据： 1234PUT /test/_doc/1&#123; &quot;num&quot;: 0&#125; 执行脚本： 1234POST /test/_update/1&#123; &quot;script&quot; : &quot;ctx._source.num+=1&quot;&#125; 查询文档1： 1GET /test/_doc/1 响应数据： 123456789101112&#123; &quot;_index&quot; : &quot;test&quot;, &quot;_type&quot; : &quot;_doc&quot;, &quot;_id&quot; : &quot;1&quot;, &quot;_version&quot; : 2, &quot;_seq_no&quot; : 1, &quot;_primary_term&quot; : 1, &quot;found&quot; : true, &quot;_source&quot; : &#123; &quot;num&quot; : 1 &#125;&#125; 需求2：搜索所有文档，将num字段乘以2输出 插入数据： 1234PUT /test/_doc/2&#123; &quot;num&quot;: 5&#125; 查询所有将num x 2： 注意：源数据不变，只是将查询的数据 x 2 1234567891011121314GET /test/_search&#123; &quot;script_fields&quot;: &#123; &quot;my_doubled_field&quot;: &#123; &quot;script&quot;: &#123; &quot;lang&quot;: &quot;expression&quot;, &quot;source&quot;: &quot;doc[&#x27;num&#x27;] * mul&quot;, &quot;params&quot;: &#123; &quot;mul&quot;: 2 &#125; &#125; &#125; &#125;&#125; 响应结果： 1234567891011121314151617181920212223242526272829303132333435363738394041&#123; &quot;took&quot; : 364, &quot;timed_out&quot; : false, &quot;_shards&quot; : &#123; &quot;total&quot; : 1, &quot;successful&quot; : 1, &quot;skipped&quot; : 0, &quot;failed&quot; : 0 &#125;, &quot;hits&quot; : &#123; &quot;total&quot; : &#123; &quot;value&quot; : 2, &quot;relation&quot; : &quot;eq&quot; &#125;, &quot;max_score&quot; : 1.0, &quot;hits&quot; : [ &#123; &quot;_index&quot; : &quot;test&quot;, &quot;_type&quot; : &quot;_doc&quot;, &quot;_id&quot; : &quot;1&quot;, &quot;_score&quot; : 1.0, &quot;fields&quot; : &#123; &quot;my_doubled_field&quot; : [ 2.0 #由1变成2 ] &#125; &#125;, &#123; &quot;_index&quot; : &quot;test&quot;, &quot;_type&quot; : &quot;_doc&quot;, &quot;_id&quot; : &quot;2&quot;, &quot;_score&quot; : 1.0, &quot;fields&quot; : &#123; &quot;my_doubled_field&quot; : [ 10.0 #由5变成10 ] &#125; &#125; ] &#125;&#125; 外部脚本： 注意：脚本性能低下，且容易发生注入，本教程忽略 自行了解：官方文档 6.ES的并发问题如同秒杀，多线程情况下，es同样会出现并发冲突问题。 6.1 乐观锁与悲观锁为控制并发问题，我们通常采用锁机制。 分为悲观锁和乐观锁两种机制： 悲观锁：很悲观，所有情况都上锁。此时只有一个线程可以操作数据。具体例子为数据库中的行级锁、表级锁、读锁、写锁等。 特点：优点是方便，直接加锁，对程序透明。缺点是效率低。 乐观锁：很乐观，对数据本身不加锁。提交数据时，通过一种机制验证是否存在冲突，如es中通过版本号验证。 特点：优点是并发能力高。缺点是操作繁琐，在提交数据时，可能反复重试多次。 6.2 基于_version乐观锁控制","categories":[],"tags":[]},{"title":"爬取某易云的免费音乐","slug":"Python/爬虫/爬取某易云音乐","date":"2022-08-06T10:59:00.000Z","updated":"2022-08-06T11:16:47.702Z","comments":true,"path":"2022/08/06/Python/爬虫/爬取某易云音乐/","link":"","permalink":"http://example.com/2022/08/06/Python/%E7%88%AC%E8%99%AB/%E7%88%AC%E5%8F%96%E6%9F%90%E6%98%93%E4%BA%91%E9%9F%B3%E4%B9%90/","excerpt":"","text":"获取加密的字符串： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253import jsonfrom base64 import b64encodefrom Crypto.Cipher import AES# 前端自定义的字符串常量_g = &quot;0CoJUm6Qyw8W8jud&quot;# 16位随机数# 必须要自己手动固定# 因为data中的params和encSecKey到了服务器解析后会对比随机数是否相同# 获取encSecKey过程中唯一的变量就是这个随机数，固定了随机数就是固定了encSecKey# 这样就只需要获取params了_i = &quot;Zrv1r2M2VOINoxIJ&quot;# 加密工具：转化为16的倍数def _to_16(data): pad = 16 - len(data) % 16 data += chr(pad) * pad return data# 获取加密的paramsdef _get_aes(a, b): key = b.encode(&quot;utf-8&quot;) iv = &quot;0102030405060708&quot;.encode(&quot;utf-8&quot;) aes = AES.new(key=key, IV=iv, mode=AES.MODE_CBC) # 创造加密器 a = _to_16(a) bs = aes.encrypt(a.encode(&quot;utf-8&quot;)) # 加密,加密内容长度必须是16的倍数， return str(b64encode(bs), &quot;utf-8&quot;) # 转化为字符串返回，# 获取encSecKeydef _get_encSecKey(): return &quot;d6b3977cdc2bf7c55093043afcc1037c7c9a52e0ee558aaa9afb4b6af&quot; \\ &quot;0078171aacc26f75e38da3cc754ac9e7c55b835f6a52496f0c7507445&quot; \\ &quot;8de571d3d5fa1c1d4ed2e8e91b95797030da6904e0a0b379fd1722665&quot; \\ &quot;29fab6d9ce2f10ead2880567491406334d7d4a90a39698eae9f886a22&quot; \\ &quot;7cdd18399533760d314d13281d3b&quot;# 获取加密参数def get_data(data): data = json.dumps(data) params = _get_aes(data, _g) params = _get_aes(params, _i) encSecKey = _get_encSecKey() data = &#123; &quot;params&quot;: params, &quot;encSecKey&quot;: encSecKey &#125; return data 获取歌曲列表： 1234567891011121314151617181920212223242526272829303132333435363738import requestsimport GetDatadef _search(content): data = &#123;&quot;hlposttag&quot;: &quot;&lt;/span&gt;&quot;, &quot;hlpretag&quot;: &#x27;&lt;span class=&quot;s-fc7&quot;&gt;&#x27;, &quot;limit&quot;: 30, &quot;offset&quot;: 0, &quot;s&quot;: f&quot;&#123;content&#125;&quot;, &quot;total&quot;: True, &quot;type&quot;: &quot;1&quot;&#125; url = &quot;https://music.163.com/weapi/cloudsearch/get/web?csrf_token=&quot; data = GetData.get_data(data) resp = requests.post(url=url, data=data) return resp.json()def show_list(content): search_list = _search(content) print(&quot;----------------------------------------------------------&quot;) print(&quot;序号 songId 歌手 歌曲 &quot;) index = 1 list = [] for i in search_list[&quot;result&quot;][&quot;songs&quot;]: print(f&quot;&#123;index&#125; &#123;i[&#x27;id&#x27;]&#125; &#123;i[&#x27;ar&#x27;][0][&#x27;name&#x27;]&#125; &#123;i[&#x27;name&#x27;]&#125;&quot;) index += 1 temp = &#123; &quot;id&quot;: i[&quot;id&quot;], &quot;song_name&quot;: i[&quot;name&quot;], &quot;singer&quot;:i[&quot;ar&quot;][0][&quot;name&quot;] &#125; list.append(temp) print(&quot;----------------------------------------------------------&quot;) return list 下载歌曲： 1234567891011121314151617181920212223242526272829import requestsimport GetDatadef _download_song(url, name): song_name = name + &quot;.m4a&quot; resp = requests.get(url=url) f = open(&quot;./&quot; + song_name, &quot;wb&quot;) f.write(resp.content) f.close() print(name + &quot;下载成功&quot;)def get_song_url(dic): data = &#123;&quot;csrf_token&quot;: &quot;&quot;, &quot;encodeType&quot;: &quot;aac&quot;, &quot;ids&quot;: f&quot;[&#123;dic[&#x27;id&#x27;]&#125;]&quot;, &quot;level&quot;: &quot;standard&quot; &#125; data = GetData.get_data(data) url = &quot;https://music.163.com/weapi/song/enhance/player/url/v1?csrf_token=&quot; resp = requests.post(url=url, data=data) song_url = resp.json()[&quot;data&quot;][0][&quot;url&quot;] _download_song(song_url, dic[&quot;song_name&quot;] + &quot;_&quot; + dic[&quot;singer&quot;]) 主函数调用： 12345678910if __name__ == &#x27;__main__&#x27;: print(&quot;仅供学习交流，严禁用于商业用途，请于24小时内删除！&quot;) search = input(&quot;请输入要搜索的歌曲或歌手&quot;) list = GetSongId.show_list(search) index = input(&quot;请选择以上的序号(-1取消)&quot;) if index != -1: Download.get_song_url(list[int(index)-1]) 目前2022&#x2F;8&#x2F;6为止，使用正常","categories":[{"name":"Python","slug":"Python","permalink":"http://example.com/categories/Python/"},{"name":"爬虫","slug":"Python/爬虫","permalink":"http://example.com/categories/Python/%E7%88%AC%E8%99%AB/"}],"tags":[{"name":"爬虫","slug":"爬虫","permalink":"http://example.com/tags/%E7%88%AC%E8%99%AB/"},{"name":"Python","slug":"Python","permalink":"http://example.com/tags/Python/"}]},{"title":"(每日LeetCode)1408. 数组中的字符串匹配","slug":"每日LeetCode/2022-8/1408 数组中的字符串匹配","date":"2022-08-06T10:43:00.000Z","updated":"2022-08-06T10:43:21.143Z","comments":true,"path":"2022/08/06/每日LeetCode/2022-8/1408 数组中的字符串匹配/","link":"","permalink":"http://example.com/2022/08/06/%E6%AF%8F%E6%97%A5LeetCode/2022-8/1408%20%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D/","excerpt":"","text":"题目：给你一个字符串数组 words ，数组中的每个字符串都可以看作是一个单词。请你按 任意 顺序返回 words 中是其他单词的子字符串的所有单词。 如果你可以删除 words[j] 最左侧和&#x2F;或最右侧的若干字符得到 word[i] ，那么字符串 words[i] 就是 words[j] 的一个子字符串。 示例： 输入：words &#x3D; [“mass”,”as”,”hero”,”superhero”]输出：[“as”,”hero”]解释：”as” 是 “mass” 的子字符串，”hero” 是 “superhero” 的子字符串。[“hero”,”as”] 也是有效的答案 思路：暴力枚举与每个字符串进行匹配 代码(cpp)：123456789101112131415class Solution &#123;public: vector&lt;string&gt; stringMatching(vector&lt;string&gt;&amp; words) &#123; vector&lt;string&gt; ans; for(int i = 0; i &lt; words.size(); i++)&#123; for(int j = 0; j &lt; words.size(); j++)&#123; if(i != j &amp;&amp; words[j].find(words[i]) != string::npos)&#123; ans.emplace_back(words[i]); break; &#125; &#125; &#125; return ans; &#125;&#125;; 复杂对分析： 时间复杂度：O(n^2 x L^2)，其中 n 是字符串数组的长度，L 是字符串数组中最长字符串的长度。使用 KMP 字符串匹配算法可以将时间复杂度优化到 O(n^2 × T)，其中 T 是字符串数组中所有字符串的平均长度。 空间复杂度：O(1)。返回值不计入空间复杂度。如果使用 KMP 字符串匹配算法，那么对应的空间复杂度为 O(T)。","categories":[{"name":"每日LeetCode","slug":"每日LeetCode","permalink":"http://example.com/categories/%E6%AF%8F%E6%97%A5LeetCode/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"}]},{"title":"(每日LeetCode)623. 在二叉树中增加一行","slug":"每日LeetCode/2022-8/623 在二叉树中增加一行","date":"2022-08-05T02:57:00.000Z","updated":"2022-08-05T03:03:21.698Z","comments":true,"path":"2022/08/05/每日LeetCode/2022-8/623 在二叉树中增加一行/","link":"","permalink":"http://example.com/2022/08/05/%E6%AF%8F%E6%97%A5LeetCode/2022-8/623%20%E5%9C%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%A2%9E%E5%8A%A0%E4%B8%80%E8%A1%8C/","excerpt":"","text":"题目：给定一个二叉树的根 root 和两个整数 val 和 depth ，在给定的深度 depth 处添加一个值为 val 的节点行。 注意，根节点 root 位于深度 1 。 加法规则如下: 给定整数 depth，对于深度为 depth - 1 的每个非空树节点 cur ，创建两个值为 val 的树节点作为 cur 的左子树根和右子树根。 cur 原来的左子树应该是新的左子树根的左子树。 cur 原来的右子树应该是新的右子树根的右子树。 如果 depth == 1 意味着 depth - 1 根本没有深度，那么创建一个树节点，值 val 作为整个原始树的新根，而原始树就是新根的左子树。 示例： 输入: root &#x3D; [4,2,6,3,1,5], val &#x3D; 1, depth &#x3D; 2输出: [4,1,1,2,null,null,6,3,1,5] 我自己写的递归很烂，不如官方的的规范、整洁！但是效率基本差不多！ 12345678910111213141516171819202122class Solution &#123;public: TreeNode* def(TreeNode* root, int&amp; val, int curDepth, int&amp; depth, int choice)&#123; if(curDepth == depth - 1) &#123; if(choice == 1) return new TreeNode(val, root, nullptr); else return new TreeNode(val, nullptr, root); &#125; if(root == nullptr) return nullptr; root-&gt;left = def(root-&gt;left, val, curDepth + 1, depth, 1); root-&gt;right = def(root-&gt;right, val, curDepth + 1, depth, 2); return root; &#125; TreeNode* addOneRow(TreeNode* root, int val, int depth) &#123; return def(root, val, 0, depth, 1); &#125;&#125;; 下面是官方的递归思路！ 思路：递归以示例中图片输出后的二叉树为例：[4,1,1,2,null,null,6,3,1,5] 如果要在深度depth为3的位置插入新元素： 第一次递归：这层元素由4 变成了元素4的左右节点1和1，深度depth减一变为2 如果深度depth为2的情况下，这层的节点的子节点就是要插入新元素的位置， 以这层左节点元素为例，元素1。创建新节点，新节点的左节点指向元素1的左节点，元素1的左节点变为新节点。这层右节点同理。到达深度为2的情况，直接返回不会到达深度为1的情况。 只有在初始化深度depth为1的情况下，说明要在根节点root处插入新元素，创建新节点，新节点的左节点为根节点root，将根节点root指向为新节点，完成插入。 并且深度为n(除了深度为1的情况)，只要递归到深度depth变为2就可以插入新元素。 代码(cpp)：12345678910111213141516171819202122class Solution &#123;public: TreeNode* addOneRow(TreeNode* root, int val, int depth) &#123; if(root == nullptr) return nullptr; //深度为1的情况，新节点的左节点指向根节点，根节点变为新节点 if(depth == 1) return new TreeNode(val, root, nullptr); if(depth == 2) &#123; //深度为2的情况 //新节点指向该节点的左节点，该节点的左节点指向新节点 root-&gt;left = new TreeNode(val, root-&gt;left, nullptr); //新节点指向该节点的右节点，该节点的右节点指向新节点 root-&gt;right = new TreeNode(val, nullptr, root-&gt;right); &#125; else &#123; //递归到该节点的左节点，深度减一 root-&gt;left = addOneRow(root-&gt;left, val, depth - 1); //递归到该节点的右节点，深度减一 root-&gt;right = addOneRow(root-&gt;right, val, depth - 1); &#125; return root; &#125;&#125;; 复杂度分析： 时间复杂度：O(n)，其中 n 为输入的树的节点数。最坏情况下，需要遍历整棵树。 空间复杂度：O(n)，递归的深度最多为 O(n)。","categories":[{"name":"每日LeetCode","slug":"每日LeetCode","permalink":"http://example.com/categories/%E6%AF%8F%E6%97%A5LeetCode/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"}]},{"title":"(每日LeetCode)1403. 非递增顺序的最小子序列","slug":"每日LeetCode/2022-8/1403 非递增顺序的最小子序列","date":"2022-08-04T04:09:00.000Z","updated":"2022-08-04T04:09:24.395Z","comments":true,"path":"2022/08/04/每日LeetCode/2022-8/1403 非递增顺序的最小子序列/","link":"","permalink":"http://example.com/2022/08/04/%E6%AF%8F%E6%97%A5LeetCode/2022-8/1403%20%E9%9D%9E%E9%80%92%E5%A2%9E%E9%A1%BA%E5%BA%8F%E7%9A%84%E6%9C%80%E5%B0%8F%E5%AD%90%E5%BA%8F%E5%88%97/","excerpt":"","text":"题目：给你一个数组 nums，请你从中抽取一个子序列，满足该子序列的元素之和 严格 大于未包含在该子序列中的各元素之和。 如果存在多个解决方案，只需返回 长度最小 的子序列。如果仍然有多个解决方案，则返回 元素之和最大 的子序列。 与子数组不同的地方在于，「数组的子序列」不强调元素在原数组中的连续性，也就是说，它可以通过从数组中分离一些（也可能不分离）元素得到。 注意，题目数据保证满足所有约束条件的解决方案是 唯一 的。同时，返回的答案应当按 非递增顺序 排列。 示例： 输入：nums &#x3D; [4,4,7,6,7]输出：[7,7,6]解释：子序列 [7,7] 的和为 14 ，不严格大于剩下的其他元素之和（14 &#x3D; 4 + 4 + 6）。因此，[7,6,7] 是满足题意的最小子序列。注意，元素按非递增顺序返回。 我自己的思路：双指针 123456789101112131415161718192021222324class Solution &#123;public: vector&lt;int&gt; minSubsequence(vector&lt;int&gt;&amp; nums) &#123; sort(nums.begin(), nums.end()); int right = nums.size() - 1; vector&lt;int&gt; ans; int left = 0; int ans_sum = 0; int temp = 0; while(left &lt;= right)&#123; ans.push_back(nums[right]); ans_sum += nums[right]; right--; while(temp &lt; ans_sum &amp;&amp; left &lt;= right)&#123; temp += nums[left]; left++; &#125; &#125; if(ans_sum &lt;= temp)&#123; ans.push_back(nums[right]); &#125; return ans; &#125;&#125;; 可以通过但是效率很低！下面是官方思路！ 思路：贪心先计算出数组中各个元素加起来的总合sum 再进行从大到小的遍历元素加起来的合cur，直到该子序列的元素之和cur大于未包含在该子序列中的各元素之和sum-cur停止。 代码(cpp)：1234567891011121314151617181920class Solution &#123;public: vector&lt;int&gt; minSubsequence(vector&lt;int&gt;&amp; nums) &#123; int sum = 0; for(auto num : nums)&#123; //计算总和 sum += num; &#125; sort(nums.begin(), nums.end()); //排序 vector&lt;int&gt; ans; int cur = 0; for(int i = nums.size() - 1; i &gt;= 0; i--)&#123; ans.emplace_back(nums[i]); //尾部插入 cur += nums[i]; //计算cur if(sum - cur &lt; cur)&#123; //如果该子序列合 大于 未在子序列中的合 break; &#125; &#125; return ans; &#125;&#125;; 复杂度分析： 时间复杂度：O(nlogn)，其中 n 为数组的长度。需要对数组进行排序，因此时间复杂度 O(nlogn)。 空间复杂度：O(logn)，其中 n 为数组的长度。排序需要的栈空间为 O(logn)。","categories":[{"name":"每日LeetCode","slug":"每日LeetCode","permalink":"http://example.com/categories/%E6%AF%8F%E6%97%A5LeetCode/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"}]},{"title":"(每日LeetCode)899. 有序队列","slug":"每日LeetCode/2022-8/899 有序队列","date":"2022-08-03T01:37:00.000Z","updated":"2022-08-03T01:37:42.753Z","comments":true,"path":"2022/08/03/每日LeetCode/2022-8/899 有序队列/","link":"","permalink":"http://example.com/2022/08/03/%E6%AF%8F%E6%97%A5LeetCode/2022-8/899%20%E6%9C%89%E5%BA%8F%E9%98%9F%E5%88%97/","excerpt":"","text":"题目：给定一个字符串 s 和一个整数 k 。你可以从 s 的前 k 个字母中选择一个，并把它加到字符串的末尾。 返回 在应用上述步骤的任意数量的移动后，字典上最小的字符串 。 示例： 输入：s &#x3D; “cba”, k &#x3D; 1输出：”acb”解释：在第一步中，我们将第一个字符（“c”）移动到最后，获得字符串 “bac”。在第二步中，我们将第一个字符（“b”）移动到最后，获得最终结果 “acb”。 思路：脑筋急转弯以s &#x3D; “cba”为例： 当k &#x3D; 1时，无论经过多少次移动，最小的字符串为”acb”，并不是”最终”最小的字符产”abc” 所以要依次遍历所有可能，找出最小的字符串 当k &gt; 1时，无论经历多少次移动，最终最小的一定是”abc” 只需对s进行排序 代码(cpp)：12345678910111213141516171819202122class Solution &#123;public: string orderlyQueue(string s, int k) &#123; if(k == 1)&#123; //k=1时 string min_s = s; //初始化最小的字符串 int size = s.size(); // 获取字符串长度 for(int i = 0; i &lt; size; i++)&#123; char temp = s[0]; //获取第一个字符 s = s.substr(1); //截取除第一个字符，剩下的字符串 s.push_back(temp); //将第一个字符，加到字符串的后面 if(min_s &gt; s)&#123; //进行比较 min_s = s; &#125; &#125; return min_s; &#125; else&#123; //k&gt;1时 sort(s.begin(), s.end()); //排序 return s; &#125; &#125;&#125;; 复杂度分析： 时间复杂度：O(n^2)，其中 n 是字符串 s 的长度。当 k &#x3D; 1 时需要遍历 n 个可能的字符串，每个字符串需要 O(n) 的时间生成和判断是否字典序最小，时间复杂度是 O(n^2)；当 k &gt; 1 时需要对字符串排序，时间复杂度是 O(nlogn)。最坏情况下时间复杂度是 O(n^2)。 空间复杂度：O(n) 或 O(logn)，其中 n 是字符串 s 的长度。空间复杂度取决于具体实现的语言。对于字符串不可变的语言，当 k &#x3D; 1 时生成每个字符串和当 k &gt; 1 时生成排序后的字符串都需要 O(n) 的空间；对于字符串可变的语言，可以省略 O(n) 的空间，只有当 k &gt; 1 时排序需要 O(logn) 的空间。","categories":[{"name":"每日LeetCode","slug":"每日LeetCode","permalink":"http://example.com/categories/%E6%AF%8F%E6%97%A5LeetCode/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"}]},{"title":"(每日LeetCode)622. 设计循环队列","slug":"每日LeetCode/2022-8/622 设计循环队列","date":"2022-08-02T04:15:00.000Z","updated":"2022-09-27T14:18:46.266Z","comments":true,"path":"2022/08/02/每日LeetCode/2022-8/622 设计循环队列/","link":"","permalink":"http://example.com/2022/08/02/%E6%AF%8F%E6%97%A5LeetCode/2022-8/622%20%E8%AE%BE%E8%AE%A1%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97/","excerpt":"","text":"题目：设计你的循环队列实现。 循环队列是一种线性数据结构，其操作表现基于 FIFO（先进先出）原则并且队尾被连接在队首之后以形成一个循环。它也被称为“环形缓冲器”。 循环队列的一个好处是我们可以利用这个队列之前用过的空间。在一个普通队列里，一旦一个队列满了，我们就不能插入下一个元素，即使在队列前面仍有空间。但是使用循环队列，我们能使用这些空间去存储新的值。 你的实现应该支持如下操作： MyCircularQueue(k)：构造器，设置队列长度为 k 。 Front()：从队首获取元素。如果队列为空，返回 -1 。 Rear()：获取队尾元素。如果队列为空，返回 -1 。 enQueue(value)：向循环队列插入一个元素。如果成功插入则返回真。 deQueue()：从循环队列中删除一个元素。如果成功删除则返回真。 isEmpty()：检查循环队列是否为空。 isFull()：检查循环队列是否已满。 示例： MyCircularQueue circularQueue &#x3D; new MyCircularQueue(3); &#x2F;&#x2F; 设置长度为 3circularQueue.enQueue(1); &#x2F;&#x2F; 返回 truecircularQueue.enQueue(2); &#x2F;&#x2F; 返回 truecircularQueue.enQueue(3); &#x2F;&#x2F; 返回 truecircularQueue.enQueue(4); &#x2F;&#x2F; 返回 false，队列已满circularQueue.Rear(); &#x2F;&#x2F; 返回 3circularQueue.isFull(); &#x2F;&#x2F; 返回 truecircularQueue.deQueue(); &#x2F;&#x2F; 返回 truecircularQueue.enQueue(4); &#x2F;&#x2F; 返回 truecircularQueue.Rear(); &#x2F;&#x2F; 返回 4 思路：数组初始化(空栈)： 以示例为例，设置长度k为3，但是初始化的实际容量capacity应该为k+1即为4 初始化头节点front以及尾节点rear为0号位置 注意：rear指向的位置不是末尾的元素，而是末尾的元素的下一位置 是否为空判断：front与rear是否再同一个位置，即front == rear front$\\Downarrow$ 0 1 2 3 空 空 空 空 $\\Uparrow$rear 如何循环？： 将rear指针所在的3号位置赋值为4后，需要将rear指针后移，但是rear+1后会导致越界 我们希望rear指针应该移动到0号位置，可以进行取余操作：(rear + 1) % capacity rear指针当前的位置为3，容量capacity为4，带入公式：(3 + 1) % 4 = 0 rear指针移动我们所想要的到达的0号位置 front$\\Downarrow$ 0 1 2 3 空 空 3 空 $\\Uparrow$rear front$\\Downarrow$ 0 1 2 3 空 空 3 4 $\\Uparrow$rear 满列的情况： 当存储的元素个数为3时，就达到满列的情况 判断是否为满列：rear指针后移，如果front与rear在同一位置，则说明满列 即(rear + 1) % capacity == front front$\\Downarrow$ 0 1 2 3 1 2 3 空 $\\Uparrow$rear 注意：也可以使用链表实现队列解决该问题！！用链表实现队列更简单 代码(cpp)：以下为数组实现： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859class MyCircularQueue &#123;private: vector&lt;int&gt; queue; // 队列 int capacity; //容量 int front; //头节点 int rear; //尾节点public: MyCircularQueue(int k) &#123; this-&gt;capacity = k + 1; this-&gt;queue = vector&lt;int&gt;(this-&gt;capacity); //初始化容量为k+1 this-&gt;front = 0; //初始化头节点 this-&gt;rear = 0; //初始化尾节点 &#125; //入列 bool enQueue(int value) &#123; //判断是否为满列 if(this-&gt;isFull()) return false; //插入队列 queue[this-&gt;rear] = value; //rear指针后移 this-&gt;rear = (this-&gt;rear + 1) % this-&gt;capacity; return true; &#125; //出列 bool deQueue() &#123; //判断是否为空 if(this-&gt;isEmpty()) return false; //front指针后移 this-&gt;front = (this-&gt;front + 1) % this-&gt;capacity; return true; &#125; int Front() &#123; //判断是否为空 if(this-&gt;isEmpty()) return -1; //返回头节点的元素 return queue[this-&gt;front]; &#125; int Rear() &#123; // 判断是否为空 if(this-&gt;isEmpty()) return -1; //rear指针为末尾元素的下一位，要回到上一位置 //如果rear=0，代入公式：(0 - 1 + 4) % 4 = 3；3为上一个位置 int temp = (this-&gt;rear - 1 + this-&gt;capacity) % this-&gt;capacity; //返回该位置的元素 return queue[temp]; &#125; bool isEmpty() &#123; //判断头节点与尾节点是否在同一位置 return this-&gt;front == this-&gt;rear; &#125; bool isFull() &#123; //判断尾节点的下一个位置是否与头节点在同一位置 return (this-&gt;rear + 1) % this-&gt;capacity == this-&gt;front; &#125;&#125;; 复杂度分析： 时间复杂度：初始化和每项操作的时间复杂度均为 O(1)。 空间复杂度：O(k)，其中 k 为给定的队列元素数目。","categories":[{"name":"每日LeetCode","slug":"每日LeetCode","permalink":"http://example.com/categories/%E6%AF%8F%E6%97%A5LeetCode/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"}]},{"title":"(每日LeetCode)1374. 生成每种字符都是奇数个的字符串","slug":"每日LeetCode/2022-8/1374 生成每种字符都是奇数个的字符串","date":"2022-08-01T03:00:00.000Z","updated":"2022-08-01T03:00:51.761Z","comments":true,"path":"2022/08/01/每日LeetCode/2022-8/1374 生成每种字符都是奇数个的字符串/","link":"","permalink":"http://example.com/2022/08/01/%E6%AF%8F%E6%97%A5LeetCode/2022-8/1374%20%E7%94%9F%E6%88%90%E6%AF%8F%E7%A7%8D%E5%AD%97%E7%AC%A6%E9%83%BD%E6%98%AF%E5%A5%87%E6%95%B0%E4%B8%AA%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2/","excerpt":"","text":"题目：给你一个整数 n，请你返回一个含 n 个字符的字符串，其中每种字符在该字符串中都恰好出现 奇数次 。 返回的字符串必须只含小写英文字母。如果存在多个满足题目要求的字符串，则返回其中任意一个即可。 示例： 输入：n &#x3D; 4输出：”pppz”解释：”pppz” 是一个满足题目要求的字符串，因为 ‘p’ 出现 3 次，且 ‘z’ 出现 1 次。当然，还有很多其他字符串也满足题目要求，比如：”ohhh” 和 “love”。 多说无益！ 代码(cpp)：1234567891011class Solution &#123;public: string generateTheString(int n) &#123; if(n%2 == 0)&#123; return string(n-1,&#x27;a&#x27;) + &#x27;b&#x27;; &#125; else&#123; return string(n, &#x27;a&#x27;); &#125; &#125;&#125;; 复杂度分析： 时间复杂度：O(n)。 空间复杂度：O(1)。这里不计入返回值需要的空间。","categories":[{"name":"每日LeetCode","slug":"每日LeetCode","permalink":"http://example.com/categories/%E6%AF%8F%E6%97%A5LeetCode/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"}]},{"title":"(每日LeetCode)1161. 最大层内元素和","slug":"每日LeetCode/2022-7/1161 最大层内元素和","date":"2022-07-31T03:29:00.000Z","updated":"2022-07-31T03:29:48.084Z","comments":true,"path":"2022/07/31/每日LeetCode/2022-7/1161 最大层内元素和/","link":"","permalink":"http://example.com/2022/07/31/%E6%AF%8F%E6%97%A5LeetCode/2022-7/1161%20%E6%9C%80%E5%A4%A7%E5%B1%82%E5%86%85%E5%85%83%E7%B4%A0%E5%92%8C/","excerpt":"","text":"题目：给你一个二叉树的根节点 root。设根节点位于二叉树的第 1 层，而根节点的子节点位于第 2 层，依此类推。 请返回层内元素之和 最大 的那几层（可能只有一层）的层号，并返回其中 最小 的那个。 示例： 输入：root &#x3D; [1,7,0,7,-8,null,null]输出：2解释：第 1 层各元素之和为 1，第 2 层各元素之和为 7 + 0 &#x3D; 7，第 3 层各元素之和为 7 + -8 &#x3D; -1，所以我们返回第 2 层的层号，它的层内元素之和最大。 思路：使用队列，层序遍历二叉树同时计算出每层的元素之和，比较每层的总和，得出最大总和所在的层数 代码(cpp)：12345678910111213141516171819202122232425262728293031323334353637class Solution &#123;public: int maxLevelSum(TreeNode* root) &#123; queue&lt;TreeNode*&gt; q; q.push(root); int max_sum = -999999; //设置最大元素之和 int max_level_sum = 1; //记录最大总和的所在的层 int level_sum = 1; //当前层数 while(!q.empty())&#123; //第一个循环，遍历层 int size = q.size(); //获取当前层的节点数 int sum = 0; //初始化该层的元素之和 while(size != 0)&#123; //第二个循环，遍历每层的节点 TreeNode* p = q.front(); //获取该节点 q.pop(); //移除在队列中的该节点 sum += p-&gt;val; //加上该节点的值，计算该层的元素之和 if(p-&gt;left != nullptr)&#123; q.push(p-&gt;left); //插入下一层的左节点 &#125; if(p-&gt;right != nullptr)&#123; q.push(p-&gt;right);//插入下一层的右节点 &#125; size--; //已遍历完gai该层节点数减一 &#125; if(max_sum &lt; sum)&#123; //如果该层的元素之和大于之前的 max_sum = sum; max_level_sum = level_sum; &#125; level_sum++; //层数加一，进入下一层 &#125; return max_level_sum; &#125;&#125;;","categories":[{"name":"每日LeetCode","slug":"每日LeetCode","permalink":"http://example.com/categories/%E6%AF%8F%E6%97%A5LeetCode/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"}]},{"title":"(每日LeetCode)1331. 数组序号转换","slug":"每日LeetCode/2022-7/1331 数组序号转换","date":"2022-07-28T01:26:00.000Z","updated":"2022-07-28T01:24:01.012Z","comments":true,"path":"2022/07/28/每日LeetCode/2022-7/1331 数组序号转换/","link":"","permalink":"http://example.com/2022/07/28/%E6%AF%8F%E6%97%A5LeetCode/2022-7/1331%20%E6%95%B0%E7%BB%84%E5%BA%8F%E5%8F%B7%E8%BD%AC%E6%8D%A2/","excerpt":"","text":"题目：给你一个整数数组 arr ，请你将数组中的每个元素替换为它们排序后的序号。 序号代表了一个元素有多大。序号编号的规则如下： 序号从 1 开始编号。一个元素越大，那么序号越大。如果两个元素相等，那么它们的序号相同。每个数字的序号都应该尽可能地小。 示例： 输入：arr &#x3D; [37,12,28,9,100,56,80,5,12]输出：[5,3,4,2,8,6,7,1,3] 思路：哈希表 首先用temp数组拷贝一份原数组arr 将temp数组进行排序 用一个哈希表保存temp数组各元素的排列序号 最后根据原数组arr各个元素的位置返回排列序号 代码(cpp)：123456789101112131415161718192021222324class Solution &#123;public: vector&lt;int&gt; arrayRankTransform(vector&lt;int&gt;&amp; arr) &#123; vector&lt;int&gt; temp(arr); //拷贝一份数组 sort(temp.begin(), temp.end()); //将temp排序 unordered_map&lt;int, int&gt; map; int count = 1; for(int i = 0; i &lt; temp.size(); i++)&#123; //如果map中已经存在，则跳过 if(!map.count(temp[i]))&#123; map[temp[i]] = count; count++; &#125; &#125; vector&lt;int&gt; ans; for(int j = 0; j &lt; arr.size(); j++)&#123; ans.emplace_back(map[arr[j]]); //插入序号 &#125; return ans; &#125;&#125;; 复杂度分析： 时间复杂度：O(n×logn)，其中 n 是输入数组 arr 的长度，排序消耗 O(n×logn) 时间。 空间复杂度：O(n)。有序数组和哈希表各消耗 O(n) 空间。","categories":[{"name":"每日LeetCode","slug":"每日LeetCode","permalink":"http://example.com/categories/%E6%AF%8F%E6%97%A5LeetCode/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"}]},{"title":"(每日LeetCode)919. 完全二叉树插入器","slug":"每日LeetCode/2022-7/919 完全二叉树插入器","date":"2022-07-25T01:51:00.000Z","updated":"2022-07-25T01:58:02.284Z","comments":true,"path":"2022/07/25/每日LeetCode/2022-7/919 完全二叉树插入器/","link":"","permalink":"http://example.com/2022/07/25/%E6%AF%8F%E6%97%A5LeetCode/2022-7/919%20%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E6%8F%92%E5%85%A5%E5%99%A8/","excerpt":"","text":"题目：完全二叉树： 是每一层（除最后一层外）都是完全填充（即，节点数达到最大）的，并且所有的节点都尽可能地集中在左侧。 设计一种算法，将一个新节点插入到一个完整的二叉树中，并在插入后保持其完整。 实现 CBTInserter 类： CBTInserter(TreeNode root) 使用头节点为 root 的给定树初始化该数据结构； CBTInserter.insert(int v) 向树中插入一个值为 Node.val &#x3D;&#x3D; val的新节点 TreeNode。使树保持完全二叉树的状态，并返回插入节点 TreeNode 的父节点的值； CBTInserter.get_root() 将返回树的头节点。 示例： 输入：[“CBTInserter”, “insert”, “insert”, “get_root”][[[1, 2]], [3], [4], []]输出：[null, 1, 2, [1, 2, 3, 4]] 解释：CBTInserter cBTInserter &#x3D; new CBTInserter([1, 2]);cBTInserter.insert(3); &#x2F;&#x2F; 返回父节点 1cBTInserter.insert(4); &#x2F;&#x2F; 返回父节点 2cBTInserter.get_root(); &#x2F;&#x2F; 返回根节点 [1, 2, 3, 4] 思路：应用队列实现树的层序遍历： 首先将二叉树的根节点进队，判断队列不为空，就输出队头的元素 判断节点如果有孩子，就将孩子进队 遍历过的节点出队 循环，直到q.empty() 代码(cpp)：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758class CBTInserter &#123;public: //存入最底层的节点方便以后插入 queue&lt;TreeNode*&gt; node; TreeNode* root; //获取底层节点 CBTInserter(TreeNode* root) &#123; this-&gt;root = root; queue&lt;TreeNode*&gt; q; //向队尾插入节点 q.push(root); while (!q.empty()) &#123; //返回队列中的第一个元素 TreeNode* n = q.front(); //删除队列第一个元素 q.pop(); if (n-&gt;left) &#123; q.push(n-&gt;left); &#125; if (n-&gt;right) &#123; q.push(n-&gt;right); &#125; if (!(n-&gt;left &amp;&amp; n-&gt;right)) &#123; //获取最底层的节点 node.push(n); &#125; &#125; &#125; int insert(int val) &#123; //创建一个新节点 TreeNode* new_node = new TreeNode(val); // 获得队列的第一个元素 TreeNode* n = node.front(); //获取该节点的值 int ret = n-&gt;val; // 如果不存在，就插入左节点 if(!(n-&gt;left))&#123; n-&gt;left = new_node; &#125; //存在，就插入到右节点 else&#123; n-&gt;right = new_node; //删除该节点，因为左右节点都已经存在 node.pop(); &#125; //将新节点插入到队列 node.push(new_node); return ret; &#125; TreeNode* get_root() &#123; return root; &#125;&#125;; 复杂度分析： 时间复杂度：初始化 CBTInserter(root) 需要的时间为 O(n)，其中 n 是给定的初始完全二叉树的节点个数。insert(v) 和 get_root() 的时间复杂度均为 O(1)。 空间复杂度：O(n+q)，其中 q 是 insert(v) 的调用次数。在调用了 q 次 insert(v) 后，完全二叉树中有 n+q 个节点，其中有一半的节点在队列中，需要 O(n+q) 的空间。","categories":[{"name":"每日LeetCode","slug":"每日LeetCode","permalink":"http://example.com/categories/%E6%AF%8F%E6%97%A5LeetCode/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"}]},{"title":"(每日LeetCode)1184. 公交站间的距离","slug":"每日LeetCode/2022-7/1184 公交站间的距离","date":"2022-07-24T00:24:00.000Z","updated":"2022-07-24T00:24:48.039Z","comments":true,"path":"2022/07/24/每日LeetCode/2022-7/1184 公交站间的距离/","link":"","permalink":"http://example.com/2022/07/24/%E6%AF%8F%E6%97%A5LeetCode/2022-7/1184%20%E5%85%AC%E4%BA%A4%E7%AB%99%E9%97%B4%E7%9A%84%E8%B7%9D%E7%A6%BB/","excerpt":"","text":"题目：环形公交路线上有 n 个站，按次序从 0 到 n - 1 进行编号。我们已知每一对相邻公交站之间的距离，distance[i] 表示编号为 i 的车站和编号为 (i + 1) % n 的车站之间的距离。 环线上的公交车都可以按顺时针和逆时针的方向行驶。 返回乘客从出发点 start 到目的地 destination 之间的最短距离。 示例： 输入：distance &#x3D; [1,2,3,4], start &#x3D; 0, destination &#x3D; 1输出：1解释：公交站 0 和 1 之间的距离顺时针是 1 ，逆时针是 9，所以最小值是 1。 思路：先计算总的距离all_sum，再计算start到destination的距离为positive_sum 返回顺时针的距离positive_sum以及逆时针的距离all_sum-positive_sum它们中的最小距离 代码(cpp)：123456789101112131415161718class Solution &#123;public: int distanceBetweenBusStops(vector&lt;int&gt;&amp; distance, int start, int destination) &#123; int all_sum = 0; for(int i =0; i &lt; distance.size(); i++)&#123; all_sum += distance[i]; &#125; if(start &gt; destination) swap(start, destination); int positive_sum = 0; for(start; start &lt; destination; start++)&#123; positive_sum += distance[start]; &#125; return min(positive_sum, all_sum - positive_sum); &#125;&#125;; 优化后：将两个循环合并在一起 123456789101112131415161718class Solution &#123;public: int distanceBetweenBusStops(vector&lt;int&gt;&amp; distance, int start, int destination) &#123; int all_sum = 0; int positive_sum = 0; if(start &gt; destination) swap(start, destination); for(int i =0; i &lt; distance.size(); i++)&#123; all_sum += distance[i]; if(i &gt;= start &amp;&amp; i &lt; destination)&#123; positive_sum += distance[i]; &#125; &#125; return min(positive_sum, all_sum - positive_sum); &#125;&#125;;","categories":[{"name":"每日LeetCode","slug":"每日LeetCode","permalink":"http://example.com/categories/%E6%AF%8F%E6%97%A5LeetCode/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"}]},{"title":"(每日LeetCode)814. 二叉树剪枝","slug":"每日LeetCode/2022-7/814 二叉树剪枝","date":"2022-07-21T00:36:00.000Z","updated":"2022-07-21T02:13:56.542Z","comments":true,"path":"2022/07/21/每日LeetCode/2022-7/814 二叉树剪枝/","link":"","permalink":"http://example.com/2022/07/21/%E6%AF%8F%E6%97%A5LeetCode/2022-7/814%20%E4%BA%8C%E5%8F%89%E6%A0%91%E5%89%AA%E6%9E%9D/","excerpt":"","text":"题目：给你二叉树的根结点 root ，此外树的每个结点的值要么是 0 ，要么是 1 。 返回移除了所有不包含 1 的子树的原二叉树。 节点 node 的子树为 node 本身加上所有 node 的后代。 示例： 输入：root &#x3D; [1,null,0,0,1]输出：[1,null,0,null,1]解释：只有红色节点满足条件“所有不包含 1 的子树”。 右图为返回的答案。 自底向上进行剪枝，如果某个节点不存在左右节点，并且该节点值为0的话就需要剪枝 代码(cpp)：123456789101112131415class Solution &#123;public: TreeNode* pruneTree(TreeNode* root) &#123; if(root == nullptr) return nullptr; root-&gt;left = pruneTree(root-&gt;left); root-&gt;right = pruneTree(root-&gt;right); if(root-&gt;left == nullptr &amp;&amp; root-&gt;right ==nullptr &amp;&amp; root-&gt;val == 0)&#123; return nullptr; &#125; return root; &#125;&#125;; 复杂度分析： 时间复杂度：O(n)，其中 n 是二叉树节点的个数。每个节点都需要遍历一次。 空间复杂度：O(n)，其中 n 是二叉树节点的个数。递归的深度最多为 O(n)。","categories":[{"name":"每日LeetCode","slug":"每日LeetCode","permalink":"http://example.com/categories/%E6%AF%8F%E6%97%A5LeetCode/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"}]},{"title":"(每日LeetCode)1252. 奇数值单元格的数目","slug":"每日LeetCode/2022-7/1252 奇数值单元格的数目","date":"2022-07-12T01:24:00.000Z","updated":"2022-07-12T01:26:30.157Z","comments":true,"path":"2022/07/12/每日LeetCode/2022-7/1252 奇数值单元格的数目/","link":"","permalink":"http://example.com/2022/07/12/%E6%AF%8F%E6%97%A5LeetCode/2022-7/1252%20%E5%A5%87%E6%95%B0%E5%80%BC%E5%8D%95%E5%85%83%E6%A0%BC%E7%9A%84%E6%95%B0%E7%9B%AE/","excerpt":"","text":"题目：给你一个 m x n 的矩阵，最开始的时候，每个单元格中的值都是 0。 另有一个二维索引数组 indices，indices[i] = [ri, ci] 指向矩阵中的某个位置，其中 ri 和 ci 分别表示指定的行和列（从 0 开始编号）。 对 indices[i] 所指向的每个位置，应同时执行下述增量操作： ri 行上的所有单元格，加 1 。ci 列上的所有单元格，加 1 。给你 m、n 和 indices 。请你在执行完所有 indices 指定的增量操作后，返回矩阵中 奇数值单元格 的数目。 示例： 输入：m &#x3D; 2, n &#x3D; 3, indices &#x3D; [[0,1],[1,1]]输出：6解释： [[0,0,0], &#x3D;&#x3D;&gt; [[1,2,1], &#x3D;&#x3D;&gt; [[1,3,1], [0,0,0]] [0,1,0]] [1,3,1]] 返回奇数的个数 代码(cpp)：1234567891011121314151617181920212223242526class Solution &#123;public: int oddCells(int m, int n, vector&lt;vector&lt;int&gt;&gt;&amp; indices) &#123; vector&lt;int&gt; dp(n); vector&lt;vector&lt;int&gt;&gt; dps(m, dp); for (int i = 0; i &lt; indices.size(); i++) &#123; for (int j = 0; j &lt; n; j++) &#123; dps[indices[i][0]][j] += 1; &#125; for (int k = 0; k &lt; m; k++) &#123; dps[k][indices[i][1]] += 1; &#125; &#125; int count = 0; for (int i = 0; i &lt; m; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; if (dps[i][j] % 2 != 0) &#123; count++; &#125; &#125; &#125; return count; &#125;&#125;; 复杂度分析： 时间复杂度：O(q×(m+n)+m×n), 其中 q 表示数组 indices 的长度，m,n 为矩阵的行数与列数。遍历数组时，每次都需要更新矩阵中一行加一列，需要的时间为 O(q×(m+n))，最后还需要遍历矩阵，需要的时间为 O(m×n)，总的时间复杂度为 O(q×(m+n)+m×n)。 空间复杂度：O(m×n)，其中 m,n 为矩阵的行数与列数。需要存储矩阵的所有元素。","categories":[{"name":"每日LeetCode","slug":"每日LeetCode","permalink":"http://example.com/categories/%E6%AF%8F%E6%97%A5LeetCode/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"}]},{"title":"(每日LeetCode)676. 实现一个魔法字典","slug":"每日LeetCode/2022-7/676 实现一个魔法字典","date":"2022-07-11T00:35:00.000Z","updated":"2022-07-11T04:04:29.012Z","comments":true,"path":"2022/07/11/每日LeetCode/2022-7/676 实现一个魔法字典/","link":"","permalink":"http://example.com/2022/07/11/%E6%AF%8F%E6%97%A5LeetCode/2022-7/676%20%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E9%AD%94%E6%B3%95%E5%AD%97%E5%85%B8/","excerpt":"","text":"题目：设计一个使用单词列表进行初始化的数据结构，单词列表中的单词 互不相同 。 如果给出一个单词，请判定能否只将这个单词中一个字母换成另一个字母，使得所形成的新单词存在于你构建的字典中。 实现 MagicDictionary 类： MagicDictionary() 初始化对象void buildDict(String[] dictionary) 使用字符串数组 dictionary 设定该数据结构，dictionary 中的字符串互不相同bool search(String searchWord) 给定一个字符串 searchWord ，判定能否只将字符串中 一个 字母换成另一个字母，使得所形成的新字符串能够与字典中的任一字符串匹配。如果可以，返回 true；否则，返回 false。 示例： 输入[“MagicDictionary”, “buildDict”, “search”, “search”, “search”, “search”][[], [[“hello”, “leetcode”]], [“hello”], [“hhllo”], [“hell”], [“leetcoded”]]输出[null, null, false, true, false, false] 解释MagicDictionary magicDictionary &#x3D; new MagicDictionary();magicDictionary.buildDict([“hello”, “leetcode”]);magicDictionary.search(“hello”); &#x2F;&#x2F; 返回 FalsemagicDictionary.search(“hhllo”); &#x2F;&#x2F; 将第二个 ‘h’ 替换为 ‘e’ 可以匹配 “hello” ，所以返回 TruemagicDictionary.search(“hell”); &#x2F;&#x2F; 返回 FalsemagicDictionary.search(“leetcoded”); &#x2F;&#x2F; 返回 False 思路：遍历词典，找到与searchWord单词长度一样的单词，再与之对比相同的位置的字母是否相同，记录不相同字母的次数，只有不相同的字母的次数为1时，才可以返回true 代码(cpp)：1234567891011121314151617181920212223242526class MagicDictionary &#123;public: vector&lt;string&gt; dic; MagicDictionary() &#123;&#125; void buildDict(vector&lt;string&gt; dictionary) &#123; this-&gt;dic= dictionary; &#125; bool search(string searchWord) &#123; int n = searchWord.size(); for(int i = 0; i &lt; dic.size(); i++)&#123; if(dic[i].size() == n)&#123; int count = 0; for(int j = 0; j &lt; n; j++)&#123; if(dic[i][j] != searchWord[j])&#123; count++; &#125; &#125; if(count == 1) return 1; &#125; &#125; return 0; &#125;&#125;; 复杂度分析： 时间复杂度：O(qnl)，其中 n 是数组 dictionary 的长度，l 是数组 dictionary 中字符串的平均长度，q 是函数 search(searchWord) 的调用次数。 空间复杂度：O(nl)，即为数组需要使用的空间。","categories":[{"name":"每日LeetCode","slug":"每日LeetCode","permalink":"http://example.com/categories/%E6%AF%8F%E6%97%A5LeetCode/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"}]},{"title":"(每日LeetCode)873. 最长的斐波那契子序列的长度","slug":"每日LeetCode/2022-7/873 最长的斐波那契子序列的长度","date":"2022-07-09T00:34:00.000Z","updated":"2022-07-09T03:38:53.250Z","comments":true,"path":"2022/07/09/每日LeetCode/2022-7/873 最长的斐波那契子序列的长度/","link":"","permalink":"http://example.com/2022/07/09/%E6%AF%8F%E6%97%A5LeetCode/2022-7/873%20%E6%9C%80%E9%95%BF%E7%9A%84%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E5%AD%90%E5%BA%8F%E5%88%97%E7%9A%84%E9%95%BF%E5%BA%A6/","excerpt":"","text":"题目：如果序列 $X_1, X_2, …, X_n$ 满足下列条件，就说它是 斐波那契式 的： n &gt;&#x3D; 3对于所有 i + 2 &lt;&#x3D; n，都有 $X_i + X_{i+1} &#x3D; X_{i+2}$给定一个严格递增的正整数数组形成序列 arr ，找到 arr 中最长的斐波那契式的子序列的长度。如果一个不存在，返回 0 。 （回想一下，子序列是从原序列 arr 中派生出来的，它从 arr 中删掉任意数量的元素（也可以不删），而不改变其余元素的顺序。例如， [3, 5, 8] 是 [3, 4, 5, 6, 7, 8] 的一个子序列） 示例： 输入: arr &#x3D; [1,3,7,11,12,14,18]输出: 3解释: 最长的斐波那契式子序列有 [1,11,12]、[3,11,14] 以及 [7,11,18] 。 思路：递归费劲尽心，最后运行超时！！ 代码(cpp)：12345678910111213141516171819202122232425262728class Solution &#123;public: int def(vector&lt;int&gt;&amp; arr, vector&lt;int&gt; dp, int pos)&#123; int ans = 0; int n = dp.size(); for(int i=pos; i &lt; arr.size(); i++)&#123; if(n &lt; 2)&#123; vector&lt;int&gt; n_dp(dp); n_dp.emplace_back(arr[i]); ans = max(def(arr, n_dp, i+1)+1, ans); &#125; else if(n &gt;= 2 &amp;&amp; dp[n-1] + dp[n-2] == arr[i])&#123; vector&lt;int&gt; n_dp(dp); n_dp.emplace_back(arr[i]); ans = max(def(arr, n_dp, i+1)+1, ans); &#125; &#125; if(ans &lt;= 2 &amp;&amp; pos &lt; 2) return 0; return ans; &#125; int lenLongestFibSubseq(vector&lt;int&gt;&amp; arr) &#123; vector&lt;int&gt; dp; return def(arr, dp, 0); &#125;&#125;; 思路：动态规划摆烂了！ arr[k]+arr[j]=arr[i] 大小：k&lt;j&lt;i 代码(cpp)：123456789101112131415161718192021222324252627282930class Solution &#123;public: int lenLongestFibSubseq(vector&lt;int&gt;&amp; arr) &#123; unordered_map&lt;int, int&gt; indices; int n = arr.size(); for (int i = 0; i &lt; n; i++) &#123; indices[arr[i]] = i; &#125; //创建全是0的n*n二维数组 vector&lt;vector&lt;int&gt;&gt; dp(n, vector&lt;int&gt;(n)); int ans = 0; for (int i = 0; i &lt; n; i++) &#123; for (int j = i - 1; j &gt;= 0 &amp;&amp; arr[j] * 2 &gt; arr[i]; j--) &#123; int k = -1; //如果indices中存在arr[i]-arr[j]这个数 if (indices.count(arr[i] - arr[j])) &#123; //获得获得此数 k = indices[arr[i] - arr[j]]; &#125; //如果k不等于-1 if (k &gt;= 0) &#123; dp[j][i] = max(dp[k][j] + 1, 3); &#125; //获得到最大的序列长度 ans = max(ans, dp[j][i]); &#125; &#125; return ans; &#125;&#125;; 复杂度分析： 时间复杂度：O(n^2)，其中 n 是数组 arr 的长度。动态规划的状态数是 O(n^2)，每个状态的计算时间都是 O(1) 空间复杂度：O(n^2)，其中 n 是数组 arr 的长度。需要创建二维数组 dp，空间是 O(n^2)","categories":[{"name":"每日LeetCode","slug":"每日LeetCode","permalink":"http://example.com/categories/%E6%AF%8F%E6%97%A5LeetCode/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"}]},{"title":"(每日LeetCode)1846. 减小和重新排列数组后的最大元素","slug":"每日LeetCode/2022-7/1846 减小和重新排列数组后的最大元素","date":"2022-07-08T00:34:00.000Z","updated":"2022-07-08T00:34:32.816Z","comments":true,"path":"2022/07/08/每日LeetCode/2022-7/1846 减小和重新排列数组后的最大元素/","link":"","permalink":"http://example.com/2022/07/08/%E6%AF%8F%E6%97%A5LeetCode/2022-7/1846%20%E5%87%8F%E5%B0%8F%E5%92%8C%E9%87%8D%E6%96%B0%E6%8E%92%E5%88%97%E6%95%B0%E7%BB%84%E5%90%8E%E7%9A%84%E6%9C%80%E5%A4%A7%E5%85%83%E7%B4%A0/","excerpt":"","text":"题目：给你一个正整数数组 arr 。请你对 arr 执行一些操作（也可以不进行任何操作），使得数组满足以下条件： arr 中 第一个 元素必须为 1 。任意相邻两个元素的差的绝对值 小于等于 1 ，也就是说，对于任意的 1 &lt;= i &lt; arr.length （数组下标从 0 开始），都满足 abs(arr[i] - arr[i - 1]) &lt;= 1 。abs(x) 为 x 的绝对值。你可以执行以下 2 种操作任意次： 减小 arr 中任意元素的值，使其变为一个 更小的正整数 。重新排列 arr 中的元素，你可以以任意顺序重新排列。请你返回执行以上操作后，在满足前文所述的条件下，arr 中可能的 最大值 。 示例： 输入：arr &#x3D; [100,1,1000]输出：3解释：一个可行的方案如下： 重新排列 arr 得到 [1,100,1000] 。 将第二个元素减小为 2 。 将第三个元素减小为 3 。现在 arr &#x3D; [1,2,3] ，满足所有条件。arr 中最大元素为 3 。 代码(cpp)：1234567891011121314151617181920212223class Solution &#123;public: int maximumElementAfterDecrementingAndRearranging(vector&lt;int&gt;&amp; arr) &#123; //将arr数组排序 sort(arr.begin(), arr.end()); //如果第一个元素不为1，则设置为1 if(arr[0] != 1) arr[0] = 1; 将最大数设置为数组第一个元素 int max = arr[0]; for(int i = 1; i &lt; arr.size(); i++)&#123; //当前的元素减去前面的元素，它们的绝对值肯定是大于0的 int temp = arr[i] - arr[i-1]; //如果绝对值大于1，则设置当前的元素为前面的元素+1 if(temp &gt; 1) arr[i] = arr[i-1]+1; //如果当前元素大于max的元素，将当前元素设置为最大数 if(arr[i] &gt; max) max = arr[i]; &#125; //返回最大数 return max; &#125; &#125;; 复杂度分析： 时间复杂度：O(nlogn)，其中 n 是数组 arr 的长度。时间复杂度即排序的复杂度。 空间复杂度：O(logn)。空间复杂度不考虑输入，因此空间复杂度主要取决于排序时产生的 O(logn) 的栈空间。","categories":[{"name":"每日LeetCode","slug":"每日LeetCode","permalink":"http://example.com/categories/%E6%AF%8F%E6%97%A5LeetCode/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"}]},{"title":"(每日LeetCode)593. 有效的正方形","slug":"每日LeetCode/2022-7/593 有效的正方形","date":"2022-07-08T00:34:00.000Z","updated":"2022-07-29T03:25:10.784Z","comments":true,"path":"2022/07/08/每日LeetCode/2022-7/593 有效的正方形/","link":"","permalink":"http://example.com/2022/07/08/%E6%AF%8F%E6%97%A5LeetCode/2022-7/593%20%E6%9C%89%E6%95%88%E7%9A%84%E6%AD%A3%E6%96%B9%E5%BD%A2/","excerpt":"","text":"题目：给定2D空间中四个点的坐标 p1, p2, p3 和 p4，如果这四个点构成一个正方形，则返回 true 。 点的坐标 pi 表示为 [xi, yi] 。输入 不是 按任何顺序给出的。 一个 有效的正方形 有四条等边和四个等角(90度角)。 示例： 输入：p1 &#x3D; [1,0], p2 &#x3D; [-1,0], p3 &#x3D; [0,1], p4 &#x3D; [0,-1]输出：true 思路：自己想出的一种很无脑的思路！ 先做一个判断，某一行或某一列是否存在三个以上的点，存在则不可能是正方形 选取其中一个最小的点，计算与其余点之间的距离。如果是正方形的话，一定有两个相等的边长，和一个较长的对角线，并且满足勾股定理。 代码(cpp)：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061class Solution &#123;public: bool judge(vector&lt;int&gt;&amp; p1, vector&lt;int&gt;&amp; p2, vector&lt;int&gt;&amp; p3, vector&lt;int&gt;&amp; p4)&#123; int count = 0; if(p1[0] == p2[0]) count++; if(p1[0] == p3[0]) count++; if(p1[0] == p4[0]) count++; //判断某行，是否存在三个点 if(count &gt;= 2) return false; count = 0; if(p1[1] == p2[1]) count++; if(p1[1] == p3[1]) count++; if(p1[1] == p4[1]) count++; //判断某列，是否存在三个点 if(count &gt;= 2) return false; return true; &#125; bool validSquare(vector&lt;int&gt;&amp; p1, vector&lt;int&gt;&amp; p2, vector&lt;int&gt;&amp; p3, vector&lt;int&gt;&amp; p4) &#123; //判断是否存在有三个点在一条线上 if(!is_duo(p1,p2,p3,p4)) return false; int n1 = p1[0] + p1[1]; int n2 = p2[0] + p2[1]; int n3 = p3[0] + p3[1]; int n4 = p4[0] + p4[1]; //选取一个最小的点作为计算与其余点之间的距离 int min_num = min(n1, n2); min_num = min(n3, min_num); min_num = min(n4, min_num); //与p1点交换，使p1点变为最小点 if(min_num == n2) p1.swap(p2); if(min_num == n3) p1.swap(p3); if(min_num == n4) p1.swap(p4); vector&lt;int&gt; nums; //计算p1点到其余三个点的距离，未取根号因为会产生小数 int num1 = pow(p1[0]-p2[0], 2) + pow(p1[1]-p2[1], 2); nums.push_back(num1); int num2 = pow(p1[0]-p3[0], 2) + pow(p1[1]-p3[1], 2); nums.push_back(num2); int num3 = pow(p1[0]-p4[0], 2) + pow(p1[1]-p4[1], 2); nums.push_back(num3); sort(nums.begin(), nums.end()); //排序，对角线大于边长 //如果存在对角线为0 if(nums[2] == 0) return false; //如果两条边长不相等 if(nums[0] != nums[1]) return false; //勾股定理，判断是否为直角 if(nums[0] + nums[1] != nums[2]) return false; return true; &#125;&#125;;","categories":[{"name":"每日LeetCode","slug":"每日LeetCode","permalink":"http://example.com/categories/%E6%AF%8F%E6%97%A5LeetCode/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"}]},{"title":"(每日LeetCode)729. 我的日程安排表 I","slug":"每日LeetCode/2022-7/729 我的日程安排表 I","date":"2022-07-05T04:50:00.000Z","updated":"2022-07-08T00:35:39.494Z","comments":true,"path":"2022/07/05/每日LeetCode/2022-7/729 我的日程安排表 I/","link":"","permalink":"http://example.com/2022/07/05/%E6%AF%8F%E6%97%A5LeetCode/2022-7/729%20%E6%88%91%E7%9A%84%E6%97%A5%E7%A8%8B%E5%AE%89%E6%8E%92%E8%A1%A8%20I/","excerpt":"","text":"题目：实现一个 MyCalendar 类来存放你的日程安排。如果要添加的日程安排不会造成 重复预订 ，则可以存储这个新的日程安排。 当两个日程安排有一些时间上的交叉时（例如两个日程安排都在同一时间内），就会产生 重复预订 。 日程可以用一对整数 start 和 end 表示，这里的时间是半开区间，即 [start, end), 实数 x 的范围为， start &lt;= x &lt; end 。 实现 MyCalendar 类： MyCalendar() 初始化日历对象。boolean book(int start, int end) 如果可以将日程安排成功添加到日历中而不会导致重复预订，返回 true。否则，返回 false 并且不要将该日程安排添加到日历中。 示例： 输入：[“MyCalendar”, “book”, “book”, “book”][[], [10, 20], [15, 25], [20, 30]]输出：[null, true, false, true] 思路：二分查找设已经插入了一些日程： $[[start_1,end_1),[start_2,end_2),[start_3,end_3)]$ 日程之间不交叉并且一定是有这样的排序： $start_1 &lt; end_1 \\leq start_2 &lt; end_2 \\leq start_3 &lt; end_3$ 如果要插入[start, end) 一定是在$end_i \\leq start&lt;end&lt; start_{i+1}$ 利用二分查找，找到恰比end大的元素：$start_{i+1}$ 再将$start_{i+1}$前面的元素$end_i$与start比较，看是否交叉。 代码(cpp)：123456789101112131415161718class MyCalendar &#123;public: //set默认的比较规则先按照first比较，如果first相同，再按照second比较 set&lt;pair&lt;int, int&gt;&gt; calendar; bool book(int start, int end) &#123; //获取比end恰好大的元素的迭代器，没有则返回迭代器end() //如果calendar没有元素，则返回迭代器begin() auto temp = calendar.lower_bound(&#123;end, 0&#125;); //如果temp为begin()说明没有元素直接插入 //如果不为begin()则与temp前面的元素的右区间比较，如果小于等于start说明没有交叉，插入 if(temp == calendar.begin() || (--temp)-&gt;second &lt;= start)&#123; calendar.insert(&#123;start, end&#125;); return true; &#125; return false; &#125;&#125;; 复杂度分析： 时间复杂度：O(nlogn), 其中 n 表示日程安排的数量。由于每次在进行预订时，都需要进行二分查找，需要的时间为 O(logn)。 空间复杂度：O(n)，其中 n 表示日程安排的数量。需要保存所有已经预订的行程。","categories":[{"name":"每日LeetCode","slug":"每日LeetCode","permalink":"http://example.com/categories/%E6%AF%8F%E6%97%A5LeetCode/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"}]},{"title":"set容器用法","slug":"C++/set容器","date":"2022-07-04T16:00:00.000Z","updated":"2022-08-15T01:16:14.261Z","comments":true,"path":"2022/07/05/C++/set容器/","link":"","permalink":"http://example.com/2022/07/05/C++/set%E5%AE%B9%E5%99%A8/","excerpt":"","text":"set容器：所有元素都会在插入时自动排序，底层结构采用二叉树实现。 set和multiset区别： set不可以插入重复数据，而multiset可以 set插入数据的同时会返回插入结果，表示插入是否成功 multiset不会检测数据，因此可以插入重复数据 set容器的使用： 头文件： 12#include&lt;set&gt; using namespace std; 构造函数： 构造函数 解释 set() 默认构造函数 set(const set &amp;st) 拷贝构造函数 成员函数： 成员函数 解释 void insert(T key) 插入key void emplace(T key) 插入key，比insert()效率高 erase() 删除 void clear() 清空 bool find(T key) 查找 int count(T key) 统计 int size() 获取大小 bool empty() 是否为空 void swap(set &amp;st) 交换 iterator lower_bound(T key) 如果set容器中没有元素，则返回迭代器begin()；如果set容器中存在元素，则返回恰好比key大的元素的迭代器，不存在则返回迭代器end() 自定义数据类型排序 set&lt;pair&lt;int,int&gt;&gt; set默认的比较规则先按照first比较，如果first相同，再按照second 比较。","categories":[{"name":"C++","slug":"C","permalink":"http://example.com/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"},{"name":"容器","slug":"容器","permalink":"http://example.com/tags/%E5%AE%B9%E5%99%A8/"},{"name":"STL","slug":"STL","permalink":"http://example.com/tags/STL/"}]},{"title":"(每日LeetCode)1200. 最小绝对差","slug":"每日LeetCode/2022-7/1200 最小绝对差","date":"2022-07-03T23:54:00.000Z","updated":"2022-07-08T00:36:23.299Z","comments":true,"path":"2022/07/04/每日LeetCode/2022-7/1200 最小绝对差/","link":"","permalink":"http://example.com/2022/07/04/%E6%AF%8F%E6%97%A5LeetCode/2022-7/1200%20%E6%9C%80%E5%B0%8F%E7%BB%9D%E5%AF%B9%E5%B7%AE/","excerpt":"","text":"题目：给你个整数数组 arr，其中每个元素都 不相同。 请你找到所有具有最小绝对差的元素对，并且按升序的顺序返回。 示例：示例1： 输入：arr &#x3D; [4,2,1,3]输出：[[1,2],[2,3],[3,4]] 示例2： 输入：arr &#x3D; [1,3,6,10,15]输出：[[1,3]] 思路：先将arr数组排序 再遍历arr数组，如果找到有比min更小的差值，将min改为该差值，将dp数组之前记录的数据清空(因为之前记录的都是差值大的)，重新插入差值更小的数据。 代码(cpp)：123456789101112131415161718192021222324class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; minimumAbsDifference(vector&lt;int&gt;&amp; arr) &#123; //将arr数组排序 sort(arr.begin(),arr.end()); int min = INT_MAX; vector&lt;vector&lt;int&gt;&gt; dp; for(int i = 1; i &lt; arr.size(); i++)&#123; //当前的差值 int temp = arr[i]-arr[i-1]; if(temp &lt; min)&#123; min = temp; //将dp数组清空 dp.clear(); //重新插入新的差值小的数据 dp.push_back(&#123;arr[i-1],arr[i]&#125;); &#125; else if(temp == min)&#123; dp.push_back(&#123;arr[i-1],arr[i]&#125;); &#125; &#125; return dp; &#125;&#125;; 复杂度分析： 时间复杂度：O(nlogn)，其中 n 是数组 arr 的长度。排序需要的时间为 O(nlogn)，遍历需要的是时间为 O(n)，因此总时间复杂度为 O(nlogn)。 空间复杂度：O(logn)，即为排序需要使用的栈空间。这里不计入返回值需要使用的空间。","categories":[{"name":"每日LeetCode","slug":"每日LeetCode","permalink":"http://example.com/categories/%E6%AF%8F%E6%97%A5LeetCode/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"}]},{"title":"(每日LeetCode)556. 下一个更大元素 III","slug":"每日LeetCode/2022-7/556 下一个更大元素 III","date":"2022-07-03T04:00:00.000Z","updated":"2022-07-08T00:35:35.528Z","comments":true,"path":"2022/07/03/每日LeetCode/2022-7/556 下一个更大元素 III/","link":"","permalink":"http://example.com/2022/07/03/%E6%AF%8F%E6%97%A5LeetCode/2022-7/556%20%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%9B%B4%E5%A4%A7%E5%85%83%E7%B4%A0%20III/","excerpt":"","text":"题目：给你一个正整数 n ，请你找出符合条件的最小整数，其由重新排列 n 中存在的每位数字组成，并且其值大于 n 。如果不存在这样的正整数，则返回 -1 。 注意 ，返回的整数应当是一个 32 位整数 ，如果存在满足题意的答案，但不是 32 位整数 ，同样返回 -1。 示例：示例 1： 输入：n &#x3D; 12324321输出：12331224 示例 2： 输入：n &#x3D; 21输出：-1 思路：以n = 12324321为例 ①.pos1指针从后往前遍历，找到第pos1位置的数比后面的数小的位置，pos1记录位置 1 2 3 2 4 3 2 1 $\\leftarrow\\Uparrow$pos1 2与1比较，2大，pos1向左移 循环直到： 1 2 3 2 4 3 2 1 $\\leftarrow\\Uparrow$pos1 2与4比较，2小，记录pos1的位置 ②.再定义pos2指针，从后往前遍历，找到比pos1位置后面的数中，有比pos1位置的数大的数，用pos2记录位置 1 2 3 2 4 3 2 1 $\\Uparrow$pos1 $\\leftarrow\\Uparrow$pos2 pos1大于pos2，pos2指针左移 循环直到： 1 2 3 2 4 3 2 1 $\\Uparrow$pos1 $\\leftarrow\\Uparrow$pos2 pos1小于pos2，记录指针pos2位置 ③.交换pos1和pos2的位置 1 2 3 3 4 2 2 1 ④.将pos1位置后面的数进行反转 1 2 3 3 1 2 2 4 结果：12331224 代码(cpp)：12345678910111213141516171819202122232425262728class Solution &#123;public: int nextGreaterElement(int n) &#123; //将n转换成字符串 string num = to_string(n); int pos1 = num.size()-2; //从后往前遍历，找到前面的数小于后面的数，前面数的位置 while(pos1 &gt;= 0 &amp;&amp; num[pos1] &gt;= num[pos1+1])&#123; pos1--; &#125; //遍历到字符串第0个位置，还没有小于的数，则不存在 if(pos1 &lt; 0) return -1; int pos2 = num.size()-1; //从后往前遍历，找到有比pos1位置的数小的数，返回pos2位置 while(pos2 &gt; pos1 &amp;&amp; num[pos1] &gt;= num[pos2])&#123; pos2--; &#125; //交换两个位置的数 swap(num[pos1],num[pos2]); //将pos1后面的字符串反转 reverse(num.begin() + pos1 + 1, num.end()); //防止溢出，先将temp转换成long型 long temp = stol(num); //如果超出int的范围，返回-1 if(temp &gt; INT_MAX) return -1; return temp; &#125;&#125;; 复杂度分析： 时间复杂度：O(logn)。 空间复杂度：O(logn)。","categories":[{"name":"每日LeetCode","slug":"每日LeetCode","permalink":"http://example.com/categories/%E6%AF%8F%E6%97%A5LeetCode/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"}]},{"title":"(每日LeetCode)871. 最低加油次数","slug":"每日LeetCode/2022-7/871 最低加油次数","date":"2022-07-02T07:36:00.000Z","updated":"2022-07-08T00:35:45.486Z","comments":true,"path":"2022/07/02/每日LeetCode/2022-7/871 最低加油次数/","link":"","permalink":"http://example.com/2022/07/02/%E6%AF%8F%E6%97%A5LeetCode/2022-7/871%20%E6%9C%80%E4%BD%8E%E5%8A%A0%E6%B2%B9%E6%AC%A1%E6%95%B0/","excerpt":"","text":"题目：汽车从起点出发驶向目的地，该目的地位于出发位置东面 target 英里处。 沿途有加油站，每个 station[i] 代表一个加油站，它位于出发位置东面 station[i][0] 英里处，并且有 station[i][1]升汽油。 假设汽车油箱的容量是无限的，其中最初有startFuel升燃料。它每行驶 1 英里就会用掉 1 升汽油。 当汽车到达加油站时，它可能停下来加油，将所有汽油从加油站转移到汽车中。 为了到达目的地，汽车所必要的最低加油次数是多少？如果无法到达目的地，则返回 -1 。 注意：如果汽车到达加油站时剩余燃料为 0，它仍然可以在那里加油。如果汽车到达目的地时剩余燃料为 0，仍然认为它已经到达目的地。 示例：示例1： 输入：target &#x3D; 100, startFuel &#x3D; 1, stations &#x3D; [[10,100]]输出：-1解释：我们无法抵达目的地，甚至无法到达第一个加油站。 示例2： 输入：target &#x3D; 100, startFuel &#x3D; 10, stations &#x3D; [[10,60],[20,30],[30,30],[60,40]]输出：2解释：我们出发时有 10 升燃料。我们开车来到距起点 10 英里处的加油站，消耗 10 升燃料。将汽油从 0 升加到 60 升。然后，我们从 10 英里处的加油站开到 60 英里处的加油站（消耗 50 升燃料），并将汽油从 10 升加到 50 升。然后我们开车抵达目的地。我们沿途在1两个加油站停靠，所以返回 2 。 思路： 一、回溯法代码(cpp)：123456789101112131415161718192021222324252627282930class Solution &#123;public: int def(vector&lt;vector&lt;int&gt;&gt;&amp; stations,int cur_station, int begin, int&amp; end, int oil)&#123; //到达目的地 if(oil+begin &gt;= end) return 0; //油量不够到达目的地 if(cur_station+1 == stations.size() &amp;&amp; oil+begin &lt; end)&#123; return -1; &#125; //油量不够到达下一个加油站 if(cur_station+1 &lt; stations.size() &amp;&amp; oil+begin &lt; stations[cur_station+1][0])&#123; return -1; &#125; int ans = INT_MAX; for(int i = cur_station+1; i &lt; stations.size(); i++)&#123; if(stations[i][0] &lt;= begin+oil)&#123; int temp = def(stations, i, stations[i][0] ,end ,oil+begin-stations[i][0]+stations[i][1]); if(temp != -1 &amp;&amp; ans &gt; temp+1) ans = temp+1; &#125; &#125; if(ans == INT_MAX) ans = -1; return ans; &#125; int minRefuelStops(int target, int startFuel, vector&lt;vector&lt;int&gt;&gt;&amp; stations) &#123; //出发地没有加油站，第一个加油站编号为0，所以初始化为-1 return def(stations, -1, 0, target, startFuel); &#125;&#125;; 运行超时 二、贪心思路：如果不需要加油就往前走，当不够到达下一个加油站或目的地，就从之前走到过的加油站之中选择汽油量最多的加油站进行补充汽油。 以此往复，到达目的地。 如果所有加油站的汽油都被加完，并且没到达目的地，则不可能到达。 代码(cpp)：1234567891011121314151617181920212223242526272829303132class Solution &#123;public: int minRefuelStops(int target, int startFuel, vector&lt;vector&lt;int&gt;&gt;&amp; stations) &#123; priority_queue&lt;int&gt; pq; int count = 0; //初始化加油次数 int begin = 0; //初始化路程 int cur_fuel = startFuel;//初始化车的汽油量 int cur_distance; //表示当前的路程 for (int i = 0; i &lt;= stations.size(); i++) &#123; if(i &lt; stations.size()) cur_distance = stations[i][0]; else cur_distance = target; //(cur_distance - begin)：表示第i-1个加油站到第i个加油站之间的路程，cur_fuel为到第i个加油站时剩余的油量 cur_fuel -= cur_distance - begin; //如果油量为负数，说明需要从第i个加油站，之前的加油站之中选择加油量最多的加油站，进行补充汽油 while (cur_fuel &lt; 0 &amp;&amp; !pq.empty()) &#123; cur_fuel += pq.top();//选择汽油量最多的加油站补充 pq.pop(); count++;//加油次数加1 &#125; //都已经把之前的加油站的汽油都补充了，还是负数说明无法到达下一个加油站或目的地 if (cur_fuel &lt; 0) &#123; return -1; &#125; if (i &lt; stations.size()) &#123; //将第i个加油站的汽油量记录，现在不需要加油，等以后缺油再加 pq.emplace(stations[i][1]); begin = cur_distance;//更新路程 &#125; &#125; return count; &#125;&#125;; 复杂度分析： 时间复杂度：O(nlogn)，其中 n 是数组 stations 的长度。需要遍历数组 stations 一次，每个加油站的汽油量最多添加到优先队列和从优先队列中移除各一次，每次优先队列的操作需要 O(logn) 的时间，因此时间复杂度是 O(nlogn)。 空间复杂度：O(n)，其中 n 是数组 stations 的长度。优先队列需要 O(n) 的空间。","categories":[{"name":"每日LeetCode","slug":"每日LeetCode","permalink":"http://example.com/categories/%E6%AF%8F%E6%97%A5LeetCode/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"}]},{"title":"vector容器用法","slug":"C++/vecter容器","date":"2022-06-30T09:00:00.000Z","updated":"2022-07-05T03:52:02.168Z","comments":true,"path":"2022/06/30/C++/vecter容器/","link":"","permalink":"http://example.com/2022/06/30/C++/vecter%E5%AE%B9%E5%99%A8/","excerpt":"","text":"vector是什么？vector是一个能够存放任意类型的动态数组。 vector实现动态增长的原理：vector的原理就是动态数组。当插入新元素的时候，如果空间不足，那么vector会重新申请更大的一块空间，将原空间数据拷贝到新空间，释放旧空间数据，再把新元素插入新申请空间。 需要导入头文件： 12#include&lt;vector&gt;using namespace std; 构造函数： 构造函数 解释 vector() 创建一个空的vector vector(int size) 创建一个vector,元素个数为size，且值均为0(默认为0) vector(int size, T value) 创建一个vector，元素个数为size,且值均为value vector(const vector&amp; v) 另一个vector容器拷贝到这个vector中 vector(iterator begin(), iterator end()) 另一个[begin,end)区间内的数组元素的复制这个vector中 成员函数： 插入函数 解释 void push_back(const T&amp; x) 容器尾部插入一个元素X void emplace_back(const T&amp; x) 容器尾部插入一个元素X，比push_back()效率高 iterator insert(iterator it,const T&amp; x) 容器中迭代器指向元素的前面插入一个元素x iterator insert(iterator it,int n,const T&amp; x) 容器中迭代器指向元素的前面插入n个相同的元素x iterator insert(iterator it,const_iterator first,const_iterator last) 向量中迭代器指向元素的前面插入另一个相同类型的vector容器的[first,last)间的数据 删除函数 解释 iterator erase(iterator it) 删除容器中迭代器指向的元素 iterator erase(iterator first,iterator last) 删除容器中[first,last)中的元素 void pop_back() 删除容器中最后一个元素 void clear() 清空容器中所有元素 遍历函数 解释 T at(int pos) 返回pos位置的元素(第一个位置为0) T front() 返回首元素 T back() 返回尾元素 iterator begin() 返回vector容器中指向的第一个元素的迭代器 iterator end() 返回vector容器中指向最后一个元素的下一个位置的迭代器 reverse_iterator rbegin() 反向迭代器，指向容器中最后一个元素 reverse_iterator rend() 反向迭代器，指向容器第一个元素前面的位置 大小函数 解释 int size() 返回vector容器中元素的个数 int capacity() 返回当前vector容器所能容纳的最大容量 int max_size() 返回vector容器的最大可允许的容量 void resize(int size) 更改vector容器的元素的个数为size void reserve(int capacity) 更改vector容器的容量为capacity 赋值函数 解释 vector&amp; operator&#x3D; 将右边vector容器的元素拷贝到左边vector容器中 void assign(int n,const T&amp; x) 设置容器中前n个元素的值为x void assign(const_iterator first,const_iterator last) 将另一个vector容器中[first,last)中元素设置成当前vector容器的元素 其他函数 解释 bool empty() 判断向量是否为空，若为空，则返回真 void swap(vector&amp; v) 将两个同类型vector容器的元素互换 vector的遍历：123for(int i = 0; i &lt; v.size(); i++)&#123; cout &lt;&lt; v[i] &lt;&lt; endl;&#125; 123for (int i = 0; i &lt; v.size(); i++)&#123; cout &lt;&lt; v1.at(i) &lt;&lt; endl;&#125; 123for (vector&lt;int&gt;::iterator it = v.begin(); it != v.end(); it++)&#123; cout &lt;&lt; *it &lt;&lt; endl;&#125; 123for (auto it = v.begin(); it != v.end(); it++)&#123; cout &lt;&lt; *it &lt;&lt; endl;&#125;","categories":[{"name":"C++","slug":"C","permalink":"http://example.com/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"},{"name":"容器","slug":"容器","permalink":"http://example.com/tags/%E5%AE%B9%E5%99%A8/"},{"name":"STL","slug":"STL","permalink":"http://example.com/tags/STL/"}]},{"title":"(每日LeetCode)1175. 质数排列","slug":"每日LeetCode/2022-6/1175 质数排列","date":"2022-06-30T03:09:00.000Z","updated":"2022-07-08T00:35:49.057Z","comments":true,"path":"2022/06/30/每日LeetCode/2022-6/1175 质数排列/","link":"","permalink":"http://example.com/2022/06/30/%E6%AF%8F%E6%97%A5LeetCode/2022-6/1175%20%E8%B4%A8%E6%95%B0%E6%8E%92%E5%88%97/","excerpt":"","text":"题目：请你帮忙给从 1 到 n 的数设计排列方案，使得所有的「质数」都应该被放在「质数索引」（索引从 1 开始）上；你需要返回可能的方案总数。由于答案可能会很大，所以请你返回答案 模 mod $10^9$ + 7 之后的结果即可。 示例： 输入：n &#x3D; 5输出：12 解释： 先看质数定义：一个大于1的自然数，除了1和它自身外，不能被其他自然数整除的数叫做质数。(1不是质数) 用红色标记质数： 1 2 3 4 5 题目的意思是将质数和非质数各分一组，进行排序一共有多少种可能： m个数排列m个位置，全排列公式：$A^m_m&#x3D;m!$ $A^3_3$为质数的所有排列次数 $A^2_2$为非质数的所有排列次数 并且每有一个质数的排列组合就有$A^2_2$次非质数的排列： 总数：$A^3_3 \\times A^2_2&#x3D;3! \\times 2!&#x3D;12$ 思路：遍历数组判断是否为质数，记录质数的个数p，非质数个数为n-p 运用公式求出总数：$A^p_p \\times A^{n-p}_{n-p}&#x3D;p! \\times (n-p)!$ 代码(cpp)：123456789101112131415161718192021222324252627282930313233343536373839class Solution &#123;public: int mod = pow(10,9)+7; //判断是否为质数 bool is_prime(int n)&#123; //从2开始 for(int i = 2; i*i &lt;= n;i++)&#123; //模运算为0，不是质数 if(n%i == 0)&#123; return false; &#125; &#125; return true; &#125; //n!运算 Long类型防止溢出 long factorial(int n)&#123; long sum = 1; for(int i = 2; i &lt;= n; i++)&#123; sum *=i; sum = sum%mod; &#125; return sum; &#125; int numPrimeArrangements(int n) &#123; int prime_num = 0; //从2开始，1不是质数 for(int i = 2; i &lt;= n; i++)&#123; if(is_prime(i))&#123; prime_num++; &#125; &#125; //n!*(n-p)! long result = (factorial(prime_num)*factorial(n-prime_num))%mod; return (int)result; &#125;&#125;; 复杂度分析： 时间复杂度：O($n^{3&#x2F;2}$)。求 n 个数中质数个数的时间复杂度为 O($n^{3&#x2F;2}$)，阶乘的时间复杂度为 O(n)，总的时间复杂度为 O($n^{3&#x2F;2}$)。 空间复杂度：O(1)O(1)，只使用了常数空间。","categories":[{"name":"每日LeetCode","slug":"每日LeetCode","permalink":"http://example.com/categories/%E6%AF%8F%E6%97%A5LeetCode/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"}]},{"title":"(每日LeetCode)535. TinyURL的加密与解密","slug":"每日LeetCode/2022-6/535 TinyURL的加密与解密","date":"2022-06-28T23:41:00.000Z","updated":"2022-07-02T07:51:52.081Z","comments":true,"path":"2022/06/29/每日LeetCode/2022-6/535 TinyURL的加密与解密/","link":"","permalink":"http://example.com/2022/06/29/%E6%AF%8F%E6%97%A5LeetCode/2022-6/535%20TinyURL%E7%9A%84%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%A7%A3%E5%AF%86/","excerpt":"","text":"题目：TinyURL 是一种 URL 简化服务， 比如：当你输入一个 URL https://leetcode.com/problems/design-tinyurl 时，它将返回一个简化的URL http://tinyurl.com/4e9iAk 。请你设计一个类来加密与解密 TinyURL 。 加密和解密算法如何设计和运作是没有限制的，你只需要保证一个 URL 可以被加密成一个 TinyURL ，并且这个 TinyURL 可以用解密方法恢复成原本的 URL 。 实现 Solution 类： Solution() 初始化 TinyURL 系统对象。String encode(String longUrl) 返回 longUrl 对应的 TinyURL 。String decode(String shortUrl) 返回 shortUrl 原本的 URL 。题目数据保证给定的 shortUrl 是由同一个系统对象加密的。 示例： 输入：url &#x3D; “https://leetcode.com/problems/design-tinyurl“输出：”https://leetcode.com/problems/design-tinyurl“ 解释：Solution obj &#x3D; new Solution();string tiny &#x3D; obj.encode(url); &#x2F;&#x2F; 返回加密后得到的 TinyURL 。string ans &#x3D; obj.decode(tiny); &#x2F;&#x2F; 返回解密后得到的原本的 URL 。 思路：使用自增id作为longUrl的键，存入unordered_map容器中 根据id来获取对应的longUrl 代码(cpp)：1234567891011121314151617181920212223class Solution &#123;private: unordered_map&lt;int, string&gt; map; int id;public: Solution()&#123; id = 0; //初始化id &#125; string encode(string longUrl) &#123; id++; map[id] = longUrl; //http://tinyurl.com/1 return &quot;http://tinyurl.com/&quot;+to_string(id); &#125; string decode(string shortUrl) &#123; //substr(int pos)：获取pos位置起的所有字符串 //stoi(string str)：将string类型的字符串转换成int类型的整数 int t_id = stoi(shortUrl.substr(19)); return map[t_id]; &#125;&#125;; 复杂度分析： 时间复杂度： Encode 函数：O(n)O(n)，其中 n 是字符串 longUrl 的长度。 Decode 函数：O(1)O(1)。我们把 shortUrl 当成有限长度的字符串看待。 空间复杂度： Encode 函数：O(n)O(n)。保存字符串 longUrl 需要 O(n)O(n) 的空间。 Decode 函数：O(1)O(1)。","categories":[{"name":"每日LeetCode","slug":"每日LeetCode","permalink":"http://example.com/categories/%E6%AF%8F%E6%97%A5LeetCode/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"}]},{"title":"(每日LeetCode)324. 摆动排序 II","slug":"每日LeetCode/2022-6/324 摆动排序 II","date":"2022-06-28T02:30:00.000Z","updated":"2022-07-08T00:35:05.704Z","comments":true,"path":"2022/06/28/每日LeetCode/2022-6/324 摆动排序 II/","link":"","permalink":"http://example.com/2022/06/28/%E6%AF%8F%E6%97%A5LeetCode/2022-6/324%20%E6%91%86%E5%8A%A8%E6%8E%92%E5%BA%8F%20II/","excerpt":"","text":"题目：给你一个整数数组 nums，将它重新排列成 nums[0] &lt; nums[1] &gt; nums[2] &lt; nums[3]... 的顺序。 你可以假设所有输入数组都可以得到满足题目要求的结果。 示例： 输入：nums &#x3D; [1,5,2,4,3,6]输出：[3,6,2,5,1,4] 思路：双指针法将数组nums按从小到大排列： 1 2 3 4 5 6 $\\leftarrow\\Uparrow$left $\\leftarrow\\Uparrow$right 把排序好的数组分成两部分，left指针位于数组中间，right指针位于数组末尾， 将left和right当前位置的元素依次打印后，left和right指针左移，直至结束 输出：[3, 6, 2, 5, 1, 4] 代码(cpp)：123456789101112131415161718192021class Solution &#123;public: void wiggleSort(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); //获取数组的元素个数 int left = n/2-1; //定义左指针 int right = n-1; //定义右指针 vector&lt;int&gt; new_nums(nums); sort(new_nums.begin(),new_nums.end()); //将新数组排序 for(int i=0;i&lt;n;i++)&#123; if(i%2 == 0)&#123; //偶数位置插入left指针的元素，奇数位置插入right指针的元素 nums[i] = a[left]; left--; &#125; else&#123; nums[i] = a[right]; rigth--; &#125; &#125; &#125;&#125;; 复杂度分析： 时间复杂度：O(nlogn)，排序所需的时间复杂度是O(nlogn)，插入O(n)，整体O(nlogn) 空间复杂度：O(n)，需要额外的空间存放排序的元素。","categories":[{"name":"每日LeetCode","slug":"每日LeetCode","permalink":"http://example.com/categories/%E6%AF%8F%E6%97%A5LeetCode/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"}]},{"title":"(每日LeetCode)剑指 Offer II 091. 粉刷房子","slug":"每日LeetCode/2022-6/剑指 Offer II 091 粉刷房子","date":"2022-06-25T02:00:00.000Z","updated":"2022-07-08T00:34:56.580Z","comments":true,"path":"2022/06/25/每日LeetCode/2022-6/剑指 Offer II 091 粉刷房子/","link":"","permalink":"http://example.com/2022/06/25/%E6%AF%8F%E6%97%A5LeetCode/2022-6/%E5%89%91%E6%8C%87%20Offer%20II%20091%20%E7%B2%89%E5%88%B7%E6%88%BF%E5%AD%90/","excerpt":"","text":"题目：假如有一排房子，共 n 个，每个房子可以被粉刷成红色、蓝色或者绿色这三种颜色中的一种，你需要粉刷所有的房子并且使其相邻的两个房子颜色不能相同。 当然，因为市场上不同颜色油漆的价格不同，所以房子粉刷成不同颜色的花费成本也是不同的。每个房子粉刷成不同颜色的花费是以一个 n x 3 的正整数矩阵 costs来表示的。 例如，costs[0][0] 表示第 0 号房子粉刷成红色的成本花费；costs[1][2] 表示第 1 号房子粉刷成绿色的花费，以此类推。请计算出粉刷完所有房子最少的花费成本。 示例： 输入: costs &#x3D; [[17,2,17],[16,16,5],[14,3,19]]输出: 10解释: 将 0 号房子粉刷成蓝色，1 号房子粉刷成绿色，2 号房子粉刷成蓝色。 最少花费: 2 + 5 + 3 &#x3D; 10。 1.递归代码(cpp)：12345678910111213141516171819202122232425262728293031class Solution &#123;public: int def(vector&lt;vector&lt;int&gt;&gt;&amp; costs, int pos, int n, vector&lt;vector&lt;int&gt;&gt; flag) &#123; //到达最后，没有房子了，退出 if (pos == n) return 0; int ans = INT_MAX; //依次选择三种颜色 for (int i = 0; i &lt; 3; i++) &#123; int temp = INT_MAX; vector&lt;vector&lt;int&gt;&gt; temp_flag(flag); //粉刷第一个房子，无需看前面房子的颜色，因为前面没有房子。 if (pos == 0) &#123; temp_flag[pos][i] = -1; temp = def(costs, pos + 1, n, temp_flag) + costs[pos][i]; &#125; //粉刷墙，要看前面用了什么颜色 else if (flag[pos - 1][i] != -1) &#123; //将这个房子的颜色标记 temp_flag[pos][i] = -1; temp = def(costs, pos + 1, n, temp_flag) + costs[pos][i]; &#125; //选择花费最少的金额 ans = min(ans, temp); &#125; return ans; &#125; int minCost(vector&lt;vector&lt;int&gt;&gt;&amp; costs) &#123; return def(costs, 0, costs.size(), costs); &#125;&#125;; 采用递归的方法，提交后，结果执行超时。 2.动态规划$$Red[pos][0]&#x3D;\\begin{cases}cost[0][0] &amp; pos &#x3D; 0; \\min(Green[pos+1][1],Blue[pos+1][2]) + costs[pos][0] &amp; pos&gt;0\\end{cases} \\$$ $$Green[pos][1]&#x3D;\\begin{cases}cost[0][1] &amp; pos &#x3D; 0; \\min(Red[pos+1][0],Blue[pos+1][2]) + costs[pos][1] &amp; pos&gt;0\\end{cases} \\$$ $$Blue[pos][2]&#x3D;\\begin{cases}cost[0][2] &amp; pos &#x3D; 0; \\min(Red[pos+1][0],Green[pos+1][1]) + costs[pos][2] &amp; pos&gt;0\\end{cases}$$ 画出动态规划图，以示例为例： costs = [[17,2,17],[16,16,5],[14,3,19]] 颜色\\pos 0 1 2 Red(0) 17 18 21 Green(1) 2 33 10 Blue(2) 17 7 37 $$mincost &#x3D; min(dp[2][0],dp[2][1],dp[2][2])$$ 代码(cpp)：123456789101112131415161718192021class Solution &#123;public: int minCost(vector&lt;vector&lt;int&gt;&gt;&amp; costs) &#123; int n = costs.size(); vector&lt;int&gt; red(n, 0); vector&lt;int&gt; blue(n, 0); vector&lt;int&gt; green(n, 0); // 初始化 red[0] = costs[0][0]; blue[0] = costs[0][1]; green[0] = costs[0][2]; for (int i = 1; i &lt; n; ++i) &#123; red[i] = min(blue[i - 1], green[i - 1]) + costs[i][0]; blue[i] = min(red[i - 1], green[i - 1]) + costs[i][1]; green[i] = min(red[i - 1], blue[i - 1]) + costs[i][2]; &#125; return min(red[n - 1], min(blue[n - 1], green[n - 1])); &#125;&#125;; 复杂度分析 时间复杂度：O(n)，其中 n 是房子个数。需要遍历全部房子一次，由于颜色数量固定是三种，因此对于每个房子计算粉刷房子的最小花费成本的时间是 O(1)，总时间复杂度是 O(n)。 空间复杂度：O(1)。使用空间优化的方法，只需要维护一个长度为 3 的数组，空间复杂度是 O(1)。","categories":[{"name":"每日LeetCode","slug":"每日LeetCode","permalink":"http://example.com/categories/%E6%AF%8F%E6%97%A5LeetCode/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"}]},{"title":"(每日LeetCode)515. 在每个树行中找最大值(中等)","slug":"每日LeetCode/2022-6/515 在每个树行中找最大值","date":"2022-06-24T01:04:00.000Z","updated":"2022-07-08T00:35:14.972Z","comments":true,"path":"2022/06/24/每日LeetCode/2022-6/515 在每个树行中找最大值/","link":"","permalink":"http://example.com/2022/06/24/%E6%AF%8F%E6%97%A5LeetCode/2022-6/515%20%E5%9C%A8%E6%AF%8F%E4%B8%AA%E6%A0%91%E8%A1%8C%E4%B8%AD%E6%89%BE%E6%9C%80%E5%A4%A7%E5%80%BC/","excerpt":"","text":"题目：给定一棵二叉树的根节点 root ，请找出该二叉树中每一层的最大值。 示例： 输入: root &#x3D; [1,3,2,5,3,null,9]输出: [1,3,9] 思路：深度优先搜索我们采用树的先序遍历，来进行深度优先搜索，并用pos来记录当前树的高度，就可以通过pos高度来判断是否在同一层，并且是否更新此高度的最大值。 代码(cpp)：123456789101112131415161718192021222324252627class Solution &#123;public: void dfs(TreeNode* root, vector&lt;int&gt;&amp; result, int pos)&#123; //如果该结点为空，则退出 if(root == nullptr) return; if(result.size() == pos)&#123; //数组的大小小于高度，大小需要加1 result.push_back(root-&gt;val); &#125; else&#123; //判断该层的某个结点，与之前记录的比较大小 result[pos] = max(result[pos], root-&gt;val); &#125; //遍历左子树，高度+1 dfs(root-&gt;left, result, pos+1); //遍历右子树，高度+1 dfs(root-&gt;right, result, pos+1); &#125; vector&lt;int&gt; largestValues(TreeNode* root) &#123; vector&lt;int&gt; result; dfs(root, result, 0); return result; &#125;&#125;; 复杂度分析 时间复杂度：O(n)，其中 n 为二叉树节点个数。二叉树的遍历中每个节点会被访问一次且只会被访问一次。 空间复杂度：O(pos)。其中 pos 表示二叉树的高度。递归函数需要栈空间，而栈空间取决于递归的深度，因此空间复杂度等价于二叉树的高度。","categories":[{"name":"每日LeetCode","slug":"每日LeetCode","permalink":"http://example.com/categories/%E6%AF%8F%E6%97%A5LeetCode/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"}]},{"title":"(每日LeetCode)30. 串联所有单词的子串","slug":"每日LeetCode/2022-6/30 串联所有单词的子串","date":"2022-06-23T03:53:00.000Z","updated":"2022-07-08T00:35:01.595Z","comments":true,"path":"2022/06/23/每日LeetCode/2022-6/30 串联所有单词的子串/","link":"","permalink":"http://example.com/2022/06/23/%E6%AF%8F%E6%97%A5LeetCode/2022-6/30%20%E4%B8%B2%E8%81%94%E6%89%80%E6%9C%89%E5%8D%95%E8%AF%8D%E7%9A%84%E5%AD%90%E4%B8%B2/","excerpt":"","text":"题目：给定一个字符串s和一些长度相同的单词words。找出s中恰好可以由words中所有单词串联形成的子串的起始位置。 注意子串要与words中的单词完全匹配，中间不能有其他字符，但不需要考虑words中单词串联的顺序。 示例： 输入：s &#x3D; “barfoofoobarthefoobarman”, words &#x3D; [“bar”,”foo”,”the”]输出：[6,9,12] 输出返回字串的第一个字符在s中的位置 第一个字串：barfoofoobarthefoobarman 6 第二个字串：barfoofoobarthefoobarman 9 第三个字符：barfoofoobarthefoobarman 12 思路：滑动窗口 word_len为每个单词的长度，因为每个单词的长度都相同； word_num为words数组中单词的个数； total_len为words数组中所有的单词的总长度； map来记录words数组中每个单词的个数； t_map遍历s时用来记录； 左指针left和右指针right用来当作左右边界； count用来统计已经匹配单词的个数，如果count == word_num，就证明匹配成功； 遍历s时无需一个一个字符的遍历，可以一个一个单词的遍历，right += word_len； 如果截取的单词map中不存在，则之前记录的全部无效，清空t_map和count； 如果某个单词在t_map中的个数大于map中的个数，就需要删除匹配的多余的单词，就需要删除窗口中第一个单词，直到某个单词出现的次数小于map中的个数 代码(cpp)：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364class Solution &#123;public: vector&lt;int&gt; findSubstring(string s, vector&lt;string&gt;&amp; words) &#123; //用来存放结果 vector&lt;int&gt; result; //判断s和words是否为空，如果其中有一个为空，则返回空数组 if(s.empty()||words.empty())&#123; return result; &#125; int word_len = words[0].size(); //一个单词的长度（每个单词长度都相同） int word_num = words.size(); // 单词的总个数 int total_len = word_len*word_num; // 全部单词的长度 //建立单词-&gt;单词个数的映射 unordered_map&lt;string, int&gt; map; //统计每个单词的个数 for(auto &amp;word : words)&#123; //map[key]:返回key值所对应的value值，如果不存在key值，则会使用该key值向当前容器中插入一个新value值为 0 map[word]++; //等价于 map[word] += 1 &#125; for(int i = 0; i&lt; word_len; i++)&#123; //left和right用来表示窗口的左右边界 int left = i; int right = i; //count用来统计已经匹配的单词个数 int count = 0; unordered_map&lt;string, int&gt; t_map; //开始滑动窗口 //right右边界依次累加单词的长度，直到超过s的长度停止循环 while(right + word_len &lt;= s.size())&#123; //substr(pos, n):从第pos的位置开始截取n个字符获取单词 string word = s.substr(right, word_len); right += word_len; //right跳到下一个单词 //count(key):在容器中查找以key键的键值对的个数。如果为0，说明此单词word在words数组中不存在。 if(map.count(word) == 0)&#123; count = 0; //清空之前统计的个数 left = right; //将左指针left移动到右指针right位置上重新开始 t_map.clear(); //之前匹配的单词没用了，清空t_map中的元素 &#125; //如果不为0，说明此单词word在words数组中存在。 else&#123; count++; //统计个数加1 t_map[word]++;// word所对应的个数加1 //t_map中的word对应的个数大于map的word对应的个数，说明匹配到多余的单词了 while(t_map[word]&gt; map[word])&#123; //获取窗口的第一个单词 string t_word = s.substr(left, word_len); //将t_word这个单词对应的个数减1 //并非是那个大于map中个数的单词 t_map[t_word]--; count--; //统计个数减1 left += word_len;//将左指针跳到下一个 &#125; //如果count等于单词的个数说明匹配成功，将左指针位置记录 if(count == word_num)&#123; result.push_back(left); &#125; &#125; &#125; &#125; return result; &#125;&#125;; 复杂度分析 时间复杂度：O(ls×n)，其中 ls 是输入 s 的长度，n 是 words 中每个单词的长度。需要做 n 次滑动窗口，每次需要遍历一次 s。","categories":[{"name":"每日LeetCode","slug":"每日LeetCode","permalink":"http://example.com/categories/%E6%AF%8F%E6%97%A5LeetCode/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"}]},{"title":"(每日LeetCode)513. 找树左下角的值","slug":"每日LeetCode/2022-6/513 找树左下角的值","date":"2022-06-22T03:11:00.000Z","updated":"2022-07-08T00:35:09.778Z","comments":true,"path":"2022/06/22/每日LeetCode/2022-6/513 找树左下角的值/","link":"","permalink":"http://example.com/2022/06/22/%E6%AF%8F%E6%97%A5LeetCode/2022-6/513%20%E6%89%BE%E6%A0%91%E5%B7%A6%E4%B8%8B%E8%A7%92%E7%9A%84%E5%80%BC/","excerpt":"","text":"题目：给定一个二叉树的 根节点 root，请找出该二叉树的 最底层 最左边 节点的值。 假设二叉树中至少有一个节点。 示例: 输入: [1,2,3,4,null,5,6,null,null,7]输出: 7 思路：深度优先搜索(DFS)我采用了优先遍历左节点，再遍历右节点，因为只有优先遍历左节点，才会优先记录当前深度左节点的值，所以就没有必要记录当前深度右边的值了。 使用depth记录当前树的深度，current_val为记录的深度current_depth的最左边的值。 进行判断如果depth的深度大于current_depth的深度，将current_val的值设置为当前结点的值，并将current_depth的值设置当前结点深度depth 代码(cpp)：1234567891011121314151617181920212223242526272829class Solution &#123;public: void dfs(TreeNode* root, int depth, int&amp; current_depth, int&amp; current_val) &#123; if (root == nullptr) //如果当前结点为空，则退出 &#123; return; &#125; //优先遍历左节点，深度加1 dfs(root-&gt;left, depth+1, current_depth, current_val); //其次遍历右节点，深度加1 dfs(root-&gt;right, depth+1, current_depth, current_val); //如果当前深度大于记录的深度 if (depth &gt; current_depth) &#123; current_depth = depth; //将当前深度记录到current_depth current_val = root-&gt;val; //将当前结点值记录到current_val &#125; &#125; int findBottomLeftValue(TreeNode* root) &#123; int current_depth = 0; //初始化current_depth int current_val = 0; //初始化current_val //因为有根结点存在，将depth设置为1，而非0 dfs(root, 1, current_depth, current_val); return current_val; &#125;&#125;; 复杂度分析 ​ 时间复杂度：O(n)，其中 n 是二叉树的节点数目。需要遍历 n 个节点。 ​ 空间复杂度：O(n)。递归栈需要占用 O(n) 的空间。","categories":[{"name":"每日LeetCode","slug":"每日LeetCode","permalink":"http://example.com/categories/%E6%AF%8F%E6%97%A5LeetCode/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"}]}],"categories":[{"name":"每日LeetCode","slug":"每日LeetCode","permalink":"http://example.com/categories/%E6%AF%8F%E6%97%A5LeetCode/"},{"name":"Java","slug":"Java","permalink":"http://example.com/categories/Java/"},{"name":"计算机4件套","slug":"计算机4件套","permalink":"http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA4%E4%BB%B6%E5%A5%97/"},{"name":"C++","slug":"C","permalink":"http://example.com/categories/C/"},{"name":"软件安装","slug":"软件安装","permalink":"http://example.com/categories/%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85/"},{"name":"Python","slug":"Python","permalink":"http://example.com/categories/Python/"},{"name":"爬虫","slug":"Python/爬虫","permalink":"http://example.com/categories/Python/%E7%88%AC%E8%99%AB/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"},{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"},{"name":"基础","slug":"基础","permalink":"http://example.com/tags/%E5%9F%BA%E7%A1%80/"},{"name":"汇编","slug":"汇编","permalink":"http://example.com/tags/%E6%B1%87%E7%BC%96/"},{"name":"数据库","slug":"数据库","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"Git","slug":"Git","permalink":"http://example.com/tags/Git/"},{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"},{"name":"容器","slug":"容器","permalink":"http://example.com/tags/%E5%AE%B9%E5%99%A8/"},{"name":"es","slug":"es","permalink":"http://example.com/tags/es/"},{"name":"kibana","slug":"kibana","permalink":"http://example.com/tags/kibana/"},{"name":"c++","slug":"c","permalink":"http://example.com/tags/c/"},{"name":"框架","slug":"框架","permalink":"http://example.com/tags/%E6%A1%86%E6%9E%B6/"},{"name":"爬虫","slug":"爬虫","permalink":"http://example.com/tags/%E7%88%AC%E8%99%AB/"},{"name":"Python","slug":"Python","permalink":"http://example.com/tags/Python/"},{"name":"STL","slug":"STL","permalink":"http://example.com/tags/STL/"}]}