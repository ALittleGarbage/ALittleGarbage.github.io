{"meta":{"title":"活着就是为了摸鱼🐟！！！","subtitle":"","description":"一个不起眼的小博客","author":"一个小垃圾","url":"http://example.com","root":"/"},"pages":[{"title":"关于我是谁","date":"2022-06-25T09:46:19.000Z","updated":"2022-06-26T00:50:58.784Z","comments":true,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":""},{"title":"archives","date":"2022-06-25T09:46:11.000Z","updated":"2022-06-25T10:00:28.430Z","comments":true,"path":"archives/index.html","permalink":"http://example.com/archives/index.html","excerpt":"","text":""},{"title":"所有标签","date":"2022-06-25T09:44:36.000Z","updated":"2022-06-25T10:10:32.117Z","comments":true,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""},{"title":"所有分类","date":"2022-06-25T09:45:03.000Z","updated":"2022-06-25T10:09:55.599Z","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"535. TinyURL的加密与解密","slug":"每日LeetCode/535 TinyURL的加密与解密","date":"2022-06-28T23:41:00.000Z","updated":"2022-06-28T23:44:36.684Z","comments":true,"path":"2022/06/29/每日LeetCode/535 TinyURL的加密与解密/","link":"","permalink":"http://example.com/2022/06/29/%E6%AF%8F%E6%97%A5LeetCode/535%20TinyURL%E7%9A%84%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%A7%A3%E5%AF%86/","excerpt":"","text":"题目：TinyURL 是一种 URL 简化服务， 比如：当你输入一个 URL https://leetcode.com/problems/design-tinyurl 时，它将返回一个简化的URL http://tinyurl.com/4e9iAk 。请你设计一个类来加密与解密 TinyURL 。 加密和解密算法如何设计和运作是没有限制的，你只需要保证一个 URL 可以被加密成一个 TinyURL ，并且这个 TinyURL 可以用解密方法恢复成原本的 URL 。 实现 Solution 类： Solution() 初始化 TinyURL 系统对象。String encode(String longUrl) 返回 longUrl 对应的 TinyURL 。String decode(String shortUrl) 返回 shortUrl 原本的 URL 。题目数据保证给定的 shortUrl 是由同一个系统对象加密的。 示例： 输入：url &#x3D; “https://leetcode.com/problems/design-tinyurl“输出：”https://leetcode.com/problems/design-tinyurl“ 解释：Solution obj &#x3D; new Solution();string tiny &#x3D; obj.encode(url); &#x2F;&#x2F; 返回加密后得到的 TinyURL 。string ans &#x3D; obj.decode(tiny); &#x2F;&#x2F; 返回解密后得到的原本的 URL 。 思路：使用自增id作为longUrl的键，存入unordered_map容器中 根据id来获取对应的longUrl 代码(cpp)：1234567891011121314151617181920212223class Solution &#123;private: unordered_map&lt;int, string&gt; map; int id;public: Solution()&#123; id = 0; //初始化id &#125; string encode(string longUrl) &#123; id++; map[id] = longUrl; //http://tinyurl.com/1 return &quot;http://tinyurl.com/&quot;+to_string(id); &#125; string decode(string shortUrl) &#123; //substr(int pos)：获取pos位置起的所有字符串 //stoi(string str)：将string类型的字符串转换成int类型的整数 int t_id = stoi(shortUrl.substr(19)); return map[t_id]; &#125;&#125;; 复杂度分析： 时间复杂度： Encode 函数：O(n)O(n)，其中 n 是字符串 longUrl 的长度。 Decode 函数：O(1)O(1)。我们把 shortUrl 当成有限长度的字符串看待。 空间复杂度： Encode 函数：O(n)O(n)。保存字符串 longUrl 需要 O(n)O(n) 的空间。 Decode 函数：O(1)O(1)。","categories":[{"name":"每日LeetCode","slug":"每日LeetCode","permalink":"http://example.com/categories/%E6%AF%8F%E6%97%A5LeetCode/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"},{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"","slug":"Java/SpringMCV框架","date":"2022-06-28T14:02:54.299Z","updated":"2022-06-28T14:02:54.299Z","comments":true,"path":"2022/06/28/Java/SpringMCV框架/","link":"","permalink":"http://example.com/2022/06/28/Java/SpringMCV%E6%A1%86%E6%9E%B6/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"324. 摆动排序 II","slug":"每日LeetCode/324 摆动排序 II","date":"2022-06-28T02:30:00.000Z","updated":"2022-06-28T02:32:38.746Z","comments":true,"path":"2022/06/28/每日LeetCode/324 摆动排序 II/","link":"","permalink":"http://example.com/2022/06/28/%E6%AF%8F%E6%97%A5LeetCode/324%20%E6%91%86%E5%8A%A8%E6%8E%92%E5%BA%8F%20II/","excerpt":"","text":"题目：给你一个整数数组 nums，将它重新排列成 nums[0] &lt; nums[1] &gt; nums[2] &lt; nums[3]... 的顺序。 你可以假设所有输入数组都可以得到满足题目要求的结果。 示例： 输入：nums &#x3D; [1,5,2,4,3,6]输出：[3,6,2,5,1,4] 思路：双指针法将数组nums按从小到大排列： 1 2 3 4 5 6 $\\leftarrow\\Uparrow$left $\\leftarrow\\Uparrow$right 把排序好的数组分成两部分，left指针位于数组中间，right指针位于数组末尾， 将left和right当前位置的元素依次打印后，left和right指针左移，直至结束 输出：[3, 6, 2, 5, 1, 4] 代码(cpp)：123456789101112131415161718192021class Solution &#123;public: void wiggleSort(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); //获取数组的元素个数 int left = n/2-1; //定义左指针 int right = n-1; //定义右指针 vector&lt;int&gt; new_nums(nums); sort(new_nums.begin(),new_nums.end()); //将新数组排序 for(int i=0;i&lt;n;i++)&#123; if(i%2 == 0)&#123; //偶数位置插入left指针的元素，奇数位置插入right指针的元素 nums[i] = a[left]; left--; &#125; else&#123; nums[i] = a[right]; rigth--; &#125; &#125; &#125;&#125;; 复杂度分析： 时间复杂度：O(nlogn)，排序所需的时间复杂度是O(nlogn)，插入O(n)，整体O(nlogn) 空间复杂度：O(n)，需要额外的空间存放排序的元素。","categories":[{"name":"每日LeetCode","slug":"每日LeetCode","permalink":"http://example.com/categories/%E6%AF%8F%E6%97%A5LeetCode/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"},{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"Spring框架","slug":"Java/Spring框架","date":"2022-06-25T09:55:58.239Z","updated":"2022-06-28T15:03:28.970Z","comments":true,"path":"2022/06/25/Java/Spring框架/","link":"","permalink":"http://example.com/2022/06/25/Java/Spring%E6%A1%86%E6%9E%B6/","excerpt":"","text":"1.初识Spring 官网：spring官网 Spring已经发展成了一种开发的生态圈，Spring提供了若干个项目，每个项目用于完成特定的功能 Spring Framework Spring Boot Spring Cloud …. 目前已经发展到Spring 5.0，需要JDK8以上支持 2.Spring Framework架构 Spring Framework是Spring生态圈中最基础的项目，是其他项目的根基 Data Access：数据访问 Data Integeration：数据集成 Web：web开发 AOP：面向切面编程 Aspects：AOP思想实现 Core Container：核心容器 Test：单元测试与集成测试 3.核心概念3.1 项目结构 java包 com包 spring包 dao包 BookDao.java impl包 BookDaoImpl.java service包 BookSerive.java impl包 BookServiceImpl.java App.java主函数 resources包 applicationContext.xml jdbc.properties 3.2 初识IOC和DI12345public class BookDaoImpl implements BookDao &#123; public void save() &#123; System.out.println(&quot;book dao save...&quot;); &#125;&#125; 123456public class BookServiceImpl implements BookService &#123; private BookDao bookDao = new BookDaoImpl; public void save() &#123; bookDao.save(); &#125;&#125; 这是一种很常见的写法。但是这样的写法耦合度太高，耦合度可以简单的理解为：两个类之间的关联程度，耦合度高就代表两个类之间关联程度很高，动其中一个类，就不得不动另外一个类。 所以就需要解耦 123456public class BookServiceImpl implements BookService &#123; private BookDao bookDao;//service:我免费啦！ public void save() &#123; bookDao.save(); &#125;&#125; IOC(Inversion of Control) 控制反转 使用对象时，由以前主动new一个对象转换为由外部提供对象，创建对象的控制权交给了外部，此思想为控制反转。 Spring技术对IOC进行实现 Spring提供一个容器，称为IOC容器，用来当作IOC思想中的**”外部”** IOC容器负责对象的创建、初始化等工作 在IOC容器中被创建或被管理的对象称之为Bean DI(Dependency Injection) 依赖注入 在容器中建立的bean与bean之间的依赖关系的整个过程，称之为依赖注入。 例：service层需要依赖dao层运行，但无需自己new一个dao层，它会自动生成dao层。 目标：充分解耦 使用IOC容器管理bean(IOC思想) 在ICO容器内将依赖关系的bean进行关系绑定(DI思想) 在使用对象时不仅可以从IOC容器中获取，并且也可以获取到bean已经绑定的所有依赖关系 4.IOC入门 pom.xml导入spring的坐标 12345&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;5.3.18&lt;/version&gt;&lt;/dependency&gt; resources目录创建Spring配置文件applicationContext.xml 配置bean bean标签：配置bean id属性：给bean起名字 class属性：给bean定义类型 123&lt;bean id=&quot;bookDao&quot; class=&quot;com.spring.dao.impl.BookDaoImpl&quot;/&gt;&lt;bean id=&quot;bookService&quot; class=&quot;com.spring.service.impl.BookServiceImpl&quot;/&gt; 创建名为启动类App 1234567891011121314151617import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;import com.spring.dao.BookDao;public class App &#123; public static void main(String[] args) &#123; //获取ICO容器 ApplicationContext ac = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); //获取bean BookDao bookDao = (BookDao) ac.getBean(&quot;bookDao&quot;); bookDao.save(); BookService bookService = (BookService) ac.getBean(&quot;bookService&quot;); bookService.save(); &#125;&#125; 5.DI入门 基于IOC管理bean 不能保留Service层中用new创建的对象 通过spring配置文件进行配置Service与Dao的关系 12345678910111213public class BookServiceImpl implements BookService &#123; //删除业务层中用new创建对象的方式 //private BookDao bookDao = new BookDaoImpl(); private BookDao bookDao; //提供相应的set的方法 public void setBookDao(BookDao bookDao) &#123; this.bookDao = bookDao; &#125; public void save() &#123; bookDao.save(); &#125;&#125; 在spring配置文件applicationContext.xml中，配置property property标签：配置当前bean的属性 name属性：配置哪个具体的属性 ref属性：参照spring配置文件中的哪个bean的id 123456&lt;bean id=&quot;bookDao&quot; class=&quot;com.spring.dao.impl.BookDaoImpl&quot;/&gt;&lt;bean id=&quot;bookService&quot; class=&quot;com.spring.service.impl.BookServiceImpl&quot;&gt; &lt;!-- 配置service与dao的关系 --&gt; &lt;property name=&quot;bookDao&quot; ref=&quot;bookDao&quot;/&gt;&lt;/bean&gt; 配置完成后，BookDao无需使用new来手动创建对象，而是通过spring来自动创建 6.bean基础配置6.1 bean别名配置 name属性：可以起多个别名用;分号 空格,逗号分隔 123&lt;bean id=&quot;bookDao&quot; name=&quot;dao Dao&quot; class=&quot;com.spring.dao.impl.BookDaoImpl&quot;/&gt;&lt;bean id=&quot;bookService&quot; name=&quot;Service service&quot; class=&quot;com.spring.service.impl.BookServiceImpl&quot;/&gt; 别名可以用于getBean()方法 1234567891011public class App &#123; public static void main(String[] args) &#123; //获取ICO容器 ApplicationContext ac = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); //获取bean //BookService bookService=(BookService)ac.getBean(&quot;bookService&quot;); //通过别名获取BookService BookService bookService=(BookService)ac.getBean(&quot;Service&quot;); bookService.save(); &#125;&#125; 别名也可以用户ref属性，不建议用别名，建议使用id 123&lt;bean id=&quot;bookService&quot; class=&quot;com.spring.service.impl.BookServiceImpl&quot;&gt; &lt;property name=&quot;bookDao&quot; ref=&quot;Dao&quot;/&gt;&lt;/bean&gt; 6.2 bean的作用范围创建的bean是否为多个对象 123456789101112public class App &#123; public static void main(String[] args) &#123; //获取ICO容器 ApplicationContext ac = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); //获取bean BookDao bookDao1 = (BookDao) ac.getBean(&quot;bookDao&quot;); BookDao bookDao2 = (BookDao) ac.getBean(&quot;bookDao&quot;); System.out.println(bookDao1); System.out.println(bookDao2); &#125;&#125; 123运行结果：com.spring.dao.impl.BookDaoImpl@7219ec67com.spring.dao.impl.BookDaoImpl@7219ec67 结论：两个对象地址相同，spring默认创建的bean是单例的 需要在配置文件的bean标签里添加一个scope属性 scope属性有singleton单例模式和prototype非单例模式 scope属性默认为singleton单例模式 1&lt;bean id=&quot;bookDao&quot; class=&quot;com.spring.dao.impl.BookDaoImpl&quot; scope=&quot;prtotype&quot;/&gt; 123再次运行后，运行结果：com.spring.dao.impl.BookDaoImpl@7219ec67com.spring.dao.impl.BookDaoImpl@45018215 结论：两个对象地址不同，为非单例模式 bean作用范围说明 单例bean的优势 减少了新生成实例的消耗，可以快速获取到bean，更大程度的复用 适合交给容器进行管理的bean 表现层对象，业务层对象，数据层对象，工具对象 不适合交给容器进行管理的bean 封装实体的域对象(存在变量的) 7.bean实例化 bean的本质就是对象，创建bean都需要使用构造方法完成 7.1 构造方法实例化bean(常用) 在BookDaoImpl类中创建构造方法： 123456789101112public class BookDaoImpl implements BookDao &#123; public BookDaoImpl()&#123; System.out.println(&quot;BookDaoImpl构造函数&quot;); &#125; /*private BookDaoImpl()&#123; System.out.println(&quot;BookDaoImpl构造函数&quot;); &#125;*/ public void save() &#123; System.out.println(&quot;BookDao~~~~~&quot;); &#125;&#125; AppForInstanceBook类进行测试： 12345678public class AppForInstanceBook &#123; public static void main(String[] args) &#123; ApplicationContext ac = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); BookDao bookDao = (BookDao) ac.getBean(&quot;bookDao&quot;); bookDao.save(); &#125;&#125; 123运行结果：BookDaoImpl构造函数BookDao~~~~~ 并且BookDaoImpl中的构造方法无论是否私有都可以被调用，这就是反射。 无参构造方法不存在，将会抛出异常 在BookDaoImpl类中构造方法改为有参构造： 123public BookDaoImpl(int i)&#123; System.out.println(&quot;BookDaoImpl构造函数&quot;);&#125; 运行后会报错，同时说明Spring创建bean的时候，调用的是无参构造。 7.2 静态工厂实例化bean(早期实例化bean 了解) 创建一个factory软件包，并在里面创建一个BookDaoFactory类： 123456public class BookDaoFactory &#123; public static BookDao getBookDao()&#123; System.out.println(&quot;factory is running&quot;); return new BookDaoImpl(); &#125;&#125; AppForInstanceBook类运行： 1234567public class AppForInstanceBook &#123; public static void main(String[] args) &#123; BookDao bookDao = BookDaoFactory.getBookDao(); bookDao.save(); &#125;&#125;//运行成功 通过配置文件使用静态工厂实例化bean： Spring配置文件中： factory-method属性：选择工厂里的bean实例方法 12&lt;bean id=&quot;bookDao&quot; class=&quot;com.spring.factory.BookDaoFactory&quot; factory-method=&quot;getBookDao&quot;/&gt; AppForInstanceBook类运行： 12345678public class AppForInstanceBook &#123; public static void main(String[] args) &#123; ApplicationContext ac = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); BookDao bookDao = (BookDao) ac.getBean(&quot;bookDao&quot;); bookDao.save(); &#125;&#125; 1234运行结果：factory is runningBookDaoImpl构造函数BookDao~~~~~ 7.3 实例工厂实例化bean(非静态工厂 了解) BookDaoFactory类中，将方法改为非静态方法 123456public class BookDaoFactory &#123; public BookDao getBookDao()&#123; System.out.println(&quot;factory is running~~~~~&quot;); return new BookDaoImpl(); &#125;&#125; AppForInstanceBook类运行： 1234567public class AppForInstanceBook &#123; public static void main(String[] args) &#123; BookDaoFactory bookDaoFactory = new BookDaoFactory(); BookDao bookDao = bookDaoFactory.getBookDao(); bookDao.save(); &#125;&#125; 1234运行结果：factory is running~~~~~BookDaoImpl构造函数BookDao~~~~~ 通过配置文件使用静态工厂实例化bean： Spring配置文件中： 12345&lt;!-- 先要造出工厂的bean --&gt;&lt;bean id=&quot;bookDaoFactory&quot; class=&quot;com.spring.factory.BookDaoFactory&quot;/&gt;&lt;bean id=&quot;bookDao&quot; factory-bean=&quot;bookDaoFactory&quot; factory-method=&quot;getBookDao&quot; /&gt; AppForInstanceBook类运行： 12345678public class AppForInstanceBook &#123; public static void main(String[] args) &#123; ApplicationContext ac = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); BookDao bookDao = (BookDao) ac.getBean(&quot;bookDao&quot;); bookDao.save(); &#125;&#125; 1234运行结果：factory is running~~~~~BookDaoImpl构造函数BookDao~~~~~ 配置文件中beanbookDaoFactory只是为了配合使用，实际没有意义。 Spring对这种实例化bean方法进行了改良： 4.通过FactoryBean实例化bean(实用) 创建BookDaoFactoryBean类实现接口FactoryBean&lt;T&gt; 123456789101112public class BookDaoFactoryBean implements FactoryBean&lt;BookDao&gt; &#123; //代替原始实例工厂中创建对象的方法 @Override public BookDao getObject() throws Exception &#123; return new BookDaoImpl(); &#125; @Override public Class&lt;?&gt; getObjectType() &#123; return BookDao.class; &#125;&#125; Spring配置文件中： 1&lt;bean id=&quot;bookDao&quot; class=&quot;com.spring.factory.BookDaoFactoryBean&quot;/&gt; AppForInstanceBook类运行： 12345678public class AppForInstanceBook &#123; public static void main(String[] args) &#123; ApplicationContext ac = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); BookDao bookDao = (BookDao) ac.getBean(&quot;bookDao&quot;); bookDao.save(); &#125;&#125; 123运行结果：BookDaoImpl构造函数BookDao~~~~~ 并且BookDaoFactoryBean类中可以重写isSinglenton方法： 12345@Overridepublic boolean isSingleton() &#123; //true：单例； false：多例；默认单例 return true;&#125; 8.bean的生命周期 bean生命周期：bean从创建到销毁的整体过程 bean生命周期控制：在bean创建后到销毁前做一些事 在BookDaoImpl类中，创建init和destroy方法 1234567891011121314public class BookDaoImpl implements BookDao &#123; public void save() &#123; System.out.println(&quot;BookDao~~~~~&quot;); &#125; public void init()&#123; System.out.println(&quot;init~~~&quot;); &#125; public void destroy()&#123; System.out.println(&quot;destroy~~~&quot;); &#125;&#125; 在Spring配置文件中： init-method和destroy-method属性 12&lt;bean id=&quot;bookDao&quot; class=&quot;com.spring.dao.impl.BookDaoImpl&quot; init-method=&quot;init&quot; destroy-method=&quot;destroy&quot;/&gt; 调用主函数： 123456789public class App &#123; public static void main(String[] args) &#123; //获取ICO容器 ApplicationContext ac = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); //获取bean BookDao bookDao = (BookDao) ac.getBean(&quot;bookDao&quot;); bookDao.save(); &#125;&#125; 123运行结果：init~~~BookDao~~~~~ 控制台并没有输出destroy~~~； 因为销毁函数还没有来得及调用，程序就被杀死了； 所以需要进行手动关闭； 我们调用主函数中的ac中的close()方法，但是ApplicationContext接口中并没有提供close()方法，所以我们要改用ClassPathXmlApplicationContext类。 12345678910public class App &#123; public static void main(String[] args) &#123; //获取ICO容器 ClassPathXmlApplicationContext ac = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); //获取bean BookDao bookDao = (BookDao) ac.getBean(&quot;bookDao&quot;); bookDao.save(); ac.close(); &#125;&#125; 12345运行结果：init~~~BookDao~~~~~destroy~~~ 成功！！！！ 容器还提供另外一种方式关闭容器：设置关闭钩子 调用ac的registerShutdownHook()方法 1234567891011public class App &#123; public static void main(String[] args) &#123; //获取ICO容器 ClassPathXmlApplicationContext ac = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); //获取bean BookDao bookDao = (BookDao) ac.getBean(&quot;bookDao&quot;); bookDao.save(); ac.registerShutdownHook(); &#125;&#125; 1234运行结果：init~~~BookDao~~~~~destroy~~~ close()和registerShutdownHook()的区别 将registerShutdownHook()放到上面： 12345678910public class App &#123; public static void main(String[] args) &#123; //获取ICO容器 ClassPathXmlApplicationContext ac = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); ac.registerShutdownHook(); //获取bean BookDao bookDao = (BookDao) ac.getBean(&quot;bookDao&quot;); bookDao.save(); &#125;&#125; 1234运行成功：init~~~BookDao~~~~~destroy~~~ 将close()放到上面： 12345678910public class App &#123; public static void main(String[] args) &#123; //获取ICO容器 ClassPathXmlApplicationContext ac = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); ac.close(); //获取bean BookDao bookDao = (BookDao) ac.getBean(&quot;bookDao&quot;); bookDao.save(); &#125;&#125; 123456运行结果：init~~~destroy~~~报错：BeanFactory not initialized or already closed - call &#x27;refresh&#x27; before accessing beans via the ApplicationContext BeanFactory没有被初始化或者已经被关闭了 运行失败！！ 或者通过接口的方式实现： BookServiceImpl类实现接口InitializingBean和DisposableBean的方法 1234567891011121314151617181920212223public class BookServiceImpl implements BookService, InitializingBean, DisposableBean &#123; private BookDao bookDao; public void setBookDao(BookDao bookDao) &#123; System.out.println(&quot;BookDao set~~~&quot;); this.bookDao = bookDao; &#125; public void save() &#123; bookDao.save(); &#125; @Override public void destroy() throws Exception &#123; System.out.println(&quot;service destroy~~~~&quot;); &#125; @Override public void afterPropertiesSet() throws Exception &#123; System.out.println(&quot;service init~~~~&quot;); &#125;&#125; 配置文件： 123456&lt;bean id=&quot;bookDao&quot; class=&quot;com.spring.dao.impl.BookDaoImpl&quot; init-method=&quot;init&quot; destroy-method=&quot;destroy&quot;/&gt;&lt;bean id=&quot;bookService&quot; class=&quot;com.spring.service.impl.BookServiceImpl&quot;&gt;&lt;property name=&quot;bookDao&quot; ref=&quot;bookDao&quot;/&gt;&lt;/bean&gt; 主函数运行： 12345678910public class App &#123; public static void main(String[] args) &#123; //获取ICO容器 ClassPathXmlApplicationContext ac = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); //获取bean BookDao bookDao = (BookDao) ac.getBean(&quot;bookDao&quot;); bookDao.save(); ac.registerShutdownHook(); &#125;&#125; 1234567运行结果：init~~~BookDao set~~~service init~~~~BookDao~~~~~service destroy~~~~destroy~~~ BookServiceImpl类中destroy()方法和afterPropertiesSet()方法被调用 并且setBookDao()方法之后才调用的afterPropertiesSet()方法 9.依赖注入方式向一个类传递数据的方式有：set方法、构造方法 9.1 setter注入 引用类型 在bean中定义引用类型属性并提供可访问的set方法 BookServiceImpl类中： 1234567public class BookServiceImpl implements BookService &#123; private BookDao bookDao; //提供相应的set的方法 public void setBookDao(BookDao bookDao) &#123; this.bookDao = bookDao; &#125;&#125; 在配置文件中使用property标签ref属性注入引用类型对象 12345&lt;bean id=&quot;bookDao&quot; class=&quot;com.spring.dao.impl.BookDaoImpl&quot;/&gt;&lt;bean id=&quot;bookService&quot; class=&quot;com.spring.service.impl.BookServiceImpl&quot;&gt; &lt;property name=&quot;bookDao&quot; ref=&quot;bookDao&quot;/&gt;&lt;/bean&gt; 简单类型 在bean中定义引用类型属性并提供可访问的set方法 BookDaoImpl类中： 1234567891011121314public class BookDaoImpl implements BookDao &#123; private String name; private int age; public void setName(String name) &#123; this.name = name; &#125; public void setAge(int age) &#123; this.age = age; &#125; public void save() &#123; System.out.println(&quot;BookDao~~~~~&quot;+&quot;姓名：&quot;+name+&quot;年龄：&quot;+age); &#125;&#125; 配置文件中，在property标签value属性注入简单类型数据 1234&lt;bean id=&quot;bookDao&quot; class=&quot;com.spring.dao.impl.BookDaoImpl&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;DaHuang&quot;/&gt; &lt;property name=&quot;age&quot; value=&quot;18&quot;/&gt;&lt;/bean&gt; 运行主函数： 12345678910public class App &#123; public static void main(String[] args) &#123; //获取ICO容器 ClassPathXmlApplicationContext ac = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); //获取bean BookDao bookDao = (BookDao) ac.getBean(&quot;bookDao&quot;); bookDao.save(); ac.registerShutdownHook(); &#125;&#125; 12运行结果：BookDao~~~~~姓名：DaHuang年龄：18 9.2 构造器注入 引用类型 在bean中定义引用类型属性并提供可访问的构造方法 12345678public class BookServiceImpl implements BookService &#123; private BookDao bookDao; public BookServiceImpl(BookDao bookDao) &#123; System.out.println(&quot;BookServiceImpl构造器运行~~~&quot;); this.bookDao = bookDao; &#125;&#125; 配置文件中，使用constructor-arg标签中的ref属性注入引用类型对象 12345678&lt;bean id=&quot;bookDao&quot; class=&quot;com.spring.dao.impl.BookDaoImpl&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;DaHuang&quot;/&gt; &lt;property name=&quot;age&quot; value=&quot;18&quot;/&gt; &lt;/bean&gt;&lt;bean id=&quot;bookService&quot; class=&quot;com.spring.service.impl.BookServiceImpl&quot;&gt; &lt;constructor-arg name=&quot;bookDao&quot; ref=&quot;bookDao&quot;/&gt;&lt;/bean&gt; 运行主函数： 123456789public class App &#123; public static void main(String[] args) &#123; //获取ICO容器 ClassPathXmlApplicationContext ac = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); //获取bean BookDao bookDao = (BookDao) ac.getBean(&quot;bookDao&quot;); bookDao.save(); &#125;&#125; 12运行结果：BookServiceImpl构造器运行~~~ 简单类型 BookDaoImpl类中： 123456789public class BookDaoImpl implements BookDao &#123; private String name; private int age; public BookDaoImpl(String name, int age) &#123; this.name = name; this.age = age; &#125;&#125; 配置文件中： 1234&lt;bean id=&quot;bookDao&quot; class=&quot;com.spring.dao.impl.BookDaoImpl&quot;&gt; &lt;constructor-arg name=&quot;name&quot; value=&quot;DaHei&quot;/&gt; &lt;constructor-arg name=&quot;age&quot; value=&quot;20&quot;/&gt;&lt;/bean&gt; 如果要更改BookDaoImpl类中的形参名字，还要更改配置文件中的name属性的名字； 存在形参与name属性名不耦合的问题。 constructor-arg标签还有type和index属性 type：形参的数据类型(存在多个同数据类型的形参，无法使用) index：形参的位置顺序 在配置文件中，使用index属性设置按形参位置顺序注入 1234&lt;bean id=&quot;bookDao&quot; class=&quot;com.spring.dao.impl.BookDaoImpl&quot;&gt; &lt;constructor-arg index=&quot;0&quot; value=&quot;DaHei&quot;/&gt; &lt;constructor-arg index=&quot;1&quot; value=&quot;20&quot;/&gt;&lt;/bean&gt; 运行主函数： 123456789public class App &#123; public static void main(String[] args) &#123; //获取ICO容器 ClassPathXmlApplicationContext ac = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); BookDao bookDao = (BookDao) ac.getBean(&quot;bookDao&quot;); bookDao.save(); &#125;&#125; 12运行结果：BookDao~~~~~姓名：DaHei年龄：20 9.3 依赖注入方式的选择 强制依赖使用构造器注入，使用setter注入有概率不注入导致null对象出现。 bean必须要的东西，要用构造器注入。因为构造器必须被执行，必须注入，否则报错 而setter方法可以执行也可以不执行，如果没有进行setter注入，会导致null对象 可选依赖使用setter注入进行，灵活性强。 setter注入可以执行也可以不执行 Spring框架倡导使用构造器。 第三方框架大多采用构造器注入的形式初始化数据，更加严谨 setter注入和构造器注入可以同时使用。 使用构造器完成强制依赖注入，使用setter注入完成可选依赖注入 自己开发的模块推荐使用setter注入 10.依赖自动装配IOC容器根据bean都依赖的资源在容器中自动查找并注入到bean中的过程称为自动装配 自动装配的方式： 按类型(常用) 按名称 按构造方法(不推荐) 不启用自动装配 10.1 按类型需要提供相应的setter方法 123456789public class BookServiceImpl implements BookService &#123; private BookDao bookDao; public void setBookDao(BookDao bookDao) &#123; System.out.println(&quot;BookDao set~~~&quot;); this.bookDao = bookDao; &#125;&#125; 配置文件中，要提前写好bookDao的bean否则无法装配， autowire属性设置为byTpye 通过类型自动装配 1234&lt;bean id=&quot;bookDao&quot; class=&quot;com.spring.dao.impl.BookDaoImpl&quot;/&gt;&lt;bean id=&quot;bookService&quot; class=&quot;com.spring.service.impl.BookServiceImpl&quot; autowire=&quot;byType&quot; /&gt; 主函数： 123456789public class App &#123; public static void main(String[] args) &#123; ClassPathXmlApplicationContext ac = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); BookService bookService = (BookService) ac.getBean(&quot;bookService&quot;); bookService.save(); &#125;&#125; 12运行结果：BookDao set~~~ 如果出现一下这种情况： 12345&lt;bean id=&quot;bookDao1&quot; class=&quot;com.spring.dao.impl.BookDaoImpl&quot;/&gt;&lt;bean id=&quot;bookDao2&quot; class=&quot;com.spring.dao.impl.BookDaoImpl&quot;/&gt;&lt;bean id=&quot;bookService&quot; class=&quot;com.spring.service.impl.BookServiceImpl&quot; autowire=&quot;byType&quot; /&gt; 出现了两个BookDao的bean，导致Spring无法区分了，这时就需要按名称装配 10.2 按名称123456789public class BookServiceImpl implements BookService &#123; private BookDao bookDao; public void setBookDao(BookDao bookDao) &#123; System.out.println(&quot;BookDao set~~~&quot;); this.bookDao = bookDao; &#125;&#125; 配置文件中，autowire属性设置为byName 通过名称自动装配 是通过BookServiceImpl类的变量名bookDao与配置文件的bean中id相同名称的进行绑定 12345&lt;bean id=&quot;bookDao&quot; class=&quot;com.spring.dao.impl.BookDaoImpl&quot;/&gt;&lt;bean id=&quot;bookDao2&quot; class=&quot;com.spring.dao.impl.BookDaoImpl&quot;/&gt;&lt;bean id=&quot;bookService&quot; class=&quot;com.spring.service.impl.BookServiceImpl&quot; autowire=&quot;ByName&quot; /&gt; 10.3 总结 自动装配用于引用类型依赖注入，不能对简单类型进行操作 使用按类型装配byType，必须保障容器中相同类型的bean唯一，推荐使用 使用按名称装配byName，必须保障容器中具有指定名称的bean，变量名要与配置耦合， 不推荐使用 自动装配优先级低于setter注入和构造器注入，同时出现时自动装配配置失效 11.集合注入123456789101112131415161718192021222324252627public class BookDaoImpl implements BookDao &#123; private int[] array; private List&lt;String&gt; list; private Set&lt;String&gt; set; private Map&lt;String, String&gt; map; private Properties properties; public void setArray(int[] array) &#123;this.array = array;&#125; public void setList(List&lt;String&gt; list) &#123;this.list = list;&#125; public void setSet(Set&lt;String&gt; set) &#123;this.set = set;&#125; public void setMap(Map&lt;String, String&gt; map) &#123;this.map = map;&#125; public void setProperties(Properties properties) &#123;this.properties = properties;&#125; public void save() &#123; System.out.println(&quot;BookDaoImpl&#123;&quot; + &quot;\\narray=&quot; + Arrays.toString(array) + &quot;, \\nlist=&quot; + list + &quot;, \\nset=&quot; + set + &quot;, \\nmap=&quot; + map + &quot;, \\nproperties=&quot; + properties + &#x27;&#125;&#x27;); &#125;&#125; 配置文件中： 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;bean id=&quot;bookDao&quot; class=&quot;com.spring.dao.impl.BookDaoImpl&quot;&gt; &lt;property name=&quot;array&quot; &gt; &lt;array&gt; &lt;value&gt;100&lt;/value&gt; &lt;value&gt;200&lt;/value&gt; &lt;value&gt;300&lt;/value&gt; &lt;/array&gt; &lt;/property&gt; &lt;property name=&quot;list&quot; &gt; &lt;list&gt; &lt;value&gt;唱&lt;/value&gt; &lt;value&gt;跳&lt;/value&gt; &lt;value&gt;Rap&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;property name=&quot;set&quot; &gt; &lt;set&gt; &lt;value&gt;唱&lt;/value&gt; &lt;value&gt;跳&lt;/value&gt; &lt;value&gt;Rap&lt;/value&gt; &lt;value&gt;Rap&lt;/value&gt; &lt;/set&gt; &lt;/property&gt; &lt;property name=&quot;map&quot; &gt; &lt;map&gt; &lt;entry key=&quot;county&quot; value=&quot;china&quot;/&gt; &lt;entry key=&quot;province&quot; value=&quot;tianjin&quot;/&gt; &lt;entry key=&quot;city&quot; value=&quot;baodi&quot;/&gt; &lt;/map&gt; &lt;/property&gt; &lt;property name=&quot;properties&quot;&gt; &lt;props&gt; &lt;prop key=&quot;county&quot;&gt;china&lt;/prop&gt; &lt;prop key=&quot;province&quot;&gt;tianjin&lt;/prop&gt; &lt;prop key=&quot;city&quot;&gt;baodi&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt; &lt;/bean&gt; 运行主函数： 12345678public class App &#123; public static void main(String[] args) &#123; ClassPathXmlApplicationContext ac = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); BookDao bookDao = (BookDao) ac.getBean(&quot;bookDao&quot;); bookDao.save(); &#125;&#125; 1234567运行结果：BookDaoImpl&#123;array=[100, 200, 300], list=[唱, 跳, Rap], set=[唱, 跳, Rap], map=&#123;county=china, province=tianjin, city=baodi&#125;, properties=&#123;province=tianjin, city=baodi, county=china&#125;&#125; 12.数据源对象管理在pom.xml导入druid坐标 12345678910&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.2.8&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8.0.28&lt;/version&gt;&lt;/dependency&gt; 配置文件中，管理DruidDataSouurce对象 123456&lt;bean id=&quot;dataSource&quot; class=&quot;com.alibaba.druid.pool.DruidDataSource&quot;&gt; &lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/demo&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;123456&quot;/&gt;&lt;/bean&gt; 运行主函数： 12345678910public class App &#123; public static void main(String[] args) &#123; //获取ICO容器 ClassPathXmlApplicationContext ac = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); DataSource dataSource = (DataSource) ac.getBean(&quot;dataSource&quot;); System.out.println(dataSource); &#125;&#125; 123456789101112运行结果：&#123; CreateTime:&quot;2022-06-24 22:27:03&quot;, ActiveCount:0, PoolingCount:0, CreateCount:0, DestroyCount:0, CloseCount:0, ConnectCount:0, Connections:[ ]&#125; 13.加载properties配置信息在rescource资源包中创建jdbc.properties文件： 1234567jdbc.driver=com.mysql.jdbc.Driverjdbc.url=jdbc:mysql://localhost:3306/demojdbc.username=rootjdbc.password=123456username=dahuangage=18 配置文件中: 在beans标签中开启context命名空间 使用context空间加载properties文件 12345678910111213141516171819202122232425262728293031&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot; http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt; &lt;!-- 1.开启context命名空间 --&gt; &lt;!-- 2.使用context空间加载properties文件 --&gt; &lt;context:property-placeholder location=&quot;jdbc.properties&quot; system-properties-mode=&quot;NEVER&quot;/&gt; &lt;bean id=&quot;dataSource&quot; class=&quot;com.alibaba.druid.pool.DruidDataSource&quot;&gt; &lt;!-- 使用占位符$&#123;&#125;读取properties中的属性 --&gt; &lt;property name=&quot;driverClassName&quot; value=&quot;$&#123;jdbc.driver&#125;&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;$&#123;jdbc.url&#125;&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;$&#123;jdbc.username&#125;&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot;/&gt; &lt;/bean&gt; &lt;bean id=&quot;bookDao&quot; class=&quot;com.spring.dao.impl.BookDaoImpl&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;$&#123;username&#125;&quot;/&gt; &lt;property name=&quot;age&quot; value=&quot;$&#123;age&#125;&quot;/&gt; &lt;/bean&gt;&lt;/beans&gt; 加载properties文件格式： 不加载系统属性： 12&lt;context:property-placeholder location=&quot;jdbc.properties&quot; system-properties-mode=&quot;NEVER&quot;/&gt; 加载多个properties文件： 1&lt;context:property-placeholder location=&quot;jdbc.properties, jdbc2.properties&quot;/&gt; 加载所有properties文件： 1&lt;context:property-placeholder location=&quot;*.properties&quot;/&gt; 加载properties文件标准格式： 1&lt;context:property-placeholder location=&quot;classpath:*.properties&quot;/&gt; 从类路径或jar包中搜索加载properties文件： 1&lt;context:property-placeholder location=&quot;classpath*:*.properties&quot;/&gt; 14.容器14.1 创建容器的几种方式 类路径下的加载配置文件 1ApplicationContext ac = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); 文件系统下加载的配置文件 1ApplicationContext ac = new ClassPathXmlApplicationContext(&quot;E:\\Java_Web\\Spring\\spring_01_IOC\\src\\main\\resources\\applicationContext.xml&quot;); 加载多个配置文件： 1ApplicationContext ac = new ClassPathXmlApplicationContext(&quot;applicationContext1.xml&quot;,&quot;applicationContext2.xml&quot;); 14.2 获取bean的几种方式 使用bean名称获取 1BookDao bookDao = (BookDao) ac.getBean(&quot;bookDao&quot;); 使用bean名称获取并指定类型 1BookDao bookDao = ac.getBean(&quot;bookDao&quot;,BookDao.class); 使用bean类型获取 1BookDao bookDao = ac.getBean(BookDao.class);//对应的容器中只能有一个该类型，唯一 14.3 容器类层次结构使用ctrl+H打开容器类的层次结构图： BeanFactory：是IOC容器的顶层接口，初始化BeanFactory对象时，加载的bean延迟加载 ApplicationContext：是Spring容器的核心接口，初始化时bean立即加载 ​ 提供基础的bean操作相关的方法，通过其他接口扩展其功能 ConfigurableApplicationContext：提供关闭容器功能 ClassPathXmlApplicationContext：常用实现类 14.4 BeanFactory初始化类路径加载配置文件： 12345678public class App &#123; public static void main(String[] args) &#123; Rescoure rescoure = new ClassPathRescoure(&quot;applicationContext.xml&quot;); BeanFactory bf = new XmlBeanFactory(rescoure); BookDao bookDao = bf.getBean(&quot;bookDao&quot;,BookDao.class); bookDao.save(); &#125;&#125; BeanFactory创建完毕后，所有bean均为延迟加载 15.注解开发*15.1 用注释定义bean123456@component(&quot;bookDao&quot;) //等价于&lt;bean id=&quot;bookDao&quot; class=&quot;com.spring.dao.impl.BookDaoImpl&quot;/&gt;public class BookDaoImpl implements BookDao &#123; public void save() &#123; System.out.println(&quot;BookDao~~~~~&quot;); &#125;&#125; 123456@Component //没有写bean名，要通过类型获取beanpublic class BookServiceImpl implements BookService &#123; public void save() &#123; System.out.println(&quot;BookService~~~~&quot;); &#125;&#125; 但是，Spring怎么感知到注释呢？ 配置文件中，需要添加扫描组件： 123456789101112&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot; http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt; &lt;!-- 扫描@component组件 --&gt; &lt;!-- base-package为扫描的位置 --&gt; &lt;context:component-scan base-package=&quot;com.spring&quot;/&gt;&lt;/beans&gt; 主函数： 123456789101112public class App &#123; public static void main(String[] args) &#123; //获取ICO容器 ClassPathXmlApplicationContext ac = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); //获取bean BookDao bookDao = (BookDao) ac.getBean(&quot;bookDao&quot;); bookDao.save(); //因为@component，并没有写bean名，所以要用类型获取bean BookService bookService = ac.getBean(BookService.class); bookService.save(); &#125;&#125; 123运行结果：BookDao~~~~~BookService~~~~ Spring提供@component注解的三个衍生注解 @Repository：用于数据层bean定义(Dao层) ​ 也可以加括号来指定bean名，如：@Repository(“bookDao2”) @Service：用于业务层bean定义(Service层) @Controller：用于表现层bean定义(Controller层) 1234@Repositorypublic class BookDaoImpl implements BookDao &#123; &#125; 1234@Servicepublic class BookServiceImpl implements BookService &#123;&#125; 1234@Controllerpublic class BookController &#123;&#125; 15.2 纯注释开发新建一个SpringConfig类，用来替代配置文件。 其位置：com.spring.config.SpringConfig.java com包 spring包 config包 SpringConfig.java @Configuration ：用于设定当前类为配置类@ComponentScan(&quot;com.spring&quot;) ：用用于设定扫描路径，此注释只能添加一次，多个数据用数组格式 123456//用来替代 &lt;context:component-scan base-package=&quot;com.spring&quot;/&gt;@Configuration //用于设定当前类为配置类@ComponentScan(&quot;com.spring&quot;) //用用于设定扫描路径，此注释只能添加一次，多个数据用数组格式public class SpringConfig &#123; &#125; 主函数： 1234567891011public class AppForAnnotation &#123; public static void main(String[] args) &#123; //改用注释配置初始化容器 ApplicationContext ac = new AnnotationConfigApplicationContext(SpringConfig.class); BookDao bookDao = ac.getBean(BookDao.class); bookDao.save(); BookService bookService = ac.getBean(BookService.class); bookService.save(); &#125;&#125; 123运行结果：BookDao~~~~~BookService~~~~ 15.3 bean管理 作用范围 @Scope(&quot;singleton&quot;)：单例，默认单例 @Scope(&quot;prototype&quot;)：多例 bean生命周期控制 @PostConstruct注解：init @PreDestroy注解：destory 123456789101112@Repository@Scope(&quot;prototype&quot;) //多例public class BookDaoImpl implements BookDao &#123; @PostConstruct public void init()&#123; System.out.println(&quot;init~~~&quot;); &#125; @PreDestroy public void destroy()&#123; System.out.println(&quot;destroy~~~&quot;); &#125;&#125; 15.4 依赖注入1.引用类型 1234567891011@Servicepublic class BookServiceImpl implements BookService &#123; @Autowired private BookDao bookDao; public void save() &#123; System.out.println(&quot;BookService~~~~&quot;); bookDao.save(); &#125;&#125; 主函数： 12345678public class AppForAnnotation &#123; public static void main(String[] args) &#123; ApplicationContext ac = new AnnotationConfigApplicationContext(SpringConfig.class); BookService bookService = ac.getBean(BookService.class); bookService.save(); &#125;&#125; 123运行结果：BookService~~~~ //在创建好BookService的bean,并注入BookDaoBookDao~~~~~ //调用BookDao的方法save(); 当有多个同类型的bean，使用@Qualifier(&quot;bookDao2&quot;)来指定bean名 并且需要@Autowired和@Qualifier(&quot;bookDao2&quot;)一起使用 1234567891011@Servicepublic class BookServiceImpl implements BookService &#123; @Autowired @Qualifier(&quot;bookDao2&quot;) private BookDao bookDao; public void save() &#123; System.out.println(&quot;BookService~~~~&quot;); bookDao.save(); &#125;&#125; 注意： 自动装配基于反射设计创建对象并暴力反射对应属性为私有属性初始化数据，无需提供setter方法 自动装配建议使用无参构造方法创建对象，如果不提供对应的构造方法，请提供唯一的构造方法 @Qualifier注解无法单独使用，必须配合@Autowired注解使用 2.简单类型 123456789@Repositorypublic class BookDaoImpl implements BookDao &#123; @Value(&quot;dahuang&quot;) private String name; public void save()&#123; System.out.println(&quot;BookDao~~~~~&quot;+&quot;姓名：&quot;+name); &#125;&#125; 主函数： 1234567public class AppForAnnotation &#123; public static void main(String[] args) &#123; ApplicationContext ac = new AnnotationConfigApplicationContext(SpringConfig.class); BookDao bookDao = ac.getBean(BookDao.class); bookDao.save(); &#125;&#125; 12运行结果：BookDao~~~~~姓名：dahaung 但是，我们为什么不直接赋值，为什么要用@Value注解呢？ 我们可以用properties文件，向其传值。 3.读取properties文件 通过创建一个jdbc.properties文件： 1name=dahei 在配置类中新加注解@PropertySource()，括号中指定文件名： 如：@PropertySource(&quot;jdbc.properties&quot;)或者@PropertySource(&quot;classpath:jdbc.properties&quot;) 也可以指定多个文件： 如：@PropertySource(&#123;&quot;jdbc.properties&quot;,&quot;jdbc1.properties&quot;,&quot;jdbc2.properties&quot;&#125;) 12345@Configuration@ComponentScan(&quot;com.spring&quot;)@PropertySource(&quot;jdbc.properties&quot;)public class SpringConfig &#123;&#125; 在BookDaoImpl中将注解改为：@Value(&quot;$&#123;&#125;&quot;)，在&#123;&#125;中填入properties文件中的属性 如：@Value(&quot;$&#123;name&#125;&quot;) 123456789@Repositorypublic class BookDaoImpl implements BookDao &#123; @Value(&quot;$&#123;name&#125;&quot;) private String name; public void save()&#123; System.out.println(&quot;BookDao~~~~~&quot;+&quot;姓名：&quot;+name); &#125;&#125; 15.5 第三方bean管理1.使用独立的配置管理第三方bean 12345678910111213@Configurationpublic class SpringConfig &#123; //定义一个方法获得想要管理的bean @Bean // 表示当前方法返回值是一个bean public DataSource dataSource()&#123; //相关配置 ds.setDriverClassName(&quot;com.mysql.jdbc.Driver&quot;); ds.setUrl(&quot;jdbc:mysql://localhost:3306/demo&quot;); ds.getUsername(&quot;root&quot;); ds.setPassword(&quot;123456&quot;); return ds; &#125;&#125; 但是不建议将独立配置直接写在核心配置类中： 方法一：导入式(建议使用) 在config包创建一个JdbcConfig.java配置类： 12345678910111213public class JdbcConfig &#123; //定义一个方法获得想要管理的bean @Bean // 表示当前方法返回值是一个bean public DataSource dataSource()&#123; DruidDataSource ds = new DruidDataSource(); //相关配置 ds.setDriverClassName(&quot;com.mysql.jdbc.Driver&quot;); ds.setUrl(&quot;jdbc:mysql://localhost:3306/demo&quot;); ds.setUsername(&quot;root&quot;); ds.setPassword(&quot;123456&quot;); return ds; &#125;&#125; 在SpringConfig.java核心配置类中导入： 使用注解@Import()在括号中添加要导入的配置类的类型 如：@Import(JdbcConfig.class) 此注解只能添加一次，导入多个配置类，可以使用数组格式导入 如：@Import(&#123;JdbcConfig.class, XXXConfig.class, XXXConfig.calss&#125;) 12345@Configuration@Import(JdbcConfig.class)public class SpringConfig &#123; &#125; 方式二：扫描式(不建议使用) 注意：使用扫描式需要在独立的配置类加入注解@Configuration 1234567891011121314@Configurationpublic class JdbcConfig &#123; //定义一个方法获得想要管理的bean @Bean // 表示当前方法返回值是一个bean public DataSource dataSource()&#123; DruidDataSource ds = new DruidDataSource(); //相关配置 ds.setDriverClassName(&quot;com.mysql.jdbc.Driver&quot;); ds.setUrl(&quot;jdbc:mysql://localhost:3306/demo&quot;); ds.setUsername(&quot;root&quot;); ds.setPassword(&quot;123456&quot;); return ds; &#125;&#125; 在SpringConfig.java核心配置类中扫描： 使用注解@ComponentScan()在括号中添加要扫描的路径 如：@@ComponentScan(&quot;com.spring.config&quot;) 扫描多个路径，可以使用数组格式导入 如：@Import(&#123;&quot;com.spring.config&quot;,&quot;com.spring.dao&quot;&#125;) 12345@Configuration@ComponentScan(&quot;com.spring.config&quot;)public class SpringConfig &#123; &#125; 2.第三方bean注入资源 简单类型依赖注入(成员变量)： 利用注解@PropertySource(&quot;jdbc.properties&quot;)导入配置文件 利用注解@Value(&quot;$&#123;&#125;&quot;)注入数据 1234567891011121314151617181920212223@PropertySource(&quot;jdbc.properties&quot;)public class JdbcConfig &#123; @Value(&quot;$&#123;jdbc.driver&#125;&quot;) private String driver; @Value(&quot;$&#123;jdbc.url&#125;&quot;) private String url; @Value(&quot;$&#123;jdbc.username&#125;&quot;) private String userName; @Value(&quot;$&#123;jdbc.password&#125;&quot;) private String password; //定义一个方法获得想要管理的bean @Bean // 表示当前方法返回值是一个bean public DataSource dataSource()&#123; DruidDataSource ds = new DruidDataSource(); ds.setDriverClassName(driver); ds.setUrl(url); ds.setUsername(userName); ds.setPassword(password); return ds; &#125;&#125; 引入类型依赖注入(方法形参)： 引用类型注入只需要为bean定义的方法设置形参，容器会根据类型自动装配对象 123456789//定义一个方法获得想要管理的bean @Bean // 表示当前方法返回值是一个bean public DataSource dataSource(BookDao bookDao)&#123; System.out.println(&quot;已引用：&quot;+bookDao); DruidDataSource ds = new DruidDataSource(); //对ds进行相关设置 return ds; &#125; 15.6 总结XML配置与注解配置的比较： 功能 XML配置 注解 定义bean bean标签：&gt;id属性&gt;class属性 @Component &gt;@Controller &gt;@Service &gt;@Repository@ComponentScan 设置依赖注入 setter注入(set方法)&gt;引用&#x2F;简单构造器注入(构造方法)&gt;自动装配 @Autowird&gt;@Qualifier@Value 配置第三方bean bean标签&gt;静态工厂&gt;实例工厂&gt;FactoryBean @Bean 作用范围 scope属性 @Scope 生命周期 标准接口&gt;init-method&gt;destory-method @PostConstructor@PreDestroy 16.AOP16.1 AOP简介 AOP(Aspect Oriented Programming)面向切面编程，一种编程范式，指导开发者如何组织程序结构 OOP(Object Oriented Programing)面向对象编程 作用：在不惊动原始设计的基础上为其进行功能增强 Spring理念：无入侵式&#x2F;无侵入式 执行save()方法 运行结果： 打印出一万次的book dao save … 和消耗的时间 执行update()方法没有图中蓝色区域的代码， 但是，运行结果： 仍会打印打印出一万次的book dao update … 和消耗的时间 连接点(JoinPoint)：程序执行过程中的任意位置，粒度为执行方法，抛出异常，设置变量等(代表所有的方法) 在SpringAOP中，理解方法的执行 切入点(Pointcut)：匹配连接点的式子(代表要追加功能的方法) 在SpringAOP中，一个切入点只描述一个具体方法，也可以匹配多个方法 一个具体方法：com.spring.dao包下的BookDao接口中的五星参无返回值的save()方法 匹配多个方法：所有save方法，所有的get开头的方法，所有以Dao结尾的接口中的任意方法，所有带有一个形参的方法 通知(Advice)：在切入点执行的操作，也就是共性功能(代表追加的功能) 在SpringAOP中，功能最终以方法的形式呈现 通知类：定义通知的类 切面(Aspect)：描述通知与切入的对应关系 16.2 AOP入门 案例设定：测试接口执行效率 简化设定：在接口执行当前输出当前的系统时间 开发模式：XML or 注解(此入门案例采用注解的方式) 思路分析： 导入坐标(pom.xml) 制作连接点方法(原始操作，Dao接口与实现类) 制作共性功能(通知类与通知) 定义切入点 绑定切入点与通知关系(切面) pom.xml： 1234567891011&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;5.3.18&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;version&gt;1.9.9.1&lt;/version&gt;&lt;/dependency&gt; 创建一个MyAdivice.java类 其位置：com.spring.aop.MyAdivice.java @Component注解：定义为Spring加载的bean @Aspect注解：把当前类标识为⼀个切⾯供容器读取 @Pointcut(&quot;execution()&quot;)注解：定义切入点，⽅法签名必须是public及void型。 @Before(&quot;pt()&quot;)注解：标识⼀个前置增强⽅法 切入点pt()的定义依托一个不具有实际意义的方法进行，即无参数、无返回值、方法无实际逻辑 1234567891011@Component@Aspectpublic class MyAdvice &#123; @Pointcut(&quot;execution(void com.spring.dao.BookDao.update())&quot;) private void pt()&#123;&#125; @Before(&quot;pt()&quot;) public void method()&#123; System.out.println(System.currentTimeMillis()); &#125;&#125; @EnableAspectJAutoProxy注解：开启AOP代理自动配置 123456@Configuration@ComponentScan(&quot;com.spring&quot;)@EnableAspectJAutoProxypublic class SpringConfig &#123;&#125; 主函数： 1234567public class App &#123; public static void main(String[] args) &#123; ApplicationContext ac = new AnnotationConfigApplicationContext(SpringConfig.class); BookDao bookDao = ac.getBean(BookDao.class); bookDao.update(); &#125;&#125; 123运行结果：1656341601464book dao update~~~ 16.3 AOP工作流程 Spring容器启动 读取所有切面配置中的切入点 初始化bean，判定bean对应的类中的方法是否匹配到任意切入点 匹配失败，创建对象 获取bean，调用方法并执行，完成操作 匹配成功，调用方法并执行，完成操作 获取的bean是代理对象时，根据代理对象的运行模式运行原始方法与增强内容，完成操作 AOP核心本质：代理模式 目标对象(Target)：原始功能去掉共性功能对应的类产生的对象，这种对象是无法直接完成最终工作的 代理(proxy)：目标对象无法直接完成工作，需要进行功能回填，通过原始对象的代理对象实现 代码依旧是入门案例的 但是将主函数修改，打印bookDao的类型： 12345678public class App &#123; public static void main(String[] args) &#123; ApplicationContext ac = new AnnotationConfigApplicationContext(SpringConfig.class); BookDao bookDao = ac.getBean(BookDao.class); System.out.println(bookDao); System.out.println(bookDao.getClass()); &#125;&#125; 123运行结果：com.spring.dao.impl.BookDaoImpl@d23e042class jdk.proxy2.$Proxy20 System.out.println(bookDao)打印出com.spring.dao.impl.BookDaoImpl@d23e042 是因为AOP对BookDao的toString()方法进行了重写 class jdk.proxy2.$Proxy20：最终用的是代理的对象 16.4 AOP切入点表达式切入点：要进行增强的方法 切入点表达式：要进行增强的方法的描述方法 1.语法格式 切入点标准格式：动作关键字(访问修饰符 返回值 包名.接口/类名.方法(参数) 异常名) 12execution(public User com.spring.service.UserService.findById(int))execution(public User com.spring.service.impl.UserServiceImpl.findById(int)) 动作关键字：描述切入点行为动作，如execution表示执行到指定切入点 访问修饰符：public，private等，可以省略 返回值 包名 接口&#x2F;类名：接口名或者类名都可以 方法名 参数 异常名：方法定义中抛出指定异常，可以省略 2.通配符 可以使用通配符描述切入点，快速描述 *：单个独立的任意符号，可以独立出现，也可以作为前缀或者后缀的匹配符出现 1execution(public * com.spring.*.UserService.find*(*)) 解释：匹配com.spring包下的任意包中含有UserService类或接口中所有含有find开头的带有任意一个参数的方法 ..：多个连续的任意符号，可以独立出现，常用于简化包名与参数的书写 1execution(public User com..UserService.findById(..)) 解释：匹配com包中的任意包中的UserService类或接口中的所有名称为findById的方法 +：专用于匹配子类类型 1execution(* *..*Service+.*(..)) 解释：匹配·任意包下的以Service结尾的类或接口的子类中业务层的所有方法 常用写法 1execution(* com.spring.*.*Service.save(..)) 解释：匹配业务层所有的名为save的方法 3.书写技巧 所有代码按照标准规范开发，否则一下技巧全部失效 描述切入点通常描述接口，而不描述实现类 访问控制修饰符针对接口开发均采用public描述(可省略) 返回值类型对应增删改类使用精准类型加速匹配，对于查询类返回值使用*通配符快速描述 包名书写尽量不使用..匹配，效率过低，常用*做单个包描述匹配，或精准匹配 接口名&#x2F;类名书写名称与模块的采用*匹配 如：UserService书写成*Service，绑定业务层接口名 方法名书写以动词进行精准匹配，名词采用*匹配 如：getById书写成getBy*，selectAll书写成selectAll 参数规则较为复杂，根据业务方法灵活调整 通常不使用异常作为匹配规则 16.5 AOP通知类型AOP通知描述了抽取的共性功能，根据共性功能抽取的位置不同，最终运行代码时要将其加入到合理的位置 AOP通知共分为5钟类型 前置通知 1234567891011@Component@Aspectpublic class MyAdvice &#123; @Pointcut(&quot;execution(void com.spring.dao.BookDao.update())&quot;) private void pt()&#123;&#125; @Before(&quot;pt()&quot;) public void method()&#123; System.out.println(&quot;before~~~&quot;); &#125;&#125; 123运行结果：before~~~book dao update~~~ 后置通知 1234567891011@Component@Aspectpublic class MyAdvice &#123; @Pointcut(&quot;execution(void com.spring.dao.BookDao.update())&quot;) private void pt()&#123;&#125; @Before(&quot;pt()&quot;) public void method()&#123; System.out.println(&quot;after~~~&quot;); &#125;&#125; 123运行结果：book dao update~~~after~~~ 环绕通知(重点) 1.无返回值 1234567891011121314@Component@Aspectpublic class MyAdvice &#123; @Pointcut(&quot;execution(void com.spring.dao.BookDao.update())&quot;) private void pt()&#123;&#125; @Around(&quot;pt()&quot;) public void method(ProceedingJoinPoint pjp) throws Throwable &#123; System.out.println(&quot;before~~~&quot;); //表示对原始操作的调用 pjp.proceed(); System.out.println(&quot;after~~~&quot;); &#125;&#125; 1234运行结果：before~~~book dao update~~~after~~~ 2.有返回值 在BookDaoImpl中新写一个有返回值的select方法 12345678@Repositorypublic class BookDaoImpl implements BookDao &#123; @Override public int select() &#123; System.out.println(&quot;book dao select~~~&quot;); return 100; &#125;&#125; 123456789101112131415@Component@Aspectpublic class MyAdvice &#123; @Pointcut(&quot;execution(void com.spring.dao.BookDao.select())&quot;) private void pt()&#123;&#125; @Around(&quot;pt()&quot;) public Object method(ProceedingJoinPoint pjp) throws Throwable &#123; System.out.println(&quot;before~~~&quot;); //表示对原始操作的调用，并获得返回值 Object ret = pjp.proceed(); System.out.println(&quot;after~~~&quot;); return ret; &#125;&#125; 主函数： 12345678public class App &#123; public static void main(String[] args) &#123; ApplicationContext ac = new AnnotationConfigApplicationContext(SpringConfig.class); BookDao bookDao = ac.getBean(BookDao.class); int num = bookDao.select(); System.out.println(num); &#125;&#125; 12345运行结果：before~~~book dao select~~~after~~~100 并且有无返回值都建议这样的写法： 1234567@Around(&quot;pt()&quot;) public Object method(ProceedingJoinPoint pjp) throws Throwable &#123; System.out.println(&quot;before~~~&quot;); Object ret = pjp.proceed(); System.out.println(&quot;after~~~&quot;); return ret; &#125; @Around注意事项 环绕通知必须依赖形参ProceedingJoinPoint才能实现对原始方法的调用 ,进而实现原始方法调用前后同时添加通知 通知中如果未使用ProceedingJoinPoint对原始方法进行调用将跳过原始方法的执行 对原始方法的调用可以不接收返回值 ,通知方法设置成void即可, 如果接收返回值, 必须设定为Object类型 原始方法的返回值如果 是void类型,通知方法的返回值类型可以设置成void ,也可以设置成Object 由于无法预知原始方法运行后是否会抛出异常 ,因此环绕通知方法必须抛出Throwable对象 返回后通知(了解) 1234567891011@Component@Aspectpublic class MyAdvice &#123; @Pointcut(&quot;execution(int com.spring.dao.BookDao.select())&quot;) private void pt()&#123;&#125; @AfterReturning(&quot;pt()&quot;) public void method()&#123; System.out.println(&quot;afterReturn~~~&quot;); &#125;&#125; 1234运行结果：book dao select~~~afterReturn~~~100 @after和@AfterReturning的区别： 原始方法有异常时： @after也会打印通知的方法 @AfterReturning不会打印通知的方法 抛出异常后通知(了解) 1234567891011@Component@Aspectpublic class MyAdvice &#123; @Pointcut(&quot;execution(int com.spring.dao.BookDao.select())&quot;) private void pt()&#123;&#125; @AfterThrowing(&quot;pt()&quot;) public void method()&#123; System.out.println(&quot;afterThrowing~~~&quot;); &#125;&#125; 123运行结果：book dao select~~~100 @AfterThrowing注解：只有原始方法抛出异常，才会执行通知的方法 16.6 AOP通知获取数据","categories":[{"name":"Java","slug":"Java","permalink":"http://example.com/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"},{"name":"框架","slug":"框架","permalink":"http://example.com/tags/%E6%A1%86%E6%9E%B6/"}]},{"title":"剑指 Offer II 091. 粉刷房子","slug":"每日LeetCode/剑指 Offer II 091 粉刷房子","date":"2022-06-25T02:00:00.000Z","updated":"2022-06-28T01:17:14.290Z","comments":true,"path":"2022/06/25/每日LeetCode/剑指 Offer II 091 粉刷房子/","link":"","permalink":"http://example.com/2022/06/25/%E6%AF%8F%E6%97%A5LeetCode/%E5%89%91%E6%8C%87%20Offer%20II%20091%20%E7%B2%89%E5%88%B7%E6%88%BF%E5%AD%90/","excerpt":"","text":"题目：假如有一排房子，共 n 个，每个房子可以被粉刷成红色、蓝色或者绿色这三种颜色中的一种，你需要粉刷所有的房子并且使其相邻的两个房子颜色不能相同。 当然，因为市场上不同颜色油漆的价格不同，所以房子粉刷成不同颜色的花费成本也是不同的。每个房子粉刷成不同颜色的花费是以一个 n x 3 的正整数矩阵 costs来表示的。 例如，costs[0][0] 表示第 0 号房子粉刷成红色的成本花费；costs[1][2] 表示第 1 号房子粉刷成绿色的花费，以此类推。请计算出粉刷完所有房子最少的花费成本。 示例： 输入: costs &#x3D; [[17,2,17],[16,16,5],[14,3,19]]输出: 10解释: 将 0 号房子粉刷成蓝色，1 号房子粉刷成绿色，2 号房子粉刷成蓝色。 最少花费: 2 + 5 + 3 &#x3D; 10。 思路：1.递归代码(cpp)：12345678910111213141516171819202122232425262728293031class Solution &#123;public: int def(vector&lt;vector&lt;int&gt;&gt;&amp; costs, int pos, int n, vector&lt;vector&lt;int&gt;&gt; flag) &#123; //到达最后，没有房子了，退出 if (pos == n) return 0; int ans = INT_MAX; //依次选择三种颜色 for (int i = 0; i &lt; 3; i++) &#123; int temp = INT_MAX; vector&lt;vector&lt;int&gt;&gt; temp_flag(flag); //粉刷第一个房子，无需看前面房子的颜色，因为前面没有房子。 if (pos == 0) &#123; temp_flag[pos][i] = -1; temp = def(costs, pos + 1, n, temp_flag) + costs[pos][i]; &#125; //粉刷墙，要看前面用了什么颜色 else if (flag[pos - 1][i] != -1) &#123; //将这个房子的颜色标记 temp_flag[pos][i] = -1; temp = def(costs, pos + 1, n, temp_flag) + costs[pos][i]; &#125; //选择花费最少的金额 ans = min(ans, temp); &#125; return ans; &#125; int minCost(vector&lt;vector&lt;int&gt;&gt;&amp; costs) &#123; return def(costs, 0, costs.size(), costs); &#125;&#125;; 采用递归的方法，提交后，结果执行超时。 2.动态规划$$Red[pos][0]&#x3D;\\begin{cases}cost[0][0] &amp; pos &#x3D; 0; \\min(Green[pos+1][1],Blue[pos+1][2]) + costs[pos][0] &amp; pos&gt;0\\end{cases} \\$$ $$Green[pos][1]&#x3D;\\begin{cases}cost[0][1] &amp; pos &#x3D; 0; \\min(Red[pos+1][0],Blue[pos+1][2]) + costs[pos][1] &amp; pos&gt;0\\end{cases} \\$$ $$Blue[pos][2]&#x3D;\\begin{cases}cost[0][2] &amp; pos &#x3D; 0; \\min(Red[pos+1][0],Green[pos+1][1]) + costs[pos][2] &amp; pos&gt;0\\end{cases}$$ 画出动态规划图，以示例为例： costs = [[17,2,17],[16,16,5],[14,3,19]] 颜色\\pos 0 1 2 Red(0) 17 18 21 Green(1) 2 33 10 Blue(2) 17 7 37 $$mincost &#x3D; min(dp[2][0],dp[2][1],dp[2][2])$$ 代码(cpp)：123456789101112131415161718192021class Solution &#123;public: int minCost(vector&lt;vector&lt;int&gt;&gt;&amp; costs) &#123; int n = costs.size(); vector&lt;int&gt; red(n, 0); vector&lt;int&gt; blue(n, 0); vector&lt;int&gt; green(n, 0); // 初始化 red[0] = costs[0][0]; blue[0] = costs[0][1]; green[0] = costs[0][2]; for (int i = 1; i &lt; n; ++i) &#123; red[i] = min(blue[i - 1], green[i - 1]) + costs[i][0]; blue[i] = min(red[i - 1], green[i - 1]) + costs[i][1]; green[i] = min(red[i - 1], blue[i - 1]) + costs[i][2]; &#125; return min(red[n - 1], min(blue[n - 1], green[n - 1])); &#125;&#125;; 复杂度分析 时间复杂度：O(n)，其中 n 是房子个数。需要遍历全部房子一次，由于颜色数量固定是三种，因此对于每个房子计算粉刷房子的最小花费成本的时间是 O(1)，总时间复杂度是 O(n)。 空间复杂度：O(1)。使用空间优化的方法，只需要维护一个长度为 3 的数组，空间复杂度是 O(1)。","categories":[{"name":"每日LeetCode","slug":"每日LeetCode","permalink":"http://example.com/categories/%E6%AF%8F%E6%97%A5LeetCode/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"},{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"515. 在每个树行中找最大值(中等)","slug":"每日LeetCode/515 在每个树行中找最大值","date":"2022-06-24T01:04:00.000Z","updated":"2022-06-28T01:16:30.086Z","comments":true,"path":"2022/06/24/每日LeetCode/515 在每个树行中找最大值/","link":"","permalink":"http://example.com/2022/06/24/%E6%AF%8F%E6%97%A5LeetCode/515%20%E5%9C%A8%E6%AF%8F%E4%B8%AA%E6%A0%91%E8%A1%8C%E4%B8%AD%E6%89%BE%E6%9C%80%E5%A4%A7%E5%80%BC/","excerpt":"","text":"题目：给定一棵二叉树的根节点 root ，请找出该二叉树中每一层的最大值。 示例： 输入: root &#x3D; [1,3,2,5,3,null,9]输出: [1,3,9] 思路：深度优先搜索我们采用树的先序遍历，来进行深度优先搜索，并用pos来记录当前树的高度，就可以通过pos高度来判断是否在同一层，并且是否更新此高度的最大值。 代码(cpp)：123456789101112131415161718192021222324252627class Solution &#123;public: void dfs(TreeNode* root, vector&lt;int&gt;&amp; result, int pos)&#123; //如果该结点为空，则退出 if(root == nullptr) return; if(result.size() == pos)&#123; //数组的大小小于高度，大小需要加1 result.push_back(root-&gt;val); &#125; else&#123; //判断该层的某个结点，与之前记录的比较大小 result[pos] = max(result[pos], root-&gt;val); &#125; //遍历左子树，高度+1 dfs(root-&gt;left, result, pos+1); //遍历右子树，高度+1 dfs(root-&gt;right, result, pos+1); &#125; vector&lt;int&gt; largestValues(TreeNode* root) &#123; vector&lt;int&gt; result; dfs(root, result, 0); return result; &#125;&#125;; 复杂度分析 时间复杂度：O(n)，其中 n 为二叉树节点个数。二叉树的遍历中每个节点会被访问一次且只会被访问一次。 空间复杂度：O(pos)。其中 pos 表示二叉树的高度。递归函数需要栈空间，而栈空间取决于递归的深度，因此空间复杂度等价于二叉树的高度。","categories":[{"name":"每日LeetCode","slug":"每日LeetCode","permalink":"http://example.com/categories/%E6%AF%8F%E6%97%A5LeetCode/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"},{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"30. 串联所有单词的子串","slug":"每日LeetCode/30 串联所有单词的子串","date":"2022-06-23T03:53:00.000Z","updated":"2022-06-28T01:15:31.687Z","comments":true,"path":"2022/06/23/每日LeetCode/30 串联所有单词的子串/","link":"","permalink":"http://example.com/2022/06/23/%E6%AF%8F%E6%97%A5LeetCode/30%20%E4%B8%B2%E8%81%94%E6%89%80%E6%9C%89%E5%8D%95%E8%AF%8D%E7%9A%84%E5%AD%90%E4%B8%B2/","excerpt":"","text":"题目：给定一个字符串s和一些长度相同的单词words。找出s中恰好可以由words中所有单词串联形成的子串的起始位置。 注意子串要与words中的单词完全匹配，中间不能有其他字符，但不需要考虑words中单词串联的顺序。 示例： 输入：s &#x3D; “barfoofoobarthefoobarman”, words &#x3D; [“bar”,”foo”,”the”]输出：[6,9,12] 输出返回字串的第一个字符在s中的位置 第一个字串：barfoofoobarthefoobarman 6 第二个字串：barfoofoobarthefoobarman 9 第三个字符：barfoofoobarthefoobarman 12 思路：滑动窗口 word_len为每个单词的长度，因为每个单词的长度都相同； word_num为words数组中单词的个数； total_len为words数组中所有的单词的总长度； map来记录words数组中每个单词的个数； t_map遍历s时用来记录； 左指针left和右指针right用来当作左右边界； count用来统计已经匹配单词的个数，如果count == word_num，就证明匹配成功； 遍历s时无需一个一个字符的遍历，可以一个一个单词的遍历，right += word_len； 如果截取的单词map中不存在，则之前记录的全部无效，清空t_map和count； 如果某个单词在t_map中的个数大于map中的个数，就需要删除匹配的多余的单词，就需要删除窗口中第一个单词，直到某个单词出现的次数小于map中的个数 代码(cpp)：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364class Solution &#123;public: vector&lt;int&gt; findSubstring(string s, vector&lt;string&gt;&amp; words) &#123; //用来存放结果 vector&lt;int&gt; result; //判断s和words是否为空，如果其中有一个为空，则返回空数组 if(s.empty()||words.empty())&#123; return result; &#125; int word_len = words[0].size(); //一个单词的长度（每个单词长度都相同） int word_num = words.size(); // 单词的总个数 int total_len = word_len*word_num; // 全部单词的长度 //建立单词-&gt;单词个数的映射 unordered_map&lt;string, int&gt; map; //统计每个单词的个数 for(auto &amp;word : words)&#123; //map[key]:返回key值所对应的value值，如果不存在key值，则会使用该key值向当前容器中插入一个新value值为 0 map[word]++; //等价于 map[word] += 1 &#125; for(int i = 0; i&lt; word_len; i++)&#123; //left和right用来表示窗口的左右边界 int left = i; int right = i; //count用来统计已经匹配的单词个数 int count = 0; unordered_map&lt;string, int&gt; t_map; //开始滑动窗口 //right右边界依次累加单词的长度，直到超过s的长度停止循环 while(right + word_len &lt;= s.size())&#123; //substr(pos, n):从第pos的位置开始截取n个字符获取单词 string word = s.substr(right, word_len); right += word_len; //right跳到下一个单词 //count(key):在容器中查找以key键的键值对的个数。如果为0，说明此单词word在words数组中不存在。 if(map.count(word) == 0)&#123; count = 0; //清空之前统计的个数 left = right; //将左指针left移动到右指针right位置上重新开始 t_map.clear(); //之前匹配的单词没用了，清空t_map中的元素 &#125; //如果不为0，说明此单词word在words数组中存在。 else&#123; count++; //统计个数加1 t_map[word]++;// word所对应的个数加1 //t_map中的word对应的个数大于map的word对应的个数，说明匹配到多余的单词了 while(t_map[word]&gt; map[word])&#123; //获取窗口的第一个单词 string t_word = s.substr(left, word_len); //将t_word这个单词对应的个数减1 //并非是那个大于map中个数的单词 t_map[t_word]--; count--; //统计个数减1 left += word_len;//将左指针跳到下一个 &#125; //如果count等于单词的个数说明匹配成功，将左指针位置记录 if(count == word_num)&#123; result.push_back(left); &#125; &#125; &#125; &#125; return result; &#125;&#125;; 复杂度分析 时间复杂度：O(ls×n)，其中 ls 是输入 s 的长度，n 是 words 中每个单词的长度。需要做 n 次滑动窗口，每次需要遍历一次 s。","categories":[{"name":"每日LeetCode","slug":"每日LeetCode","permalink":"http://example.com/categories/%E6%AF%8F%E6%97%A5LeetCode/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"},{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"513. 找树左下角的值","slug":"每日LeetCode/513 找树左下角的值","date":"2022-06-22T03:11:00.000Z","updated":"2022-06-28T01:16:04.637Z","comments":true,"path":"2022/06/22/每日LeetCode/513 找树左下角的值/","link":"","permalink":"http://example.com/2022/06/22/%E6%AF%8F%E6%97%A5LeetCode/513%20%E6%89%BE%E6%A0%91%E5%B7%A6%E4%B8%8B%E8%A7%92%E7%9A%84%E5%80%BC/","excerpt":"","text":"题目：给定一个二叉树的 根节点 root，请找出该二叉树的 最底层 最左边 节点的值。 假设二叉树中至少有一个节点。 示例: 输入: [1,2,3,4,null,5,6,null,null,7]输出: 7 思路：深度优先搜索(DFS)我采用了优先遍历左节点，再遍历右节点，因为只有优先遍历左节点，才会优先记录当前深度左节点的值，所以就没有必要记录当前深度右边的值了。 使用depth记录当前树的深度，current_val为记录的深度current_depth的最左边的值。 进行判断如果depth的深度大于current_depth的深度，将current_val的值设置为当前结点的值，并将current_depth的值设置当前结点深度depth 代码(cpp)：1234567891011121314151617181920212223242526272829class Solution &#123;public: void dfs(TreeNode* root, int depth, int&amp; current_depth, int&amp; current_val) &#123; if (root == nullptr) //如果当前结点为空，则退出 &#123; return; &#125; //优先遍历左节点，深度加1 dfs(root-&gt;left, depth+1, current_depth, current_val); //其次遍历右节点，深度加1 dfs(root-&gt;right, depth+1, current_depth, current_val); //如果当前深度大于记录的深度 if (depth &gt; current_depth) &#123; current_depth = depth; //将当前深度记录到current_depth current_val = root-&gt;val; //将当前结点值记录到current_val &#125; &#125; int findBottomLeftValue(TreeNode* root) &#123; int current_depth = 0; //初始化current_depth int current_val = 0; //初始化current_val //因为有根结点存在，将depth设置为1，而非0 dfs(root, 1, current_depth, current_val); return current_val; &#125;&#125;; 复杂度分析 ​ 时间复杂度：O(n)，其中 n 是二叉树的节点数目。需要遍历 n 个节点。 ​ 空间复杂度：O(n)。递归栈需要占用 O(n) 的空间。","categories":[{"name":"每日LeetCode","slug":"每日LeetCode","permalink":"http://example.com/categories/%E6%AF%8F%E6%97%A5LeetCode/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"},{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]}],"categories":[{"name":"每日LeetCode","slug":"每日LeetCode","permalink":"http://example.com/categories/%E6%AF%8F%E6%97%A5LeetCode/"},{"name":"Java","slug":"Java","permalink":"http://example.com/categories/Java/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"},{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"},{"name":"框架","slug":"框架","permalink":"http://example.com/tags/%E6%A1%86%E6%9E%B6/"}]}