{"meta":{"title":"活着就是为了摸鱼🐟！！！","subtitle":"","description":"一个不起眼的小博客","author":"一个小垃圾","url":"http://example.com","root":"/"},"pages":[{"title":"archives","date":"2022-06-25T09:46:11.000Z","updated":"2022-06-25T10:00:28.430Z","comments":true,"path":"archives/index.html","permalink":"http://example.com/archives/index.html","excerpt":"","text":""},{"title":"所有标签","date":"2022-06-25T09:44:36.000Z","updated":"2022-06-25T10:10:32.117Z","comments":true,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""},{"title":"关于我是谁","date":"2022-06-25T09:46:19.000Z","updated":"2022-06-26T00:50:58.784Z","comments":true,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":""},{"title":"所有分类","date":"2022-06-25T09:45:03.000Z","updated":"2022-06-25T10:09:55.599Z","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"","slug":"考研/高数","date":"2022-09-27T13:40:02.560Z","updated":"2022-09-27T13:40:12.715Z","comments":true,"path":"2022/09/27/考研/高数/","link":"","permalink":"http://example.com/2022/09/27/%E8%80%83%E7%A0%94/%E9%AB%98%E6%95%B0/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"(每日LeetCode)面试题 01.02. 判定是否互为字符重排","slug":"每日LeetCode/2022-9/面试题 01.02 判定是否互为字符重排","date":"2022-09-27T04:43:00.000Z","updated":"2022-09-27T04:43:35.593Z","comments":true,"path":"2022/09/27/每日LeetCode/2022-9/面试题 01.02 判定是否互为字符重排/","link":"","permalink":"http://example.com/2022/09/27/%E6%AF%8F%E6%97%A5LeetCode/2022-9/%E9%9D%A2%E8%AF%95%E9%A2%98%2001.02%20%E5%88%A4%E5%AE%9A%E6%98%AF%E5%90%A6%E4%BA%92%E4%B8%BA%E5%AD%97%E7%AC%A6%E9%87%8D%E6%8E%92/","excerpt":"","text":"题目： 给定两个字符串 s1 和 s2，请编写一个程序，确定其中一个字符串的字符重新排列后，能否变成另一个字符串。 示例： 输入: s1 &#x3D; “abc”, s2 &#x3D; “bca”输出: true 代码(cpp)： 方式一：排序 12345678910111213141516171819class Solution &#123;public: bool CheckPermutation1(string s1, string s2) &#123; if(s1.size() != s2.size())&#123; return false; &#125; sort(s1.begin(), s1.end()); sort(s2.begin(), s2.end()); for(int i = 0; i &lt; s1.size(); i++)&#123; if(s1[i] != s2[i])&#123; return false; &#125; &#125; return true; &#125;&#125;; 方式二：哈希 12345678910111213141516171819202122class Solution &#123;public: bool CheckPermutation(string s1, string s2)&#123; if(s1.size() != s2.size())&#123; return false; &#125; vector&lt;int&gt; map(26, 0); for(auto&amp; s : s1)&#123; map[s - &#x27;a&#x27;]++; &#125; for(auto&amp; s : s2)&#123; if(map[s - &#x27;a&#x27;] != 0)&#123; map[s - &#x27;a&#x27;]--; &#125; else return false; &#125; return true; &#125;&#125;;","categories":[{"name":"每日LeetCode","slug":"每日LeetCode","permalink":"http://example.com/categories/%E6%AF%8F%E6%97%A5LeetCode/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"},{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"(每日LeetCode)面试题 17.19. 消失的两个数字","slug":"每日LeetCode/2022-9/面试题 17.19 消失的两个数字","date":"2022-09-26T14:25:00.000Z","updated":"2022-09-27T04:42:48.846Z","comments":true,"path":"2022/09/26/每日LeetCode/2022-9/面试题 17.19 消失的两个数字/","link":"","permalink":"http://example.com/2022/09/26/%E6%AF%8F%E6%97%A5LeetCode/2022-9/%E9%9D%A2%E8%AF%95%E9%A2%98%2017.19%20%E6%B6%88%E5%A4%B1%E7%9A%84%E4%B8%A4%E4%B8%AA%E6%95%B0%E5%AD%97/","excerpt":"","text":"题目： 给定一个数组，包含从 1 到 N 所有的整数，但其中缺了两个数字。你能在 O(N) 时间内只用 O(1) 的空间找到它们吗？ 以任意顺序返回这两个数字均可。 示例： 输入: [2,3]输出: [1,4] 代码(cpp)： 1234567891011121314151617181920212223242526class Solution &#123;public: vector&lt;int&gt; missingTwo(vector&lt;int&gt;&amp; nums) &#123; //总长度 int all = nums.size() + 2; //获取总长度的元素总和 int all_sum = all*(1 + all) / 2; //计算剩余的总和 int remain_sum = all_sum; for(auto&amp; num : nums)&#123; remain_sum -= num; &#125; //获取结果中间的元素，说明有一个答案必定有一个小于mid的 int mid = remain_sum / 2; //计算出总和 int mid_sum = mid*(1 + mid) / 2; //获取那个小于mid的答案 for(auto&amp; num : nums)&#123; if(num &lt;= mid)&#123; mid_sum -= num; &#125; &#125; //用剩余的减去mid_sumjiu&#x27;de return &#123;mid_sum, remain_sum - mid_sum&#125;; &#125;&#125;;","categories":[{"name":"每日LeetCode","slug":"每日LeetCode","permalink":"http://example.com/categories/%E6%AF%8F%E6%97%A5LeetCode/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"},{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"(每日LeetCode)1652. 拆炸弹","slug":"每日LeetCode/2022-9/1652 拆炸弹","date":"2022-09-24T01:25:00.000Z","updated":"2022-09-24T01:25:16.126Z","comments":true,"path":"2022/09/24/每日LeetCode/2022-9/1652 拆炸弹/","link":"","permalink":"http://example.com/2022/09/24/%E6%AF%8F%E6%97%A5LeetCode/2022-9/1652%20%E6%8B%86%E7%82%B8%E5%BC%B9/","excerpt":"","text":"题目：你有一个炸弹需要拆除，时间紧迫！你的情报员会给你一个长度为 n 的 循环 数组 code 以及一个密钥 k 。 为了获得正确的密码，你需要替换掉每一个数字。所有数字会 同时 被替换。 如果 k &gt; 0 ，将第 i 个数字用 接下来 k 个数字之和替换。 如果 k &lt; 0 ，将第 i 个数字用 之前 k 个数字之和替换。 如果 k &#x3D;&#x3D; 0 ，将第 i 个数字用 0 替换。 由于 code 是循环的， code[n-1] 下一个元素是 code[0] ，且 code[0] 前一个元素是 code[n-1] 。 给你 循环 数组 code 和整数密钥 k ，请你返回解密后的结果来拆除炸弹！ 示例： 输入：code &#x3D; [5,7,1,4], k &#x3D; 3输出：[12,10,16,13]解释：每个数字都被接下来 3 个数字之和替换。解密后的密码为 [7+1+4, 1+4+5, 4+5+7, 5+7+1]。注意到数组是循环连接的。 输入：code &#x3D; [2,4,9,3], k &#x3D; -2输出：[12,5,6,13]解释：解密后的密码为 [3+9, 2+3, 4+2, 9+4] 。注意到数组是循环连接的。如果 k 是负数，那么和为 之前 的数字。 思路：分为3中情况，模拟出3种情况即可 代码(cpp)：123456789101112131415161718192021222324252627282930class Solution &#123;public: vector&lt;int&gt; decrypt(vector&lt;int&gt;&amp; code, int k) &#123; vector&lt;int&gt; ans; int n = code.size(); if(k == 0)&#123; return vector&lt;int&gt;(n); &#125; else if (k &gt; 0)&#123; for(int i = 0; i &lt; code.size(); i++)&#123; int sum = 0; for(int j = 0; j &lt; k; j++)&#123; sum += code[(i + j + 1) % n]; &#125; ans.emplace_back(sum); &#125; &#125; else &#123; for(int i = 0; i &lt; code.size(); i++)&#123; int sum = 0; for(int j = 0; j &lt; abs(k); j++)&#123; sum += code[(i - j - 1 + n) % n]; &#125; ans.emplace_back(sum); &#125; &#125; return ans; &#125;&#125;;","categories":[{"name":"每日LeetCode","slug":"每日LeetCode","permalink":"http://example.com/categories/%E6%AF%8F%E6%97%A5LeetCode/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"},{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"(每日LeetCode)707. 设计链表","slug":"每日LeetCode/2022-9/707 设计链表","date":"2022-09-23T01:23:00.000Z","updated":"2022-09-23T01:24:10.730Z","comments":true,"path":"2022/09/23/每日LeetCode/2022-9/707 设计链表/","link":"","permalink":"http://example.com/2022/09/23/%E6%AF%8F%E6%97%A5LeetCode/2022-9/707%20%E8%AE%BE%E8%AE%A1%E9%93%BE%E8%A1%A8/","excerpt":"","text":"题目：设计链表的实现。您可以选择使用单链表或双链表。单链表中的节点应该具有两个属性：val 和 next。val 是当前节点的值，next 是指向下一个节点的指针&#x2F;引用。如果要使用双向链表，则还需要一个属性 prev 以指示链表中的上一个节点。假设链表中的所有节点都是 0-index 的。 在链表类中实现这些功能： get(index)：获取链表中第 index 个节点的值。如果索引无效，则返回-1。 addAtHead(val)：在链表的第一个元素之前添加一个值为 val 的节点。插入后，新节点将成为链表的第一个节点。 addAtTail(val)：将值为 val 的节点追加到链表的最后一个元素。 addAtIndex(index,val)：在链表中的第 index 个节点之前添加值为 val 的节点。如果 index 等于链表的长度，则该节点将附加到链表的末尾。如果 index 大于链表长度，则不会插入节点。如果index小于0，则在头部插入节点。 deleteAtIndex(index)：如果索引 index 有效，则删除链表中的第 index 个节点。 示例： MyLinkedList linkedList &#x3D; new MyLinkedList();linkedList.addAtHead(1);linkedList.addAtTail(3);linkedList.addAtIndex(1,2); &#x2F;&#x2F;链表变为1-&gt; 2-&gt; 3linkedList.get(1); &#x2F;&#x2F;返回2linkedList.deleteAtIndex(1); &#x2F;&#x2F;现在链表是1-&gt; 3linkedList.get(1); &#x2F;&#x2F;返回3 代码(cpp)：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566class MyLinkedList &#123;public: MyLinkedList() &#123; this-&gt;head = new ListNode(-1, nullptr); this-&gt;size = 0; &#125; int get(int index) &#123; if(index &lt; 0 || this-&gt;size &lt;= index) return -1; auto temp = this-&gt;head; while(index &gt;=0) &#123; temp = temp-&gt;next; index--; &#125; return temp-&gt;val; &#125; void addAtHead(int val) &#123; addAtIndex(0, val); &#125; void addAtTail(int val) &#123; this-&gt;addAtIndex(this-&gt;size, val); &#125; void addAtIndex(int index, int val) &#123; if(index &lt; 0 || this-&gt;size &lt; index) return; auto temp = this-&gt;head; while(index &gt; 0) &#123; temp = temp-&gt;next; index--; &#125; ListNode* newNode = new ListNode(val, temp-&gt;next); temp-&gt;next = newNode; this-&gt;size++; &#125; void deleteAtIndex(int index) &#123; if(index &lt; 0 || this-&gt;size &lt;= index) return; auto temp = this-&gt;head; while(index &gt; 0) &#123; temp = temp-&gt;next; index--; &#125; auto e = temp-&gt;next; temp-&gt;next = e-&gt;next; delete e; this-&gt;size--; &#125;private: class ListNode &#123; public: int val; ListNode* next; ListNode(int val, ListNode* next) &#123; this-&gt;val = val; this-&gt;next = next; &#125; &#125;; int size; ListNode* head;&#125;; 复杂度分析： 时间复杂度：初始化消耗 O(1)，get 消耗 O(index)，addAtHead 消耗 O(1)，addAtTail 消耗 O(n)，其中 n 为链表当前长度，即 addAtHead，addAtTail 和 addAtIndex 已调用次数之和，addAtIndex 消耗 O(index)。 空间复杂度：所有函数的单次调用空间复杂度均为 O(1)，总体空间复杂度为 O(n)，其中 n 为 addAtHead，addAtTail 和 addAtIndex 调用次数之和。","categories":[{"name":"每日LeetCode","slug":"每日LeetCode","permalink":"http://example.com/categories/%E6%AF%8F%E6%97%A5LeetCode/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"},{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"Git的学习笔记","slug":"Java/Git","date":"2022-09-21T14:17:30.898Z","updated":"2022-09-27T14:10:34.902Z","comments":true,"path":"2022/09/21/Java/Git/","link":"","permalink":"http://example.com/2022/09/21/Java/Git/","excerpt":"","text":"1.概述1.1 开发常用场景 备份 代码还原 协同开发 追溯问题代码的编写人员和编写时间 1.2 SVNSVN(subversion)，是一个开放源代码的版本控制系统，通过采用分支管理系统的高效管理，简而言之就是用于多个人共同开发同一个项目，实现共享资源，实现最终集中式的管理。 工作流程： SVN是集中式版本控制系统，版本库是集中放在中央服务器的工作流程如下: 从中央服务器远程仓库下载代码 修改后将代码提交到中央服务器远程仓库 优缺点: 优点：简单,易操作 缺点：所有代码必须放在中央服务器 服务器一旦宕机无法提交代码,即容错性较差 离线无法提交代码,无法及时记录我们的提交行为 1.3 Git工作流程： Git是分布式版本控制系统(Distributed Version Control System，简称 DVCS)，分为两种类型的仓库： 本地仓库 远程仓库 工作流程如下： 从远程仓库中克隆或拉取代码到本地仓库(clone&#x2F;pull) 从本地进行代码修改 在提交前先将代码提交到暂存区 提交到本地仓库。本地仓库中保存修改的各个历史版本 修改完成后，需要和团队成员共享代码时，将代码push到远程仓库 Git和SVN的区别： SVN 是集中式版本控制工具，Git是分布式版本控制工具 SVN不支持离线提交，Git支持离线提交代码 1.4 Git 工作流程flowchart LR A[(Remote远程仓库)] B[(Repository本地仓库)] C[(index暂存区)] D[workspace工作区] A--1.抓取/克隆fetch/clone-->B A--5.拉取pullfetch+merge-->D B--2.检出checked-->D B--6.推送push-->A C--4.提交commit-->B D--3.添加add-->C 命令如下： clone(克隆)：从玩程仓庄中克隆代码到本地仓库 checkout(检出)：从本地仓库中检出一个仓库分支然后进行修订 add(添加)：在提交的先格代码堤交到智存区 commit(提交)：提交到本地仓库，本地仓南中保存修放的各个历史版本 fetch(抓取)：从污程车，抓取到本地仓库，不进行任何的合井动作，一般操作比较少。 pull(拉取)：从运程库拉到本地库，白动进行合井(merge)，然后放到到工作区，相当于fetch+merge push(推送)：修改完成后，需要和团队成员共享代码，将代码推送到远程仓库 2.Git的使用及常用命令再windows桌面或者文件夹中右键，会出现： Git GUI：Git提供的图像化界面工具 Git Bash：Git提供的命令行工具 2.1 基本配置配置用户信息 打开Git Bash 设置用户信息 git config --global user.name&quot;XXX&quot; git config --global user.email&quot;666@qq.com&quot; 查看用户信息 git config --global user.name git config --global user.email 为常用指令配置别名有些常用的指令参数非常多，每次都要出入好多参数，我们可以起别名： 打开Users目录，创建.bashrc文件 再Users目录中右键，打开Git Bash，输入下面来创建.bashrc文件 1touch ~/.bashrc 再.bashrc文件输入以下内容 1234#用于输出git提交日志alias git-log=&#x27;git log --pretty=oneline --all --graph --abbrev-commit&#x27;#用于输出当前目录所有文件及其文件信息alias ll=&#x27;ls -al&#x27; 接着执行： 1source ~/.bash 解决Git Bash乱码问题 打开Git Bash执行下面命令： 1git config --global core.quotepath false $&#123;git_home&#125;/etc/bash.bashrc文件最后加入下面内容： 12export LANG=&quot;zh_CN.UTF-8&quot;export LC_ALL=&quot;zh_CN.UTF-8&quot; 2.2 获取本地仓库要使用Git对代码进行版本控制，首先需要获得本地仓库 在电脑的任意位置创建一个空目录(例如test)作为我们的本地Git仓库 进入这个目录中，点击右键打开Git bash窗口 执行命令： 1git init 如果创建成功后可在文件夹下看到隐藏的.git目录。 2.3 基础操作命令Git工作目录对于文件的修改(增加、删除、更新)会存在几个状态，这些修改状态会随着执行Git命令而发生变化 使用命令来控制这些状态之间的转换： git add：工作区–&gt;暂存区 git commit：暂存区–&gt;本地仓库 查看修改的状态查看修改的状态(暂存区、工作区)： 1git status 添加工作区到暂存区1git add 文件名 或者使用通配符，如：将所有文件添加到暂存区 1git add . 提交暂存区到本地仓库1git commit -m &#x27;注释内容&#x27; 查看日志1git log [option] option多个参数： --all：显示所有分支 --pretty=oneline：将提交的信息显示为一行 --abbrev-commit：使得输出的commitId更简短 --graph：以图的形式显示 1git log --pretty=oneline --all --graph --abbrev-commit 或者在之前的常用指令设置的别名： 1git-log 版本回退1git reset --hard commitID commitID可以使用git-log或git log查看 查看已经删除的记录： 1git reflog 添加文件至忽略列表在工作目录创建一个名为.gitignore的文件(文件名固定) 可以列出要忽略的文件名，如： 忽略后缀为a的文件： 1*.a 2.4 分支几乎所有的版本控制系统都以某种形式支持分支。使用分支意味着你可以把你的工作从开发主线上分离来进行重大的BUG修改，开发新功能，以免影响开发主线 查看本地分支1git branch 创建本地分支1git branch 分支名 切换分支1git checkout 分支名 还可以切换到另一个不存在的分支(创建并切换) 1git checkout -b 分支名 合并分支一个分支上的提交可以合并到另一个分支 1git merge 分支名称 删除分支不能删除当前分支，只能删除其他分支 删除分支时，需要删除其他分支： 1git branch -d b1 不做任何检查，强制删除： 1git branch -D b1 解决冲突当两个分支上对文件的修改可能会存在冲突，如同时修改同一个文件的同一行，这时需要手动解决冲突，解决步骤如下： 处理文件中冲突的地方 将解决完的冲突的文件加入暂存区(add) 提交到仓库(commit) 开发中分支使用原则在开发中，一般有如下分支使用原则与流程： master(生产分支) 线上分支、主分支、中小规模项目作为线上运行的应用对应的分支 develop(开发分支) 是从master创建的分支，一般作为开发部门的主要开发分支，如果没有其他并行开发不同期上线要求，都可以在此版本进行开发，阶段开发完成后，需要合并到master分支，准备上线 feature&#x2F;XXX分支 从develop创建的分支，一般是同期并行开发，但不同期上线时创建的分支，分支上的研发任务完成后合并到develop分支。 hotfix&#x2F;XXX分支 从master派生的分支，一般作为线上bug修复使用，修复完成后需要合并到master、test、 develop分支。 还有其他一些分支如，test分支(用于代码测试)、pre分支(预上线分支)等 3.Git远程仓库3.1 常用的托管仓库那么我们如何搭建Git远程仓库呢？ 我们可以借助互联网上提供的一些代码托管服务水实现，其中比较常用的有GitHub、码云等。 gitHub是一个面向开源及私有软件项目的托管平台，因为只支持Git作为唯一的版本库格式进行托管，故名gitHub 码云(gitee)是国内的一个代码托管平台，由手服务器在国内，所以相比于GitHub，码云速度会更快 3.2 操作远程仓库远程仓库的添加命令：git remote add &lt;远端名称&gt; &lt;仓库路径&gt; 远端名称：默认为origin(可以自己取)，取决于远端服务器设置 仓库名称：从远程仓库服务器获取的URL 1git remote add origin 仓库地址 查看远程仓库1git remote 推送到远程仓库命令：git push [-f] [--set-upstream] [远端名称] [本地分支名]:[远端分支名] -f：强制覆盖 注意：如果本地分支名和远端分支名相同，则只需写本地分支名即可 1git push origin master --set-upstream：推送到远端的同时并建立起与远端分支的关联 1git push --set-upstream origin master 如果当前分支已经和远端分支关联，则可以省略分支名和远端名 1git push 本地分支与远端分支查看关联关系： 1git branch -vv 从远程仓库克隆将远程仓库克隆到本地： 命令：git clone &lt;仓库路径&gt; &lt;本地目录&gt; 注意：本地目录可以省略，会在当前文件夹自动生成一个目录 1git clone 仓库路径 从远程仓库抓取和拉取抓取：将仓库里的更新都抓取到本地，不会进行合并 抓取命令：git fetch [remote name] [branch name] 如果不指定远端名称和分支名，则会抓取所有分支 拉取：将远端仓库的修改拉到本地并自动进行合并，等同于fetch+merge 拉取命令：git pull [remote name] [branch name] 如果不指定远端名称和分支名，则会抓取所有分支并更新当前分支 解决合并冲突在一段时间，A、B用户修改了同一个文件，且修改了同一行位置的代码，此时会发生合并冲突。 A用户在本地修改代码后优先推送到远程仓库，此时B用户在本地修订代码，提交到本地仓库后，也需要推送到远程仓库，此时B用户晚于A用户，故需要先拉取远程仓库的提交，经过合井后才能推送到远端分支,如下图所示。 在B用户拉取代码时，因为A、B用户同一段时同修改了同一个文件的相同位置代码，故会发生合并冲突。 远程分支也是分支，所以合井时冲突的解决方式也和解決本地分支冲突相同相同","categories":[{"name":"Java","slug":"Java","permalink":"http://example.com/categories/Java/"}],"tags":[{"name":"Git","slug":"Git","permalink":"http://example.com/tags/Git/"}]},{"title":"(每日LeetCode)698. 划分为k个相等的子集","slug":"每日LeetCode/2022-9/698 划分为k个相等的子集","date":"2022-09-20T01:18:00.000Z","updated":"2022-09-20T01:18:46.428Z","comments":true,"path":"2022/09/20/每日LeetCode/2022-9/698 划分为k个相等的子集/","link":"","permalink":"http://example.com/2022/09/20/%E6%AF%8F%E6%97%A5LeetCode/2022-9/698%20%E5%88%92%E5%88%86%E4%B8%BAk%E4%B8%AA%E7%9B%B8%E7%AD%89%E7%9A%84%E5%AD%90%E9%9B%86/","excerpt":"","text":"题目：给定一个整数数组 nums 和一个正整数 k，找出是否有可能把这个数组分成 k 个非空子集，其总和都相等。 示例： 输入： nums &#x3D; [4, 3, 2, 3, 5, 2, 1], k &#x3D; 4输出： True说明： 有可能将其分成 4 个子集（5），（1,4），（2,3），（2,3）等于总和。 思路：计算出nums的元素总和。 除以k，不能除尽，则说明不存在解 总和除以k，可以求出平均值，得出每个桶(arr数组)需要装的元素大小 利用回溯进行装球(nums中的元素)，得出解 代码(cpp)；123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354class Solution &#123;public: bool dfs(vector&lt;int&gt;&amp; nums, int target, vector&lt;int&gt; arr, int k, int index)&#123; //如果index到了nums的末尾的后一位 if(index == nums.size())&#123; for(auto&amp; a : arr)&#123; //如果有一个桶里的数不等于平均数，则返回false if(a != target) return false; &#125; //遍历完成，返回true return true; &#125; //遍历每个桶 for(int i = 0; i &lt; k; i++)&#123; //如果第i桶加上nums中的index位置的元素，大于平均数 if(arr[i] + nums[index] &gt; target) //进入到下一个桶(i+1) continue; //第i桶加上index位置元素 arr[i] += nums[index]; //调用递归，插入index+1位置的元素 if(dfs(nums, target, arr, k, index + 1)) //如果递归完成后每个桶里的数都等于平均数，则返回为真 return true; //运行到这里说明，这个index位置的元素，放到i桶里不合适 //将i桶中的这个位置的元素剔除，放到i+1桶里试试 arr[i] -= nums[index]; //剔除这个位置的元素后，如果这个桶为0，则说明放到别的桶里也一样 //每个桶要放的大小都一样 if(arr[i] == 0) break; //剪枝 &#125; //遍历完全后，还没有找到解，则返回false return false; &#125; bool canPartitionKSubsets(vector&lt;int&gt;&amp; nums, int k) &#123; //如果nums的元素个数小于k，则返回flase if(nums.size() &lt; k) return false; //获取nums的元素总和 int sum = accumulate(nums.begin(),nums.end(),0); //如果不能被k除尽，则返回false if(sum%k != 0) return false; //降序排列 sort(nums.begin(), nums.end(), greater&lt;int&gt;()); //获取sum的平均数 int target = sum / k; //用来记录每个桶的大小 vector&lt;int&gt; arr(k); //调用回溯,得出解 return dfs(nums, target, arr, k, 0); &#125;&#125;;","categories":[{"name":"每日LeetCode","slug":"每日LeetCode","permalink":"http://example.com/categories/%E6%AF%8F%E6%97%A5LeetCode/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"},{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"(每日LeetCode)1636. 按照频率将数组升序排序","slug":"每日LeetCode/2022-9/1636 按照频率将数组升序排序","date":"2022-09-19T01:48:00.000Z","updated":"2022-09-19T01:48:44.717Z","comments":true,"path":"2022/09/19/每日LeetCode/2022-9/1636 按照频率将数组升序排序/","link":"","permalink":"http://example.com/2022/09/19/%E6%AF%8F%E6%97%A5LeetCode/2022-9/1636%20%E6%8C%89%E7%85%A7%E9%A2%91%E7%8E%87%E5%B0%86%E6%95%B0%E7%BB%84%E5%8D%87%E5%BA%8F%E6%8E%92%E5%BA%8F/","excerpt":"","text":"题目：给你一个整数数组 nums ，请你将数组按照每个值的频率 升序 排序。如果有多个值的频率相同，请你按照数值本身将它们 降序 排序。 请你返回排序后的数组。 示例： 输入：nums &#x3D; [1,1,2,2,2,3]输出：[3,1,1,2,2,2]解释：’3’ 频率为 1，’1’ 频率为 2，’2’ 频率为 3 。 思路：获取nums数组中的每个元素的频率，通过频率比较： 如果频率相等的情况，按照元素的大小进行降序排列 如果频率不相等的情况，按照元素的排列大小进行升序排列 代码(cpp)：123456789101112131415161718192021class Solution &#123;public: vector&lt;int&gt; frequencySort(vector&lt;int&gt;&amp; nums) &#123; unordered_map&lt;int, int&gt; map; //获取nums中各个元素的频率 for(auto&amp; num : nums)&#123; map[num]++; &#125; //给nums自定义排序 sort(nums.begin(), nums.end(), [&amp;](int a, int b)&#123; //频率不相等的情况，按照升序排列 if(map[a] != map[b])&#123; return map[a] &lt; map[b]; &#125; //排列相等的情况，按照降序排序 return a &gt; b; &#125;); return nums; &#125;&#125;; 复杂度分析： 时间复杂度：O(nlogn)，其中 n 是数组 nums 的长度。排序消耗 O(nlogn) 时间。 空间复杂度：O(n)，存储数组元素频率的哈希表消耗 O(n) 空间。","categories":[{"name":"每日LeetCode","slug":"每日LeetCode","permalink":"http://example.com/categories/%E6%AF%8F%E6%97%A5LeetCode/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"},{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"(每日LeetCode)1640. 能否连接形成数组","slug":"每日LeetCode/2022-9/1640 能否连接形成数组","date":"2022-09-19T01:48:00.000Z","updated":"2022-09-22T01:34:16.162Z","comments":true,"path":"2022/09/19/每日LeetCode/2022-9/1640 能否连接形成数组/","link":"","permalink":"http://example.com/2022/09/19/%E6%AF%8F%E6%97%A5LeetCode/2022-9/1640%20%E8%83%BD%E5%90%A6%E8%BF%9E%E6%8E%A5%E5%BD%A2%E6%88%90%E6%95%B0%E7%BB%84/","excerpt":"","text":"题目：给你一个整数数组 arr ，数组中的每个整数 互不相同 。另有一个由整数数组构成的数组 pieces，其中的整数也 互不相同 。请你以 任意顺序 连接 pieces 中的数组以形成 arr 。但是，不允许 对每个数组 pieces[i] 中的整数重新排序。 如果可以连接 pieces 中的数组形成 arr ，返回 true ；否则，返回 false 。 示例： 输入：arr &#x3D; [91,4,64,78], pieces &#x3D; [[78],[4,64],[91]]输出：true解释：依次连接 [91]、[4,64] 和 [78] 思路：使用哈希表存储pieces中每个数组的首元素及其该数组的位置 再与arr数组比较： 如果未找到(arr与pieces中的元素都相同)，则说明该元素不是pieces的数组中的首元素，返回false 如果找到，再依次比较后面的元素，如果有不同的元素，返回false 直到遍历完全，没有上述问题，返回true 代码(cpp)：12345678910111213141516171819202122232425class Solution &#123;public: bool canFormArray(vector&lt;int&gt;&amp; arr, vector&lt;vector&lt;int&gt;&gt;&amp; pieces) &#123; unordered_map&lt;int, int&gt; map; for(int i = 0; i &lt; pieces.size(); i++)&#123; map.emplace(pieces[i][0], i); &#125; int i = 0; while(i &lt; arr.size())&#123; auto temp = map.find(arr[i]); if(temp != map.end())&#123; for(int j = 0; j &lt; pieces[temp-&gt;second].size(); j++)&#123; if(arr[i++] != pieces[temp-&gt;second][j])&#123; return false; &#125; &#125; &#125; else &#123; return false; &#125; &#125; return true; &#125;&#125;; 复杂度分析： 时间复杂度：O(n)，其中 n 是数组 arr 的长度。 空间复杂度：O(n)。保存哈希表需要 O(n) 的空间。","categories":[{"name":"每日LeetCode","slug":"每日LeetCode","permalink":"http://example.com/categories/%E6%AF%8F%E6%97%A5LeetCode/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"},{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"","slug":"Java/手写Spring","date":"2022-09-17T13:54:33.871Z","updated":"2022-09-20T10:27:33.908Z","comments":true,"path":"2022/09/17/Java/手写Spring/","link":"","permalink":"http://example.com/2022/09/17/Java/%E6%89%8B%E5%86%99Spring/","excerpt":"","text":"手写Spring启动和扫描123456@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)public @interface ComponentScan &#123; String value() default &quot;&quot;;&#125; 123456@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)public @interface Component &#123; String value() default &quot;&quot;;&#125; 12345@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)public @interface Scope &#123; public String value() default &quot;&quot;;&#125; 1234567891011121314151617181920212223242526272829public class BeanDefinition &#123; private Class cls; private String scope; public BeanDefinition()&#123; &#125; public BeanDefinition(Class cls, String scope) &#123; this.cls = cls; this.scope = scope; &#125; public Class getCls() &#123; return cls; &#125; public void setCls(Class cls) &#123; this.cls = cls; &#125; public String getScope() &#123; return scope; &#125; public void setScope(String scope) &#123; this.scope = scope; &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667public class MyApplicationContext &#123; private Class ApplicationConfig; private final ConcurrentHashMap&lt;String, Object&gt; beanDefinitionMap = new ConcurrentHashMap&lt;&gt;(); public MyApplicationContext(Class ApplicationConfig) &#123; this.ApplicationConfig = ApplicationConfig; //解析配置类 scan(ApplicationConfig); &#125; //扫描路径中的bean private void scan(Class ApplicationConfig) &#123; //判断是否存在ComponentScan注解 if (!ApplicationConfig.isAnnotationPresent(ComponentScan.class))&#123; throw new RuntimeException(&quot;not found interface ComponentScan&quot;); &#125; //获取ComponentScan注解 ComponentScan componentScan = (ComponentScan) ApplicationConfig.getDeclaredAnnotation(ComponentScan.class); //获取扫描的路径 String path = componentScan.value(); path = path.replace(&quot;.&quot;,&quot;/&quot;); //扫描路径 ClassLoader classLoader = MyApplicationContext.class.getClassLoader(); //app URL resource = classLoader.getResource(path); File file = new File(resource.getFile()); //获取目录 if (file.isDirectory())&#123; //目录是否为空 File[] files = file.listFiles(); //获取目录中的类路径 for (File f : files) &#123; String fileName = f.getAbsolutePath(); //获取类路径字符串 if (fileName.endsWith(&quot;.class&quot;))&#123; //判断是否是类文件 //分割获取指定的路径 String className = fileName.substring(fileName.indexOf(&quot;com&quot;),fileName.indexOf(&quot;.class&quot;)); className = className.replace(&quot;\\\\&quot;, &quot;.&quot;); try &#123; Class&lt;?&gt; cls = classLoader.loadClass(className); //获取到类 //判断是否类中是否有Component注解 if (cls.isAnnotationPresent(Component.class))&#123; //获取Component中的bean名 Component component = cls.getDeclaredAnnotation(Component.class); String beanName = component.value(); BeanDefinition definition = new BeanDefinition(); definition.setCls(cls); //判断是否类中是否有Scope注解 if (cls.isAnnotationPresent(Scope.class))&#123; Scope scope = cls.getDeclaredAnnotation(Scope.class); definition.setScope(scope.value()); &#125; else &#123; definition.setScope(&quot;singleton&quot;); &#125; beanDefinitionMap.put(beanName, definition); &#125; &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; &#125; //TODO public Object getBean(String beanName)&#123; return null;&#125; 手写getBean()123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112public class MyApplicationContext &#123; private Class ApplicationConfig; //单例对象池 private final ConcurrentHashMap&lt;String, Object&gt; singletonObjects = new ConcurrentHashMap&lt;&gt;(); private final ConcurrentHashMap&lt;String, Object&gt; beanDefinitionMap = new ConcurrentHashMap&lt;&gt;(); public MyApplicationContext(Class ApplicationConfig) &#123; this.ApplicationConfig = ApplicationConfig; //解析配置类 scan(ApplicationConfig); //创建出单例bean，多例bean无需创建随用随创 for (String beanName : beanDefinitionMap.keySet()) &#123; BeanDefinition beanDefinition = (BeanDefinition) beanDefinitionMap.get(beanName); if (beanDefinition.getScope().equals(&quot;singleton&quot;)) &#123; Object bean = createBean(beanDefinition); singletonObjects.put(beanName, bean); &#125; &#125; &#125; //通过beanDefinition中的cls创建bean private Object createBean(BeanDefinition beanDefinition)&#123; Class cls = beanDefinition.getCls(); try &#123; Object instance = cls.getDeclaredConstructor().newInstance(); return instance; &#125; catch (InstantiationException e) &#123; e.printStackTrace(); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; catch (InvocationTargetException e) &#123; e.printStackTrace(); &#125; catch (NoSuchMethodException e) &#123; e.printStackTrace(); &#125; return null; &#125; //扫描路径中的bean private void scan(Class ApplicationConfig) &#123; //判断是否存在ComponentScan注解 if (!ApplicationConfig.isAnnotationPresent(ComponentScan.class))&#123; throw new RuntimeException(&quot;not found interface ComponentScan&quot;); &#125; //获取ComponentScan注解 ComponentScan componentScan = (ComponentScan) ApplicationConfig.getDeclaredAnnotation(ComponentScan.class); //获取扫描的路径 String path = componentScan.value(); path = path.replace(&quot;.&quot;,&quot;/&quot;); //扫描路径 ClassLoader classLoader = MyApplicationContext.class.getClassLoader(); //app URL resource = classLoader.getResource(path); File file = new File(resource.getFile()); //获取目录 if (file.isDirectory())&#123; //目录是否为空 File[] files = file.listFiles(); //获取目录中的类路径 for (File f : files) &#123; String fileName = f.getAbsolutePath(); //获取类路径字符串 if (fileName.endsWith(&quot;.class&quot;))&#123; //判断是否是类文件 //分割获取指定的路径 String className = fileName.substring(fileName.indexOf(&quot;com&quot;),fileName.indexOf(&quot;.class&quot;)); className = className.replace(&quot;\\\\&quot;, &quot;.&quot;); try &#123; Class&lt;?&gt; cls = classLoader.loadClass(className); //获取到类 //判断是否类中是否有Component注解 if (cls.isAnnotationPresent(Component.class))&#123; //获取Component中的bean名 Component component = cls.getDeclaredAnnotation(Component.class); String beanName = component.value(); BeanDefinition definition = new BeanDefinition(); definition.setCls(cls); //判断是否类中是否有Scope注解 if (cls.isAnnotationPresent(Scope.class))&#123; Scope scope = cls.getDeclaredAnnotation(Scope.class); definition.setScope(scope.value()); &#125; else &#123; definition.setScope(&quot;singleton&quot;); &#125; beanDefinitionMap.put(beanName, definition); &#125; &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; &#125; //getBean方法 public Object getBean(String beanName)&#123; if (beanDefinitionMap.containsKey(beanName))&#123; BeanDefinition beanDefinition = (BeanDefinition) beanDefinitionMap.get(beanName); if (beanDefinition.getScope().equals(&quot;singleton&quot;))&#123; //如果是单例bean，直接在单例池中取 Object bean = singletonObjects.get(beanName); return bean; &#125;else &#123; //多例bean就创建新的bean对象 Object bean = createBean(beanDefinition); return bean; &#125; &#125;else &#123; throw new RuntimeException(&quot;not found bean&quot;); &#125; &#125;&#125; 测试：配置类： 1234@ComponentScan(&quot;com.mine.service&quot;)public class AppConfig &#123;&#125; 主函数： 1234567891011public class Application &#123; public static void main(String[] args) &#123; MyApplicationContext app = new MyApplicationContext(AppConfig.class); UserService userService = (UserService) app.getBean(&quot;userService&quot;); UserService userService1 = (UserService) app.getBean(&quot;userService&quot;); UserService userService2 = (UserService) app.getBean(&quot;userService&quot;); System.out.println(&quot;userService = &quot; + userService); System.out.println(&quot;userService1 = &quot; + userService1); System.out.println(&quot;userService2 = &quot; + userService2); &#125;&#125; 将UserService设置为单例(默认就为单例)： 123@Component(&quot;userService&quot;)public class UserService &#123;&#125; 运行结果： 123userService2 = com.mine.service.UserService@2e817b38userService1 = com.mine.service.UserService@2e817b38userService3 = com.mine.service.UserService@2e817b38 将UserService设为多例： 12345@Component(&quot;userService&quot;)@Scope(&quot;prototype&quot;)public class UserService &#123;&#125; 运行结果： 123userService2 = com.mine.service.UserService@433c675duserService1 = com.mine.service.UserService@3f91beefuserService3 = com.mine.service.UserService@1a6c5a9e 手写依赖注入123456@Target(&#123;ElementType.METHOD, ElementType.FIELD&#125;)@Retention(RetentionPolicy.RUNTIME)public @interface Autowired &#123; String value() default &quot;&quot;;&#125; 123@Component(&quot;orderService&quot;)public class OrderService &#123;&#125; 12345678910@Component(&quot;userService&quot;)@Scope(&quot;prototype&quot;)public class UserService &#123; @Autowired private OrderService orderService; public void test()&#123; System.out.println(&quot;orderService = &quot; + orderService); &#125;&#125; 在createBean方法中添加： 1234567891011121314151617181920212223242526272829private Object createBean(BeanDefinition beanDefinition)&#123; Class cls = beanDefinition.getCls(); try &#123; Object instance = cls.getDeclaredConstructor().newInstance(); //获取每个字段 for (Field field : cls.getDeclaredFields()) &#123; //判断该字段是否有Autowired注解 if (field.isAnnotationPresent(Autowired.class)) &#123; field.setAccessible(true); //设置可以访问private变量的变量值 Object bean = getBean(field.getName()); //将该字段注入 field.set(instance, bean); &#125; &#125; return instance; &#125; catch (InstantiationException e) &#123; e.printStackTrace(); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; catch (InvocationTargetException e) &#123; e.printStackTrace(); &#125; catch (NoSuchMethodException e) &#123; e.printStackTrace(); &#125; return null; &#125; 测试：12345678public class Application &#123; public static void main(String[] args) &#123; MyApplicationContext app = new MyApplicationContext(AppConfig.class); UserService userService = (UserService) app.getBean(&quot;userService&quot;); System.out.println(&quot;userService = &quot; + userService); userService.test(); &#125;&#125; 运行结果： 12userService = com.mine.service.UserService@179d3b25orderService = com.mine.service.OrderService@254989ff Aware回调123public interface BeanNameAware &#123; void setBeanName(String name);&#125; 实现BeanNameAware的接口 123456789101112131415161718@Component(&quot;userService&quot;)@Scope(&quot;prototype&quot;)public class UserService implements BeanNameAware &#123; @Autowired private OrderService orderService; private String beanName; @Override public void setBeanName(String name) &#123; beanName = name; &#125; public void test()&#123; System.out.println(&quot;orderService = &quot; + orderService); System.out.println(&quot;beanName = &quot; + beanName); &#125;&#125; 需要在createBean添加内容，并添加一个参数(记得把调用的createBean方法也进行修改) 123456789101112131415161718192021222324252627282930313233private Object createBean(String beanName, BeanDefinition beanDefinition)&#123; Class cls = beanDefinition.getCls(); try &#123; Object instance = cls.getDeclaredConstructor().newInstance(); //获取每个字段 for (Field field : cls.getDeclaredFields()) &#123; //判断该字段是否有Autowired注解 if (field.isAnnotationPresent(Autowired.class)) &#123; field.setAccessible(true); //设置可以访问private变量的变量值 Object bean = getBean(field.getName()); //将该字段注入 field.set(instance, bean); &#125; &#125; //Aware回调 if (instance instanceof BeanNameAware) &#123; //判断instance是否实现了BeanNameAware的方法 ((BeanNameAware) instance).setBeanName(beanName); &#125; return instance; &#125; catch (InstantiationException e) &#123; e.printStackTrace(); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; catch (InvocationTargetException e) &#123; e.printStackTrace(); &#125; catch (NoSuchMethodException e) &#123; e.printStackTrace(); &#125; return null; &#125; 测试：12345678public class Application &#123; public static void main(String[] args) &#123; MyApplicationContext app = new MyApplicationContext(AppConfig.class); UserService userService = (UserService) app.getBean(&quot;userService&quot;); System.out.println(&quot;userService = &quot; + userService); userService.test(); &#125;&#125; 运行结果·： 123userService = com.mine.service.UserService@254989fforderService = com.mine.service.OrderService@5d099f62beanName = userService 初始化机制123public interface InitializingBean &#123; void afterPropertiesSet() throws Exception;&#125; 123456789101112131415@Component(&quot;userService&quot;)@Scope(&quot;prototype&quot;)public class UserService implements InitializingBean &#123; @Autowired private OrderService orderService; public void test()&#123; System.out.println(&quot;orderService = &quot; + orderService); &#125; @Override public void afterPropertiesSet() throws Exception &#123; System.out.println(&quot;初始化&quot;); &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142private Object createBean(String beanName, BeanDefinition beanDefinition)&#123; Class cls = beanDefinition.getCls(); try &#123; Object instance = cls.getDeclaredConstructor().newInstance(); //获取每个字段 for (Field field : cls.getDeclaredFields()) &#123; //判断该字段是否有Autowired注解 if (field.isAnnotationPresent(Autowired.class)) &#123; field.setAccessible(true); //设置可以访问private变量的变量值 Object bean = getBean(field.getName()); //将该字段注入 field.set(instance, bean); &#125; &#125; //Aware回调 if (instance instanceof BeanNameAware) &#123; //instance是否实现了BeanNameAware的方法 ((BeanNameAware) instance).setBeanName(beanName); &#125; //初始化 if (instance instanceof InitializingBean) &#123; try &#123; ((InitializingBean) instance).afterPropertiesSet(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; return instance; &#125; catch (InstantiationException e) &#123; e.printStackTrace(); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; catch (InvocationTargetException e) &#123; e.printStackTrace(); &#125; catch (NoSuchMethodException e) &#123; e.printStackTrace(); &#125; return null;&#125; 测试：12345678public class Application &#123; public static void main(String[] args) &#123; MyApplicationContext app = new MyApplicationContext(AppConfig.class); UserService userService = (UserService) app.getBean(&quot;userService&quot;); System.out.println(&quot;userService = &quot; + userService); userService.test(); &#125;&#125; 运行结果： 123初始化userService = com.mine.service.UserService@254989fforderService = com.mine.service.OrderService@5d099f62 手写BeanPostProcessor机制12345public interface BeanPostProcessor &#123; Object postProcessBeforeInitialization(Object bean, String beanName); Object postProcessAfterInitialization(Object bean, String beanName);&#125; 1234567891011121314@Componentpublic class MyBeanPostProcessor implements BeanPostProcessor &#123; @Override public Object postProcessBeforeInitialization(Object bean, String beanName) &#123; System.out.println(&quot;初始化前&quot;+beanName); return bean; &#125; @Override public Object postProcessAfterInitialization(Object bean, String beanName) &#123; System.out.println(&quot;初始化后&quot;+beanName); return bean; &#125;&#125; scan方法中的部分代码，添加判断BeanPostProcessor接口： 12345678910111213141516171819202122232425try &#123; Class&lt;?&gt; cls = classLoader.loadClass(className); //获取到类 if (cls.isAnnotationPresent(Component.class))&#123; //判断是否类中是否有Component注解 //判断是否实现了BeanPostProcessor接口 if(BeanPostProcessor.class.isAssignableFrom(cls)) &#123; BeanPostProcessor beanPostProcessor = (BeanPostProcessor) cls.getDeclaredConstructor().newInstance(); beanPostProcessorList.add(beanPostProcessor); &#125; Component component = cls.getDeclaredAnnotation(Component.class); String beanName = component.value(); BeanDefinition definition = new BeanDefinition(); definition.setCls(cls); if (cls.isAnnotationPresent(Scope.class))&#123; Scope scope = cls.getDeclaredAnnotation(Scope.class); definition.setScope(scope.value()); &#125; else &#123; definition.setScope(&quot;singleton&quot;); &#125; beanDefinitionMap.put(beanName, definition); &#125; &#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950private Object createBean(String beanName, BeanDefinition beanDefinition)&#123; Class cls = beanDefinition.getCls(); try &#123; Object instance = cls.getDeclaredConstructor().newInstance(); //获取每个字段 for (Field field : cls.getDeclaredFields()) &#123; //判断该字段是否有Autowired注解 if (field.isAnnotationPresent(Autowired.class)) &#123; field.setAccessible(true); //设置可以访问private变量的变量值 Object bean = getBean(field.getName()); //将该字段注入 field.set(instance, bean); &#125; &#125; //Aware回调 if (instance instanceof BeanNameAware) &#123; //o是否实现了BeanNameAware的方法 ((BeanNameAware) instance).setBeanName(beanName); &#125; //调用初始化前定义的方法 for (BeanPostProcessor beanPostProcessor : beanPostProcessorList) &#123; instance = beanPostProcessor.postProcessBeforeInitialization(instance, beanName); &#125; //初始化 if (instance instanceof InitializingBean) &#123; try &#123; ((InitializingBean) instance).afterPropertiesSet(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; //调用初始化后定义的方法 for (BeanPostProcessor beanPostProcessor : beanPostProcessorList) &#123; instance = beanPostProcessor.postProcessAfterInitialization(instance, beanName); &#125; return instance; &#125; catch (InstantiationException e) &#123; e.printStackTrace(); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; catch (InvocationTargetException e) &#123; e.printStackTrace(); &#125; catch (NoSuchMethodException e) &#123; e.printStackTrace(); &#125; return null; &#125; 123456public class Application &#123; public static void main(String[] args) &#123; MyApplicationContext app = new MyApplicationContext(AppConfig.class); UserService userService = (UserService) app.getBean(&quot;userService&quot;); &#125;&#125; 运行结果： 123456初始化前初始化后初始化前orderService初始化后orderService初始化前userService初始化后userService 手写Bean生命周期 手写Aop机制","categories":[],"tags":[]},{"title":"","slug":"Java/基础","date":"2022-09-17T12:53:05.148Z","updated":"2022-09-21T13:33:42.088Z","comments":true,"path":"2022/09/17/Java/基础/","link":"","permalink":"http://example.com/2022/09/17/Java/%E5%9F%BA%E7%A1%80/","excerpt":"","text":"注解 java中注解分为两种：元注解与自定义注解 元注解：描述注解的注解 自定义注解：开发者自己定义的注解，如Spring框架中@Value、@Autowired等 JDK提供了4个标准的注解： 元注解 作用 @Target 指定注解使用的作用范围(类、方法、字段等) @Retention 指定注解的生命周期(源码、class文件、运行等) @Documented 表示该注解会被javadoc文档记录 @Inherited 表示该注解的子类可以继承父类的注解，只能作用于类上的注解 除了以上4个注解其余都是自定义注解 元注解参数说明： @Target参数 ElementType.METHOD：用于描述方法 ElementType.TYPE：用于描述类、接口(包括注解类型)或enum声明 ElementType.CONSTRUCTOR：用于描述构造器 ElementType.FIELD：成员变量、对象、属性(包括enum实例) ElementType.LOCAL_VARIABLE：用于描述局部变量 ElementType.PACKAGE：用于描述包 ElementType.PARAMETER：用于描述参数 ElementType.ANNOTATION_TYPE:用于描述参数 @Retention参数 RetentionPolicy.RUNTIME：始终不会丢弃，运行期也保留该注解，因此可以使用反射机制读取该注解的信息 RetentionPolicy.SOURCE：在编译阶段丢弃，这些注解在编译结束后就不再有任何意义，所以它们不会写入字节码。如：@Override就属于这类注解 RetentionPolicy.CLASS：在类加载的时候丢弃，在字节码文件的处理中有用，注解默认使用这种方式 自定义注解实现： 需求：需要记录方法的入口参数以及方法的返回参数，以及方法执行的时间 自定义一个@MyLog注解： 123456@Target(ElementType.METHOD)@Retention(RetentionPolicy.RUNTIME)public @interface MyLog &#123; //描述方法 String value() default &quot;&quot;;&#125;","categories":[],"tags":[]},{"title":"(每日LeetCode)1624. 两个相同字符之间的最长子字符串","slug":"每日LeetCode/2022-9/1624 两个相同字符之间的最长子字符串","date":"2022-09-17T01:21:00.000Z","updated":"2022-09-17T01:22:01.274Z","comments":true,"path":"2022/09/17/每日LeetCode/2022-9/1624 两个相同字符之间的最长子字符串/","link":"","permalink":"http://example.com/2022/09/17/%E6%AF%8F%E6%97%A5LeetCode/2022-9/1624%20%E4%B8%A4%E4%B8%AA%E7%9B%B8%E5%90%8C%E5%AD%97%E7%AC%A6%E4%B9%8B%E9%97%B4%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2/","excerpt":"","text":"题目：给你一个字符串 s，请你返回 两个相同字符之间的最长子字符串的长度 ，计算长度时不含这两个字符。如果不存在这样的子字符串，返回 -1 。 子字符串 是字符串中的一个连续字符序列。 示例： 输入：s &#x3D; “abca”输出：2解释：最优的子字符串是 “bc” 。 思路：使用哈希表存放某个字母第一次出现的位置，之后与后面再次出现的字母得到字串长度，最后得到最长的字串长度 代码(cpp)：1234567891011121314151617181920class Solution &#123;public: unordered_map&lt;char, int&gt; map; int maxLengthBetweenEqualCharacters(string s) &#123; int ans = -1; for(int i = 0; i &lt; s.size(); i++)&#123; auto it = map.find(s[i]); if(it == map.end())&#123; map.emplace(s[i], i); &#125; else &#123; int temp = i - 1 - it-&gt;second; ans = max(temp, ans); &#125; &#125; return ans; &#125;&#125;; 复杂度分析： 时间复杂度：O(n)，其中 n 表示字符串的长度。我们只需遍历一遍字符串即可。 空间复杂度：O(∣Σ∣)，其中 Σ 是字符集，在本题中字符集为所有小写字母，∣Σ∣&#x3D;26。","categories":[{"name":"每日LeetCode","slug":"每日LeetCode","permalink":"http://example.com/categories/%E6%AF%8F%E6%97%A5LeetCode/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"},{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"(每日LeetCode)670. 最大交换","slug":"每日LeetCode/2022-9/670 最大交换","date":"2022-09-13T00:42:00.000Z","updated":"2022-09-13T00:42:46.437Z","comments":true,"path":"2022/09/13/每日LeetCode/2022-9/670 最大交换/","link":"","permalink":"http://example.com/2022/09/13/%E6%AF%8F%E6%97%A5LeetCode/2022-9/670%20%E6%9C%80%E5%A4%A7%E4%BA%A4%E6%8D%A2/","excerpt":"","text":"题目：给定一个非负整数，你至多可以交换一次数字中的任意两位。返回你能得到的最大值。 示例： 输入: 2736输出: 7236解释: 交换数字2和数字7。 思路：遍历先用第一个数字与后面的数字比较，找出最大的并且大于第一个数字，未找到，则用第二个数字与后面的数字比较 依次遍历，直到找到有比所比较的数字大的数字后交换位置，返回交换后的数字 如果遍历完全后，未找到，则说明，此数字已经为最大数，直接返回 代码(cpp)：123456789101112131415161718192021class Solution &#123;public: int maximumSwap(int num) &#123; string str = to_string(num); for(int i = 0; i &lt; str.size(); i++)&#123; int temp = i; for(int j = str.size() - 1; j &gt;= i + 1; j--)&#123; if(str[temp] &lt; str[j])&#123; temp = j; &#125; &#125; if(temp != i)&#123; swap(str[i], str[temp]); int ans = stoi(str); return ans; &#125; &#125; return num; &#125;&#125;; 复杂度分析： 时间复杂度：O(n^2) 空间复杂度：O(n)","categories":[{"name":"每日LeetCode","slug":"每日LeetCode","permalink":"http://example.com/categories/%E6%AF%8F%E6%97%A5LeetCode/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"},{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"(每日LeetCode)1608. 特殊数组的特征值","slug":"每日LeetCode/2022-9/1608 特殊数组的特征值","date":"2022-09-12T01:12:00.000Z","updated":"2022-09-12T01:12:09.046Z","comments":true,"path":"2022/09/12/每日LeetCode/2022-9/1608 特殊数组的特征值/","link":"","permalink":"http://example.com/2022/09/12/%E6%AF%8F%E6%97%A5LeetCode/2022-9/1608%20%E7%89%B9%E6%AE%8A%E6%95%B0%E7%BB%84%E7%9A%84%E7%89%B9%E5%BE%81%E5%80%BC/","excerpt":"","text":"题目：给你一个非负整数数组 nums 。如果存在一个数 x ，使得 nums 中恰好有 x 个元素 大于或者等于 x ，那么就称 nums 是一个 特殊数组 ，而 x 是该数组的 特征值 。 注意： x 不必 是 nums 的中的元素。 如果数组 nums 是一个 特殊数组 ，请返回它的特征值 x 。否则，返回 -1 。可以证明的是，如果 nums 是特殊数组，那么其特征值 x 是 唯一的 。 示例： 输入：nums &#x3D; [3,5]输出：2解释：有 2 个元素（3 和 5）大于或等于 2 。 代码(cpp)：暴力枚举12345678910111213141516171819class Solution &#123;public: int specialArray(vector&lt;int&gt;&amp; nums) &#123; int size = nums.size(); for(int i = 0; i &lt;= size; i++)&#123; int count = 0; for(int j = 0; j &lt; size; j++)&#123; if(nums[j] &gt;= i)&#123; count++; &#125; &#125; if(count == i)&#123; return i; &#125; &#125; return -1; &#125;&#125;; 思路：降序排序+一次遍历先将nums数组降序排序， 先以x = 0为例：这就说明nums数组中第一个元素以及之后的都要小于x x = 1时：nums数组第一个元素要大于等于x，之后的要小于x x = 2时：nums数组第二个元素要大于等于x(因为是降序所以第一个元素肯定大于x)，之后的要小于x 结论：nums[x-1] &gt;= x并且num[x] &lt; x 代码(cpp)：123456789101112131415161718192021class Solution &#123;public: int specialArray(vector&lt;int&gt;&amp; nums) &#123; int size = nums.size(); //降序排列 sort(nums.begin(), nums.end(), greater&lt;int&gt;()); for(int x = 0; x &lt;= size; x++)&#123; //如果存在nums[x-1] &lt; x的情况，跳出此次遍历，进入下一个 if(x-1 &gt;=0 &amp;&amp; nums[x-1] &lt; x)&#123; break; &#125; //如果num[x] &lt; x，返回x if(x == size || nums[x] &lt; i)&#123; return x; &#125; &#125; return -1; &#125;&#125;; 复杂度分析： 时间复杂度：O(nlogn)，其中 n 是数组 nums 的长度。 空间复杂度：O(logn)，即为排序需要的栈空间。","categories":[{"name":"每日LeetCode","slug":"每日LeetCode","permalink":"http://example.com/categories/%E6%AF%8F%E6%97%A5LeetCode/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"},{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"(每日LeetCode)1619. 删除某些元素后的数组均值","slug":"每日LeetCode/2022-9/1619 删除某些元素后的数组均值","date":"2022-09-12T01:12:00.000Z","updated":"2022-09-14T02:37:02.282Z","comments":true,"path":"2022/09/12/每日LeetCode/2022-9/1619 删除某些元素后的数组均值/","link":"","permalink":"http://example.com/2022/09/12/%E6%AF%8F%E6%97%A5LeetCode/2022-9/1619%20%E5%88%A0%E9%99%A4%E6%9F%90%E4%BA%9B%E5%85%83%E7%B4%A0%E5%90%8E%E7%9A%84%E6%95%B0%E7%BB%84%E5%9D%87%E5%80%BC/","excerpt":"","text":"题目：给你一个整数数组 arr ，请你删除最小 5% 的数字和最大 5% 的数字后，剩余数字的平均值。 与 标准答案 误差在 10^(-5) 的结果都被视为正确结果。 示例： 输入：arr &#x3D; [1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,3]输出：2.00000解释：删除数组中最大和最小的元素后，所有元素都等于 2，所以平均值为 2 。 思路：将size设为数组的元素个数 将数组排序后，将左边size*0.05个元素删除，并且将右边size*0.05个元素删除 再计算出总和除以size*0.9个元素(删除左右两边各size*0.05个元素，还剩size*0.9个元素) 返回平均数 代码(cpp)：1234567891011121314class Solution &#123;public: double trimMean(vector&lt;int&gt;&amp; arr) &#123; sort(arr.begin(), arr.end()); int size = arr.size(); int temp = int(size * 0.05); int sum = 0; for(int i = temp; i &lt; size - temp; i++)&#123; sum += arr[i]; &#125; double ans = sum / (size*0.9); return ans; &#125;&#125;; 复杂度分析： 时间复杂度：O(nlogn)，其中 n 是数组 arr 的长度。 空间复杂度：O(logn)。排序需要 O(logn) 的栈空间。","categories":[{"name":"每日LeetCode","slug":"每日LeetCode","permalink":"http://example.com/categories/%E6%AF%8F%E6%97%A5LeetCode/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"},{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"(每日LeetCode)669. 修剪二叉搜索树","slug":"每日LeetCode/2022-9/669 修剪二叉搜索树","date":"2022-09-10T01:35:00.000Z","updated":"2022-09-10T01:35:18.888Z","comments":true,"path":"2022/09/10/每日LeetCode/2022-9/669 修剪二叉搜索树/","link":"","permalink":"http://example.com/2022/09/10/%E6%AF%8F%E6%97%A5LeetCode/2022-9/669%20%E4%BF%AE%E5%89%AA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/","excerpt":"","text":"题目：给你二叉搜索树的根节点 root ，同时给定最小边界low 和最大边界 high。通过修剪二叉搜索树，使得所有节点的值在[low, high]中。修剪树 不应该 改变保留在树中的元素的相对结构 (即，如果没有被移除，原有的父代子代关系都应当保留)。 可以证明，存在 唯一的答案 。 所以结果应当返回修剪好的二叉搜索树的新的根节点。注意，根节点可能会根据给定的边界发生改变。 示例： 输入：root &#x3D; [3,0,4,null,2,null,null,1], low &#x3D; 1, high &#x3D; 3输出：[3,2,null,1] 思路：DFS通过深度优先搜索，找出不符合[low, high]区间的结点，并剔除 二叉平衡树的性质：父节点大于左子树，小于右子树 如果有节点存在，val值小于low值，则说明该节点的左子树，也均小于low值 同理，如果有节点存在，val值大于high值，则说明该节点的右子树，也均大于high值 代码(cpp)：1234567891011121314151617181920class Solution1 &#123;public: TreeNode* trimBST(TreeNode* root, int low, int high) &#123; //找到符合区间的结点 while(root != nullptr)&#123; if(root-&gt;val &lt; low) root = root-&gt;right; else if(root-&gt;val &gt; high) root = root-&gt;left; else break; &#125; //遍历左右子树 if(root != nullptr)&#123; root-&gt;left = trimBST(root-&gt;left, low, high); root-&gt;right = trimBST(root-&gt;right, low, high); &#125; return root; &#125;&#125;; 官方代码(cpp)：12345678910111213141516171819class Solution &#123;public: TreeNode* trimBST(TreeNode* root, int low, int high) &#123; if (root == nullptr) return nullptr; //小于low的情况 if (root-&gt;val &lt; low) //返回该节点的右子树 return trimBST(root-&gt;right, low, high); //大于high的情况 else if (root-&gt;val &gt; high) //返回该节点的左子树 return trimBST(root-&gt;left, low, high); //遍历左右子树 root-&gt;left = trimBST(root-&gt;left, low, high); root-&gt;right = trimBST(root-&gt;right, low, high); return root; &#125;&#125;; 复杂度分析： 时间复杂度：O(n)，其中 n 为二叉树的结点数目。 空间复杂度：O(n)。递归栈最坏情况下需要 O(n) 的空间。","categories":[{"name":"每日LeetCode","slug":"每日LeetCode","permalink":"http://example.com/categories/%E6%AF%8F%E6%97%A5LeetCode/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"},{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"","slug":"软件安装/Docker安装Nacos","date":"2022-09-09T03:52:41.536Z","updated":"2022-09-12T02:24:30.593Z","comments":true,"path":"2022/09/09/软件安装/Docker安装Nacos/","link":"","permalink":"http://example.com/2022/09/09/%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85/Docker%E5%AE%89%E8%A3%85Nacos/","excerpt":"","text":"1.安装Nacos1.1 搜索Nacos镜像1docker search nacos 1.2 拉取Nacos镜像1docker pull nacos/nacos-server 1.3 启动Nacos容器1234567docker run -id \\--name c_nacos \\-p 8848:8848 \\--privileged=true \\-e MODE=standalone \\-e PREFER_HOST_MODE=hostname \\nacos/nacos-server:latest 参数： --privileged=true：使容器内的root拥有真正的root权限 1.4 测试访问：http://主机地址:8848/nacos/index.html 2.搭建Nacos集群2.1 拉取mysql镜像 1docker pull mysql 2.2 拉取","categories":[],"tags":[]},{"title":"(每日LeetCode)1598. 文件夹操作日志搜集器","slug":"每日LeetCode/2022-9/1598 文件夹操作日志搜集器","date":"2022-09-09T01:07:00.000Z","updated":"2022-09-09T01:07:42.354Z","comments":true,"path":"2022/09/09/每日LeetCode/2022-9/1598 文件夹操作日志搜集器/","link":"","permalink":"http://example.com/2022/09/09/%E6%AF%8F%E6%97%A5LeetCode/2022-9/1598%20%E6%96%87%E4%BB%B6%E5%A4%B9%E6%93%8D%E4%BD%9C%E6%97%A5%E5%BF%97%E6%90%9C%E9%9B%86%E5%99%A8/","excerpt":"","text":"题目：每当用户执行变更文件夹操作时，LeetCode 文件系统都会保存一条日志记录。 下面给出对变更操作的说明： &quot;../&quot; ：移动到当前文件夹的父文件夹。如果已经在主文件夹下，则 继续停留在当前文件夹 。 &quot;./&quot; ：继续停留在当前文件夹。 &quot;x/&quot; ：移动到名为 x 的子文件夹中。题目数据 保证总是存在文件夹 x 。给你一个字符串列表 logs ，其中 logs[i] 是用户在 i^th 步执行的操作。 文件系统启动时位于主文件夹，然后执行 logs 中的操作。 执行完所有变更文件夹操作后，请你找出 返回主文件夹所需的最小步数 。 示例： 输入：logs &#x3D; [“d1&#x2F;“,”d2&#x2F;“,”..&#x2F;“,”d21&#x2F;“,”.&#x2F;“]输出：2解释：执行 “..&#x2F;“ 操作变更文件夹 2 次，即可回到主文件夹 思路：栈模拟代码(cpp)：1234567891011121314151617181920class Solution &#123;public: int minOperations(vector&lt;string&gt;&amp; logs) &#123; stack&lt;string&gt; s; for(auto&amp; log : logs)&#123; if(log == &quot;../&quot;)&#123; if(!s.empty())&#123; s.pop(); &#125; &#125; else if(log == &quot;./&quot;)&#123; continue; &#125; else &#123; s.emplace(log); &#125; &#125; return s.size(); &#125;&#125;; 复杂度分析： 时间复杂度：O(n)，其中 n 字符串数组的长度。只需遍历一遍字符串数组即可。 空间复杂度：O(1)。","categories":[{"name":"每日LeetCode","slug":"每日LeetCode","permalink":"http://example.com/categories/%E6%AF%8F%E6%97%A5LeetCode/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"},{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"(每日LeetCode)1592. 重新排列单词间的空格","slug":"每日LeetCode/2022-9/1592 重新排列单词间的空格","date":"2022-09-07T02:59:00.000Z","updated":"2022-09-07T02:59:51.599Z","comments":true,"path":"2022/09/07/每日LeetCode/2022-9/1592 重新排列单词间的空格/","link":"","permalink":"http://example.com/2022/09/07/%E6%AF%8F%E6%97%A5LeetCode/2022-9/1592%20%E9%87%8D%E6%96%B0%E6%8E%92%E5%88%97%E5%8D%95%E8%AF%8D%E9%97%B4%E7%9A%84%E7%A9%BA%E6%A0%BC/","excerpt":"","text":"题目：给你一个字符串 text ，该字符串由若干被空格包围的单词组成。每个单词由一个或者多个小写英文字母组成，并且两个单词之间至少存在一个空格。题目测试用例保证 text 至少包含一个单词 。 请你重新排列空格，使每对相邻单词之间的空格数目都 相等 ，并尽可能 最大化 该数目。如果不能重新平均分配所有空格，请 将多余的空格放置在字符串末尾 ，这也意味着返回的字符串应当与原 text 字符串的长度相等。 返回 重新排列空格后的字符串 。 示例： 输入：text &#x3D; “ this is a sentence “输出：”this is a sentence”解释：总共有 9 个空格和 4 个单词。可以将 9 个空格平均分配到相邻单词之间，相邻单词间空格数为：9 &#x2F; (4-1) &#x3D; 3 个。 代码(cpp)：感觉像屎山，不确定我在看看~ 1234567891011121314151617181920212223242526272829303132333435363738394041424344class Solution &#123;public: string reorderSpaces(string text) &#123; vector&lt;string&gt; str; int count = 0; //空格数初始化为0 string temp = &quot;&quot;; //初始化单词为空 for(int i = 0; i &lt; text.size(); i++) &#123; if(text[i] == &#x27; &#x27;) &#123; //如果是空格 //temp不为空，插入str，并将temp置空，获取下一个单词 if(temp != &quot;&quot;)&#123; str.emplace_back(temp); temp = &quot;&quot;; &#125; count++; //空格数加1 &#125; else &#123; //如果不为空格 temp += text[i]; //添加字符 //如果处在text字符串的末尾，直接将temp插入str中 if(i == text.size() - 1)&#123; str.emplace_back(temp); &#125; &#125; &#125; int num = 0; //初始化两个单词之间的空格数为0 if(str.size() &gt; 1)&#123; //获取两个单词之间的空格数 num = count / (str.size()-1); &#125; //拼接字符串 string ans = str[0]; for(int i = 1; i &lt; str.size(); i++)&#123; //拼接 ans += string(num, &#x27; &#x27;) + str[i]; count -= num; //剩余的空格数 &#125; //将剩余的空格加到ans的末尾 ans += string(count, &#x27; &#x27;); return ans; &#125;&#125;;","categories":[{"name":"每日LeetCode","slug":"每日LeetCode","permalink":"http://example.com/categories/%E6%AF%8F%E6%97%A5LeetCode/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"},{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"(每日LeetCode)652. 寻找重复的子树","slug":"每日LeetCode/2022-9/652 寻找重复的子树","date":"2022-09-05T00:28:00.000Z","updated":"2022-09-05T00:51:43.629Z","comments":true,"path":"2022/09/05/每日LeetCode/2022-9/652 寻找重复的子树/","link":"","permalink":"http://example.com/2022/09/05/%E6%AF%8F%E6%97%A5LeetCode/2022-9/652%20%E5%AF%BB%E6%89%BE%E9%87%8D%E5%A4%8D%E7%9A%84%E5%AD%90%E6%A0%91/","excerpt":"","text":"题目：给定一棵二叉树 root，返回所有重复的子树。 对于同一类的重复子树，你只需要返回其中任意一棵的根结点即可。 如果两棵树具有相同的结构和相同的结点值，则它们是重复的。 示例： 输入：root &#x3D; [2,2,2,3,null,3,null]输出：[[2,3],[3]] 思路：递归通过递归获取每一段的子树的字符串 如果哈希表中不存在此字符串，则插入，存在此字符串，说明此字符串存在重复的子树 代码(cpp)：12345678910111213141516171819202122232425class Solution &#123;public: unordered_set&lt;TreeNode*&gt; set; unordered_map&lt;string, TreeNode*&gt; map; string dfs(TreeNode* node)&#123; if(node == nullptr) return &quot;&quot;; //获取node结点的子树字符串 string str = to_string(node-&gt;val) + &quot;(&quot; + dfs(node-&gt;left) + &quot;)(&quot; + dfs(node-&gt;right) + &quot;)&quot;; //在哈希表中查询 auto temp = map.find(str); if(temp != map.end()) //存在，则插入到set中 set.emplace(temp-&gt;second); else map[str] = node; //不存在，插入到哈希表中 return str; &#125; vector&lt;TreeNode*&gt; findDuplicateSubtrees(TreeNode* root) &#123; dfs(root); //将set中的元素拷贝到vector中 return &#123;set.begin(), set.end()&#125;; &#125;&#125;; 复杂度分析： 时间复杂度：O(n^2)，其中 n 是树中节点的数目。在最坏情况下，树呈现链状的结构，而每一个节点都会在其左右子树序列的基础上再增加最多 99 个字符（两组括号以及节点本身的值），那么所有子树的序列长度之和为 $\\sum_{i&#x3D;1}^n$ 9n &#x3D; O(n^2)。构造出这些序列就需要 O(n^2) 的时间。 空间复杂度：O(n^2)，即为哈希表需要使用的空间。","categories":[{"name":"每日LeetCode","slug":"每日LeetCode","permalink":"http://example.com/categories/%E6%AF%8F%E6%97%A5LeetCode/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"},{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"(每日LeetCode)1582. 二进制矩阵中的特殊位置","slug":"每日LeetCode/2022-9/1582 二进制矩阵中的特殊位置","date":"2022-09-04T01:21:00.000Z","updated":"2022-09-04T01:21:39.244Z","comments":true,"path":"2022/09/04/每日LeetCode/2022-9/1582 二进制矩阵中的特殊位置/","link":"","permalink":"http://example.com/2022/09/04/%E6%AF%8F%E6%97%A5LeetCode/2022-9/1582%20%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E7%89%B9%E6%AE%8A%E4%BD%8D%E7%BD%AE/","excerpt":"","text":"题目：给你一个大小为 rows x cols 的矩阵 mat，其中 mat[i][j] 是 0 或 1，请返回 矩阵 mat 中特殊位置的数目 。 特殊位置 定义：如果 mat[i][j] &#x3D;&#x3D; 1 并且第 i 行和第 j 列中的所有其他元素均为 0（行和列的下标均 从 0 开始 ），则位置 (i, j) 被称为特殊位置。 示例： 输入：mat &#x3D; [[1,0,0], [0,0,1], [1,0,0]]输出：1解释：(1,2) 是一个特殊位置，因为 mat[1][2] &#x3D;&#x3D; 1 且所处的行和列上所有其他元素都是 0 思路：模拟获取mat数组中的每行i及每列j的1元素的总个数row、column 如果某i行只有一个1元素，某j列也只有一个1元素，并且该行列在mat数组中存在为1 说明mat[i][j]所处的行和列上所有其他元素都是 0 代码(cpp)：1234567891011121314151617181920212223242526class Solution &#123;public: int numSpecial(vector&lt;vector&lt;int&gt;&gt;&amp; mat) &#123; int n = mat.size(); //获取行数 int m = mat[0].size(); //获取列数 vector&lt;int&gt; row(n); vector&lt;int&gt; column(m); for(int i = 0; i &lt; n; i++)&#123; for(int j = 0; j &lt; m; j++)&#123; row[i] += mat[i][j]; //获取每行的1元素的总个数 column[j] += mat[i][j]; //获取每列的1元素的总个数 &#125; &#125; int ans = 0; for(int i = 0; i &lt; n; i++)&#123; for(int j = 0; j &lt; m; j++)&#123; //如果i行只有一个1，j列只有一个1，并且mat数组i行j列为1 if(mat[i][j] == 1 &amp;&amp; row[i] == 1 &amp;&amp; column[j] == 1)&#123; ans++; &#125; &#125; &#125; return ans; &#125;&#125;; 复杂度分析： 时间复杂度：O(m×n)，其中 m 为矩阵 mat 的行数，n 为矩阵 mat 的列数。 空间复杂度：O(m+n)，主要为预处理每一行和列的空间开销。","categories":[{"name":"每日LeetCode","slug":"每日LeetCode","permalink":"http://example.com/categories/%E6%AF%8F%E6%97%A5LeetCode/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"},{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"C++11的学习笔记","slug":"C++/C++11特性","date":"2022-09-03T03:49:33.141Z","updated":"2022-09-27T14:06:55.074Z","comments":true,"path":"2022/09/03/C++/C++11特性/","link":"","permalink":"http://example.com/2022/09/03/C++/C++11%E7%89%B9%E6%80%A7/","excerpt":"","text":"C++11 简介C++11是对目前C++语言的扩展与修正，C++11不仅包含核心语言的新机能，而且拓展了C++的标准库(STL)，并入了大部分的C++Trehnical Report 1(TR1)程序库。 C++11包括的新特性，包括：lambda表达式、类型推导关键字auto、decltype以及模板的大量改进 1.类型推导1.1 auto在C中，auto修饰局部变量，局部变量也叫auto变量，自动变量 而在C++11中，auto根据用户初始化数据类型自动推导 举例前，需要引入typeinfo： 1#include &lt;typeinfo&gt; 其中下面的函数可返回a的数据类型的字符串形式： 1typeid(a).name(); 1. 1234567891011121314#include&lt;iostream&gt;#include &lt;typeinfo&gt;using namespace std;void main()&#123; int a = 1; auto b = 2; //b的数据类型自动推导为int cout &lt;&lt; typeid(b).name() &lt;&lt; endl; auto c = 2.5; //c的数据类型自动推导为double cout &lt;&lt; typeid(c).name() &lt;&lt; endl;&#125; 运行结果： 12intdouble 2. 123456789101112131415#include&lt;iostream&gt;#include &lt;typeinfo&gt;using namespace std;double fun()&#123; return 1.5;&#125;void main()&#123; auto a = fun(); //c的数据类型根据返回值自动推导为double cout &lt;&lt; typeid(a).name() &lt;&lt; endl;&#125; 运行结果： 1double 3. 12345678910111213141516#include&lt;iostream&gt;#include &lt;typeinfo&gt;using namespace std;struct Test&#123; int a;&#125;;void main()&#123; Test t = &#123; 1 &#125;; //初始化Test结构体 a = 1 auto a = t; // d的数据类型自动推导为Test cout &lt;&lt; typeid(a).name() &lt;&lt; endl;&#125; 运行结果： 1&gt;struct Test 两种遍历方式： 12345678910111213141516171819#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;void fun1(vector&lt;int&gt;&amp; v)&#123; for (auto it = v.begin(); it != v.end(); it++) &#123; cout &lt;&lt; *it &lt;&lt; endl; &#125;&#125;void fun2(vector&lt;int&gt;&amp; v) &#123; for (auto&amp; i : v) &#123; cout &lt;&lt; i &lt;&lt; endl; &#125;&#125; 注意： 使用auto时，数据必须要初始化： 12345void main()&#123; auto a; //报错 a = 10;&#125; vs不支持函数形参是auto变量(部分编译器会支持)： 1234void fun3(auto a) //报错&#123;&#125; 不能作为自定义类型的成员变量： 123456struct Test&#123; int a; auto b; //报错 auto c = 0; //报错&#125;; auto不能作为初始化数组，但是可以赋值： 1234567891011#include&lt;iostream&gt;#include &lt;typeinfo&gt;using namespace std;void main()&#123; //auto a[3] = &#123; 1, 2, 3 &#125;; //报错 int b[3] = &#123; 1, 2, 3 &#125;; auto c = b; cout &lt;&lt; typeid(c).name() &lt;&lt; endl;&#125; 运行结果： 1int * __ptr64 模板实例化不能是auto类型： 1234567void main()&#123; //vector&lt;auto&gt; v1; //报错 //vector&lt;auto&gt; v2 = &#123; 1 &#125;; //报错 vector&lt;int&gt; v3 = &#123; 1 &#125;; auto v4 = v3; //正常&#125; 1.2 decltypedecltype()与auto相反，可以获取a的数据类型，并用做b的数据类型 1decltype(a) b; 1. 12345678910#include&lt;iostream&gt;using namespace std;void main()&#123; int i; //decltype(i)等价于int decltype(i) j = 0; cout &lt;&lt; typeid(j).name() &lt;&lt; endl;&#125; 运行结果： 1int 2. 1234567891011#include&lt;iostream&gt;#include&lt;typeinfo&gt;using namespace std;void main()&#123; float a; double b; decltype(a + b) c; cout &lt;&lt; typeid(c).name() &lt;&lt; endl;&#125; 运行结果： 1&gt;double 3. 1234567891011121314151617#include&lt;iostream&gt;#include&lt;typeinfo&gt;#include&lt;vector&gt;using namespace std;void main()&#123; vector&lt;int&gt; v; decltype(v.begin()) it; //打印迭代器数据类型 cout &lt;&lt; typeid(it).name() &lt;&lt; endl; for (it = v.begin(); it != v.end(); it++) &#123; //数组为空，无打印 cout &lt;&lt; *it &lt;&lt; endl; &#125;&#125; 运行结果： 1&gt;class std::_Vector_iterator&lt;class std::_Vector_val&lt;struct std::_Simple_types&lt;int&gt; &gt; &gt; 匿名数据类型： 1234567891011#include&lt;iostream&gt;#include&lt;typeinfo&gt;using namespace std;void main()&#123; //匿名类型的枚举变量 enum &#123;OK, Error&#125; flag; decltype(flag) flag2; cout &lt;&lt; typeid(flag2).name() &lt;&lt; endl;&#125; 运行结果： 1enum `void __cdecl main(void)&#x27;::`2&#x27;::&lt;unnamed-type-flag&gt; 1.3 跟踪返回类型 正常写函数以及返回值 1234double fun(int a, double b)&#123; return a + b;&#125; 引入auto作为返回值，并指定返回值为double与上面的函数效果等价 1234auto fun1(int a, double b) -&gt; double&#123; return a + b;&#125; 自定义返回值 1234auto fun2(int a, double b) -&gt; decltype(a + b)&#123; return a + b;&#125; 引入模板 12345template&lt;class T1, class T2&gt;auto fun3(T1 a, T2 b) -&gt; decltype(a + b)&#123; return a + b;&#125; 2.易用性改进2.1 类内成员初始化 类中的数据成员在申明时可以直接赋予一个默认值 12345678910111213141516171819202122#include&lt;string&gt;using namespace std;class A&#123;public: A(int a, int b) : a(a),b(b) //参数列表初始化 &#123; &#125; int a = 10; //`=`等号初始化默认值 int b&#123; 20 &#125;; //`&#123;&#125;`大括号初始化默认值 string str1 = &quot;str1&quot;; //`=`等号初始化默认值 //string str2(&quot;str2&quot;); //报错 string str3&#123; &quot;str3&quot; &#125;; //`&#123;&#125;`大括号初始化默认值&#125;;void main()&#123; A a&#123;1&#125;; //通过大括号初始化&#125; 2.2 列表初始化 列表初始化(&#123;&#125;初始化方式) 123456789101112131415161718192021#include&lt;iostream&gt;using namespace std;struct Test&#123; int age; double money; char name[20];&#125;;void main()&#123; Test t = &#123; 18, 64.8, &quot;Tom&quot; &#125;; int a = 1; int b = &#123; 1 &#125;; int c&#123; 1 &#125;; int arr1[] = &#123; 1, 2, 3 &#125;; int arr2[]&#123; 1, 2, 3 &#125;;&#125; 使用列表初始化的方式可以防止类型收窄(隐式转换导致数据丢失) =赋值的情况： 12345678910#include&lt;iostream&gt;using namespace std;void main()&#123; int a = 128; char b = a; cout &lt;&lt; a &lt;&lt; endl; cout &lt;&lt; b &lt;&lt; endl;&#125; 运行结果： 12&gt;128 //为空，数据丢失。c语言中ascii码最多能表示0~127，共128个字符 &#123;&#125;赋值的情况： 1234567void main()&#123; int a = 128; char b&#123; a &#125;; cout &lt;&lt; a &lt;&lt; endl; cout &lt;&lt; b &lt;&lt; endl;&#125; vs运行报错：从“int”转换到“char”需要收缩转换 2.3 for循环 for循环遍历数组 12345678910111213#include&lt;iostream&gt;using namespace std;void main()&#123; int a[] = &#123; 1, 2, 3, 4, 5 &#125;; int size = sizeof(a) / sizeof(*a); //获取元素个数 for (int i = 0; i &lt; size; i++) &#123; cout &lt;&lt; a[i] &lt;&lt; endl; &#125;&#125; 基于范围的for循环 123456789101112#include&lt;iostream&gt;using namespace std;void main()&#123; int a[] = &#123; 1, 2, 3, 4, 5 &#125;; for (auto&amp; temp : a) &#123; cout &lt;&lt; temp &lt;&lt; endl; &#125;&#125; 运行结果： 1234512345 容器范围的for遍历 12345678910111213#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;void main()&#123; vector&lt;int&gt; v = &#123; 1, 2, 3, 4, 5 &#125;; for (auto&amp; temp : v) &#123; cout &lt;&lt; temp &lt;&lt; endl; &#125;&#125; 注意： 容器的范围的for遍历，需要容器含有begin()和end()才可以使用 例如：queue、stack等容器无法使用范围的for遍历 2.4 静态断言C++提供了调试工具assert，这是个宏，用于在运行阶段对断言进行检查，如果条件为true，执行程序，否则调用abort() 使用assert()需要导入： 1#include &lt;cassert&gt; assert()断言： 运行时检查条件 条件应为常量、变量均可 123456789101112#include&lt;iostream&gt;#include &lt;cassert&gt;using namespace std;void main()&#123; bool flag = false; //运行时检查条件，如果为真，继续执行；否则中断程序，报错 assert(flag == true); cout &lt;&lt; &quot;hello assert&quot; &lt;&lt; endl;&#125; 运行报错： 1Assertion failed: flag == true, file E:\\08_静态断言.cpp, line 9 static_assert()静态断言： 编译时检查条件 条件应为常量，编译阶段不会有变量 下面为，检查是否不为64位系统： 12345678910#include&lt;iostream&gt;#include &lt;cassert&gt;using namespace std;void main()&#123; static_assert(sizeof(void*) == 8, &quot;不支持64位系统&quot;); cout &lt;&lt; &quot;hello static_assert&quot; &lt;&lt; endl;&#125; 2.5 noexcept修饰符抛出异常： 1234void fun1()&#123; throw 1; //抛出异常&#125; 不让函数抛出异常： 12345//fun2函数不能抛出任何异常，老式写法，在C++11中被废弃void fun2() throw()&#123;&#125; 注意：此写法，在C++11中被废弃 新写法使用noexcept修饰符 来替代throw() 12345//fun3函数不能抛出任何异常void fun3() noexcept&#123;&#125; 2.6 nullptrnullptr是为了解决C++中NULL的二义性问题从而引进的一种新的类型，NULL实际上代表的是0 重载fun函数： ​ 当调用fun(NULL)时，我们希望它打印的是：fun2 1234567891011121314151617#include&lt;iostream&gt;using namespace std;void fun(int a)&#123; cout &lt;&lt; &quot;fun1&quot; &lt;&lt; endl;&#125;void fun(int* p)&#123; cout &lt;&lt; &quot;fun2&quot; &lt;&lt; endl;&#125;void main()&#123; fun(NULL);&#125; 运行结果： 1fun1 但是，打印的是：fun1； 如果要解决这个二义性，所以就需要使用nullptr： 1234567891011121314151617#include&lt;iostream&gt;using namespace std;void fun(int a)&#123; cout &lt;&lt; &quot;fun1&quot; &lt;&lt; endl;&#125;void fun(int* p)&#123; cout &lt;&lt; &quot;fun2&quot; &lt;&lt; endl;&#125;void main()&#123; fun(nullptr);&#125; 运行结果： 1&gt;fun2 比较NULL和nullptr： 12345678910111213#include&lt;iostream&gt;using namespace std;void main()&#123; int* p1 = NULL; int* p2 = nullptr; if (p1 == p2) &#123; cout &lt;&lt; &quot;p1 = p2&quot; &lt;&lt; endl; &#125;&#125; 运行结果： 1&gt;p1 = p2 证明：NULL和nullptr相等 nullptr不能赋值给普通类型： 1234567void main()&#123; int a = NULL; //正常 //int b = nullptr; //报错 //double c = nullptr; //报错 int* p = nullptr; //正常&#125; 2.7 强类型枚举12345void main()&#123; enum Status1 &#123; Ok, Error &#125;; enum Status2 &#123; Ok, Error &#125;;&#125; 运行报错： 12“main::Ok”: 重定义；以前的定义是“枚举数”“main::Error”: 重定义；以前的定义是“枚举数” 强类型枚举：enum后面加上class或struct修饰，即可： 12345void main()&#123; enum class Status1 &#123; Ok, Error &#125;; enum class Status2 &#123; Ok, Error &#125;;&#125; 运行成功！ 调用时，需要指定枚举类型的作用域： 12345678void main()&#123; enum class Status1 &#123; Ok, Error &#125;; enum class Status2 &#123; Ok, Error &#125;; //Status1 flag = OK; //报错，必须要指定枚举的作用域 Status1 flag = Status1::Ok; //正常&#125; 强枚举类型，并且可以指定成员变量的类型： 12345678void main()&#123; enum class Status1 &#123; Ok, Error &#125;; enum class Status2 : char &#123; Ok, Error &#125;; cout &lt;&lt; sizeof(Status1::Ok) &lt;&lt; endl; //4字节 cout &lt;&lt; sizeof(Status2::Ok) &lt;&lt; endl; //1字节&#125; 运行结果： 12&gt;4&gt;1 2.8 常量表达式常量表达式要在程序编译时执行，普通变量要在程序运行时执行 constexpr：可以将变量或函数在编译阶段初始化 1234567891011121314151617181920212223242526272829#include&lt;iostream&gt;using namespace std;//运行时初始化，非常量int getNum1()&#123; return 2;&#125;//const修饰的常量属于右值//const修饰的形参不是常量const int getNum2()&#123; return 2;&#125;//常量表达式，发生在编译阶段constexpr int getNum3()&#123; return 2;&#125;void main()&#123; // 枚举类型成员初始化，必须是整型常量 //enum &#123;e1 = getNum1(), e2 &#125;; //报错 //enum &#123; e1 = getNum2(), e2 &#125;; //const，报错 enum &#123; e1 = getNum3(), e2 &#125;; //正常 constexpr int temp = getNum3(); //正常，发生在编译阶段 enum &#123; e3 = temp, e4 &#125;; //正常&#125; constexpr的限制： 函数中允许包含typedef、using指令、静态断言 函数必须有返回值 在使用前必须已有定义 return返回语句表达式不能使用非常量表达式的函数、全局函数，且必须是一个常量表达式 总结：运行阶段产生的变量或函数，不要瞎掺和到常量表达式中 2.9 自定义字面量根据C++11标准，只有以下参数才是合法的： char const * unsigned long long long double char const *, size_t wchar const *, size_t char16_t const *, size_t char32_t const *, size_t 123456789101112131415161718192021222324252627#include&lt;iostream&gt;using namespace std;//自定义字面量，起名要求 operator&quot;&quot;XXX//只需要传递第一个参数，第二个参数自动推导出第一个参数的长度并赋值size_t operator&quot;&quot;_len(char const* str, size_t size)&#123; return size;&#125;char const* operator&quot;&quot;_str(char const* str, size_t size)&#123; return str;&#125;char const* operator&quot;&quot;_test(char const* str)&#123; return str;&#125;void main()&#123; cout &lt;&lt; &quot;abc&quot;_len &lt;&lt; endl; //正常 cout &lt;&lt; &quot;abc&quot;_str &lt;&lt; endl; //正常 //cout &lt;&lt; &quot;abc&quot;_test &lt;&lt; endl; //报错 cout &lt;&lt; 123_test &lt;&lt; endl; //正常&#125; 运行结果： 123&gt;3&gt;abc&gt;123 2.10 原生字符串字面值原生字符串字面值：使用户书写的字符串”所见即所得” C++11中使用原生字符串字面值只需要在R&quot;()&quot;括号中写入字符串，即可 123456789101112131415#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;void main()&#123; cout &lt;&lt; R&quot;(Hello ,\\n \\rworld !!!)&quot; &lt;&lt; endl; cout &lt;&lt; &quot;-------------------&quot; &lt;&lt; endl; //也可以赋值给string数据类型 string str = R&quot;(Hello ,\\n \\r)&quot;; cout &lt;&lt; str &lt;&lt; endl;&#125; 运行结果： 12345&gt;Hello ,\\n \\r&gt;world !!!&gt;-------------------&gt;Hello ,\\n \\r 3.类的改进….. 4.模板的改进4.1 右尖括号&gt;在C++98&#x2F;03中，模板实例化时，连续的右尖括号&gt;&gt;会被编译成右移动操作符 需要在两个右尖括号之间添加空格&gt; &gt; 123456789#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;void main()&#123; //vector&lt;vector&lt;int&gt;&gt; v1; //报错 vector&lt;vector&lt;int&gt; &gt; v2; //正常&#125; 在C++11中解决了此问题： 12345678#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;void main()&#123; vector&lt;vector&lt;int&gt;&gt; v //正常&#125; 4.2 类型的别名需要导入一个库来判断数据类型是否相同 1#include&lt;type_traits&gt; is_same判断两个数据类型是否相同，返回值为bool类型： 1is_same&lt;T1, T2&gt;::value 12345678910111213#include&lt;iostream&gt;#include&lt;type_traits&gt;using namespace std;//通过typedef给一个类型起别名，不能新建类型typedef int int32;//C++11起别名方式using my_int = int;void main()&#123; cout &lt;&lt; is_same&lt;int32, my_int&gt;::value &lt;&lt; endl;&#125; 4.3 函数模板的默认模板参数1234567891011121314151617181920212223242526272829#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;//类模板支持默认模板参数//注意：如果有多个类模板参数，默认模板参数要写在**最右边**template&lt;class T = int&gt;class A&#123;public: A(T a) : a(a) &#123;&#125; T a;&#125;;//C++11支持函数模板的默认模板参数template&lt;class T = int&gt;void fun(T t)&#123; &#125;void main()&#123; A&lt;&gt; a(10); //默认为int cout &lt;&lt; a.a &lt;&lt; endl; A&lt;string&gt; b(&quot;abc&quot;); //指定为string cout &lt;&lt; b.a &lt;&lt; endl; fun(10); //传入int fun&lt;string&gt;(&quot;abc&quot;); //传入string&#125; 4.4 可变参数模板函数可变模板函数的声明： 123456789101112131415161718#include&lt;iostream&gt;using namespace std;//下面为可变参数模板函数template&lt;class ... T&gt; //T为模板参数包void fun(T ... args) //args为函数参数包&#123; //获取可变参数个数 cout &lt;&lt; sizeof ... (args) &lt;&lt; endl;&#125;void main()&#123; fun&lt;int&gt;(10); fun&lt;int, string&gt;(10, &quot;abc&quot;); fun&lt;int, string, char&gt;(10, &quot;abc&quot;, &#x27;a&#x27;); fun(1, 1, 1, 1); //不指定数据类型也可以&#125; 运行结果： 1234&gt;1&gt;2&gt;3&gt;4 参数包的展开 递归的方式展开： 12345678910111213141516171819202122#include&lt;iostream&gt;using namespace std;//递归终止函数，当参数列表遍历完后，调用此重载函数结束递归//本质就是重载函数void fun()&#123; cout &lt;&lt; &quot;参数已为空&quot; &lt;&lt; endl;&#125;template&lt;class T1, class ... T2&gt;void fun(T1 first, T2 ... last)&#123; cout &lt;&lt; first &lt;&lt; endl; fun(last ...);&#125;void main()&#123; fun(1, 2.5, 3, &quot;abc&quot;, &#x27;a&#x27;);&#125; 运行结果： 123456&gt;1&gt;2.5&gt;3&gt;abc&gt;a&gt;参数已为空 非递归的方式展开： 123456789101112131415161718192021#include&lt;iostream&gt;using namespace std;template&lt;class T&gt;void print(T t)&#123; cout &lt;&lt; t &lt;&lt; endl;&#125;template&lt;class ... T&gt;void fun(T ... args)&#123; //逗号运算符 //初始化列表 int a[] = &#123; (print(args), 0) ... &#125;;&#125;void main()&#123; fun(1, 2.5, &quot;abc&quot;, &#x27;a&#x27;);&#125; 运行结果： 1234&gt;1&gt;2.5&gt;abc&gt;a 4.5 可变参数模板类继承的方式展开参数模板类 类模板继承方式展开参数包： 12345678910111213141516171819202122232425262728#include&lt;iostream&gt;#include&lt;typeinfo&gt;using namespace std;//可变参数模板的声明，必须要声明template &lt;class ... T&gt;class Car; //主模板的声明中不允许使用模板参数列表&lt; &gt;//递归继承模板类template&lt;class Head, class ... Tail&gt;class Car&lt;Head, Tail ...&gt; : public Car&lt;Tail ...&gt;&#123;public: Car() &#123; cout &lt;&lt; typeid(Head).name() &lt;&lt; endl; &#125;&#125;;//递归终止类template&lt;&gt; class Car&lt;&gt;&#123; &#125;;void main()&#123; //初始化Car Car&lt;int, double, string, char&gt; c;&#125; 运行结果： 1234&gt;char&gt;class std::basic_string&lt;char,struct std::char_traits&lt;char&gt;,class std::allocator&lt;char&gt; &gt;&gt;double&gt;int 类模板递归和特化方式展开参数包 下面的是获得相加的数据类型的字节总数： 123456789101112131415161718192021222324//可变参数模板的声明template&lt;class ... T&gt;class Add;//可变参数模板的定义template&lt;class first, class ... last&gt;class Add&lt;first, last ...&gt;&#123;public: static const int val = Add&lt;first&gt;::val + Add&lt;last ...&gt;::val;&#125;;//边界条件，递归终止条件template&lt;class first&gt;class Add&lt;first&gt;&#123;public: static const int val = sizeof(first);&#125;;void main()&#123; cout &lt;&lt; Add&lt;int&gt;::val &lt;&lt; endl; //int类型字节为4 cout &lt;&lt; Add&lt;double&gt;::val &lt;&lt; endl; //double类型字节为8 cout &lt;&lt; Add&lt;int, int, double&gt;::val &lt;&lt; endl; //int+int+double字节数为16 &#125; 运行结果： 123&gt;4&gt;8&gt;16 也可以指定数据类型： 指定数据类型为int，并获得他们的之间相乘的总和： 1234567891011121314151617181920212223242526272829#include&lt;iostream&gt;#include&lt;typeinfo&gt;using namespace std;//可变参数模板的声明//并指定为int类型template&lt;int ... T&gt;class Mul;//可变参数模板的定义template&lt;int first, int ... last&gt;class Mul&lt;first, last ...&gt;&#123;public: static const int val = first * Mul&lt;last ...&gt;::val;&#125;;//边界条件，递归终止条件template&lt;&gt;class Mul&lt;&gt;&#123;public: static const int val = 1;&#125;;void main()&#123; cout &lt;&lt; Mul&lt;2&gt;::val &lt;&lt; endl; //2*1 cout &lt;&lt; Mul&lt;2, 2&gt;::val &lt;&lt; endl; //2*2 cout &lt;&lt; Mul&lt;3, 3, 3&gt;::val &lt;&lt; endl; //3*3*3&#125; 运行结果： 123&gt;2&gt;4&gt;27 5.左值、右值5.1 左值、右值引用左值引用： 1234567891011121314151617void main1()&#123; //引用&amp;：给一个内存起别名，定义时必须初始化 int a; const int temp = 1; int t1 = 1; int t2 = 2; int&amp; b = a; //正常 //int&amp; c = 1; //报错，非常量引用的初始值必须为左值 //int&amp; d = t1 + t2; //报错，非常量引用的初始值必须为左值 //const int&amp; 万能引用 const int&amp; e = a; //正常 const int&amp; f = 1; //正常 const int&amp; t = temp; //正常&#125; 右值引用： 1234567891011void main()&#123; //右值引用 int&amp;&amp; a = 10; //正常 int&amp;&amp; b = fun(); //正常 int t1 = 1; int t2 = 1; //int&amp;&amp; c = t1; //报错，无法将右值引用绑定到左值 int&amp;&amp; d = t1 + t2; //正常&#125; 左值、右值判断： 123456789101112131415161718192021222324#include&lt;iostream&gt;using namespace std;//通过重载函数的特点，来进行判断void test(int&amp; left)&#123; cout &lt;&lt; &quot;左值&quot; &lt;&lt; endl;&#125;void test(int&amp;&amp; right)&#123; cout &lt;&lt; &quot;右值&quot; &lt;&lt; endl;&#125;void main()&#123; int a = 1; int b = 1; int&amp;&amp; c = 1; test(a); //左值 test(1); //右值 test(a + b); //右值 test(c); //左值&#125; 运行结果： 1234&gt;左值&gt;右值&gt;右值&gt;左值 5.2 返回值优化…… 6.移动语义…… 6.3 std::move123456789#include&lt;iostream&gt;using namespace std;void main()&#123; int a = 10; //int&amp;&amp; b = a; //报错，左值不能绑定到右值引用 int&amp;&amp; c = move(a); //正常，move将左值转化为右值&#125; 6.4 std::forward当我们需要将一组参数原封不动的传递给里一个函数时： 12345678910111213141516171819202122232425262728293031323334#include&lt;iostream&gt;using namespace std;template&lt;class T&gt;void fun(const T&amp; t)&#123; cout &lt;&lt; &quot;fun(const T&amp; t) &quot; &lt;&lt; endl;&#125;template&lt;class T&gt;void fun(T&amp; t)&#123; cout &lt;&lt; &quot;fun(T&amp; t) &quot; &lt;&lt; endl;&#125;template&lt;class T&gt;void forwardVal(const T&amp; t)&#123; fun(t);&#125;template&lt;class T&gt;void forwardVal(T&amp; t)&#123; fun(t);&#125;void main()&#123; int a = 0; const int b = 1; forwardVal(a); forwardVal(b);&#125; 运行结果： 12&gt;fun(T&amp; t)&gt;fun(const T&amp; t) 使用std::forward函数，实现完美转发： 12345678910111213141516171819202122232425262728293031323334template&lt;class T&gt;void fun(const T&amp; t)&#123; cout &lt;&lt; &quot;fun(const T&amp; t) &quot; &lt;&lt; endl;&#125;template&lt;class T&gt;void fun(T&amp; t)&#123; cout &lt;&lt; &quot;fun(T&amp; t) &quot; &lt;&lt; endl;&#125;template&lt;class T&gt;void fun(const T&amp;&amp; t)&#123; cout &lt;&lt; &quot;fun(const T&amp;&amp; t) &quot; &lt;&lt; endl;&#125;//只需定义一个函数，无需重载函数template&lt;class T&gt;void forwardVal(T&amp;&amp; t)&#123; //forward保存参数的左值、右值属性 fun(forward&lt;T&gt;(t));&#125;void main()&#123; int a = 1; const int b = 2; forwardVal(a); forwardVal(b); forwardVal(10);&#125; 运行结果： 123&gt;fun(T&amp; t)&gt;fun(const T&amp; t)&gt;fun(const T&amp;&amp; t) 7.智能指针7.1 unique_ptr12345678910111213141516#include&lt;iostream&gt;#include&lt;memory&gt; //智能指针头文件using namespace std;void main()&#123; //智能指针无需释放，自动释放 unique_ptr&lt;int&gt; ptr(new int(10)); cout &lt;&lt; *ptr &lt;&lt; endl; //重载了operator*() cout &lt;&lt; ptr &lt;&lt; endl; //可以人为指定释放堆区空间 //ptr = nullptr; //正常 //ptr = NULL; //正常 ptr.reset(); //正常&#125; 1234567891011121314151617#include&lt;iostream&gt;#include&lt;memory&gt; //智能指针头文件using namespace std;void main()&#123; unique_ptr&lt;int&gt; ptr1(new int(10)); //报错，禁用拷贝构造 //unique_ptr&lt;int&gt; ptr2 = ptr; //int* p = ptr //报错 //将ptr1使用权(指向的内存)交给ptr3，ptr1不能再操作堆区内存了 unique_ptr&lt;int&gt; ptr3 = move(ptr1); //cout &lt;&lt; *ptr1 &lt;&lt; endl; //报错 cout &lt;&lt; *ptr3 &lt;&lt; endl; //正常&#125; 1234567891011121314#include&lt;iostream&gt;#include&lt;memory&gt; //智能指针头文件using namespace std;void main()&#123; unique_ptr&lt;int&gt; ptr(new int(10)); //无参，作用为显式释放堆区内存 //ptr.reset(); //有参，先释放堆区内存，再重新绑定一个新堆区内存 ptr.reset(new int(20));&#125; 1234567891011121314151617#include&lt;iostream&gt;#include&lt;memory&gt; //智能指针头文件using namespace std;void main()&#123; unique_ptr&lt;int&gt; ptr(new int(10)); //释放ptr对堆区内存的控制权但是不释放堆区的内存，并将控制权交给指针p int* p = ptr.release(); //cout &lt;&lt; *ptr &lt;&lt; endl; //报错 cout &lt;&lt; *p &lt;&lt; endl; //正常 //需要人为将p指针的堆区释放 delete p;&#125; 7.2 shared_ptrshared_ptr允许多个智能指针共享并拥有同一个堆区分配对象的内存。通过引用计数实现，会记录有多少个shared_ptr共同指向同一个对象，如果最后一个共享指针被销毁，也就是对某个引用对象的计数变为0时，自动释放此内存。 123456789101112131415161718192021222324#include&lt;iostream&gt;#include&lt;memory&gt;using namespace std;void main()&#123; //shared_ptr也会自动释放堆区空间 shared_ptr&lt;int&gt; ptr1(new int(10)); //拷贝构造，此时有2个对象和堆区内存绑定 shared_ptr&lt;int&gt; ptr2 = ptr1; //正常 //打印ptr1与ptr2的地址 cout &lt;&lt; ptr1 &lt;&lt; endl; cout &lt;&lt; ptr2 &lt;&lt; endl; //计数器，获取与堆区绑定的对象的个数 cout &lt;&lt; ptr1.use_count() &lt;&lt; endl; //2 //释放ptr1对象，计数器减1，不会释放堆区内存 ptr1.reset(); cout &lt;&lt; ptr2.use_count() &lt;&lt; endl; //1 //当计数器为0时，才会释放堆区空间 ptr2.reset();&#125; 运行结果： 1234&gt;0000026C3E3E6CA0&gt;0000026C3E3E6CA0&gt;2&gt;1 7.3 weak_ptrweak_ptr是为配合 shared_ptr 而引入的一种智能指针来协助 shared_ptr 工作，它可以从一个shared_ptr 或另一个 weak_ptr 对象构造，它的构造和析构不会引起引用计数的增加或减少。没有重载 * 和-&gt;但可以使用 lock 获得一个可用的 shared_ptr 对象。 weak_ptr 的使用更为复杂一点，它可以指向 shared_ptr 指针指向的对象内存，却并不拥有该内存，而使用 weak_ptr 成员lock，则可返回其指向内存的一个 share_ptr 对象，且在所指对象内存己经无效时，返回指针空值 nullptr。 12345678910111213141516171819202122232425262728293031323334#include&lt;iostream&gt;#include&lt;memory&gt;using namespace std;void main()&#123; shared_ptr&lt;int&gt; ptr1(new int(10)); shared_ptr&lt;int&gt; ptr2 = ptr1; //2个对象绑定堆区空间 //weak_ptr不和堆区空间绑定，可以通过lock函数获取shared_ptr的对象 weak_ptr&lt;int&gt; ptr3 = ptr1; cout &lt;&lt; ptr1.use_count() &lt;&lt; endl; //打印计数器 cout &lt;&lt; ptr3.use_count() &lt;&lt; endl; //打印计数器 cout &lt;&lt; &quot;----------------&quot; &lt;&lt; endl; //通过lock函数获取shared_ptr的对象 shared_ptr&lt;int&gt; ptr4 = ptr3.lock(); //3个对象绑定堆区空间 cout &lt;&lt; ptr1.use_count() &lt;&lt; endl; //打印计数器 cout &lt;&lt; ptr3.use_count() &lt;&lt; endl; //打印计数器 cout &lt;&lt; *ptr1 &lt;&lt; &quot;,&quot; &lt;&lt; *ptr2 &lt;&lt; &quot;,&quot; &lt;&lt; *ptr4 &lt;&lt; endl; //正常 //cout &lt;&lt; *ptr3 &lt;&lt; endll; //报错，没有重载*和-&gt; //释放所有shared_ptr对象 ptr1.reset(); ptr2.reset(); ptr4.reset(); shared_ptr&lt;int&gt; temp = ptr3.lock(); if (temp == nullptr) &#123; cout &lt;&lt; &quot;temp为空，已经释放了堆区空间！&quot; &lt;&lt; endl; &#125;&#125; 运行结果： 1234567&gt;2&gt;2&gt;----------------&gt;3&gt;3&gt;10,10,10&gt;temp为空，已经释放了堆区空间！ 8.闭包的实现8.1 闭包是什么闭包有很多种定义，一种说法是，闭包是带有上下文的函数。说白了，就是有状态的函数，更直接一些，不就是个类吗？换了个名字化 。 一个函数，带上了一个状态，就变成了闭包了。那什么叫“带上状态，呢？意思是这个闭包有属于自己的变量，这些个变量的值是创建闭包的时候设置的，并在调用闭包的时候，可以访问这些变量。 函数是代码，状态是一组变量，将代码和一组变量捆绑(bind)，就形成了闭包。 闭包的状态㧢绑，必须发生在运行时。 8.2 仿函数：重载operator()C++11之前就已经支持 比较大小： 123456789101112131415161718#include&lt;iostream&gt;using namespace std;//仿函数：重载operator()class Compare&#123;public: //如果val1小于val2,则返回真，否则返回假 bool operator()(int val1, int val2) &#123; return val1 &lt; val2; &#125;&#125;;void main()&#123; cout &lt;&lt; Compare()(11, 12) &lt;&lt; endl;&#125; 运行结果： 1&gt;1 8.3 std::function在C++中，可调用实体主要包括：函数、函数指针、函数引用、可以隐式转换为函数指定的对系，或者实现了 opetator()的对象。 C++11中，新增加了一个 std::function 类模板，它是对 C++中现有的可调用实体的一种类型安全的包装。通过指定它的模板参数，它可以用统一的方式处理函数、函数对象、函数指针，并允许保存和延迟执行它们。 12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;iostream&gt;#include&lt;functional&gt; //std::functionusing namespace std;//普通函数void fun()&#123; //__func__：返回函数名 cout &lt;&lt; __func__ &lt;&lt; endl;&#125;//类中静态函数class Test&#123;public: static int testFun(int a) &#123; cout &lt;&lt; __func__ &lt;&lt; endl; return a; &#125;&#125;;//类中仿函数class MyFun&#123;public: int operator()(int a) &#123; cout &lt;&lt; __func__ &lt;&lt; endl; return a; &#125;&#125;;void main()&#123; //绑定普通函数 function&lt;void()&gt; f1 = fun; f1(); //绑定类中的静态函数 function&lt;int(int)&gt; f2 = Test::testFun; cout &lt;&lt; f2(100) &lt;&lt; endl; //绑定类中的仿函数，绑定对象 function&lt;int(int)&gt; f3 = MyFun(); cout &lt;&lt; f3(30) &lt;&lt; endl;&#125; 运行结果： 12345&gt;fun&gt;testFun&gt;100&gt;operator ()&gt;30 std:function对象最大的用处就是在实现函数回调，使用者需要注忘，它不能被用来检查相等或者不相等，但是可以与 NULL 或者nullptr 进行比较。 8.4 std::bindstd:bind 是这样一种机制，它可以预先把指定可调用实体的某些参数鄉定到己有的变量，产生一个新的可调用实体，这种机制在 回调函数 的使用过程中也频为有用。 C++98中，有两个两数bindlst 和bind2nd，它们分别可以用来绑定 functor 的第一个和第二个参数，它们都是只可以绑定一个参数，各种限制，使得 bind1st 和 bind2nd 的可用性大大降低。 在C++11中，提供了std:bind， 它鄉定的参数的个数不受限制，绑定的具体哪些参数也不受限制，由用户指定，这个bind 才是真正意义上的绑定。 123456789101112131415161718192021222324252627282930#include&lt;iostream&gt;#include&lt;functional&gt; //std::bindusing namespace std;void fun(int x, int y)&#123; cout &lt;&lt; x &lt;&lt; &quot; &quot; &lt;&lt; y &lt;&lt; endl;&#125;void main()&#123; bind(fun, 1, 2)(); //输出1 2 //std::placeholders::_1 表示函数调用，第1个参数替换 //std::placeholders::_2 表示函数调用，第2个参数替换 //std::placeholders::_3 表示函数调用，第3个参数替换 bind(fun, placeholders::_1, placeholders::_2)(5, 10); //输出5 10 //简化写法 using namespace std::placeholders; //将第1个参数与_1替换 bind(fun, 5, _1)(2, 4, 10); //输出5 2 //将第2个参数与_2替换 bind(fun, 5, _2)(2, 4, 10); //输出5 4 //第1个参数与第一个参数互换 bind(fun, _2, _1)(2, 4, 10); //输出4 2 //bind(fun, _2, 10)(20); //报错，不存咋第2个参数&#125; 运行结果： 12345&gt;1 2&gt;5 10&gt;5 2&gt;5 4&gt;4 2 8.5 function结合bind12345678910111213141516171819202122232425262728#include&lt;iostream&gt;#include&lt;functional&gt;using namespace std;using namespace std::placeholders;class Test&#123;public: int a; void fun(int x, int y) &#123; cout &lt;&lt; x &lt;&lt; &quot; &quot; &lt;&lt; y &lt;&lt; endl; &#125;&#125;;void main()&#123; Test test; //创建对象 //绑定成员函数 function&lt;void(int, int)&gt; f1 = bind(&amp;Test::fun, &amp;test, _1, _2); f1(1, 2); //test.fun(1, 2) //绑定成员变量 function&lt;int&amp; ()&gt; f2 = bind(&amp;Test::a, &amp;test); f2() = 12; //test.a = 12; cout &lt;&lt; test.a &lt;&lt; endl;&#125; 运行结果： 12&gt;1 2&gt;12 8.6 lambda表达式lambda表达式的基本格式： 1234[]()&#123; &#125; 基础语法： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include&lt;iostream&gt;using namespace std;//[]中只能捕获全局变量与同一作用域的变量void main()&#123; auto f1 = []() &#123;&#125;; int a = 1; int b = 2; cout &lt;&lt; &quot;f2-------------&quot; &lt;&lt; endl; //a、b以值传递方式 auto f2 = [a, b]() &#123; cout &lt;&lt; a &lt;&lt; &quot; &quot; &lt;&lt; b &lt;&lt; endl; &#125;; f2(); cout &lt;&lt; &quot;f3-------------&quot; &lt;&lt; endl; //添加x、y参数 auto f3 = [a, b](int x, int y) &#123; cout &lt;&lt; a &lt;&lt; &quot; &quot; &lt;&lt; b &lt;&lt; endl; cout &lt;&lt; &quot;x=&quot; &lt;&lt; x &lt;&lt; &quot;,y=&quot; &lt;&lt; y &lt;&lt; endl; &#125;; f3(3, 6); cout &lt;&lt; &quot;f4-------------&quot; &lt;&lt; endl; //=：以值传递的方式捕获外面的变量 auto f4 = [=]() &#123; f3(4, 8); cout &lt;&lt; a &lt;&lt; &quot; &quot; &lt;&lt; b &lt;&lt; endl; &#125;; f4(); cout &lt;&lt; &quot;f5-------------&quot; &lt;&lt; endl; //&amp;：以引用的方式捕获外面的变量 auto f5 = [&amp;]() &#123; f3(5, 10); cout &lt;&lt; a &lt;&lt; &quot; &quot; &lt;&lt; b &lt;&lt; endl; &#125;; f5(); cout &lt;&lt; &quot;f6-------------&quot; &lt;&lt; endl; //a为值传递，其余为引用 auto f6 = [&amp;, a]() &#123; f3(6, 12); cout &lt;&lt; a &lt;&lt; &quot; &quot; &lt;&lt; b &lt;&lt; endl; &#125;; f6(); cout &lt;&lt; &quot;f7-------------&quot; &lt;&lt; endl; //a为引用，其余为值传递 auto f7 = [=, &amp;a]() &#123; f3(7, 14); cout &lt;&lt; a &lt;&lt; &quot; &quot; &lt;&lt; b &lt;&lt; endl; &#125;; f7(); //默认情况下，lambda表达式以const修饰函数体 //添加mutable，就可以修改了 auto f8 = [=]() mutable &#123; //不加mutable会报错，无法修改 a++; //正常 &#125;;&#125; 运行结果： 1234567891011121314151617181920&gt;1 2&gt;f3-------------&gt;1 2&gt;x=3,y=6&gt;f4-------------&gt;1 2&gt;x=4,y=8&gt;1 2&gt;f5-------------&gt;1 2&gt;x=5,y=10&gt;1 2&gt;f6-------------&gt;1 2&gt;x=6,y=12&gt;1 2&gt;f7-------------&gt;1 2&gt;x=7,y=14&gt;1 2 类和全局变量： 12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;iostream&gt;using namespace std;int globality = 10;class Test&#123;public: int i = 10; void testFun() &#123; int a = 5; cout &lt;&lt; __func__ &lt;&lt; endl; auto f1 = [=]() &#123; cout &lt;&lt; i &lt;&lt; endl; //正常 cout &lt;&lt; globality &lt;&lt; endl; //正常 &#125;; auto f2 = [&amp;]() &#123; cout &lt;&lt; i &lt;&lt; endl; //正常 cout &lt;&lt; globality &lt;&lt; endl; //正常 &#125;; //只能捕获类成员变量和全局变量，不能捕获局部变量 auto f3 = [this]() &#123; cout &lt;&lt; i &lt;&lt; endl; //正常 cout &lt;&lt; globality &lt;&lt; endl; //正常 //cout &lt;&lt; a &lt;&lt; endl; //报错 &#125;; &#125;&#125;;//[]中只能捕获全局变量与同一作用域的变量void main()&#123; auto f1 = [=]() &#123; cout &lt;&lt; globality &lt;&lt; endl; &#125;; f1();&#125; 8.7 值传递与引用捕获参数的区别12345678910111213141516171819202122232425#include&lt;iostream&gt;using namespace std;void main()&#123; int a = 1; auto f1 = [=]() mutable &#123; a++; cout &lt;&lt; a &lt;&lt; endl; //a = 2; &#125;; f1(); cout &lt;&lt; a &lt;&lt; endl; //a = 1; cout &lt;&lt; &quot;-----------&quot; &lt;&lt; endl; int b = 1; auto f2 = [&amp;]() mutable &#123; b++; cout &lt;&lt; b &lt;&lt; endl; //b = 2; &#125;; f2(); cout &lt;&lt; b &lt;&lt; endl; //b = 2;&#125; 运行结果： 12345&gt;2&gt;1&gt;-----------&gt;2&gt;2 8.8 lambda表达式与仿函数事实上，仿函数是编译器实现lambda 的一种方式，通过编译器都是把lambda表达式转化为一个仿函数对象。 因此，在C++11中，lambda 可以视为仿函数的一种等价形式。 1234567891011121314151617181920212223242526272829303132#include&lt;iostream&gt;using namespace std;class MyFun&#123;private: int a;public: MyFun(int a) &#123; this-&gt;a = a; &#125; int operator()(int val) &#123; return this-&gt;a + val; &#125;&#125;;void main()&#123; int a = 10; //仿函数 cout &lt;&lt; MyFun(a)(20) &lt;&lt; endl; //lambda表达式 auto f = [=](int val) &#123; return a + val; &#125;; cout &lt;&lt; f(20) &lt;&lt; endl;;&#125; 8.9 lambda表达式类型1234567891011121314151617181920212223#include&lt;iostream&gt;#include&lt;functional&gt;using namespace std;using namespace std::placeholders;void main()&#123; function&lt;int(int)&gt; f1 = [](int x) &#123;return x + 1; &#125;; cout &lt;&lt; f1(1) &lt;&lt; endl; //2 function&lt;int(int)&gt; f2 = bind([](int x) &#123;return x + 1; &#125;, _1); cout &lt;&lt; f2(2) &lt;&lt; endl; //3 auto f3 = [](int x, int y) -&gt;int &#123;return x + y; &#125;; auto f4 = [=](int x, int y) -&gt;int &#123;return x + y; &#125;; //定义一个FUN_PTR函数指针，参数列表为两个int，返回值为int typedef int (*FUN_PTR)(int, int); FUN_PTR p1 = f3; //正常，lambda表达式可以转化为函数指针 //FUN_PTR p2 = f4; //报错，lambda表达式转化为函数指针不允许捕获变量 cout&lt;&lt; p1(1, 2) &lt;&lt; endl; //3&#125; 运行结果： 123233 8.10 lambda的优势传统筛选出大于5的数： 12345678910111213141516171819202122232425262728293031323334#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;vector&lt;int&gt; arr;vector&lt;int&gt; largeNums; //筛选出大于5的数void print(const vector&lt;int&gt;&amp; v)&#123; for (auto&amp; i : v) &#123; cout &lt;&lt; i &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl;&#125;void main()&#123; for (int i = 0; i &lt; 10; i++) &#123; arr.emplace_back(i); &#125; int temp = 5; //传统操作 for (auto&amp; a : arr) &#123; if (a &gt; temp) &#123; largeNums.emplace_back(a); &#125; &#125; print(largeNums);&#125; 回调函数： 12345678910111213141516171819202122232425262728293031323334#include&lt;iostream&gt;#include&lt;algorithm&gt; //std::for_each#include&lt;vector&gt;using namespace std;vector&lt;int&gt; arr;vector&lt;int&gt; largeNums; //筛选出大于5的数int temp = 5;void fun(int&amp; n)&#123; if (n &gt; temp) &#123; largeNums.emplace_back(n); &#125;&#125;void print(int&amp; n)&#123; cout &lt;&lt; n &lt;&lt; &quot; &quot;;&#125;void main()&#123; for (int i = 0; i &lt; 10; i++) &#123; arr.emplace_back(i); &#125; //筛选 for_each(arr.begin(), arr.end(), fun); //遍历 for_each(largeNums.begin(), largeNums.end(), print);&#125; lambda表达式： 123456789101112131415161718192021222324252627#include&lt;iostream&gt;#include&lt;algorithm&gt; //std::for_each#include&lt;vector&gt;using namespace std;vector&lt;int&gt; arr;vector&lt;int&gt; largeNums; //筛选出大于5的数void main()&#123; for (int i = 0; i &lt; 10; i++) &#123; arr.emplace_back(i); &#125; int temp = 5; //筛选 for_each(arr.begin(), arr.end(), [&amp;temp](int&amp; n) &#123; if (n &gt; temp) largeNums.emplace_back(n); &#125;); //遍历 for_each(largeNums.begin(), largeNums.end(), [](int&amp; n) &#123; cout &lt;&lt; n &lt;&lt; &quot; &quot;; &#125;);&#125;","categories":[{"name":"C++","slug":"C","permalink":"http://example.com/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"}]},{"title":"(每日LeetCode)646. 最长数对链","slug":"每日LeetCode/2022-9/646 最长数对链","date":"2022-09-03T00:34:00.000Z","updated":"2022-09-03T00:35:59.480Z","comments":true,"path":"2022/09/03/每日LeetCode/2022-9/646 最长数对链/","link":"","permalink":"http://example.com/2022/09/03/%E6%AF%8F%E6%97%A5LeetCode/2022-9/646%20%E6%9C%80%E9%95%BF%E6%95%B0%E5%AF%B9%E9%93%BE/","excerpt":"","text":"题目： 给出 n 个数对。 在每一个数对中，第一个数字总是比第二个数字小。 现在，我们定义一种跟随关系，当且仅当 b &lt; c 时，数对(c, d) 才可以跟在 (a, b) 后面。我们用这种形式来构造一个数对链。 给定一个数对集合，找出能够形成的最长数对链的长度。你不需要用到所有的数对，你可以以任何顺序选择其中的一些数对来构造。 示例： 输入：[[1,2], [2,3], [3,4]]输出：2解释：最长的数对链是 [1,2] -&gt; [3,4] 思路：动态规划遍历数组pairs 用 i表示 如果存在pairs[j][1] &lt; pairs[i][0] 重新遍历之前已经遍历过的元素(i位置之前的元素)pairs用j表示并且j &lt; i，找到最大的dp[j] + 1，记录到dp[i]中 返回dp数组的最后一个元素就为最长数对链 代码(cpp)：12345678910111213141516class Solution &#123;public: int findLongestChain(vector&lt;vector&lt;int&gt;&gt;&amp; pairs) &#123; vector&lt;int&gt; dp(pairs.size(), 1); sort(pairs.begin(), pairs.end()); for(int i = 0; i &lt; pairs.size(); i++)&#123; for(int j = 0; j &lt; i; j++)&#123; if (pairs[j][1] &lt; pairs[i][0]) &#123; dp[i] = max(dp[i], dp[j] + 1); &#125; &#125; &#125; return dp.back(); &#125;&#125;; 复杂度分析： 时间复杂度：O(n^2)，其中 n 为 pairs 的长度。排序的时间复杂度为 O(nlogn)，两层 for 循环的时间复杂度为 O(n^2)。 空间复杂度：O(n)，数组 dp 的空间复杂度为 O(n)。","categories":[{"name":"每日LeetCode","slug":"每日LeetCode","permalink":"http://example.com/categories/%E6%AF%8F%E6%97%A5LeetCode/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"},{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"(每日LeetCode)687. 最长同值路径","slug":"每日LeetCode/2022-9/687 最长同值路径","date":"2022-09-02T01:36:00.000Z","updated":"2022-09-02T01:36:36.365Z","comments":true,"path":"2022/09/02/每日LeetCode/2022-9/687 最长同值路径/","link":"","permalink":"http://example.com/2022/09/02/%E6%AF%8F%E6%97%A5LeetCode/2022-9/687%20%E6%9C%80%E9%95%BF%E5%90%8C%E5%80%BC%E8%B7%AF%E5%BE%84/","excerpt":"","text":"题目：给定一个二叉树的 root ，返回 最长的路径的长度 ，这个路径中的 每个节点具有相同值 。 这条路径可以经过也可以不经过根节点。 两个节点之间的路径长度 由它们之间的边数表示。 示例： 输入：root &#x3D; [5,4,5,1,1,5]输出：2 思路：深度优先搜索(DFS)递归到树的最底部后，得到左右子树的路径长度 其中ans记录了左右子树由它们的父节点相连，所得到的左右子树相加的路径长度 返回值为左右子树中最长路径的长度 举例： ​ 1 &#x2F; \\ 1 1 &#x2F; \\ 1 1 此时，红色标记的就是父节点 1 &#x2F; \\ 1 1 ans的值就为：2(左右子树的路径长度的相加之和)，也就是局部的最优解 但是返回值应为左右子树的中的最长路径的长度 因为如果返回左右子树相加之和的路径长度就会导致： ​ 1 &#x2F; 1 &#x2F; \\ 1 1 出现”三岔口”。 返回左右子树的中的最长路径的长度 ​ 1 &#x2F; 1 \\ ​ 1 不会出现”三岔口”。 一直向上返回值，直至到达root根节点，最后得到ans的最大值(全局最优解) ​ 1 &#x2F; \\ 1 1 \\ ​ 1 代码(cpp)：12345678910111213141516171819202122232425262728class Solution &#123;public: int ans = 0; //记录最长的路径 int dfs(TreeNode* root)&#123; if(root == nullptr) return 0; //进入最底层的节点，从下往上计算 int L = dfs(root-&gt;left); //获取左子树中最长的一段路径 int R = dfs(root-&gt;right); //获取右子树中最长的一段路径 int temp_L = 0; int temp_R = 0; //如果左子树的值与父节点的值相同，则加一，否则置为0 if(root-&gt;left != nullptr &amp;&amp; root-&gt;left-&gt;val == root-&gt;val) temp_L = L + 1; if(root-&gt;right != nullptr &amp;&amp; root-&gt;right-&gt;val == root-&gt;val) temp_R = R + 1; //将左右子树相加变为一条路径，与之前的最长路径比较 ans = max(ans, temp_L + temp_R); //返回左子树或右子树中的最长的一段路径 return max(temp_L, temp_R); &#125; int longestUnivaluePath(TreeNode* root) &#123; dfs(root); return ans; &#125;&#125;; 复杂度分析： 时间复杂度：O(n)，其中 n 为树的结点数目。 空间复杂度：O(n)。递归栈最坏情况下需要 O(n) 的空间。","categories":[{"name":"每日LeetCode","slug":"每日LeetCode","permalink":"http://example.com/categories/%E6%AF%8F%E6%97%A5LeetCode/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"},{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"(每日LeetCode)1475. 商品折扣后的最终价格","slug":"每日LeetCode/2022-9/1475 商品折扣后的最终价格","date":"2022-09-01T01:35:00.000Z","updated":"2022-09-01T01:36:05.052Z","comments":true,"path":"2022/09/01/每日LeetCode/2022-9/1475 商品折扣后的最终价格/","link":"","permalink":"http://example.com/2022/09/01/%E6%AF%8F%E6%97%A5LeetCode/2022-9/1475%20%E5%95%86%E5%93%81%E6%8A%98%E6%89%A3%E5%90%8E%E7%9A%84%E6%9C%80%E7%BB%88%E4%BB%B7%E6%A0%BC/","excerpt":"","text":"题目：给你一个数组 prices ，其中 prices[i] 是商店里第 i 件商品的价格。 商店里正在进行促销活动，如果你要买第 i 件商品，那么你可以得到与 prices[j] 相等的折扣，其中 j 是满足 j &gt; i 且 prices[j] &lt;= prices[i] 的 最小下标 ，如果没有满足条件的 j ，你将没有任何折扣。 请你返回一个数组，数组中第 i 个元素是折扣后你购买商品 i 最终需要支付的价格。 示例： 输入：prices &#x3D; [8,4,6,2,3]输出：[4,2,4,2,3]解释：商品 0 的价格为 price[0]&#x3D;8 ，你将得到 prices[1]&#x3D;4 的折扣，所以最终价格为 8 - 4 &#x3D; 4 。商品 1 的价格为 price[1]&#x3D;4 ，你将得到 prices[3]&#x3D;2 的折扣，所以最终价格为 4 - 2 &#x3D; 2 。商品 2 的价格为 price[2]&#x3D;6 ，你将得到 prices[3]&#x3D;2 的折扣，所以最终价格为 6 - 2 &#x3D; 4 。商品 3 和 4 都没有折扣。 思路：遍历遍历找到满足 j &gt; i 且 prices[j] &lt;= prices[i] 的 最小下标 代码(cpp)：123456789101112131415161718class Solution &#123;public: vector&lt;int&gt; finalPrices(vector&lt;int&gt;&amp; prices) &#123; int n = prices.size(); vector&lt;int&gt; ans(n); for(int i = 0; i &lt; n; i++)&#123; ans[i] = prices[i]; for(int j = i + 1; j &lt; n; j++)&#123; if(prices[j] &lt;= prices[i])&#123; ans[i] -= prices[j]; break; &#125; &#125; &#125; return ans; &#125;&#125;; 复杂度分析： 时间复杂度：O(n^2)，其中 n 为数组的长度。对于每个商品，我们需要遍历一遍数组查找符合题目要求的折扣。 空间复杂度：O(1)。返回值不计入空间复杂度。","categories":[{"name":"每日LeetCode","slug":"每日LeetCode","permalink":"http://example.com/categories/%E6%AF%8F%E6%97%A5LeetCode/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"},{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"(每日LeetCode)946. 验证栈序列","slug":"每日LeetCode/2022-8/946 验证栈序列","date":"2022-08-31T00:20:00.000Z","updated":"2022-08-31T00:20:45.457Z","comments":true,"path":"2022/08/31/每日LeetCode/2022-8/946 验证栈序列/","link":"","permalink":"http://example.com/2022/08/31/%E6%AF%8F%E6%97%A5LeetCode/2022-8/946%20%E9%AA%8C%E8%AF%81%E6%A0%88%E5%BA%8F%E5%88%97/","excerpt":"","text":"题目：给定 pushed 和 popped 两个序列，每个序列中的 值都不重复，只有当它们可能是在最初空栈上进行的推入 push 和弹出 pop 操作序列的结果时，返回 true；否则，返回 false 。 示例： 输入：pushed &#x3D; [1,2,3,4,5], popped &#x3D; [4,5,3,2,1]输出：true解释：我们可以按以下顺序执行：push(1), push(2), push(3), push(4), pop() -&gt; 4,push(5), pop() -&gt; 5, pop() -&gt; 3, pop() -&gt; 2, pop() -&gt; 1 思路：模拟依次将pushed数组中的元素入栈，如果栈s的栈顶等于popped的第一个元素，将栈顶元素出栈，并判断popped数组的下一个元素 最后只需要判断栈s是否为空即可 代码(cpp)：123456789101112131415class Solution &#123;public: bool validateStackSequences(vector&lt;int&gt;&amp; pushed, vector&lt;int&gt;&amp; popped) &#123; stack&lt;int&gt; s; int pos = 0 for (int i = 0; i &lt; pushed.size(); i++) &#123; s.emplace(pushed[i]); while (!s.empty() &amp;&amp; s.top() == popped[pos]) &#123; s.pop(); pos++; &#125; &#125; return s.empty(); &#125;&#125;; 复杂度分析： 时间复杂度：O(n)，其中 nn 是数组 pushed 和 popped 的长度。需要遍历数组 pushed 和 popped 各一次，判断两个数组是否为有效的栈操作序列。 空间复杂度：O(n)，其中 n 是数组 pushed 和 popped 的长度。空间复杂度主要取决于栈空间，栈内元素个数不超过 n。","categories":[{"name":"每日LeetCode","slug":"每日LeetCode","permalink":"http://example.com/categories/%E6%AF%8F%E6%97%A5LeetCode/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"},{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"(每日LeetCode)998. 最大二叉树 II","slug":"每日LeetCode/2022-8/998 最大二叉树 II","date":"2022-08-30T00:45:00.000Z","updated":"2022-08-30T00:49:28.038Z","comments":true,"path":"2022/08/30/每日LeetCode/2022-8/998 最大二叉树 II/","link":"","permalink":"http://example.com/2022/08/30/%E6%AF%8F%E6%97%A5LeetCode/2022-8/998%20%E6%9C%80%E5%A4%A7%E4%BA%8C%E5%8F%89%E6%A0%91%20II/","excerpt":"","text":"题目： 最大树 定义：一棵树，并满足：其中每个节点的值都大于其子树中的任何其他值。 给你最大树的根节点 root 和一个整数 val 。 就像 之前的问题 那样，给定的树是利用 Construct(a) 例程从列表 a（root &#x3D; Construct(a)）递归地构建的： 如果 a 为空，返回 null 。否则，令 a[i] 作为 a 的最大元素。创建一个值为 a[i] 的根节点 root 。root 的左子树将被构建为 Construct([a[0], a[1], …, a[i - 1]]) 。root 的右子树将被构建为 Construct([a[i + 1], a[i + 2], …, a[a.length - 1]]) 。返回 root 。请注意，题目没有直接给出 a ，只是给出一个根节点 root &#x3D; Construct(a) 。 假设 b 是 a 的副本，并在末尾附加值 val。题目数据保证 b 中的值互不相同。 返回 Construct(b) 。 示例： 输入：root &#x3D; [4,1,3,null,null,2], val &#x3D; 5输出：[5,4,null,1,3,null,null,2]解释：a &#x3D; [1,4,2,3], b &#x3D; [1,4,2,3,5] 没看懂题目… 看题解大概是：val足够大，整个树都是左子树。val足够小，变成一个右叶子。 代码(cpp)： 12345678910111213class Solution &#123;public: TreeNode* insertIntoMaxTree(TreeNode* root, int val) &#123; if(root == nullptr)&#123; return new TreeNode(val); &#125; if(root-&gt;val &lt; val)&#123; return new TreeNode(val, root, nullptr); &#125; root-&gt;right = insertIntoMaxTree(root-&gt;right, val); return root; &#125;&#125;;","categories":[{"name":"每日LeetCode","slug":"每日LeetCode","permalink":"http://example.com/categories/%E6%AF%8F%E6%97%A5LeetCode/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"},{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"(每日LeetCode)1470. 重新排列数组","slug":"每日LeetCode/2022-8/1470 重新排列数组","date":"2022-08-28T23:54:00.000Z","updated":"2022-08-28T23:54:54.268Z","comments":true,"path":"2022/08/29/每日LeetCode/2022-8/1470 重新排列数组/","link":"","permalink":"http://example.com/2022/08/29/%E6%AF%8F%E6%97%A5LeetCode/2022-8/1470%20%E9%87%8D%E6%96%B0%E6%8E%92%E5%88%97%E6%95%B0%E7%BB%84/","excerpt":"","text":"题目：给你一个数组 nums ，数组中有 2n 个元素，按 [x1,x2,...,xn,y1,y2,...,yn] 的格式排列。 请你将数组按 [x1,y1,x2,y2,...,xn,yn] 格式重新排列，返回重排后的数组。 示例： 输入：nums &#x3D; [2,5,1,3,4,7], n &#x3D; 3输出：[2,3,5,4,1,7]解释：由于 x1&#x3D;2, x2&#x3D;5, x3&#x3D;1, y1&#x3D;3, y2&#x3D;4, y3&#x3D;7 ，所以答案为 [2,3,5,4,1,7] 思路：双指针在数组nums的起始位置和中间位置依次遍历添加到ans新数组中 代码(cpp)：123456789101112131415class Solution &#123;public: vector&lt;int&gt; shuffle(vector&lt;int&gt;&amp; nums, int n) &#123; vector&lt;int&gt; ans(2*n); int left = 0; int right = n; while(left &lt; n)&#123; ans.emplace_back(nums[left]); ans.emplace_back(nums[right]); left++; right++; &#125; return ans; &#125;&#125;; 复杂度分析： 时间复杂度：O(n)，其中 n 是给定的参数。需要遍历长度为 2n 的数组 nums 一次将数组重新排列，每个元素重新排列的时间是 O(1)O(1)。 空间复杂度：O(1)。注意返回值不计入空间复杂度。","categories":[{"name":"每日LeetCode","slug":"每日LeetCode","permalink":"http://example.com/categories/%E6%AF%8F%E6%97%A5LeetCode/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"},{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"(每日LeetCode)662. 二叉树最大宽度","slug":"每日LeetCode/2022-8/662 二叉树最大宽度","date":"2022-08-27T02:23:00.000Z","updated":"2022-08-27T02:24:07.404Z","comments":true,"path":"2022/08/27/每日LeetCode/2022-8/662 二叉树最大宽度/","link":"","permalink":"http://example.com/2022/08/27/%E6%AF%8F%E6%97%A5LeetCode/2022-8/662%20%E4%BA%8C%E5%8F%89%E6%A0%91%E6%9C%80%E5%A4%A7%E5%AE%BD%E5%BA%A6/","excerpt":"","text":"题目：给你一棵二叉树的根节点 root ，返回树的 最大宽度 。 树的 最大宽度 是所有层中最大的 宽度 。 每一层的 宽度 被定义为该层最左和最右的非空节点（即，两个端点）之间的长度。将这个二叉树视作与满二叉树结构相同，两端点间会出现一些延伸到这一层的 null 节点，这些 null 节点也计入长度。 题目数据保证答案将会在 32 位 带符号整数范围内。 示例： 输入：root &#x3D; [1,3,2,5,3,null,9]输出：4解释：最大宽度出现在树的第 3 层，宽度为 4 (5,3,null,9) 。 思路：广度优先搜索(BFS)就是一个二叉树的层序遍历 只是遍历的时候增加了一个 标记每个结点的序号 的过程 如果某节点node的序号为n，那么它的左节点为2n，右节点为2n+1 每层的尾序号与首序号之间的差就是该层的宽度 返回最大宽度 代码(cpp)：1234567891011121314151617181920212223class Solution &#123;public: int widthOfBinaryTree(TreeNode* root) &#123; // 初始化数组储存结点以及对应的序号 vector&lt;pair&lt;TreeNode*, unsigned long long&gt;&gt; array; array.emplace_back(root, 1L); unsigned long long ans = 0; while(!array.empty())&#123; //层序遍历 vector&lt;pair&lt;TreeNode*, unsigned long long&gt;&gt; temp; // 获取每个结点以及对应的序号 for(auto&amp; [node, index] : array)&#123; //遍历该层的每个结点 if(node-&gt;left) temp.emplace_back(node-&gt;left, index*2); if(node-&gt;right) temp.emplace_back(node-&gt;right, index*2 + 1); &#125; ans = max(ans, array.back().second - array[0].second + 1); array = move(temp); //将temp(就是下一层的结点)引用给array &#125; return ans; &#125;&#125;; 复杂度分析： 时间复杂度：O(n)，其中 n 是二叉树的节点个数。需要遍历所有节点。 空间复杂度：O(n)。广度优先搜索的空间复杂度最多为 O(n)。","categories":[{"name":"每日LeetCode","slug":"每日LeetCode","permalink":"http://example.com/categories/%E6%AF%8F%E6%97%A5LeetCode/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"},{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"(每日LeetCode)1464. 数组中两元素的最大乘积","slug":"每日LeetCode/2022-8/1464 数组中两元素的最大乘积","date":"2022-08-26T01:01:00.000Z","updated":"2022-08-26T01:01:39.525Z","comments":true,"path":"2022/08/26/每日LeetCode/2022-8/1464 数组中两元素的最大乘积/","link":"","permalink":"http://example.com/2022/08/26/%E6%AF%8F%E6%97%A5LeetCode/2022-8/1464%20%E6%95%B0%E7%BB%84%E4%B8%AD%E4%B8%A4%E5%85%83%E7%B4%A0%E7%9A%84%E6%9C%80%E5%A4%A7%E4%B9%98%E7%A7%AF/","excerpt":"","text":"题目：给你一个整数数组 nums，请你选择数组的两个不同下标 i 和 j，使 (nums[i]-1)*(nums[j]-1) 取得最大值。 请你计算并返回该式的最大值。 示例： 输入：nums &#x3D; [3,4,5,2]输出：12解释：如果选择下标 i&#x3D;1 和 j&#x3D;2（下标从 0 开始），则可以获得最大值，(nums[1]-1)(nums[2]-1) &#x3D; (4-1)(5-1) &#x3D; 3*4 &#x3D; 12 。 代码(cpp)：1234567class Solution &#123;public: int maxProduct(vector&lt;int&gt;&amp; nums) &#123; sort(nums.begin(), nums.end()); return (nums[nums.size()-2] - 1)*(nums[nums.size()-1] - 1); &#125;&#125;; 复杂度分析： 时间复杂度：O(nlogn)，其中 n 为数组 nums 的长度，主要为数组排序的时间复杂度。 空间复杂度：O(1)，仅使用常量空间。","categories":[{"name":"每日LeetCode","slug":"每日LeetCode","permalink":"http://example.com/categories/%E6%AF%8F%E6%97%A5LeetCode/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"},{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"(每日LeetCode)658. 找到 K 个最接近的元素","slug":"每日LeetCode/2022-8/658 找到 K 个最接近的元素","date":"2022-08-25T02:34:00.000Z","updated":"2022-08-25T02:34:05.353Z","comments":true,"path":"2022/08/25/每日LeetCode/2022-8/658 找到 K 个最接近的元素/","link":"","permalink":"http://example.com/2022/08/25/%E6%AF%8F%E6%97%A5LeetCode/2022-8/658%20%E6%89%BE%E5%88%B0%20K%20%E4%B8%AA%E6%9C%80%E6%8E%A5%E8%BF%91%E7%9A%84%E5%85%83%E7%B4%A0/","excerpt":"","text":"题目：给定一个 排序好 的数组 arr ，两个整数 k 和 x ，从数组中找到最靠近 x（两数之差最小）的 k 个数。返回的结果必须要是按升序排好的。 整数 a 比整数 b 更接近 x 需要满足： |a - x| &lt; |b - x| 或者|a - x| == |b - x| 且 a &lt; b 示例： 输入：arr &#x3D; [1,2,3,4,5], k &#x3D; 4, x &#x3D; 3输出：[1,2,3,4] 思路：二分查找+双指针利用 二分查找 找到第一个不小于x的元素 利用 双指针 循环找到最接近x值的元素区间 返回此区间的元素即可 代码(cpp)：1234567891011121314151617181920212223class Solution &#123;public: vector&lt;int&gt; findClosestElements(vector&lt;int&gt;&amp; arr, int k, int x) &#123; auto right = lower_bound(arr.begin(), arr.end(), x); auto left = right - 1; while (k &gt; 0) &#123; if (left &lt; arr.begin()) &#123; right++; &#125; else if (right &gt;= arr.end()) &#123; left--; &#125; else if (x - *left &lt;= *right - x) &#123; left--; &#125; else &#123; right++; &#125; k--; &#125; return vector&lt;int&gt;(left + 1, right); &#125;&#125;; 复杂度分析： 时间复杂度：O(logn+k)，其中 n 是数组 arr 的长度。二分查找需要 O(logn)，双指针查找需要 O(k)。 空间复杂度：O(1)。返回值不计入空间复杂度。","categories":[{"name":"每日LeetCode","slug":"每日LeetCode","permalink":"http://example.com/categories/%E6%AF%8F%E6%97%A5LeetCode/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"},{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"(每日LeetCode)1460. 通过翻转子数组使两个数组相等","slug":"每日LeetCode/2022-8/1460 通过翻转子数组使两个数组相等","date":"2022-08-24T01:54:00.000Z","updated":"2022-08-24T01:55:04.953Z","comments":true,"path":"2022/08/24/每日LeetCode/2022-8/1460 通过翻转子数组使两个数组相等/","link":"","permalink":"http://example.com/2022/08/24/%E6%AF%8F%E6%97%A5LeetCode/2022-8/1460%20%E9%80%9A%E8%BF%87%E7%BF%BB%E8%BD%AC%E5%AD%90%E6%95%B0%E7%BB%84%E4%BD%BF%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9B%B8%E7%AD%89/","excerpt":"","text":"题目：给你两个长度相同的整数数组 target 和 arr 。每一步中，你可以选择 arr 的任意 非空子数组 并将它翻转。你可以执行此过程任意次。 如果你能让 arr 变得与 target 相同，返回 True；否则，返回 False 。 示例： 输入：target &#x3D; [1,2,3,4], arr &#x3D; [2,4,1,3]输出：true解释：你可以按照如下步骤使 arr 变成 target：1- 翻转子数组 [2,4,1] ，arr 变成 [1,4,2,3]2- 翻转子数组 [4,2] ，arr 变成 [1,2,4,3]3- 翻转子数组 [4,3] ，arr 变成 [1,2,3,4]上述方法并不是唯一的，还存在多种将 arr 变成 target 的方法。 思路：这道题很简单！ 不需要关注过程，只需要看到结果即可 将target与arr排序后比较是否相同即可 代码(cpp)：123456789class Solution &#123;public: bool canBeEqual(vector&lt;int&gt;&amp; target, vector&lt;int&gt;&amp; arr) &#123; sort(target.begin(), target.end()); sort(arr.begin(), arr.end()); return target == arr; &#125;&#125;; 复杂度分析： 时间复杂度：O(n×logn)，其中 n 是输入数组的长度。排序消耗 O(n×logn) 复杂度，判断是否相同消耗 O(n) 复杂度。 空间复杂度：O(logn)，快速排序递归深度平均为 O(logn)。","categories":[{"name":"每日LeetCode","slug":"每日LeetCode","permalink":"http://example.com/categories/%E6%AF%8F%E6%97%A5LeetCode/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"},{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"(每日LeetCode)655. 输出二叉树","slug":"每日LeetCode/2022-8/655 输出二叉树","date":"2022-08-22T02:20:00.000Z","updated":"2022-08-22T02:21:03.902Z","comments":true,"path":"2022/08/22/每日LeetCode/2022-8/655 输出二叉树/","link":"","permalink":"http://example.com/2022/08/22/%E6%AF%8F%E6%97%A5LeetCode/2022-8/655%20%E8%BE%93%E5%87%BA%E4%BA%8C%E5%8F%89%E6%A0%91/","excerpt":"","text":"题目：给你一棵二叉树的根节点 root ，请你构造一个下标从 0 开始、大小为 m x n 的字符串矩阵 res ，用以表示树的 格式化布局 。构造此格式化布局矩阵需要遵循以下规则： 树的 高度 为 height ，矩阵的行数 m 应该等于 height + 1 。矩阵的列数 n 应该等于 2^(height+1 - 1) 。根节点 需要放置在 顶行 的 正中间 ，对应位置为 res[0][(n-1)/2] 。对于放置在矩阵中的每个节点，设对应位置为 res[r][c] ，将其左子节点放置在 res[r+1][c-2height-r-1] ，右子节点放置在 res[r+1][c+2height-r-1]。继续这一过程，直到树中的所有节点都妥善放置。任意空单元格都应该包含空字符串 &quot;&quot; 。返回构造得到的矩阵 res 。 示例： 输入：root &#x3D; [1,2,3,null,4]输出：[[“”,””,””,”1”,””,””,””],[“”,”2”,””,””,””,”3”,””],[“”,””,”4”,””,””,””,””]] 思路：DFS(深度优先搜索) 利用DFS获取深度 利用DFS遍历二叉树获取对应的val值 代码(cpp)：1234567891011121314151617181920212223242526272829303132333435class Solution &#123;public: int getHeight(TreeNode* root)&#123; int height = 0; if(root-&gt;left)&#123; height = max(height, getHeight(root-&gt;left) + 1); &#125; if(root-&gt;right)&#123; height = max(height, getHeight(root-&gt;right) + 1); &#125; return height; &#125; void dfs(int r, int c, TreeNode* root, vector&lt;vector&lt;string&gt;&gt;&amp; res, int&amp; height)&#123; if(root == nullptr) return; res[r][c] = to_string(root-&gt;val); dfs(r+1, c-pow(2, height-r-1), root-&gt;left, res, height); dfs(r+1, c+pow(2, height-r-1), root-&gt;right, res, height); &#125; vector&lt;vector&lt;string&gt;&gt; printTree(TreeNode* root) &#123; int height = getHeight(root); //获取深度 int m = height + 1; int n = pow(2, m) - 1; //初始化res vector&lt;vector&lt;string&gt;&gt; res(m, vector&lt;string&gt;(n)); //dfs遍历二叉树 dfs(0, (n-1)/2, root, res, height); return res; &#125;&#125;; 复杂度分析： 时间复杂度：O(height×2^height)，其中height 是二叉树的高度。需要填充 (height + 1)×(2^(height+1) − 1) 的数组。 空间复杂度：O(height)，其中 height 是二叉树的高度。空间复杂度主要是递归调用的栈空间，取决于二叉树的高度。注意返回值不计入空间复杂度。","categories":[{"name":"每日LeetCode","slug":"每日LeetCode","permalink":"http://example.com/categories/%E6%AF%8F%E6%97%A5LeetCode/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"},{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"","slug":"小技巧/C++中1《《 n的意思","date":"2022-08-22T01:35:19.667Z","updated":"2022-08-22T01:42:23.591Z","comments":true,"path":"2022/08/22/小技巧/C++中1《《 n的意思/","link":"","permalink":"http://example.com/2022/08/22/%E5%B0%8F%E6%8A%80%E5%B7%A7/C++%E4%B8%AD1%E3%80%8A%E3%80%8A%20n%E7%9A%84%E6%84%8F%E6%80%9D/","excerpt":"","text":"1 &lt;&lt; n是什么意思？1的二进制是0000 0001&lt;&lt;：将二进制编码向左移动n位并将空位补0 例如： 1 &lt;&lt; 2 就是将0000 0001左移2位为变成0000 0100 转换成十进制最终变成4 同理： 1 &gt;&gt; n：将二进制编码向右移动n位","categories":[],"tags":[]},{"title":"(每日LeetCode)1455. 检查单词是否为句中其他单词的前缀","slug":"每日LeetCode/2022-8/1455 检查单词是否为句中其他单词的前缀","date":"2022-08-21T00:33:00.000Z","updated":"2022-08-21T00:40:32.493Z","comments":true,"path":"2022/08/21/每日LeetCode/2022-8/1455 检查单词是否为句中其他单词的前缀/","link":"","permalink":"http://example.com/2022/08/21/%E6%AF%8F%E6%97%A5LeetCode/2022-8/1455%20%E6%A3%80%E6%9F%A5%E5%8D%95%E8%AF%8D%E6%98%AF%E5%90%A6%E4%B8%BA%E5%8F%A5%E4%B8%AD%E5%85%B6%E4%BB%96%E5%8D%95%E8%AF%8D%E7%9A%84%E5%89%8D%E7%BC%80/","excerpt":"","text":"题目：给你一个字符串 sentence 作为句子并指定检索词为 searchWord ，其中句子由若干用 单个空格 分隔的单词组成。请你检查检索词 searchWord 是否为句子 sentence 中任意单词的前缀。 如果 searchWord 是某一个单词的前缀，则返回句子 sentence 中该单词所对应的下标（下标从 1 开始）。如果 searchWord 是多个单词的前缀，则返回匹配的第一个单词的下标（最小下标）。如果 searchWord 不是任何单词的前缀，则返回 -1 。 字符串 s 的 前缀 是 s 的任何前导连续子字符串。 示例： 输入：sentence &#x3D; “i love eating burger”, searchWord &#x3D; “burg”输出：4解释：”burg” 是 “burger” 的前缀，而 “burger” 是句子中第 4 个单词。 代码(cpp)：123456789101112131415161718192021class Solution &#123;public: int isPrefixOfWord(string sentence, string searchWord) &#123; int ans = 1; //初始化第一个单词的wei for (int i = 0; i &lt; sentence.size(); i++) &#123; int temp = 0; while (sentence[i] == searchWord[temp]) &#123; // 与searchWord进行比较 if (temp == searchWord.size() - 1) &#123; //比较完，返回单词位置 return ans; &#125; temp++; i++; &#125; while (i &lt; sentence.size() &amp;&amp; sentence[i] != &#x27; &#x27;)&#123;//遍历到下一个单词 i++; &#125; ans++; // 进入下一个单词的位置 &#125; return -1; //不存在，返回-1 &#125;&#125;;","categories":[{"name":"每日LeetCode","slug":"每日LeetCode","permalink":"http://example.com/categories/%E6%AF%8F%E6%97%A5LeetCode/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"},{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"(每日LeetCode)654. 最大二叉树","slug":"每日LeetCode/2022-8/654 最大二叉树","date":"2022-08-20T02:04:00.000Z","updated":"2022-08-20T02:05:04.652Z","comments":true,"path":"2022/08/20/每日LeetCode/2022-8/654 最大二叉树/","link":"","permalink":"http://example.com/2022/08/20/%E6%AF%8F%E6%97%A5LeetCode/2022-8/654%20%E6%9C%80%E5%A4%A7%E4%BA%8C%E5%8F%89%E6%A0%91/","excerpt":"","text":"题目：给定一个不重复的整数数组 nums 。 最大二叉树 可以用下面的算法从 nums 递归地构建: 创建一个根节点，其值为 nums 中的最大值。递归地在最大值 左边 的 子数组前缀上 构建左子树。递归地在最大值 右边 的 子数组后缀上 构建右子树。返回 nums 构建的 最大二叉树 。 示例： 输入：nums &#x3D; [3,2,1,6,0,5]输出：[6,3,5,null,2,0,null,null,1]解释：递归调用如下所示： [3,2,1,6,0,5] 中的最大值是 6 ，左边部分是 [3,2,1] ，右边部分是 [0,5] 。 [3,2,1] 中的最大值是 3 ，左边部分是 [] ，右边部分是 [2,1] 。 空数组，无子节点。 [2,1] 中的最大值是 2 ，左边部分是 [] ，右边部分是 [1] 。 空数组，无子节点。 只有一个元素，所以子节点是一个值为 1 的节点。 [0,5] 中的最大值是 5 ，左边部分是 [0] ，右边部分是 [] 。 只有一个元素，所以子节点是一个值为 0 的节点。 空数组，无子节点。 思路：递归每次递归遍历中找到left和right区间的最大值作为该节点的val值，以及该最大值的位置max_pos 划分该节点的左子树的区间为left和max_pos 划分该节点的右子树的区间为max_pos+1和right 如果左右区间left &gt;= right说明已经遍历完全，退出递归 代码(cpp)：12345678910111213141516171819202122232425class Solution &#123;public: TreeNode* def(vector&lt;int&gt;&amp; nums, int left, int right)&#123; if(left &gt;= right) return nullptr; int temp = -1; int max_pos = 0; for(int i = left; i &lt; right; i++)&#123; if(nums[i] &gt; temp)&#123; temp = nums[i]; max_pos = i; &#125; &#125; TreeNode* node = new TreeNode(temp); node-&gt;left = def(nums, left, max_pos); node-&gt;right = def(nums, max_pos + 1, right); return node; &#125; TreeNode* constructMaximumBinaryTree(vector&lt;int&gt;&amp; nums) &#123; return def(nums, 0, nums.size()); &#125;&#125;; 复杂度分析： 时间复杂度：O(n^2)，其中 n 是数组 nums 的长度。在最坏的情况下，数组严格递增或递减，需要递归 n 层，第 (0 ≤ i &lt; n) 层需要遍历 n-i 个元素以找出最大值，总时间复杂度为 O(n^2)。 空间复杂度：O(n)，即为最坏情况下需要使用的栈空间。","categories":[{"name":"每日LeetCode","slug":"每日LeetCode","permalink":"http://example.com/categories/%E6%AF%8F%E6%97%A5LeetCode/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"},{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"Docker中安装es以及kibana","slug":"软件安装/Docker中安装es以及kibana","date":"2022-08-19T02:55:08.053Z","updated":"2022-08-20T04:48:54.524Z","comments":true,"path":"2022/08/19/软件安装/Docker中安装es以及kibana/","link":"","permalink":"http://example.com/2022/08/19/%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85/Docker%E4%B8%AD%E5%AE%89%E8%A3%85es%E4%BB%A5%E5%8F%8Akibana/","excerpt":"","text":"1.es1.1 安装es镜像我的容器中jdk版本为8 这里我选择的是es的7.17.5版本镜像镜像安装，因为es8以上的版本不支持jdk8 1docker pull elasticsearch:7.17.5 1.2 启动es容器12345docker run -id \\--name c_es \\-p 9200:9200 \\-e &quot;discovery.type=single-node&quot; \\elasticsearch:7.17.5 1.3 测试在浏览器中访问：http://主机地址ip:9200 如果出现： 1234567891011121314151617&#123; &quot;name&quot; : &quot;3c9efa3c75db&quot;, &quot;cluster_name&quot; : &quot;docker-cluster&quot;, &quot;cluster_uuid&quot; : &quot;1hr4ILNNQfufDSJYgcuIHQ&quot;, &quot;version&quot; : &#123; &quot;number&quot; : &quot;7.17.5&quot;, &quot;build_flavor&quot; : &quot;default&quot;, &quot;build_type&quot; : &quot;docker&quot;, &quot;build_hash&quot; : &quot;8d61b4f7ddf931f219e3745f295ed2bbc50c8e84&quot;, &quot;build_date&quot; : &quot;2022-06-23T21:57:28.736740635Z&quot;, &quot;build_snapshot&quot; : false, &quot;lucene_version&quot; : &quot;8.11.1&quot;, &quot;minimum_wire_compatibility_version&quot; : &quot;6.8.0&quot;, &quot;minimum_index_compatibility_version&quot; : &quot;6.0.0-beta1&quot; &#125;, &quot;tagline&quot; : &quot;You Know, for Search&quot;&#125; 则说明安装成功！ 1.4 跨域访问问题进入容器： 1docker exec -it c_es /bin/bash 修改elasticsearch.yml： 12cd /usr/share/elasticsearch/config/vi elasticsearch.yml 文件末尾添加以下内容： 12http.cors.enabled: truehttp.cors.allow-origin: &quot;*&quot; 重启容器： 1docker restart c_es 2.kibana2.1 安装kibana镜像前提：已经成功部署es 注意：kibana版本要与es的版本一致 1docker pull kibana:7.17.5 2.2 获取es容器内部ip查看c_es容器信息： 1docker inspect c_es 找到IPAddress: &quot;ip&quot;，此ip就是es容器内部ip 2.3 启动kibana容器将ELASTICSEARCH_HOSTS修改为自己es容器内部ip 12345docker run -id \\--name c_kibana \\-e ELASTICSEARCH_HOSTS=http://es容器内部ip:9200 \\-p 5601:5601 \\kibana:7.17.5 2.4 修改中文进入容器： 1docker exec -u 0 -it c_kibana /bin/bash 12cd configvi kibana.yml 在末尾加上一下内容： 1i18n.locale: &quot;zh-CN&quot; 2.5 测试在浏览器中访问：http://主机地址ip:5601 就可以看到kibana的界面了！","categories":[{"name":"软件安装","slug":"软件安装","permalink":"http://example.com/categories/%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85/"}],"tags":[{"name":"容器","slug":"容器","permalink":"http://example.com/tags/%E5%AE%B9%E5%99%A8/"},{"name":"es","slug":"es","permalink":"http://example.com/tags/es/"},{"name":"kibana","slug":"kibana","permalink":"http://example.com/tags/kibana/"}]},{"title":"(每日LeetCode)1450. 在既定时间做作业的学生人数","slug":"每日LeetCode/2022-8/1450 在既定时间做作业的学生人数","date":"2022-08-19T00:21:00.000Z","updated":"2022-08-19T00:21:37.245Z","comments":true,"path":"2022/08/19/每日LeetCode/2022-8/1450 在既定时间做作业的学生人数/","link":"","permalink":"http://example.com/2022/08/19/%E6%AF%8F%E6%97%A5LeetCode/2022-8/1450%20%E5%9C%A8%E6%97%A2%E5%AE%9A%E6%97%B6%E9%97%B4%E5%81%9A%E4%BD%9C%E4%B8%9A%E7%9A%84%E5%AD%A6%E7%94%9F%E4%BA%BA%E6%95%B0/","excerpt":"","text":"题目：给你两个整数数组 startTime（开始时间）和 endTime（结束时间），并指定一个整数 queryTime 作为查询时间。 已知，第 i 名学生在 startTime[i] 时开始写作业并于 endTime[i] 时完成作业。 请返回在查询时间 queryTime 时正在做作业的学生人数。形式上，返回能够使 queryTime 处于区间 [startTime[i], endTime[i]]（含）的学生人数。 示例： 输入：startTime &#x3D; [1,2,3], endTime &#x3D; [3,2,7], queryTime &#x3D; 4输出：1解释：一共有 3 名学生。第一名学生在时间 1 开始写作业，并于时间 3 完成作业，在时间 4 没有处于做作业的状态。第二名学生在时间 2 开始写作业，并于时间 2 完成作业，在时间 4 没有处于做作业的状态。第三名学生在时间 3 开始写作业，预计于时间 7 完成作业，这是是唯一一名在时间 4 时正在做作业的学生。 思路：枚举代码(cpp)：123456789101112class Solution &#123;public: int busyStudent(vector&lt;int&gt;&amp; startTime, vector&lt;int&gt;&amp; endTime, int queryTime) &#123; int sum = 0; for(int i = 0; i &lt; startTime.size(); i++)&#123; if(startTime[i] &lt;= queryTime &amp;&amp; queryTime &lt;= endTime[i]) &#123; sum++; &#125; &#125; return sum; &#125;&#125;; 复杂度分析： 时间复杂度：O(n)，其中 n 为 数组的长度。只需遍历一遍数组即可。 空间复杂度：O(1)。","categories":[{"name":"每日LeetCode","slug":"每日LeetCode","permalink":"http://example.com/categories/%E6%AF%8F%E6%97%A5LeetCode/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"},{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"(每日LeetCode)1302. 层数最深叶子节点的和","slug":"每日LeetCode/2022-8/1302 层数最深叶子节点的和","date":"2022-08-17T02:50:00.000Z","updated":"2022-08-17T02:50:49.131Z","comments":true,"path":"2022/08/17/每日LeetCode/2022-8/1302 层数最深叶子节点的和/","link":"","permalink":"http://example.com/2022/08/17/%E6%AF%8F%E6%97%A5LeetCode/2022-8/1302%20%E5%B1%82%E6%95%B0%E6%9C%80%E6%B7%B1%E5%8F%B6%E5%AD%90%E8%8A%82%E7%82%B9%E7%9A%84%E5%92%8C/","excerpt":"","text":"题目：给你一棵二叉树的根节点 root ，请你返回 层数最深的叶子节点的和 。 示例： 输入：root &#x3D; [1,2,3,4,5,null,6,7,null,null,null,null,8]输出：15 思路一：深度优先搜索(DFS)代码(cpp)：12345678910111213141516171819202122232425class Solution &#123;public: int max_level = 0; int sum = 0; void dfs(TreeNode* root, int level)&#123; if(!root) return; if(max_level &lt; level)&#123; //max_sum如果不是最大深度，重新开始 sum = root-&gt;val; max_level = level; &#125; else if(max_level == level) &#123; //为最大深度，le sum += root-&gt;val; &#125; dfs(root-&gt;left, level + 1); dfs(root-&gt;right, level + 1); &#125; int deepestLeavesSum(TreeNode* root) &#123; dfs(root, 0); return sum; &#125;&#125;; 复杂度分析： 时间复杂度：O(n)，其中 n 是二叉树的节点数。深度优先搜索需要遍历每个节点一次。 空间复杂度：O(n)，其中 n 是二叉树的节点数。空间复杂度主要取决于递归调用栈的深度，为二叉树的深度，最坏情况下二叉树的深度是 O(n)。 思路二：广度优先搜索(BFS)代码(cpp)：1234567891011121314151617181920class Solution &#123;public: int deepestLeavesSum(TreeNode* root) &#123; queue&lt;TreeNode*&gt; q; q.emplace(root); int sum = 0; while(!q.empty())&#123; //层遍历 sum = 0; int size = q.size(); //获取该层的元素个数 for(int i = 0; i &lt; size; i++)&#123; //该层的元素遍历 TreeNode* node = q.front(); q.pop(); if(node-&gt;left) q.emplace(node-&gt;left); if(node-&gt;right) q.emplace(node-&gt;right); sum += node-&gt;val; &#125; &#125; return sum; &#125;&#125;; 复杂度分析： 时间复杂度：O(n)，其中 n 是二叉树的节点数。广度优先搜索需要遍历每个节点一次。 空间复杂度：O(n)，其中 n 是二叉树的节点数。空间复杂度主要取决于队列空间，队列中的节点个数不超过 n 个。","categories":[{"name":"每日LeetCode","slug":"每日LeetCode","permalink":"http://example.com/categories/%E6%AF%8F%E6%97%A5LeetCode/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"},{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"(每日LeetCode)1656. 设计有序流","slug":"每日LeetCode/2022-8/1656 设计有序流","date":"2022-08-16T03:34:00.000Z","updated":"2022-08-16T03:34:20.019Z","comments":true,"path":"2022/08/16/每日LeetCode/2022-8/1656 设计有序流/","link":"","permalink":"http://example.com/2022/08/16/%E6%AF%8F%E6%97%A5LeetCode/2022-8/1656%20%E8%AE%BE%E8%AE%A1%E6%9C%89%E5%BA%8F%E6%B5%81/","excerpt":"","text":"题目：有 n 个 (id, value) 对，其中 id 是 1 到 n 之间的一个整数，value 是一个字符串。不存在 id 相同的两个 (id, value) 对。 设计一个流，以 任意 顺序获取 n 个 (id, value) 对，并在多次调用时 按 id 递增的顺序 返回一些值。 实现 OrderedStream 类： OrderedStream(int n) 构造一个能接收 n 个值的流，并将当前指针 ptr 设为 1 。 String[] insert(int id, String value) 向流中存储新的 (id, value) 对。存储后： 如果流存储有 id = ptr 的 (id, value) 对，则找出从 id = ptr 开始的 最长 id 连续递增序列 ，并 按顺序 返回与这些 id 关联的值的列表。然后，将 ptr 更新为最后那个 id + 1 。 否则，返回一个空列表。 示例： 输入[“OrderedStream”, “insert”, “insert”, “insert”, “insert”, “insert”][[5], [3, “ccccc”], [1, “aaaaa”], [2, “bbbbb”], [5, “eeeee”], [4, “ddddd”]]输出[null, [], [“aaaaa”], [“bbbbb”, “ccccc”], [], [“ddddd”, “eeeee”]] 解释OrderedStream os&#x3D; new OrderedStream(5);os.insert(3, “ccccc”); &#x2F;&#x2F; 插入 (3, “ccccc”)，返回 []os.insert(1, “aaaaa”); &#x2F;&#x2F; 插入 (1, “aaaaa”)，返回 [“aaaaa”]os.insert(2, “bbbbb”); &#x2F;&#x2F; 插入 (2, “bbbbb”)，返回 [“bbbbb”, “ccccc”]os.insert(5, “eeeee”); &#x2F;&#x2F; 插入 (5, “eeeee”)，返回 []os.insert(4, “ddddd”); &#x2F;&#x2F; 插入 (4, “ddddd”)，返回 [“ddddd”, “eeeee”] 代码(cpp)：12345678910111213141516171819class OrderedStream &#123;public: int ptr; vector&lt;string&gt; array; OrderedStream(int n) &#123; ptr = 1; array = vector&lt;string&gt;(n + 1); &#125; vector&lt;string&gt; insert(int idKey, string value) &#123; vector&lt;string&gt; ans; array[idKey] = value; while(ptr &lt; array.size() &amp;&amp; array[ptr] != &quot;&quot;)&#123; ans.emplace_back(array[ptr]); ptr++; &#125; return ans; &#125;&#125;; 复杂度分析： 时间复杂度：OrderedStream(int n) 的时间复杂度为 O(n)；String[] insert(int id, String value) 的时间复杂度为均摊 O(1)，这是因为我们会恰好调用该函数 n 次，那么每一个字符串最多会被包含在返回数组中一次。 空间复杂度：O(n)，即为存储 n 个字符串需要的空间。","categories":[{"name":"每日LeetCode","slug":"每日LeetCode","permalink":"http://example.com/categories/%E6%AF%8F%E6%97%A5LeetCode/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"},{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"(每日LeetCode)641. 设计循环双端队列","slug":"每日LeetCode/2022-8/641 设计循环双端队列","date":"2022-08-15T02:29:00.000Z","updated":"2022-08-15T02:29:10.370Z","comments":true,"path":"2022/08/15/每日LeetCode/2022-8/641 设计循环双端队列/","link":"","permalink":"http://example.com/2022/08/15/%E6%AF%8F%E6%97%A5LeetCode/2022-8/641%20%E8%AE%BE%E8%AE%A1%E5%BE%AA%E7%8E%AF%E5%8F%8C%E7%AB%AF%E9%98%9F%E5%88%97/","excerpt":"","text":"题目：设计实现双端队列。 实现 MyCircularDeque 类: MyCircularDeque(int k) ：构造函数,双端队列最大为 k 。 boolean insertFront()：将一个元素添加到双端队列头部。 如果操作成功返回 true ，否则返回 false。 boolean insertLast() ：将一个元素添加到双端队列尾部。如果操作成功返回 true ，否则返回 false 。 boolean deleteFront() ：从双端队列头部删除一个元素。 如果操作成功返回 true ，否则返回 false 。 boolean deleteLast() ：从双端队列尾部删除一个元素。如果操作成功返回 true ，否则返回 false 。 int getFront()：从双端队列头部获得一个元素。如果双端队列为空，返回 -1 。 int getRear() ：获得双端队列的最后一个元素。 如果双端队列为空，返回 -1 。 boolean isEmpty() ：若双端队列为空，则返回 true ，否则返回 false 。 boolean isFull() ：若双端队列满了，则返回 true ，否则返回 false 。 示例： 输入[“MyCircularDeque”, “insertLast”, “insertLast”, “insertFront”, “insertFront”, “getRear”, “isFull”, “deleteLast”, “insertFront”, “getFront”][[3], [1], [2], [3], [4], [], [], [], [4], []]输出[null, true, true, true, false, 2, true, true, true, 4] 解释MyCircularDeque circularDeque &#x3D; new MycircularDeque(3); &#x2F;&#x2F; 设置容量大小为3circularDeque.insertLast(1); &#x2F;&#x2F; 返回 truecircularDeque.insertLast(2); &#x2F;&#x2F; 返回 truecircularDeque.insertFront(3); &#x2F;&#x2F; 返回 truecircularDeque.insertFront(4); &#x2F;&#x2F; 已经满了，返回 falsecircularDeque.getRear(); &#x2F;&#x2F; 返回 2circularDeque.isFull(); &#x2F;&#x2F; 返回 truecircularDeque.deleteLast(); &#x2F;&#x2F; 返回 truecircularDeque.insertFront(4); &#x2F;&#x2F; 返回 truecircularDeque.getFront(); &#x2F;&#x2F; 返回 4 思路：数组可参考力扣 622 设计循环队列 代码(cpp)：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657class MyCircularDeque &#123;public: vector&lt;int&gt; deque; int front; int rear; int capacity; MyCircularDeque(int k) &#123; capacity = k; deque = vector&lt;int&gt;(k + 1); front = 0; rear = 0; &#125; bool insertFront(int value) &#123; if(isFull()) return false; front = (front - 1 + capacity + 1) % (capacity + 1); deque[front] = value; return true; &#125; bool insertLast(int value) &#123; if(isFull()) return false; deque[rear] = value; rear = (rear + 1) % (capacity + 1); return true; &#125; bool deleteFront() &#123; if(isEmpty()) return false; front = (front + 1) % (capacity + 1); return true; &#125; bool deleteLast() &#123; if(isEmpty()) return false; rear = (rear - 1 + capacity + 1) % (capacity + 1); return true; &#125; int getFront() &#123; if(isEmpty()) return -1; return deque[front]; &#125; int getRear() &#123; if(isEmpty()) return -1; return deque[(rear - 1 + capacity + 1) % (capacity + 1)]; &#125; bool isEmpty() &#123; return front == rear; &#125; bool isFull() &#123; return (rear + 1) % (capacity + 1) == front; &#125;&#125;; 复杂度分析： 时间复杂度：初始化和每项操作的时间复杂度均为 O(1)。 空间复杂度：O(k)，其中 k 为给定的队列元素数目。","categories":[{"name":"每日LeetCode","slug":"每日LeetCode","permalink":"http://example.com/categories/%E6%AF%8F%E6%97%A5LeetCode/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"},{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"(每日LeetCode)1422. 分割字符串的最大得分","slug":"每日LeetCode/2022-8/1422 分割字符串的最大得分","date":"2022-08-14T01:44:00.000Z","updated":"2022-08-14T01:45:00.113Z","comments":true,"path":"2022/08/14/每日LeetCode/2022-8/1422 分割字符串的最大得分/","link":"","permalink":"http://example.com/2022/08/14/%E6%AF%8F%E6%97%A5LeetCode/2022-8/1422%20%E5%88%86%E5%89%B2%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%9C%80%E5%A4%A7%E5%BE%97%E5%88%86/","excerpt":"","text":"题目：给你一个由若干 0 和 1 组成的字符串 s ，请你计算并返回将该字符串分割成两个 非空 子字符串（即 左 子字符串和 右 子字符串）所能获得的最大得分。 「分割字符串的得分」为 左 子字符串中 0 的数量加上 右 子字符串中 1 的数量。 示例： 输入：s &#x3D; “011101”输出：5解释：将字符串 s 划分为两个非空子字符串的可行方案有：左子字符串 &#x3D; “0” 且 右子字符串 &#x3D; “11101”，得分 &#x3D; 1 + 4 &#x3D; 5左子字符串 &#x3D; “01” 且 右子字符串 &#x3D; “1101”，得分 &#x3D; 1 + 3 &#x3D; 4左子字符串 &#x3D; “011” 且 右子字符串 &#x3D; “101”，得分 &#x3D; 1 + 2 &#x3D; 3左子字符串 &#x3D; “0111” 且 右子字符串 &#x3D; “01”，得分 &#x3D; 1 + 1 &#x3D; 2左子字符串 &#x3D; “01110” 且 右子字符串 &#x3D; “1”，得分 &#x3D; 2 + 1 &#x3D; 3 思路：枚举获得每一种可能的分数，比较出最高得分 代码(cpp)：123456789101112131415161718192021class Solution &#123;public: int maxScore(string s) &#123; int score = 0; for(int i = 0; i &lt; s.size() - 1; i++)&#123; int temp_score = 0; for(int j = 0; j &lt;= i; j++)&#123; if(s[j] == &#x27;0&#x27;)&#123; temp_score++; &#125; &#125; for(int k = i + 1; k &lt; s.size(); k++)&#123; if(s[k] == &#x27;1&#x27;)&#123; temp_score++; &#125; &#125; score = max(score, temp_score); &#125; return score; &#125;&#125;; 复杂度分析： 时间复杂度：O(n^2)，其中 n 是字符串 s 的长度。需要遍历 n−1 个分割点，对于每个分割点需要 O(n) 的时间遍历整个字符串计算分割字符串的得分，因此时间复杂度是 O(n^2) 空间复杂度：O(1)","categories":[{"name":"每日LeetCode","slug":"每日LeetCode","permalink":"http://example.com/categories/%E6%AF%8F%E6%97%A5LeetCode/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"},{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"(每日LeetCode)1282. 用户分组","slug":"每日LeetCode/2022-8/1282 用户分组","date":"2022-08-12T02:14:00.000Z","updated":"2022-08-12T02:14:47.826Z","comments":true,"path":"2022/08/12/每日LeetCode/2022-8/1282 用户分组/","link":"","permalink":"http://example.com/2022/08/12/%E6%AF%8F%E6%97%A5LeetCode/2022-8/1282%20%E7%94%A8%E6%88%B7%E5%88%86%E7%BB%84/","excerpt":"","text":"题目：有 n 个人被分成数量未知的组。每个人都被标记为一个从 0 到 n - 1 的唯一ID 。 给定一个整数数组 groupSizes ，其中 groupSizes[i] 是第 i 个人所在的组的大小。例如，如果 groupSizes[1] &#x3D; 3 ，则第 1 个人必须位于大小为 3 的组中。 返回一个组列表，使每个人 i 都在一个大小为 groupSizes[i] 的组中。 每个人应该 恰好只 出现在 一个组 中，并且每个人必须在一个组中。如果有多个答案，返回其中 任何 一个。可以 保证 给定输入 至少有一个 有效的解。 示例： 输入：groupSizes &#x3D; [3,3,3,3,3,1,3]输出：[[5],[0,1,2],[3,4,6]]解释：第一组是 [5]，大小为 1，groupSizes[5] &#x3D; 1。第二组是 [0,1,2]，大小为 3，groupSizes[0] &#x3D; groupSizes[1] &#x3D; groupSizes[2] &#x3D; 3。第三组是 [3,4,6]，大小为 3，groupSizes[3] &#x3D; groupSizes[4] &#x3D; groupSizes[6] &#x3D; 3。其他可能的解决方案有 [[2,1,6],[5],[0,4,3]] 和 [[5],[0,6,2],[4,3,1]]。 思路：哈希表使用哈希表获取用户人数相同的元素的所在位置 遍历哈希表，依次截取用户人数为大小的片段 代码(cpp)：1234567891011121314151617class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; groupThePeople(vector&lt;int&gt;&amp; groupSizes) &#123; unordered_map&lt;int, vector&lt;int&gt;&gt; groups; for(int i = 0; i &lt; groupSizes.size(); i++)&#123; groups[groupSizes[i]].emplace_back(i); &#125; vector&lt;vector&lt;int&gt;&gt; ans; for(auto&amp; group : groups)&#123; for(auto it = group.second.begin(); it != group.second.end();)&#123; ans.emplace_back(vector&lt;int&gt;(it, it + group.first)); //截取数组片段 it += group.first; &#125; &#125; return ans; &#125;&#125;; 复杂度分析： 时间复杂度：O(n)，其中 n 是数组 groupSize 的长度。需要遍历数组一次得到每个组的大小对应的所有人的编号，然后需要遍历所有元素完成分组。 空间复杂度：O(n)，其中 n 是数组 groupSize 的长度。空间复杂度主要取决于哈希表，哈希表需要 O(n) 的空间记录每个组的大小对应的所有人的编号。","categories":[{"name":"每日LeetCode","slug":"每日LeetCode","permalink":"http://example.com/categories/%E6%AF%8F%E6%97%A5LeetCode/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"},{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"(每日LeetCode)1417. 重新格式化字符串","slug":"每日LeetCode/2022-8/1417 重新格式化字符串","date":"2022-08-11T03:17:00.000Z","updated":"2022-08-11T03:17:50.166Z","comments":true,"path":"2022/08/11/每日LeetCode/2022-8/1417 重新格式化字符串/","link":"","permalink":"http://example.com/2022/08/11/%E6%AF%8F%E6%97%A5LeetCode/2022-8/1417%20%E9%87%8D%E6%96%B0%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2/","excerpt":"","text":"题目：给你一个混合了数字和字母的字符串 s，其中的字母均为小写英文字母。 请你将该字符串重新格式化，使得任意两个相邻字符的类型都不同。也就是说，字母后面应该跟着数字，而数字后面应该跟着字母。 请你返回 重新格式化后 的字符串；如果无法按要求重新格式化，则返回一个 空字符串 。 示例：输入：s &#x3D; “a0b1c2”输出：”0a1b2c”解释：”0a1b2c” 中任意两个相邻字符的类型都不同。 “a0b1c2”, “0a1b2c”, “0c2a1b” 也是满足题目要求的答案。 思路：分别获取数字num和字母letter 求得数字长度与字母长度之间的差： 差的绝对值大于1，则无解； 差等于0，依次添加数字、字母； 差等于1，先添加数字再添加字母； 差等于-1，先添加字母再添加数字； 代码(cpp)：1234567891011121314151617181920212223242526272829303132333435363738394041class Solution &#123;public: string reformat(string s) &#123; string num = &quot;&quot;; string letter = &quot;&quot;; for(auto i : s)&#123; if(i &gt;= 48 &amp;&amp; i &lt;= 57)&#123; num += i; &#125; else&#123; letter += i; &#125; &#125; int temp = num.size() - letter.size(); if(temp &gt; 1 || temp &lt; -1)&#123; return &quot;&quot;; &#125; string ans; if(temp == 0)&#123; for(int i = 0; i &lt; num.size(); i++)&#123; ans += num[i]; ans += letter[i]; &#125; &#125; else if(temp == 1)&#123; ans += num[0]; for(int i = 0; i &lt; letter.size(); i++)&#123; ans += letter[i]; ans += num[i + 1]; &#125; &#125; else&#123; ans += letter[0]; for(int i = 0; i &lt; num.size(); i++)&#123; ans += num[i]; ans += letter[i + 1]; &#125; &#125; return ans; &#125;&#125;;","categories":[{"name":"每日LeetCode","slug":"每日LeetCode","permalink":"http://example.com/categories/%E6%AF%8F%E6%97%A5LeetCode/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"},{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"","slug":"C++/做题常用函数","date":"2022-08-11T02:49:11.978Z","updated":"2022-09-19T23:36:20.290Z","comments":true,"path":"2022/08/11/C++/做题常用函数/","link":"","permalink":"http://example.com/2022/08/11/C++/%E5%81%9A%E9%A2%98%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/","excerpt":"","text":"函数 bool isdigit(char c) 判断字符是否为数字 int abs(int num) 获取num的绝对值 string to_string (int val) 数字转字符串 iterator lower_bound(iterator first, iterator last, T&amp; val) 指定区域内查找不小于目标值的第一个元素 二分查找 T move(T t) 将左值强制转化为右值引用 效率更高,增强型等号 int atoi(const char *nptr) 将char*类型的字符串转为int整型 int stoi(string str) 将string类型的字符串转为int整型 accumulate(起始迭代器, 结束迭代器, 初始值, 自定义操作函数) 累加","categories":[],"tags":[]},{"title":"(每日LeetCode)1413. 逐步求和得到正数的最小值","slug":"每日LeetCode/2022-8/1413 逐步求和得到正数的最小值","date":"2022-08-09T01:31:00.000Z","updated":"2022-08-09T01:31:40.351Z","comments":true,"path":"2022/08/09/每日LeetCode/2022-8/1413 逐步求和得到正数的最小值/","link":"","permalink":"http://example.com/2022/08/09/%E6%AF%8F%E6%97%A5LeetCode/2022-8/1413%20%E9%80%90%E6%AD%A5%E6%B1%82%E5%92%8C%E5%BE%97%E5%88%B0%E6%AD%A3%E6%95%B0%E7%9A%84%E6%9C%80%E5%B0%8F%E5%80%BC/","excerpt":"","text":"题目：给你一个整数数组 nums 。你可以选定任意的 正数 startValue 作为初始值。 你需要从左到右遍历 nums 数组，并将 startValue 依次累加上 nums 数组中的值。 请你在确保累加和始终大于等于 1 的前提下，选出一个最小的 正数 作为 startValue 。 示例： 输入：nums &#x3D; [-3,2,-3,4,2]输出：5解释：如果你选择 startValue &#x3D; 4，在第三次累加时，和小于 1 。 累加求和 startValue &#x3D; 4 | startValue &#x3D; 5 | nums (4 -3 ) &#x3D; 1 | (5 -3 ) &#x3D; 2 | -3 (1 +2 ) &#x3D; 3 | (2 +2 ) &#x3D; 4 | 2 (3 -3 ) &#x3D; 0 | (4 -3 ) &#x3D; 1 | -3 (0 +4 ) &#x3D; 4 | (1 +4 ) &#x3D; 5 | 4 (4 +2 ) &#x3D; 6 | (5 +2 ) &#x3D; 7 | 2 思路：遍历数组，如果累加中小于1时，增加startValue的值直到累加为1 代码(cpp)：123456789101112131415class Solution &#123;public: int minStartValue(vector&lt;int&gt;&amp; nums) &#123; int startValue = 1; //初始化为1，因为startValue为最小的正数 int sum = 1; //初始化为1，因为一开始初始化为0要加上startValue就变成了1 for(auto&amp; num : nums)&#123; sum += num; //累加 if(sum &lt; 1)&#123; //小于1的情况 startValue += 1 - sum; //加上相差的数 sum = 1; //总和就变成了1 &#125; &#125; return startValue; &#125;&#125;;","categories":[{"name":"每日LeetCode","slug":"每日LeetCode","permalink":"http://example.com/categories/%E6%AF%8F%E6%97%A5LeetCode/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"},{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"(每日LeetCode)636. 函数的独占时间","slug":"每日LeetCode/2022-8/636 函数的独占时间","date":"2022-08-07T03:38:00.000Z","updated":"2022-08-07T03:38:19.485Z","comments":true,"path":"2022/08/07/每日LeetCode/2022-8/636 函数的独占时间/","link":"","permalink":"http://example.com/2022/08/07/%E6%AF%8F%E6%97%A5LeetCode/2022-8/636%20%E5%87%BD%E6%95%B0%E7%9A%84%E7%8B%AC%E5%8D%A0%E6%97%B6%E9%97%B4/","excerpt":"","text":"题目：有一个 单线程 CPU 正在运行一个含有 n 道函数的程序。每道函数都有一个位于 0 和 n-1 之间的唯一标识符。 函数调用 存储在一个 调用栈 上 ：当一个函数调用开始时，它的标识符将会推入栈中。而当一个函数调用结束时，它的标识符将会从栈中弹出。标识符位于栈顶的函数是 当前正在执行的函数 。每当一个函数开始或者结束时，将会记录一条日志，包括函数标识符、是开始还是结束、以及相应的时间戳。 给你一个由日志组成的列表 logs ，其中 logs[i] 表示第 i 条日志消息，该消息是一个按&quot;&#123;function_id&#125;:&#123;&quot;start&quot; | &quot;end&quot;&#125;:&#123;timestamp&#125;&quot; 进行格式化的字符串。例如，&quot;0:start:3&quot; 意味着标识符为 0 的函数调用在时间戳 3 的 起始开始执行 ；而 &quot;1:end:2&quot; 意味着标识符为 1 的函数调用在时间戳 2 的 末尾结束执行。注意，函数可以 调用多次，可能存在递归调用 。 函数的 独占时间 定义是在这个函数在程序所有函数调用中执行时间的总和，调用其他函数花费的时间不算该函数的独占时间。例如，如果一个函数被调用两次，一次调用执行 2 单位时间，另一次调用执行 1 单位时间，那么该函数的 独占时间 为 2 + 1 = 3 。 以数组形式返回每个函数的 独占时间 ，其中第 i 个下标对应的值表示标识符 i 的函数的独占时间。 示例： 输入：n = 2, logs = [&quot;0:start:0&quot;,&quot;1:start:2&quot;,&quot;1:end:5&quot;,&quot;0:end:6&quot;]输出：[3,4]解释：函数 0 在时间戳 0 的起始开始执行，执行 2 个单位时间，于时间戳 1 的末尾结束执行。函数 1 在时间戳 2 的起始开始执行，执行 4 个单位时间，于时间戳 5 的末尾结束执行。函数 0 在时间戳 6 的开始恢复执行，执行 1 个单位时间。所以函数 0 总共执行 2 + 1 &#x3D; 3 个单位时间，函数 1 总共执行 4 个单位时间。 思路：栈遍历logs数组 遍历到status为start时： 将栈顶函数的运行部分时长更新，因为要运行新的函数，先暂时停止运行栈顶函数 将栈顶函数的时刻更新为现在的时刻，再入栈 status为end时： 获取栈顶函数，更新运行总时长，将此函数弹出，因为已经运行完毕了 此时栈顶函数就是之前的那个函数了，要继续运行此函数， 将此函数从时刻更新为现在的时刻，因为是现在的时刻开始继续运行的 代码(cpp)：12345678910111213141516171819202122232425262728293031class Solution &#123;public: vector&lt;int&gt; exclusiveTime(int n, vector&lt;string&gt;&amp; logs) &#123; stack&lt;pair&lt;int, int&gt;&gt; s; vector&lt;int&gt; ans(n); for(auto&amp; log : logs)&#123; int id; char status[10]; int cur_time; sscanf(log.c_str(), &quot;%d:%[^:]:%d&quot;, &amp;id, status, &amp;cur_time); if(status[0] == &#x27;s&#x27;)&#123; if(!s.empty())&#123; ans[s.top().first] += cur_time - s.top().second; s.top().second = cur_time; &#125; s.emplace(id, cur_time); &#125; else&#123; auto temp = s.top(); s.pop(); ans[temp.first] += cur_time + 1 - temp.second; if(!s.empty())&#123; s.top().second = cur_time + 1; &#125; &#125; &#125; return ans; &#125;&#125;; 复杂度分析： 时间复杂度：O(n)，其中 n 为全部日志 logs 的数量，n 条日志信息对应总共 n 次入栈和出栈操作。 空间复杂度：O(n)，其中 n 为全部日志 logs 的数量，n 条日志信息对应 n&#x2F;2 次入栈操作，最坏的情况下全部 n&#x2F;2 条日志入栈后才会依次弹栈。","categories":[{"name":"每日LeetCode","slug":"每日LeetCode","permalink":"http://example.com/categories/%E6%AF%8F%E6%97%A5LeetCode/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"},{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"Docker容器的学习笔记","slug":"Java/Docker容器","date":"2022-08-06T13:24:22.587Z","updated":"2022-08-20T04:31:38.169Z","comments":true,"path":"2022/08/06/Java/Docker容器/","link":"","permalink":"http://example.com/2022/08/06/Java/Docker%E5%AE%B9%E5%99%A8/","excerpt":"","text":"1.初识Docker我们写好的代码会接触到好几个环境：开发环境、测试环境和生产环境 可能导致在不同的环境下代码运行产生问题(“水土”不服) 所以就需要将代码以及运行环境装到一个容器 测试只需要在容器中进行测试即可，使用的是容器中的运行环境，解决了软件跨环境迁移的问题 1.1 Docker概念 Docker是一个开源的应用容器引擎 诞生于2013年初，基于Go语言实现 Docker可以让开发者打包他们的应用以及依赖包到一个轻量级、可移值的容器中，然后发布到任何流行的Linux机器上 容器是完全使用沙箱机制，相互隔离(一台Linux机器可以启动多个容器，容器之间互不影响) 容器性能开销极低 小结：docker是一种容器技术，解决软件跨环境迁移的问题 1.2 Docker架构 镜像(Image)：Docker镜像(image)，就相当于是一个root文件系统。比如官方镜像ubuntu:16.04包含了一个完整的一套Ubuntu 16.04最小系统的root文件系统。 容器(Container)：镜像(image)和容器(Container)的关系就像是面向对象程序设计中的类和对象一样，镜像是静态的定义，容器是镜像运行时的实体类。容器可以被创建、启动、停止、删除、暂停等操作。 仓库(Repository)：仓库看成一个代码控制中心，用来保存镜像。 1.3 Docker与虚拟机容器就是将软件打包成标准化单元，以用于开发、交付和部署。 容器镜像是轻量的、可执行的独立软件包，包含软件运行新需的所有内容：代码、运行时环境、系结工具、系统库和设置。 容器化软件在任何环境中都能够始终如一地运行。 容器赋于了软件独立性，使其免受外在环境差异的影响，从而有助于减少团队间在相同基础设施上运行不同软件时的冲突。 docker容器虚拟化与传统虚拟机比较 相同： 容器和虚拟机具有相似的资源隔离和分配优势 不同： 容器虛拟化的是操作系統，虛拟机虚拟化的是硬件。 传统虚拟机可以运行不同的操作系统，容器只能运行同一类型操作系统 特性 容器 虚拟机 启动 秒级 分钟级 硬盘使用 一般为MB 一般为GB 性能 接近原生 较弱 系统支持量 单机支持上千个容器 一般为几十个 2.Docker命令2.1 服务相关命令 启动docker服务： 1systemctl start docker 停止docker服务： 1systemctl stop docker 重启docker服务： 1systemctl restart docker 查看docker服务状态： 1systemctl status docker 设置开机启动docker服务： 1systemctl enable docker 2.2 镜像相关命令 查看镜像： 1docker images 查看镜像所有的image id： 1docker images -q 搜索镜像： 搜索redis镜像 1docker search redis 拉取(下载)镜像： 默认下载最新版本的redis镜像 1docker search redis 也可以指定版本号： 下载7.0版本的redis镜像 1docker search redis:7.0 查看版本：打开docker官网，搜索redis，找到并打开官方镜像查看描述信息 删除镜像： 通过image id删除镜像 1docker rmi &lt;IMAGE ID&gt; 也可以通过名称指定版本：删除7.0版本的redis镜像 1docker rmi redis:7.0 删除所有镜像： 1docker rmi &#x27;docker images -q&#x27; 删除无用镜像： 1docker rmi $(docker images -f &quot;dangling=true&quot; -q) 2.3 容器相关命令 查看容器： 查看正在运行的容器： 1docker ps 查看所有容器： 1docker ps -a 创建容器： 1docker run [参数] 例子： 1docker run -it --name=c1 centos:latest /bin/bash 1docker run -id --name=c2 centos:latest -i：保持容器运行 -t：为容器重新分配一个伪终端(可与-i合并为-it) -it创建的容器称为交互式容器 -d：守护(后台)模式运行容器 -id：创建的容器称为守护式容器，需要使用docker exec进入容器 --name=c1：给容器起名为c1 退出容器： 1exit 进入容器： 1docker exec [参数] 进入c2容器： 1docker exec -it c2 /bin/bash 以root权限进入容器： 参数 0 表示root 1docker exec -u 0 -it 容器名 /bin/bash 启动容器： 1docker start 容器名称 停止容器： 1docker stop 容器名称 删除容器： 1docker rm 容器名称 查看容器信息： 1docker inspect 容器名称 3.Docker容器数据卷3.1 数据卷概念 数据卷是宿主机中的一个目录或文件 当容器目录和数据卷目录被绑定后，双方的修改会立即同步 一个数据卷可以被多个容器同时挂载 一个容器可以被挂载多个数据卷 数据卷的作用： 容器的持久化 外部机器和容器间接通信 容器之间数据交换 3.2 配置数据卷创建启动容器时，使用-v设置数据卷 docker run -v 宿主机目录(或文件):容器内目录(或文件) 注意事项： 目录必须是绝对路径 如果目录不存在，会自动创建 可以挂载多个数据卷 例子： 1docker run -it --name=c1 -v /root/data:/root/data_container centos:latest /bin/bash 挂载多个数据卷： 1234docker run -it --name=c2 \\-v /root/data1:/root/data_container1 \\-v /root/data2:/root/data_container2 \\centos:latest /bin/bash 3.3 配置数据卷容器多容器进行数据交换： 多个容器挂载同一个数据卷 数据卷容器 创建启动c3数据卷容器，使用-v 参数设置数据卷： 1docker run -it --name=c3 -v /volume centos:latest /bin/bash 创建启动c1、c2容器，使用--volume-from 参数设置数据卷： 1docker run -it --name=c1 --volume-from c3 centos:latest /bin/bash 1docker run -it --name=c2 --volume-from c3 centos:latest /bin/bash 3.4 数据卷小结 数据卷的概念 宿主机的一个目录或文件 数据卷的作用 容器数据持久化 客户端和容器数据交换 容器之间数据交换 数据卷容器 创建一个容器，挂载一个目录，让其他容器继承该容器 通过简单方式实现数据卷配置 4.Docker应用部署基本步骤： 搜索镜像 拉取镜像 创建容器 操作容器 容器内的网络服务和外部机器不能直接通信 外部机器和宿主机可以直接通信 宿主机和容器可以直接通信 当容器中的网络服务需要被外部机器访问时，可以将容器中提供服务的端口映射到宿主机的端口上。外部机器访问宿主机的该端口，从而问接访问容器的服务。 这种操作称为：端口映射 4.1 MySQL部署需求： 在Docker容器中部署MySQL，并通过外部mysql客户端操作MySQL server 搜索镜像 1docker search mysql 拉取镜像 1docker pull mysql 创建容器，设置端口映射、目录映射 123#在/root目录下创建mysql目录用于存储mysql数据信息mkdir ~/mysqlcd ~/mysql 1234567docker run -id \\-p 3307:3306 \\--name=c_mysql \\-v $PWD/conf:/etc/mysql/conf.d \\-v $PWD/data:/var/lib/mysql \\-e MYSQL_ROOT_PASSWORD=123456 \\mysql:latest 参数说明： $PWD：相当于主机目录的 &#x2F;root&#x2F;mysql -p 3307:3306：将容器的3306端口映射到宿主机的3306端口 端口映射 -V $PWD/conf:/etc/mysql/conf.d：将主机当前目录下的 conf&#x2F;my.cnf 挂载到容器的&#x2F;etc&#x2F;mysql&#x2F;my.cnf 配置目录 -V $PWD/logs:/logs：将主机当前目录下的logs目录挂载到容器的 &#x2F;logs 日志目录 -V $PWD/data:/var/lib/mysql：将主机当前目录下的data目录挂载到容器的 &#x2F;var&#x2F;lib&#x2F;mysql 数据目录 -e MYSOL_ROOT_PASSWORD=123456：初始化root 用户的密码为123456 操作MySQL容器 容器内连接MySQL： 1docker exec -it c_mysql /bin/bash 1mysql -uroot -p123456 图形化客户端连接MySQL： 主机：宿主机的ip 端口：为上面映射为的3307 用户名：root 密码：为上面的123456 4.2 Tomcat部署需求： 在Docker容器中部署Tomcat，并通过外部机器访问Tomcat部署的项目 搜索Tomcat镜像 1docker search tomcat 拉取Tomcat镜像 1docker pull tomcat 创建容器，设置端口映射、目录映射 123#在/root目录下创建tomcat目录用于存储tomcat数据信息mkdir ~/tomcatcd ~/tomcat 12345docker run -id \\--name=c_tomcat \\-p 8080:8080 \\-v $PWD:/usr/local/tomcat/webapps \\tomcat:latest 参数说明： -p 8080:8080：将容器的8080端口映射到主机的8080端口 -v $PWD:/user/local/tomcat/webapps：将主机中当前目录挂载到容器中的 &#x2F;user&#x2F;local&#x2F;tomcat&#x2F;webapps 测试Tomcat 在tomcat目录下，创建test包，在test包中创建一个测试文件： 123mkdir testcd testvim index.html 在index.html文件中写入： 1&lt;h1&gt; Hello Tomcat &lt;/h1&gt; 保存退出： Esc+:wq 使用浏览器访问Tomcat：主机地址:8080/test/index.html 4.3 Redis部署需求： 在Docker容器中部署Redis，并通过外部机器连接Redis 搜索Redis镜像 1docker search redis 拉取Tomcat镜像 1docker pull redis 创建容器，设置端口映射 1234docker run -id \\-p 6379:6379 \\--name=c_redis \\redis:latest 图形化客户端连接redis 主机地址：宿主机的ip 端口：为6379 4.4 Nginx部署需求： 在Docker容器中部署Nginx，并通过外部机器访问Nginx 搜索Nginx镜像 1docker search nginx 拉取Nginx镜像 1docker pull nginx 部署Nginx 在&#x2F;root目录下创建nginx目录用于存储nginx数据信息： 12mkdir ~/nginxcd ~/nginx 在~&#x2F;nginx&#x2F;conf&#x2F;下创建nginx.conf文件： 123mkdir confcd confvim nginx.conf 在nginx.conf中写入： 1234567891011121314151617181920212223242526272829user nginx;worker_processes 1;error_log /var/log/nginx/error.log warn;pid /var/run/nginx.pid;events &#123; worker_connections 1024;&#125;http &#123; include /etc/nginx/mime.types; default_type application/octet-stream; log_format main &#x27;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#x27; &#x27;$status $body_bytes_sent &quot;$http_referer&quot; &#x27; &#x27;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#x27;; access_log /var/log/nginx/access.log main; sendfile on; #tcp_nopush on; keepalive_timeout 65; #gzip on; include /etc/nginx/conf.d/*.conf;&#125; 回到nginx目录： 1cd .. 创建容器，设置端口映射、目录映射： 1234567docker run -id \\--name=c_nginx \\-p 80:80 \\-v $PWD/conf/nginx.conf:/etc/nginx/nginx.conf \\-v $PWD/logs:/var/log/nginx \\-v $PWD/html:/usr/share/nginx/html \\nginx:latest 参数说明： -p 80:80：将容器的80端口映射到宿主机的 80 端口 -v $PWD/conf/nginx.conf:/etc/nginx/nginx.conf：将主机当前目录下的&#x2F;conf&#x2F;nginx.conf 挂载到容器的：&#x2F;etc&#x2F;nginx&#x2F;nginx.conf 配置目录 -v $PWD/logs:/var/log/nginx：将主机当前目录下的 logs 目录挂载到容器的&#x2F;var&#x2F;log&#x2F;nginx 日志目录 使用浏览器访问nginx 创建nginx&#x2F;html&#x2F;test&#x2F;index.html文件： 1234cd htmlmkdir testcd testvim index.html 写入下面内容： 1&lt;h1&gt; Hello Nginx &lt;/h1&gt; 浏览器访问：主机地址/test/index.html 5.DockerFile5.1 Docker镜像原理 操作系统组成部分： 进程调度子系统 进程通信子系統 内存管理子系统 设备管理子系统 文件管理子系统 网络通信子系统 作业控制子系统 Linux文件系统由bootfs和rootfs两部分组成： bootfs：包含bootloader(引导加载程序)和kernel(内核） rootfs：root文件系统，包含的就是典型Linux 系统中的&#x2F;dev、&#x2F;proc、&#x2F;bin、&#x2F;etc等标准目录和文件 不同的linux发行版，bootfs基本一样，而rootis不同。如ubuntu、centos等 Docker镜像原理： Docker镜像是由特殊的文件系统叠加而成 最底端是bootfs， 并使用宿主机的bootfs 第二层是root文件系统rootfs称为base image(基础镜像) 然后再往上可以叠加其他的镜像文件 统一文件系统 (Union File System）技术能够将不同的层整合成一个文件系统，为这些层提供了一个统一的视角，迹样就隐藏了多层的存在，在用户的角度看来，只存在一个文件系统。 一个镜像可以放在另一个镜像的上面。位于下面的镜像称为父镜像，最底部的镜像成为基础镜像。 当一个镜像启动容器时，Docker会在最底层加载一个读写文件系统作为容器 这样分层的好处就是复用 总结： Docker镜像的本质是什么? 一个分层文件系统 centos镜像只有200MB，而一个centos的操作系统的iso文件要几个G？ centos的镜像文件包含bootfs和rootfs，而docker的centos镜像复用了操作系统(就是宿主机)的bootfs，只有rootfs和其他镜像层 Docker中一个tomcat镜像为什么有500MB，而—个tomcat安装包只有70多MB? 由于docker中镜像是分层的，tomcat虽然只有70多MB，但他需要依赖于父镜像和基础镜像，所有整个对外暴露的tomcat镜像加起来大小500多MB 5.2 容器转镜像容器转镜像 1docker commit [容器id] [新的镜像名称]:[自定义版本号] 镜像转压缩文件 1docker save -o [自定义压缩文件名称.tar] [镜像名称]:[自定义版本号] 压缩文件转镜像 1docker load -i [压缩文件] 5.3 DockerFile概念 DockerFile是一个文本系统 包含了一条条的指令 每条指令构建一层，基于基础镜像，最终构建出一个新的镜像 可以为开发团队提高一个完全一致的开发环境 在部署时，可以实现应用的无缝移植 例如： centos7的dockerfile nginx的dockerfile 5.4 DockerFile的关键字 关键字 作用 FROM 指定父镜像 MAINTAINER 作者信息 LABEL 标签 RUN 执行命令 CMD 容器启动命令 ENTRYPOINT 入口 COPY 复制文件 ADD 添加文件 ENV 环境变量 ARG 构建参数 VOLUME 定义外部可以挂载的数据卷 EXPOSE 暴露端口 WORKDIR 工作目录 USER 指定执行用户 HEALTHCHECK 健康检查 ONBUILD 触发器 STOPSIGNAL 发送信息量到宿主机 SHELL 执行执行脚本shell 5.5 部署SpringBoot项目需求： 定义dockerfile，发布springboot项目 实现步骤： 定义父镜像 定义作者信息 将jar包添加到容器 定义容器启动执行的命令 通过dockerfile构建镜像 创建目录： 12mkdir ~/docker-filescd ~/docker-files 将打包好的SpringBoot项目上传到~&#x2F;docker-files目录下 注意：SpringBoot项目也要为java8版本 在docker-files目录编写springboot_dockerfile： 1vim springboot_dockerfile 写入下面的内容： 1234FROM java:8MAINTAINER AiADD springboot-demo-0.0.1-SNAPSHOT.jar app.jarCMD java -jar app.jar 保存退出，将jar包转换为镜像： 1docker build -f ./springboot_dockerfile -t app . 测试 创建容器： 1docker run -id --name=c_app -p 8080:8080 app:latest 浏览器访问：主机地址:8080/hello 5.6 自定义Centos需求： 自定义centos:7镜像，要求： 默认登录路径为&#x2F;usr 可以使用vim 实现步骤： 定义父镜像 定义作者信息 执行安装vim命令 定义默认的工作目录 定义容器启动执行的命令 转到~&#x2F;docker-files目录 1cd ~/docker-files 编写centos7_dockerfile 1vim centos7_dockerfile 写入下面内容： 12345FROM centos:7MAINTAINER AiRUN yum install -y vimWORKDIR /usrCMD /bin/bash 保存退出 创建自定义centos7镜像 1docker build -f ./centos7_dockerfile -t my_centos:1 . 6.Docker服务编排6.1 Docker Compose概述微服务架构的应用系统中一般包含若干个微服务，每个微服务一般都会部署多个实例，如果每个微服务都要手动启停，维护的工作量会很大。 要从Dockerfile build image 或者去dockerhub拉取image 要创建多个container 要管理这些container(启动停止删除) 服务编排：按照一定的业务规则批量管理容器 Docker Compose是一个编排多容器分布式部署的工具，提供命令集管理容器化应用的完整开发周期，包括服务构建、启动和停止。使用步骤： 利用 Dockerfile 定义运行环境镜像 使用 docker-compose.yml定义组成应用的各服务 运行 docker-compose up 启动应用 6.2 Docker Compose安装在安装docker-compose之前要安装docker，以二进制包的方式安装在Linux中： 1curl -L https://get.daocloud.io/docker/compose/releases/download/v2.9.0/docker-compose-`uname -s`-`uname -m` &gt; /usr/local/bin/docker-compose 设置可执行权限： 1chmod +x /usr/local/bin/docker-compose 查看版本信息： 1docker-compose -v docker-compose的卸载，删除二进制文件即可： 1rm /usr/local/bin/docker-compose 6.3 编排Nginx+SpringBoot项目 创建目录 123mkdir ~/docker-composecd ~/docker-composevim docker-compose.yml 编写docker-compose.yml文件 1234567891011121314version: &#x27;3&#x27;services: nginx: image: nginx ports: - 80:80 links: - app volumes: - ./nginx/conf.d:/etc/nginx/conf.d app: image: app expose: - &quot;8080&quot; 创建.&#x2F;nginx&#x2F;conf.d目录下 123mkdir -p ./nginx/conf.dcd ./nginx/conf.dvim my.conf 编写my.conf文件： 1234567server &#123; listen 80; access_log off; location / &#123; proxy_pass http://app:8080; &#125;&#125; 在~&#x2F;docker-compose目录下使用docker-compose启动容器 1docker-compose up 测试 使用浏览器访问：主机地址:80/hello 7.Docker私有仓库Docker私有仓库： Docker官方的Docker hub是一个用于管理公共镜像的仓库，我们可以从上面拉取镜像到本地，也可以把我们自己的镜像推送上去。但是，有时候我们的服务器无法访问互联网，或者你不希望将自己的镜像放到公网当中，那么我们就需要搭建自己的私有仓库来存储和管理自己的镜像。 7.1 搭建私有仓库 拉取私有仓库镜像 1docker pull registry 启动私有仓库容器 1docker run -id --name=registry -p 5000:5000 registry 打开浏览器，输入地址https://私有仓库服务器ip:5000/v2/_catalog 如果看到&#123;&quot;repositories&quot;:[]&#125;表示私有仓库搭建成功 修改deamon.json 1vim /etc/docker/daemon.json 在deamon.json中添加一个key，让docker信任私有仓库地址，添加下面内容： 1&#123;&quot;insecure-registries&quot;: [&quot;私有仓库服务器ip:5000&quot;]&#125; 重启docker服务 1systemctl restart docker 启动registry容器 1docker start registry 7.2 上传镜像到私有仓库上传centos:7为例： 标记镜像为私有仓库的镜像 1docker tag centos:7 私有仓库地址ip:5000/centos:7 上传标记的镜像 1docker push 私有仓库地址ip:5000/centos:7 注意：要启动registry容器，才可以上传到私有仓库 1docker start registry 7.3 从私有仓库拉取镜像拉取centos:7为例： 1dokcer pull 私有仓库地址ip:5000/centos:7","categories":[{"name":"Java","slug":"Java","permalink":"http://example.com/categories/Java/"}],"tags":[{"name":"容器","slug":"容器","permalink":"http://example.com/tags/%E5%AE%B9%E5%99%A8/"},{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"}]},{"title":"数据结构的学习笔记","slug":"计算机4件套/数据结构","date":"2022-08-06T11:11:16.400Z","updated":"2022-09-27T14:16:26.838Z","comments":true,"path":"2022/08/06/计算机4件套/数据结构/","link":"","permalink":"http://example.com/2022/08/06/%E8%AE%A1%E7%AE%97%E6%9C%BA4%E4%BB%B6%E5%A5%97/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/","excerpt":"","text":"0.排序0.1 冒泡排序12345678910111213141516171819202122#include&lt;vector&gt;#include&lt;functional&gt;using namespace std;class Bubble&#123;public: template &lt;class T, class compare = less&lt;&gt;&gt; static void sort(T&amp; v) &#123; for (int i = v.size() - 1; i &gt; 0; i--) &#123; for (int j = 0; j &lt; i; j++) &#123; if (!compare()(v[j], v[j + 1])) &#123; swap(v[j], v[j + 1]); &#125; &#125; &#125; &#125;&#125;; 由于使用了类模板，导致测试时，导入头文件，例如：#include&quot;ArrayList.h&quot;，会报错。 所以改用导入源文件，例如：#include&quot;ArrayList.cpp&quot;，这样就能成功运行了！ 1.线性表1.1 顺序表(动态数组)Cpp实现，顺序表的基本实现 头文件ArrayList.h： 12345678910111213141516171819202122#pragma oncetemplate &lt;class T&gt;class ArrayList &#123; private: T* arrayList; // 存储元素的数组 int size; // 数组的大小 int capacity; // 数组的容量 void resize(int newCapacity); // 重新设置容量 public: ArrayList(int capacity); // 构造函数，初始化容量 ~ArrayList(); // 析构函数 void clear(); // 清空数组 bool isEmpty(); // 数组是否为空 int length(); // 获取数组的长度 T get(int pos); // 获取该位置的元素 void insert(T val); // 在数组末尾插入元素 void insert(int pos, T val); // 指定数组中的位置插入元素 T remove(int pos); // 删除该位置的元素并返回该元素 int indexOf(T val); // 根据元素值查找最小索引的位置，没有返回-1&#125;; 源文件ArrayList.cpp： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125#include&quot;ArrayList.h&quot;template&lt;class T&gt;ArrayList&lt;T&gt;::ArrayList()&#123; this-&gt;capacity = 5; this-&gt;arrayList = new T[this-&gt;capacity]; this-&gt;size = 0;&#125;template&lt;class T&gt;ArrayList&lt;T&gt;::ArrayList(int capacity)&#123; this-&gt;capacity = capacity; this-&gt;arrayList = new T[this-&gt;capacity]; this-&gt;size = 0;&#125;template &lt;class T&gt;ArrayList&lt;T&gt;::~ArrayList() &#123; if (this-&gt;arrayList != nullptr)&#123; delete[] this-&gt;arrayList; this-&gt;arrayList = nullptr; &#125;&#125;template&lt;class T&gt;void ArrayList&lt;T&gt;::clear()&#123; this-&gt;size = 0;&#125;template&lt;class T&gt;bool ArrayList&lt;T&gt;::isEmpty()&#123; return this-&gt;arrayList == nullptr;&#125;template&lt;class T&gt;int ArrayList&lt;T&gt;::length()&#123; return this-&gt;size;&#125;template&lt;class T&gt;T ArrayList&lt;T&gt;::get(int pos)&#123; if (pos &lt;0 || pos &gt;= this-&gt;size) return T(); return this-&gt;arrayList[pos];&#125;template&lt;class T&gt;void ArrayList&lt;T&gt;::insert(T val)&#123; if (this-&gt;size == this-&gt;capacity) &#123; this-&gt;resize(this-&gt;capacity * 2); &#125; this-&gt;arrayList[this-&gt;size] = val; this-&gt;size++;&#125;template&lt;class T&gt;void ArrayList&lt;T&gt;::insert(int pos, T val)&#123; if (this-&gt;size == this-&gt;capacity) &#123; this-&gt;resize(this-&gt;capacity * 2); &#125; for (int i = this-&gt;size - 1; i &gt;= pos ; i--) &#123; this-&gt;arrayList[i + 1] = this-&gt;arrayList[i]; &#125; this-&gt;arrayList[pos] = val; this-&gt;size++;&#125;template&lt;class T&gt;T ArrayList&lt;T&gt;::remove(int pos)&#123; if (pos &lt;0 || pos &gt;= this-&gt;size) return T(); T val = this-&gt;arrayList[pos]; for (int i = pos; i &lt; this-&gt;size; i++) &#123; this-&gt;arrayList[i] = this-&gt;arrayList[i + 1]; &#125; this-&gt;size--; if (this-&gt;size &lt; this-&gt;capacity / 4) &#123; this-&gt;resize(this-&gt;capacity / 2); &#125; return val;&#125;template&lt;class T&gt;int ArrayList&lt;T&gt;::indexOf(T val)&#123; for (int i = 0; i &lt; this-&gt;size; i++) &#123; if (this-&gt;arrayList[i] == val) &#123; return val; &#125; &#125; return -1;&#125;template&lt;class T&gt;void ArrayList&lt;T&gt;::resize(int newCapacity)&#123; this-&gt;capacity = newCapacity; T* temp = new T[this-&gt;capacity]; for (int i = 0; i &lt; this-&gt;size; i++) &#123; temp[i] = this-&gt;arrayList[i]; &#125; delete[] this-&gt;arrayList; this-&gt;arrayList = temp;&#125; 部分测试main.cpp： 12345678910111213141516171819202122#include&quot;ArrayList.cpp&quot;#include&lt;iostream&gt;using namespace std;void main() &#123; ArrayList a(3); for (int i = 0; i &lt; 6; i++) &#123; a.insert(i); &#125; cout &lt;&lt; a.isEmpty() &lt;&lt; endl; cout &lt;&lt; a.remove(1) &lt;&lt; endl; cout &lt;&lt; a.indexOf(1) &lt;&lt; endl; for (int i = 0; i &lt; a.length(); i++) &#123; cout &lt;&lt; a.get(i) &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl;&#125; 1.2 单向链表头文件： 123456789101112131415161718192021222324252627282930313233343536373839#pragma oncetemplate&lt;class T&gt;class LinkedList&#123;private: class Node &#123; public: T data; Node* next; Node() &#123;&#125; Node(Node* next) &#123; this-&gt;next = next; &#125; Node(T data, Node* next) &#123; this-&gt;data = data; this-&gt;next = next; &#125; &#125;; Node* head; int size; Node* reverse(Node* curr); // 当前节点实现反转public: LinkedList(); ~LinkedList(); void clear(); bool isEmpty(); int length(); T get(int pos); void insert(T data); void insert(int pos, T data); T remove(int pos); int indexOf(T data); void reverse(); T getMid();&#125;; 源文件： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175#include&quot;LinkedList.h&quot;#include&lt;iostream&gt;using namespace std;template&lt;class T&gt;typename LinkedList&lt;T&gt;::Node* LinkedList&lt;T&gt;::reverse(Node* curr)&#123; if (curr-&gt;next == nullptr) &#123; this-&gt;head-&gt;next = curr; return curr; &#125; Node* p = reverse(curr-&gt;next); p-&gt;next = curr; curr-&gt;next = nullptr; return curr;&#125;template&lt;class T&gt;LinkedList&lt;T&gt;::LinkedList()&#123; this-&gt;head = new Node(nullptr); this-&gt;size = 0;&#125;template&lt;class T&gt;LinkedList&lt;T&gt;::~LinkedList()&#123; if (this-&gt;head == nullptr) &#123; return; &#125; this-&gt;clear(); delete this-&gt;head; this-&gt;head = nullptr;&#125;template&lt;class T&gt;void LinkedList&lt;T&gt;::clear()&#123; if (this-&gt;head == nullptr) &#123; return; &#125; Node* p = this-&gt;head-&gt;next; while (p != nullptr) &#123; Node* newNode = p-&gt;next; delete p; p = newNode; &#125; this-&gt;head-&gt;next = nullptr; this-&gt;size = 0;&#125;template&lt;class T&gt;bool LinkedList&lt;T&gt;::isEmpty()&#123; return this-&gt;size == 0;&#125;template&lt;class T&gt;int LinkedList&lt;T&gt;::length()&#123; return this-&gt;size;&#125;template&lt;class T&gt;T LinkedList&lt;T&gt;::get(int pos)&#123; if (pos &lt; 0 || pos &gt;= this-&gt;size) return T(); Node* p = this-&gt;head-&gt;next; for (int i = 0; i &lt; pos; i++) &#123; p = p-&gt;next; &#125; return p-&gt;data;&#125;template&lt;class T&gt;void LinkedList&lt;T&gt;::insert(T data)&#123; Node* p = this-&gt;head; while (p-&gt;next != nullptr) &#123; p = p-&gt;next; &#125; Node* newNode = new Node(data, nullptr); p-&gt;next = newNode; this-&gt;size++;&#125;template&lt;class T&gt;void LinkedList&lt;T&gt;::insert(int pos, T data)&#123; Node* p = this-&gt;head; for (int i = 0; i &lt; pos; i++) &#123; p = p-&gt;next; &#125; Node* newNode = new Node(data, p-&gt;next); p-&gt;next = newNode; this-&gt;size++;&#125;template&lt;class T&gt;T LinkedList&lt;T&gt;::remove(int pos)&#123; if (pos &lt; 0 || pos &gt;= this-&gt;size) return T(); Node* p = this-&gt;head; for (int i = 0; i &lt; pos; i++) &#123; p = p-&gt;next; &#125; Node* e = p-&gt;next; p-&gt;next = e-&gt;next; T res = e-&gt;data; delete e; e = nullptr; this-&gt;size--; return res;&#125;template&lt;class T&gt;int LinkedList&lt;T&gt;::indexOf(T data)&#123; Node* p = this-&gt;head-&gt;next; int pos = 0; while (p != nullptr) &#123; if (p-&gt;data == data) &#123; return pos; &#125; p = p-&gt;next; pos++; &#125; return -1;&#125;template&lt;class T&gt;void LinkedList&lt;T&gt;::reverse()&#123; if (this-&gt;size &lt; 2) &#123; return; &#125; reverse(this-&gt;head-&gt;next);&#125;template&lt;class T&gt;T LinkedList&lt;T&gt;::getMid()&#123; if (this-&gt;head-&gt;next == nullptr) return T(); Node* fast = this-&gt;head-&gt;next; Node* slow = this-&gt;head-&gt;next; while (fast != nullptr &amp;&amp; fast-&gt;next != nullptr) &#123; fast = fast-&gt;next-&gt;next; slow = slow-&gt;next; &#125; return slow-&gt;data;&#125; 测试： 123456789101112131415161718192021222324#include&quot;LinkedList.cpp&quot;#include&lt;iostream&gt;using namespace std;void main()&#123; LinkedList&lt;int&gt; list; for (int i = 0; i &lt; 6; i++) &#123; list.insert(i); &#125; list.insert(2, 100); cout &lt;&lt; list.isEmpty() &lt;&lt; endl; cout &lt;&lt; list.remove(5) &lt;&lt; endl; cout &lt;&lt; list.indexOf(5) &lt;&lt; endl; //list.clear(); for (int i = 0; i &lt; list.length(); i++) &#123; cout &lt;&lt; list.get(i) &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl;&#125; 1.3 双向链表头文件： 12345678910111213141516171819202122232425262728293031323334353637383940414243#pragma oncetemplate&lt;class T&gt;class DoubleLinkedList&#123;private: class Node &#123; public: T data; Node* pre; Node* next; Node() &#123;&#125; Node(Node* pre, Node* next) &#123; this-&gt;pre = pre; this-&gt;next = next; &#125; Node(Node* pre, T data, Node* next) &#123; this-&gt;pre = pre; this-&gt;data = data; this-&gt;next = next; &#125; &#125;; Node* head; Node* last; int size; Node* getNode(int pos);public: DoubleLinkedList(); ~DoubleLinkedList(); void clear(); bool isEmpty(); int length(); T get(int pos); void insert(T data); void insert(int pos, T data); T remove(int pos); int indexOf(T data); T getFirst(); T getLast();&#125;; 源文件： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161#include&quot;DoubleLinkedList.h&quot;template&lt;class T&gt;typename DoubleLinkedList&lt;T&gt;::Node* DoubleLinkedList&lt;T&gt;::getNode(int pos)&#123; Node* p; //从前往后遍历 if (pos &lt; int(this-&gt;size / 2)) &#123; p = this-&gt;head-&gt;next; for (int i = 0; i &lt; pos; i++) &#123; p = p-&gt;next; &#125; &#125; //从后往前遍历 else &#123; p = this-&gt;last; for (int i = 0; i &lt; pos; i++) &#123; p = p-&gt;pre; &#125; &#125; return p;&#125;template&lt;class T&gt;DoubleLinkedList&lt;T&gt;::DoubleLinkedList()&#123; this-&gt;head = new Node(nullptr, nullptr); this-&gt;last = this-&gt;head; this-&gt;size = 0;&#125;template&lt;class T&gt;DoubleLinkedList&lt;T&gt;::~DoubleLinkedList()&#123; if (this-&gt;head == nullptr) &#123; return; &#125; this-&gt;clear(); delete this-&gt;head; this-&gt;head = nullptr; this-&gt;last = nullptr;&#125;template&lt;class T&gt;void DoubleLinkedList&lt;T&gt;::clear()&#123; if (this-&gt;head == nullptr) &#123; return; &#125; Node* p = this-&gt;head-&gt;next; while (p != nullptr) &#123; Node* newNode = p-&gt;next; delete p; p = newNode; &#125; this-&gt;head-&gt;next = nullptr; this-&gt;last = this-&gt;head; this-&gt;size = 0;&#125;template&lt;class T&gt;bool DoubleLinkedList&lt;T&gt;::isEmpty()&#123; return this-&gt;size == 0;&#125;template&lt;class T&gt;int DoubleLinkedList&lt;T&gt;::length()&#123; return this-&gt;size;&#125;template&lt;class T&gt;T DoubleLinkedList&lt;T&gt;::get(int pos)&#123; if (pos &lt; 0 || pos &gt;= this-&gt;size) return T(); Node* p = this-&gt;getNode(pos); return p-&gt;data;&#125;template&lt;class T&gt;void DoubleLinkedList&lt;T&gt;::insert(T data)&#123; Node* newNode = new Node(this-&gt;last, data, nullptr); this-&gt;last-&gt;next = newNode; this-&gt;last = newNode; this-&gt;size++;&#125;template&lt;class T&gt;void DoubleLinkedList&lt;T&gt;::insert(int pos, T data)&#123; Node* p = this-&gt;getNode(pos); Node* newNode = new Node(p, data, p-&gt;next); p-&gt;next-&gt;pre = newNode; p-&gt;next = newNode; this-&gt;size++;&#125;template&lt;class T&gt;T DoubleLinkedList&lt;T&gt;::remove(int pos)&#123; if (pos &lt; 0 || pos &gt;= this-&gt;size) return T(); Node* p = this-&gt;getNode(pos); T res = p-&gt;data; p-&gt;pre-&gt;next = p-&gt;next; p-&gt;next-&gt;pre = p-&gt;pre; delete p; p = nullptr; this-&gt;size--; return res;&#125;template&lt;class T&gt;int DoubleLinkedList&lt;T&gt;::indexOf(T data)&#123; Node* p = this-&gt;head-&gt;next; int pos = 0; while (p != nullptr) &#123; if (p-&gt;data == data) &#123; return pos; &#125; p = p-&gt;next; &#125; return -1;&#125;template&lt;class T&gt;T DoubleLinkedList&lt;T&gt;::getFirst()&#123; if (this-&gt;isEmpty()) return T(); return this-&gt;head-&gt;next-&gt;data;&#125;template&lt;class T&gt;T DoubleLinkedList&lt;T&gt;::getLast()&#123; if (this-&gt;isEmpty()) return T(); return this-&gt;last-&gt;data;&#125; 1.4 栈(链栈)头文件： 1234567891011121314151617181920212223242526272829303132#pragma oncetemplate&lt;class T&gt;class Stack&#123;private: class Node &#123; public: T data; Node* next; Node() &#123;&#125; Node(Node* next) &#123; this-&gt;next = next; &#125; Node(T data, Node* next) &#123; this-&gt;data = data; this-&gt;next = next; &#125; &#125;; Node* head; int size;public: Stack(); ~Stack(); bool isEmpty(); int getSize(); T pop(); void push(T data);&#125;; 源文件： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include &quot;Stack.h&quot;template&lt;class T&gt;Stack&lt;T&gt;::Stack()&#123; this-&gt;head = new Node(nullptr); this-&gt;size = 0;&#125;template&lt;class T&gt;Stack&lt;T&gt;::~Stack()&#123; if (this-&gt;head == nullptr) &#123; return; &#125; Node* p = this-&gt;head-&gt;next; while (p != nullptr) &#123; Node* newNode = p-&gt;next; delete p; p = newNode; &#125; delete this-&gt;head; this-&gt;head = nullptr;&#125;template&lt;class T&gt;bool Stack&lt;T&gt;::isEmpty()&#123; return this-&gt;size == 0;&#125;template&lt;class T&gt;int Stack&lt;T&gt;::getSize()&#123; return this-&gt;size;&#125;template&lt;class T&gt;T Stack&lt;T&gt;::pop()&#123; if (this-&gt;size == 0) return T(); Node* p = this-&gt;head-&gt;next; T data = p-&gt;data; this-&gt;head-&gt;next = p-&gt;next; this-&gt;size--; return data;&#125;template&lt;class T&gt;void Stack&lt;T&gt;::push(T data)&#123; Node* p = new Node(data, this-&gt;head-&gt;next); this-&gt;head-&gt;next = p; this-&gt;size++;&#125; 1.5 队列(链队)头文件： 1234567891011121314151617181920212223242526272829303132#pragma oncetemplate&lt;class T&gt;class Queue&#123;private: class Node &#123; public: T data; Node* next; Node() &#123;&#125; Node(Node* next) &#123; this-&gt;next = next; &#125; Node(T data, Node* next) &#123; this-&gt;data = data; this-&gt;next = next; &#125; &#125;; Node* head; Node* last; int size;public: Queue(); ~Queue(); bool isEmpty(); T dequeue(); //出队 void enqueue(T data); //入队&#125;; 源文件： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &quot;Queue.h&quot;template&lt;class T&gt;Queue&lt;T&gt;::Queue()&#123; this-&gt;head = new Node(nullptr); this-&gt;last = this-&gt;head; this-&gt;size = 0;&#125;template&lt;class T&gt;Queue&lt;T&gt;::~Queue()&#123; if (this-&gt;head == nullptr) &#123; return; &#125; Node* p = this-&gt;head-&gt;next; while (p != nullptr) &#123; Node* newNode = p-&gt;next; delete p; p = newNode; &#125; delete this-&gt;head; this-&gt;head = nullptr; this-&gt;last = nullptr;&#125;template&lt;class T&gt;bool Queue&lt;T&gt;::isEmpty()&#123; return this-&gt;size == 0;&#125;template&lt;class T&gt;T Queue&lt;T&gt;::dequeue()&#123; if (this-&gt;size == 0) return T(); Node* p = this-&gt;head-&gt;next; T data = p-&gt;data; this-&gt;head-&gt;next = p-&gt;next; delete p; this-&gt;size--; if (this-&gt;isEmpty()) &#123; this-&gt;last = this-&gt;head; &#125; return data;&#125;template&lt;class T&gt;void Queue&lt;T&gt;::enqueue(T data)&#123; Node* newNode = new Node(data, nullptr); this-&gt;last-&gt;next = newNode; this-&gt;last = newNode; this-&gt;size++;&#125; 2.符号表2.1 符号表(map)头文件： 12345678910111213141516171819202122232425262728293031323334#pragma oncetemplate&lt;class K, class V&gt;class Map&#123;private: class Node &#123; public: K key; V value; Node* next; Node() &#123;&#125; Node(Node* next) &#123; this-&gt;next = next; &#125; Node(K key, V value, Node* next) &#123; this-&gt;key = key; this-&gt;value = value; this-&gt;next = next; &#125; &#125;; Node* head; int size;public: Map(); ~Map(); V get(K key); void put(K key, V value); bool remove(K key); int getSize();&#125;; 源文件： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include&quot;Map.h&quot;template&lt;class K, class V&gt;Map&lt;K, V&gt;::Map()&#123; this-&gt;head = new Node(nullptr); this-&gt;size = 0;&#125;template&lt;class K, class V&gt;Map&lt;K, V&gt;::~Map()&#123; if (this-&gt;head == nullptr) &#123; return; &#125; Node* p = this-&gt;head-&gt;next; while (p != nullptr) &#123; Node* newNode = p-&gt;next; delete p; p = newNode; &#125; delete this-&gt;head; this-&gt;head = nullptr;&#125;template&lt;class K, class V&gt;V Map&lt;K, V&gt;::get(K key)&#123; Node* p = this-&gt;head-&gt;next; while (p != nullptr) &#123; if (p-&gt;key == key) &#123; return p-&gt;value; &#125; p = p-&gt;next; &#125; return V();&#125;template&lt;class K, class V&gt;void Map&lt;K, V&gt;::put(K key, V value)&#123; Node* p = this-&gt;head; while (p-&gt;next != nullptr) &#123; p = p-&gt;next; if (p-&gt;key == key) &#123; p-&gt;value = value; return; &#125; &#125; Node* newNode = new Node(key, value, nullptr); p-&gt;next = newNode; this-&gt;size++;&#125;template&lt;class K, class V&gt;bool Map&lt;K, V&gt;::remove(K key)&#123; Node* p = this-&gt;head; while (p-&gt;next != nullptr) &#123; if (p-&gt;next-&gt;key == key) &#123; Node* e = p-&gt;next; p-&gt;next = e-&gt;next; delete e; this-&gt;size--; return true; &#125; p = p-&gt;next; &#125; return false;&#125;template&lt;class K, class V&gt;int Map&lt;K, V&gt;::getSize()&#123; return this-&gt;size;&#125; 2.2 有序符号表头文件： 123456789101112131415161718192021222324252627282930313233343536#pragma once#include&lt;functional&gt;using namespace std;template&lt;class K, class V, class compare = less&lt;K&gt;&gt;class OrderMap&#123;private: class Node &#123; public: K key; V value; Node* next; Node() &#123;&#125; Node(Node* next) &#123; this-&gt;next = next; &#125; Node(K key, V value, Node* next) &#123; this-&gt;key = key; this-&gt;value = value; this-&gt;next = next; &#125; &#125;; Node* head; int size;public: OrderMap(); ~OrderMap(); V get(K key); void put(K key, V value); bool remove(K key); int getSize();&#125;; 源文件： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394#include &quot;OrderMap.h&quot;template&lt;class K, class V, class compare&gt;OrderMap&lt;K, V, compare&gt;::OrderMap()&#123; this-&gt;head = new Node(nullptr); this-&gt;size = 0;&#125;template&lt;class K, class V, class compare&gt;OrderMap&lt;K, V, compare&gt;::~OrderMap()&#123; if (this-&gt;head == nullptr) &#123; return; &#125; Node* p = this-&gt;head-&gt;next; while (p != nullptr) &#123; Node* newNode = p-&gt;next; delete p; p = newNode; &#125; delete this-&gt;head; this-&gt;head = nullptr;&#125;template&lt;class K, class V, class compare&gt;V OrderMap&lt;K, V, compare&gt;::get(K key)&#123; Node* p = this-&gt;head-&gt;next; while (p != nullptr) &#123; if (p-&gt;key == key) &#123; return p-&gt;value; &#125; p = p-&gt;next; &#125; return V();&#125;template&lt;class K, class V, class compare&gt;void OrderMap&lt;K, V, compare&gt;::put(K key, V value)&#123; Node* p = this-&gt;head-&gt;next; Node* pre = this-&gt;head; while (p != nullptr &amp;&amp; compare()(p-&gt;key, key)) &#123; p = p-&gt;next; pre = pre-&gt;next; &#125; if (p == nullptr) &#123; Node* newNode = new Node(key, value, nullptr); pre-&gt;next = newNode; this-&gt;size++; return; &#125; if (p-&gt;key == key) &#123; p-&gt;value = value; return; &#125; Node* newNode = new Node(key, value, p); pre-&gt;next = newNode; this-&gt;size++;&#125;template&lt;class K, class V, class compare&gt;bool OrderMap&lt;K, V, compare&gt;::remove(K key)&#123; Node* p = this-&gt;head; while (p-&gt;next != nullptr) &#123; if (p-&gt;next-&gt;key == key) &#123; Node* e = p-&gt;next; p-&gt;next = e-&gt;next; delete e; this-&gt;size--; return true; &#125; p = p-&gt;next; &#125; return false;&#125;template&lt;class K, class V, class compare&gt;int OrderMap&lt;K, V, compare&gt;::getSize()&#123; return this-&gt;size;&#125; 3.树3.1 二叉查找树头文件： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#pragma once#include&lt;vector&gt;#include&lt;queue&gt;using namespace std;template&lt;class K, class V&gt;class BinaryTree&#123;private: class Node &#123; public: K key; V value; Node* left; Node* right; Node() &#123;&#125; Node(K key, V value, Node* left, Node* right) &#123; this-&gt;key = key; this-&gt;value = value; this-&gt;left = left; this-&gt;right = right; &#125; &#125;; Node* root; int size; Node* put(Node* node, K key, V value); V get(Node* node, K key); Node* remove(Node* node, K key); void destroy(Node* node); Node* min(Node* node); Node* max(Node* node); int depth(Node* node); void ergodic(Node* node, vector&lt;K&gt;&amp; keys, int select); void layerErgodic(Node* node, vector&lt;K&gt;&amp; keys);public: BinaryTree(); ~BinaryTree(); void put(K key, V value); V get(K key); void remove(K key); int getSize(); K getMin(); K getMax(); int getDepth(); vector&lt;K&gt; ergodic(int select); //0 层序 先序1 中序2 后序3&#125;; 源文件： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234#include &quot;BinaryTree.h&quot;template&lt;class K, class V&gt;typename BinaryTree&lt;K, V&gt;::Node* BinaryTree&lt;K, V&gt;::put(Node* node, K key, V value)&#123; if (node == nullptr) &#123; this-&gt;size++; return new Node(key, value, nullptr, nullptr); &#125; if (node-&gt;key &gt; key) node-&gt;left = this-&gt;put(node-&gt;left, key, value); else if (node-&gt;key &lt; key) node-&gt;right = this-&gt;put(node-&gt;right, key, value); else node-&gt;value = value; return node;&#125;template&lt;class K, class V&gt;V BinaryTree&lt;K, V&gt;::get(Node* node, K key)&#123; if (node == nullptr) return V(); if (node-&gt;key &gt; key) return this-&gt;get(node-&gt;left, key); else if (node-&gt;key &lt; key) return this-&gt;get(node-&gt;right, key); else return node-&gt;value; return V();&#125;template&lt;class K, class V&gt;typename BinaryTree&lt;K, V&gt;::Node* BinaryTree&lt;K, V&gt;::remove(Node* node, K key)&#123; //未找到key值 if (node == nullptr) return nullptr; if (node-&gt;key &gt; key) node-&gt;left = this-&gt;remove(node-&gt;left, key); else if (node-&gt;key &lt; key) node-&gt;right = this-&gt;remove(node-&gt;right, key); // node-&gt;key == key情况 else &#123; //左子树为空的情况 if (node-&gt;left == nullptr) &#123; Node* temp = node-&gt;right; delete node; node = temp; this-&gt;size--; return node; &#125; //右子树为空的情况 if (node-&gt;right == nullptr) &#123; Node* temp = node-&gt;left; delete node; node = temp; this-&gt;size--; return node; &#125; //左右字树都不为空的情况 Node* nodeLeft = node-&gt;left; //要删除的节点的左子树 Node* nodeRight = node-&gt;right; //要删除的节点的左子树 //循环，找到右子树的左节点的底节点e以及e的父节点p Node* p = node; //初始化父节点为node Node* e = node-&gt;right; //初始化底节点e为node的右节点 while (e-&gt;left != nullptr) &#123; p = e; e = e-&gt;left; &#125; // 如果node的右节点就是底节点e了 if (p == node) &#123; delete node; //将node节点销毁 node = e; //换成e节点 node-&gt;left = nodeLeft; //e节点(就是现在的node)的左子树为nodeLeft this-&gt;size--; //size-1 &#125; // 获取底层节点e，将e的父节点p左子树置空 else &#123; p-&gt;left = nullptr; //将父节点置空 delete node; //将node节点销毁 node = e; //换成e节点 node-&gt;left = nodeLeft; //e节点(就是现在的node)的左子树为nodeLeft //e节点遍历右子树到底层节点temp Node* temp = node; while (temp-&gt;right != nullptr) &#123; temp = temp-&gt;right; &#125; temp-&gt;right = nodeRight; //temp的右子树为nodeRight this-&gt;size--; //size-1 &#125; &#125; return node;&#125;template&lt;class K, class V&gt;void BinaryTree&lt;K, V&gt;::destroy(Node* node)&#123; if (node == nullptr) return; this-&gt;destroy(node-&gt;left); this-&gt;destroy(node-&gt;right); delete node;&#125;template&lt;class K, class V&gt;typename BinaryTree&lt;K, V&gt;::Node* BinaryTree&lt;K, V&gt;::min(Node* node)&#123; if (node-&gt;left == nullptr) return node; return this-&gt;min(node-&gt;left);&#125;template&lt;class K, class V&gt;typename BinaryTree&lt;K, V&gt;::Node* BinaryTree&lt;K, V&gt;::max(Node* node)&#123; if (node-&gt;right == nullptr) return node; return this-&gt;max(node-&gt;right);&#125;template&lt;class K, class V&gt;int BinaryTree&lt;K, V&gt;::depth(Node* node)&#123; if (node == nullptr) return 0; int left = this-&gt;depth(node-&gt;left) + 1; int right = this-&gt;depth(node-&gt;right) + 1; if (left &gt; right) return left; return right;&#125;template&lt;class K, class V&gt;void BinaryTree&lt;K, V&gt;::ergodic(Node* node, vector&lt;K&gt;&amp; keys, int select)&#123; if (node == nullptr) return; if (select == 1) keys.emplace_back(node-&gt;key); //先序的选择 this-&gt;ergodic(node-&gt;left, keys, select); if (select == 2) keys.emplace_back(node-&gt;key); //中序的选择 this-&gt;ergodic(node-&gt;right, keys, select); if (select == 3) keys.emplace_back(node-&gt;key); //后序的选择&#125;template&lt;class K, class V&gt;void BinaryTree&lt;K, V&gt;::layerErgodic(Node* node, vector&lt;K&gt;&amp; keys)&#123; queue&lt;Node*&gt; q; q.emplace(node); while (!q.empty()) &#123; Node* temp = q.front(); keys.emplace_back(temp-&gt;key); q.pop(); if (temp-&gt;left != nullptr) q.emplace(temp-&gt;left); if (temp-&gt;right != nullptr) q.emplace(temp-&gt;right); &#125;&#125;template&lt;class K, class V&gt;BinaryTree&lt;K, V&gt;::BinaryTree()&#123; this-&gt;root = nullptr; this-&gt;size = 0;&#125;template&lt;class K, class V&gt;BinaryTree&lt;K, V&gt;::~BinaryTree()&#123; this-&gt;destroy(this-&gt;root);&#125;template&lt;class K, class V&gt;void BinaryTree&lt;K, V&gt;::put(K key, V value)&#123; this-&gt;root = this-&gt;put(this-&gt;root, key, value);&#125;template&lt;class K, class V&gt;V BinaryTree&lt;K, V&gt;::get(K key)&#123; return this-&gt;get(this-&gt;root, key);&#125;template&lt;class K, class V&gt;void BinaryTree&lt;K, V&gt;::remove(K key)&#123; this-&gt;root = this-&gt;remove(this-&gt;root, key);&#125;template&lt;class K, class V&gt;int BinaryTree&lt;K, V&gt;::getSize()&#123; return this-&gt;size;&#125;template&lt;class K, class V&gt;K BinaryTree&lt;K, V&gt;::getMin()&#123; return this-&gt;min(this-&gt;root)-&gt;key;&#125;template&lt;class K, class V&gt;K BinaryTree&lt;K, V&gt;::getMax()&#123; return this-&gt;max(this-&gt;root)-&gt;key;&#125;template&lt;class K, class V&gt;int BinaryTree&lt;K, V&gt;::getDepth()&#123; return this-&gt;depth(this-&gt;root);&#125;template&lt;class K, class V&gt;vector&lt;K&gt; BinaryTree&lt;K, V&gt;::ergodic(int select)&#123; vector&lt;K&gt; keys; if (select == 0) this-&gt;layerErgodic(this-&gt;root, keys); //0 层序 this-&gt;ergodic(this-&gt;root, keys, select); return keys;&#125; 3.2 红黑树红黑树含有黑红链接满足下列条件： 红链接均为左链接 没有任何一个结点同时和两条红链接相连 该树是完美黑色平衡，即任意空链接到根节点的路径上的黑链接数量相同 头文件： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#pragma once#include&lt;functional&gt;using namespace std;//默认为less&lt;&gt;为左小右大，可修改为greater&lt;&gt;左大右小template&lt;class K, class V, class compare = less&lt;K&gt;&gt;class RedBlackTree&#123;private: class Node &#123; public: K key; V value; Node* left; Node* right; bool color; Node() &#123;&#125; Node(K key, V value, Node* left, Node* right, bool color) &#123; this-&gt;key = key; this-&gt;value = value; this-&gt;left = left; this-&gt;right = right; this-&gt;color = color; &#125; &#125;; Node* root; int size; static const bool RED = true; static const bool BLACK = false; bool isRed(Node* node); Node* rotateLeft(Node* node); Node* rotateRight(Node* node); void flipColors(Node* node); //颜色反转 Node* put(Node* node, K key, V value); V get(Node* node, K key); void destroy(Node* node);public: RedBlackTree(); ~RedBlackTree(); void put(K key, V value); V get(K key); int getSize();&#125;; 源文件： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116#include &quot;RedBlackTree.h&quot;template&lt;class K, class V, class compare&gt;bool RedBlackTree&lt;K, V, compare&gt;::isRed(Node* node)&#123; if (node == nullptr) return false; return node-&gt;color == this-&gt;RED;&#125;template&lt;class K, class V, class compare&gt;typename RedBlackTree&lt;K, V, compare&gt;::Node* RedBlackTree&lt;K, V, compare&gt;::rotateLeft(Node* node)&#123; Node* r = node-&gt;right; //获取node的右节点r node-&gt;right = r-&gt;left; //将node的右节点指向之前的右节点r的左节点 r-&gt;left = node; //将右节点r的左节点指向node r-&gt;color = node-&gt;color; node-&gt;color = this-&gt;RED; return r;&#125;template&lt;class K, class V, class compare&gt;typename RedBlackTree&lt;K, V, compare&gt;::Node* RedBlackTree&lt;K, V, compare&gt;::rotateRight(Node* node)&#123; Node* l = node-&gt;left; node-&gt;left = l-&gt;right; l-&gt;right = node; l-&gt;color = node-&gt;color; node-&gt;color = this-&gt;RED; return l;&#125;template&lt;class K, class V, class compare&gt;void RedBlackTree&lt;K, V, compare&gt;::flipColors(Node* node)&#123; node-&gt;color = this-&gt;RED; node-&gt;left-&gt;color = this-&gt;BLACK; node-&gt;right-&gt;color = this-&gt;BLACK;&#125;template&lt;class K, class V, class compare&gt;typename RedBlackTree&lt;K, V, compare&gt;::Node* RedBlackTree&lt;K, V, compare&gt;::put(Node* node, K key, V value)&#123; if (node == nullptr) &#123; this-&gt;size++; Node* newNode = new Node(key, value, nullptr, nullptr, RED); return newNode; &#125; if (compare()(key, node-&gt;key)) node-&gt;left = this-&gt;put(node-&gt;left, key, value); else if (compare()(node-&gt;key, key)) node-&gt;right = this-&gt;put(node-&gt;right, key, value); else node-&gt;value = value; //左旋 if (isRed(node-&gt;right) &amp;&amp; !isRed(node-&gt;left)) node = this-&gt;rotateLeft(node); //右旋 if (isRed(node-&gt;left) &amp;&amp; isRed(node-&gt;left-&gt;left)) node = this-&gt;rotateRight(node); //颜色反转 if (isRed(node-&gt;left) &amp;&amp; isRed(node-&gt;right)) this-&gt;flipColors(node); return node;&#125;template&lt;class K, class V, class compare&gt;V RedBlackTree&lt;K, V, compare&gt;::get(Node* node, K key)&#123; if (node == nullptr) return V(); if (compare()(key, node-&gt;key)) return this-&gt;get(node-&gt;left, key); else if (compare()(node-&gt;key, key)) return this-&gt;get(node-&gt;right, key); else return node-&gt;value; return V();&#125;template&lt;class K, class V, class compare&gt;void RedBlackTree&lt;K, V, compare&gt;::destroy(Node* node)&#123; if (node == nullptr) return; this-&gt;destroy(node-&gt;left); this-&gt;destroy(node-&gt;right); delete node;&#125;template&lt;class K, class V, class compare&gt;RedBlackTree&lt;K, V, compare&gt;::RedBlackTree()&#123; this-&gt;size = 0; this-&gt;root = nullptr;&#125;template&lt;class K, class V, class compare&gt;RedBlackTree&lt;K, V, compare&gt;::~RedBlackTree()&#123; this-&gt;destroy(this-&gt;root);&#125;template&lt;class K, class V, class compare&gt;void RedBlackTree&lt;K, V, compare&gt;::put(K key, V value)&#123; this-&gt;root = this-&gt;put(this-&gt;root, key, value); this-&gt;root-&gt;color = this-&gt;BLACK;&#125;template&lt;class K, class V, class compare&gt;V RedBlackTree&lt;K, V, compare&gt;::get(K key)&#123; return this-&gt;get(this-&gt;root, key);&#125;template&lt;class K, class V, class compare&gt; int RedBlackTree&lt;K, V, compare&gt;::getSize()&#123; return this-&gt;size;&#125; 3.3 并查集头文件： 12345678910111213141516#pragma onceclass UF_Tree_Weighted&#123;private: int* array; int* size; int count;public: UF_Tree_Weighted(int capacity); ~UF_Tree_Weighted(); int getCount(); bool connected(int p, int q); int find(int p); void merge(int p, int q);&#125;; 源文件： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &quot;UF_Tree_Weighted.h&quot;UF_Tree_Weighted::UF_Tree_Weighted(int capacity)&#123; this-&gt;array = new int[capacity]; this-&gt;size = new int[capacity]; this-&gt;count = capacity; for (int i = 0; i &lt; this-&gt;count; i++) &#123; this-&gt;array[i] = i; this-&gt;size[i] = 1; &#125;&#125;UF_Tree_Weighted::~UF_Tree_Weighted()&#123; if (this-&gt;array != nullptr) &#123; delete[] array; &#125;&#125;int UF_Tree_Weighted::getCount()&#123; return this-&gt;count;&#125;bool UF_Tree_Weighted::connected(int p, int q)&#123; return find(p) == find(q);&#125;int UF_Tree_Weighted::find(int p)&#123; while (true) &#123; if (this-&gt;array[p] == p) return p; p = this-&gt;array[p]; &#125;&#125;void UF_Tree_Weighted::merge(int p, int q)&#123; int pRoot = this-&gt;find(p); int qRoot = this-&gt;find(q); if (pRoot == qRoot) return; //判断哪个结点长，哪个就当根节点 if (this-&gt;size[pRoot] &lt; this-&gt;size[qRoot]) &#123; //让p的根节点指向q的根节点 this-&gt;array[pRoot] = qRoot; this-&gt;size[qRoot] += this-&gt;size[pRoot]; &#125; else &#123; this-&gt;array[qRoot] = pRoot; this-&gt;size[pRoot] += this-&gt;size[qRoot]; &#125; this-&gt;count--;&#125; 4.堆4.1 堆(完全二叉树)堆是用数组完成数据元素的存储(0位置被废止了) 如果一个节点的位置为k，那么它的父节点的位置为k/2，而它的子节点的位置为2k和2k+1 并且每个节点都要大于它的子节点之和，但是这两个子节点的顺序位置没有要求 头文件： 123456789101112131415161718192021222324#pragma once#include&lt;functional&gt;using namespace std;//默认less&lt;&gt;为小堆顶，使用可修改为greater&lt;&gt;为大堆顶template&lt;class T, class compare = less&lt;T&gt;&gt;class Heap&#123;private: T* arrayList; int size; int capacity; bool less(int i, int j); //判断i位置的元素是否小于j位置的元素 void exch(int i, int j); //交换i位置与j位置的元素 void swim(int pos); //使用上浮算法，使pos位置的元素能处于正确位置 void sink(int pos); //使用下浮算法，使pos位置的元素能处于正确位置 void resize(int newCapacity);public: Heap(); Heap(int capacity); ~Heap(); T delMax(); //删除堆中最大的元素，并返回该元素 void insert(T val); //插入一个元素&#125;; 源文件： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113#include &quot;Heap.h&quot;template&lt;class T, class compare&gt;bool Heap&lt;T, compare&gt;::less(int i, int j)&#123; return compare()(this-&gt;arrayList[i], this-&gt;arrayList[j]);&#125;template&lt;class T, class compare&gt;void Heap&lt;T, compare&gt;::exch(int i, int j)&#123; T temp = this-&gt;arrayList[i]; this-&gt;arrayList[i] = this-&gt;arrayList[j]; this-&gt;arrayList[j] = temp;&#125;template&lt;class T, class compare&gt;void Heap&lt;T, compare&gt;::swim(int pos)&#123; while (pos &gt; 1 &amp;&amp; this-&gt;less(pos, int(pos / 2))) &#123; this-&gt;exch(int(pos / 2), pos); pos = int(pos / 2); &#125;&#125;template&lt;class T, class compare&gt;void Heap&lt;T, compare&gt;::sink(int pos)&#123; while (2 * pos &lt;= this-&gt;size) &#123; int min; // 如果存在右节点，判断两个子节点哪个最小 if (2 * pos + 1 &lt;= this-&gt;size) &#123; if (this-&gt;less(2 * pos + 1, 2 * pos)) min = 2 * pos + 1; else min = 2 * pos; &#125; // 只有左节点 else min = 2 * pos; // 父节点pos小于最小的子节点，不需要继续下浮了 if (this-&gt;less(pos, min)) break; this-&gt;exch(pos, min); //交换 pos = min; &#125;&#125;template&lt;class T, class compare&gt;void Heap&lt;T, compare&gt;::resize(int newCapacity)&#123; this-&gt;capacity = newCapacity; T* temp = new T[this-&gt;capacity + 1]; for (int i = 1; i &lt;= this-&gt;size; i++) &#123; temp[i] = this-&gt;arrayList[i]; &#125; delete[] this-&gt;arrayList; this-&gt;arrayList = temp;&#125;template&lt;class T, class compare&gt;Heap&lt;T, compare&gt;::Heap()&#123; this-&gt;capacity = 5; this-&gt;arrayList = new T[this-&gt;capacity + 1]; this-&gt;size = 0;&#125;template&lt;class T, class compare&gt;Heap&lt;T, compare&gt;::Heap(int capacity)&#123; this-&gt;capacity = capacity; this-&gt;arrayList = new T[this-&gt;capacity + 1]; this-&gt;size = 0;&#125;template&lt;class T, class compare&gt;Heap&lt;T, compare&gt;::~Heap()&#123; if (this-&gt;arrayList != nullptr) &#123; delete[] this-&gt;arrayList; this-&gt;arrayList = nullptr; &#125;&#125;template&lt;class T, class compare&gt;T Heap&lt;T, compare&gt;::delMax()&#123; if (this-&gt;size == 0) return T(); T val = this-&gt;arrayList[1]; this-&gt;exch(1, this-&gt;size); this-&gt;size--; this-&gt;sink(1); //下沉算法 return val;&#125;template&lt;class T, class compare&gt;void Heap&lt;T, compare&gt;::insert(T val)&#123; if (this-&gt;size == this-&gt;capacity) &#123; this-&gt;resize(this-&gt;capacity * 2); &#125; //不用0位置 this-&gt;arrayList[this-&gt;size + 1] = val; this-&gt;size++; this-&gt;swim(this-&gt;size); //上浮算法&#125; 5.优先队列5.1 优先队列(堆实现)头文件： 1234567891011121314151617181920212223242526#pragma once#include&lt;functional&gt;using namespace std;//默认为greater&lt;&gt;最大优先队列，可修改为less&lt;&gt;为最小优先队列template&lt;class T, class compare = greater&lt;T&gt;&gt;class PriorityQueue&#123;private: T* arrayList; int size; int capacity; bool less(int i, int j); //判断i位置的元素是否小于j位置的元素 void exch(int i, int j); //交换i位置与j位置的元素 void swim(int pos); //使用上浮算法，使pos位置的元素能处于正确位置 void sink(int pos); //使用下浮算法，使pos位置的元素能处于正确位置 void resize(int newCapacity);public: PriorityQueue(); PriorityQueue(int capacity); ~PriorityQueue(); T delMax(); //删除堆中最大的元素，并返回该元素 void insert(T val); //插入一个元素 int getSize(); bool isEmpty();&#125;; 源文件： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125#include &quot;PriorityQueue.h&quot;template&lt;class T, class compare&gt;bool PriorityQueue&lt;T, compare&gt;::less(int i, int j)&#123; return compare()(this-&gt;arrayList[i], this-&gt;arrayList[j]);&#125;template&lt;class T, class compare&gt;void PriorityQueue&lt;T, compare&gt;::exch(int i, int j)&#123; T temp = this-&gt;arrayList[i]; this-&gt;arrayList[i] = this-&gt;arrayList[j]; this-&gt;arrayList[j] = temp;&#125;template&lt;class T, class compare&gt;void PriorityQueue&lt;T, compare&gt;::swim(int pos)&#123; while (pos &gt; 1 &amp;&amp; this-&gt;less(pos, int(pos / 2))) &#123; this-&gt;exch(int(pos / 2), pos); pos = int(pos / 2); &#125;&#125;template&lt;class T, class compare&gt;void PriorityQueue&lt;T, compare&gt;::sink(int pos)&#123; while (2 * pos &lt;= this-&gt;size) &#123; int max; // 如果存在右节点，判断两个子节点哪个最大 if (2 * pos + 1 &lt;= this-&gt;size) &#123; if (this-&gt;less(2 * pos + 1, 2 * pos)) max = 2 * pos + 1; else max = 2 * pos; &#125; // 只有左节点 else max = 2 * pos; // 父节点pos大于最大的子节点，不需要继续下浮了 if (this-&gt;less(pos, max)) break; this-&gt;exch(pos, max); //交换 pos = max; &#125;&#125;template&lt;class T, class compare&gt;void PriorityQueue&lt;T, compare&gt;::resize(int newCapacity)&#123; this-&gt;capacity = newCapacity; T* temp = new T[this-&gt;capacity + 1]; for (int i = 1; i &lt;= this-&gt;size; i++) &#123; temp[i] = this-&gt;arrayList[i]; &#125; delete[] this-&gt;arrayList; this-&gt;arrayList = temp;&#125;template&lt;class T, class compare&gt;PriorityQueue&lt;T, compare&gt;::PriorityQueue()&#123; this-&gt;capacity = 5; this-&gt;arrayList = new T[this-&gt;capacity + 1]; this-&gt;size = 0;&#125;template&lt;class T, class compare&gt;PriorityQueue&lt;T, compare&gt;::PriorityQueue(int capacity)&#123; this-&gt;capacity = capacity; this-&gt;arrayList = new T[this-&gt;capacity + 1]; this-&gt;size = 0;&#125;template&lt;class T, class compare&gt;PriorityQueue&lt;T, compare&gt;::~PriorityQueue()&#123; if (this-&gt;arrayList != nullptr) &#123; delete[] this-&gt;arrayList; this-&gt;arrayList = nullptr; &#125;&#125;template&lt;class T, class compare&gt;T PriorityQueue&lt;T, compare&gt;::delMax()&#123; if (this-&gt;size == 0) return T(); T val = this-&gt;arrayList[1]; this-&gt;exch(1, this-&gt;size); this-&gt;size--; this-&gt;sink(1); //下沉算法 return val;&#125;template&lt;class T, class compare&gt;void PriorityQueue&lt;T, compare&gt;::insert(T val)&#123; if (this-&gt;size == this-&gt;capacity) &#123; this-&gt;resize(this-&gt;capacity * 2); &#125; //不用0位置 this-&gt;arrayList[this-&gt;size + 1] = val; this-&gt;size++; this-&gt;swim(this-&gt;size); //上浮算法&#125;template&lt;class T, class compare&gt;int PriorityQueue&lt;T, compare&gt;::getSize()&#123; return this-&gt;size;&#125;template&lt;class T, class compare&gt;bool PriorityQueue&lt;T, compare&gt;::isEmpty()&#123; return this-&gt;size == 0;&#125; 5.2 索引优先队列头文件： 1 源文件： 1 6.图6.1 无向图(邻接表)头文件： 123456789101112131415161718192021222324252627282930#pragma once#include&lt;vector&gt;#include&lt;queue&gt;#include&lt;stack&gt;using namespace std;class Graph&#123;private: int V; int E; vector&lt;int&gt;* adj; int start; int* edgeTo; bool* visited; void dfs(int v, bool* marked, vector&lt;int&gt;&amp; visit); void bfs(int v, bool* marked, vector&lt;int&gt;&amp; visit); void dfsSeek(int s, bool* visited);public: Graph(int v); ~Graph(); int getV(); int getE(); void addEdge(int v, int w); vector&lt;int&gt; get(int v); vector&lt;int&gt; dfs(int v); vector&lt;int&gt; bfs(int v); bool isPath(int start, int end); stack&lt;int&gt; getPath(int start, int end);&#125;; 源文件： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135#include &quot;Graph.h&quot;void Graph::dfs(int v, bool* marked, vector&lt;int&gt;&amp; visit)&#123; marked[v] = false; for (auto&amp; w : this-&gt;adj[v]) &#123; if (marked[w]) &#123; visit.emplace_back(w); this-&gt;dfs(w, marked, visit); &#125; &#125;&#125;void Graph::bfs(int v, bool* marked, vector&lt;int&gt;&amp; visit)&#123; queue&lt;int&gt; q; marked[v] = false; q.emplace(v); while (!q.empty()) &#123; int temp = q.front(); q.pop(); visit.emplace_back(temp); for (auto&amp; w : this-&gt;adj[v]) &#123; if (marked[w]) &#123; marked[w] = false; q.emplace(w); &#125; &#125; &#125;&#125;void Graph::dfsSeek(int s, bool* visited)&#123; visited[s] = false; for (auto&amp; w : this-&gt;adj[s]) &#123; if (visited[w]) &#123; edgeTo[w] = s; this-&gt;dfsSeek(w, visited); &#125; &#125;&#125;Graph::Graph(int v)&#123; this-&gt;V = v; this-&gt;E = 0; this-&gt;start = -1; this-&gt;edgeTo = new int[v]; this-&gt;visited = new bool[v]; this-&gt;adj = new vector&lt;int&gt;[v];&#125;Graph::~Graph()&#123; if (this-&gt;adj != nullptr) delete[] this-&gt;adj; if (this-&gt;edgeTo != nullptr) delete[] this-&gt;edgeTo; if (this-&gt;visited != nullptr) delete[] this-&gt;visited;&#125;int Graph::getV()&#123; return this-&gt;V;&#125;int Graph::getE()&#123; return this-&gt;E;&#125;void Graph::addEdge(int v, int w)&#123; this-&gt;adj[v].emplace_back(w); this-&gt;adj[w].emplace_back(v); this-&gt;E++;&#125;vector&lt;int&gt; Graph::get(int v)&#123; return this-&gt;adj[v];&#125;vector&lt;int&gt; Graph::dfs(int v)&#123; vector&lt;int&gt; visit; bool* marked = new bool[this-&gt;getV()]; this-&gt;dfs(v, marked, visit); delete[] marked; return visit;&#125;vector&lt;int&gt; Graph::bfs(int v)&#123; vector&lt;int&gt; visit; bool* marked = new bool[this-&gt;getV()]; this-&gt;bfs(v, marked, visit); delete[] marked; return visit;&#125;bool Graph::isPath(int start, int end)&#123; if (this-&gt;start != start) &#123; delete[] visited; this-&gt;visited = new bool[this-&gt;getV()]; this-&gt;start = start; this-&gt;dfsSeek(this-&gt;start, visited); &#125; return !visited[end];&#125;stack&lt;int&gt; Graph::getPath(int start, int end)&#123; if(isPath(start, end)) return stack&lt;int&gt;(); stack&lt;int&gt; s; s.emplace(end); int temp = end; while (temp != start) &#123; temp = this-&gt;edgeTo[temp]; s.emplace(temp); &#125; return s;&#125; 6.2 有向图头文件： 12345678910111213141516171819202122232425#pragma once#include&lt;vector&gt;#include&lt;stack&gt;using namespace std;class Digraph&#123;private: int V; int E; vector&lt;int&gt;* adj; void dfsIsCycle(int v, bool* marked, bool* toStack, bool&amp; isCycle); void dfsSort(int v, bool* marked, stack&lt;int&gt;&amp; s); void reversePost(stack&lt;int&gt;&amp; s);public: Digraph(int v); ~Digraph(); int getV(); int getE(); void addEdge(int v, int w); vector&lt;int&gt; get(int v); Digraph reverse(); bool isCycle(); //是否有环 stack&lt;int&gt; order(); //拓扑排序&#125;; 源文件： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118#include &quot;Digraph.h&quot;void Digraph::dfsIsCycle(int v, bool* marked, bool* toStack, bool&amp; isCycle)&#123; marked[v] = false; //将此点标记为已经遍历过了 toStack[v] = false; //第一次标记此点 for (auto&amp; w : this-&gt;adj[v]) &#123; //如果没遍历过此点，则遍历 if (marked[w]) this-&gt;dfsIsCycle(w, marked, toStack, isCycle); //如果遍历过了此点，又出现了，说明此点存在环 if (!toStack[w]) &#123; isCycle = true; return; //直接退出，无需继续遍历了 &#125; &#125; //遍历完成，说明此点不存在环，将此点取消标记 //只有不存在环，才会运行到这里，并且结束递归时toStack又恢复到原来状态了 toStack[v] = true;&#125;void Digraph::dfsSort(int v, bool* marked, stack&lt;int&gt;&amp; s)&#123; marked[v] = false; for (auto&amp; w : this-&gt;adj[v]) &#123; if (marked[w]) this-&gt;dfsSort(w, marked, s); &#125; s.emplace(v);&#125;void Digraph::reversePost(stack&lt;int&gt;&amp; s)&#123; bool* marked = new bool[this-&gt;getV()]; for (int v = 0; v &lt; this-&gt;getV(); v++) &#123; if (marked[v]) this-&gt;dfsSort(v, marked, s); &#125; delete[] marked;&#125;Digraph::Digraph(int v)&#123; this-&gt;V = v; this-&gt;E = 0; this-&gt;adj = new vector&lt;int&gt;[v];&#125;Digraph::~Digraph()&#123; if (this-&gt;adj != nullptr) &#123; delete[] this-&gt;adj; &#125;&#125;int Digraph::getV()&#123; return this-&gt;V;&#125;int Digraph::getE()&#123; return this-&gt;E;&#125;void Digraph::addEdge(int v, int w)&#123; this-&gt;adj[v].emplace_back(w); this-&gt;E++;&#125;vector&lt;int&gt; Digraph::get(int v)&#123; return this-&gt;adj[v];&#125;Digraph Digraph::reverse()&#123; Digraph newDigraph(this-&gt;getV()); for (int v = 0; v &lt; this-&gt;getV(); v++) &#123; for (auto&amp; w : this-&gt;adj[v]) &#123; newDigraph.addEdge(w, v); &#125; &#125; return newDigraph;&#125;bool Digraph::isCycle()&#123; bool isCycle = false; bool* marked = new bool[this-&gt;getV()]; bool* toStack = new bool[this-&gt;getV()]; for (int v = 0; v &lt; this-&gt;getV(); v++) &#123; if (marked[v]) this-&gt;dfsIsCycle(v, marked, toStack, isCycle); &#125; delete[] marked, toStack; return isCycle;&#125;stack&lt;int&gt; Digraph::order()&#123; if (this-&gt;isCycle()) return stack&lt;int&gt;(); stack&lt;int&gt; s; this-&gt;reversePost(s); return s;&#125; 6.3 加权无向图","categories":[{"name":"计算机4件套","slug":"计算机4件套","permalink":"http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA4%E4%BB%B6%E5%A5%97/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"c++","slug":"c","permalink":"http://example.com/tags/c/"}]},{"title":"操作系统的学习笔记","slug":"计算机4件套/操作系统","date":"2022-08-06T11:11:16.398Z","updated":"2022-09-27T14:16:30.089Z","comments":true,"path":"2022/08/06/计算机4件套/操作系统/","link":"","permalink":"http://example.com/2022/08/06/%E8%AE%A1%E7%AE%97%E6%9C%BA4%E4%BB%B6%E5%A5%97/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/","excerpt":"","text":"一、操作系统概述1.1 特征操作系统的特征： 并发：指两个多个事件在同一时间间隔内发生 这些事件宏观上是同时发生的，但微观上是交替发生的 并行：指两个或多个事件在同一时刻同时发生 操作系统的并发性指计算机系统中同时存在着多个运行着的程序。 单核CPU同一时刻只能执行一个程序，因此操作系统会负责协调多个程序交替执行，但在宏观上看多个程序在同时执行 操作系统是伴随着”多道程序技术”而出现的，因此，操作系统和程序并发是一起诞生的 如今一般都是多核CPU，比如一个4核的CPU，同一时刻可以有4个程序并行执行，但是操作系统的并发性依然必不可少，因为不可能只运行4个程序 共享：即资源共享，是指系统中的资源可供内存中多个并发程序执行的进程共同使用 资源共享的方式： 互斥共享方式：系统中的某些资源，虽然可以提供给多个进程使用，但是一段时间内只允许一个进程访问该资源 示例：使用QQ和微信视频，同一时间内摄像头只能分配给其中一个进程 同时共享方式：系统中的某些资源，允许一个时间段由多个进程”同时”对它们进行访问 其中所谓”同时”，是在宏观上，而微观上，这些进程可能是交替地对该资源进行访问 示例：使用QQ发送文件A，同时使用微信发送文件B。从宏观上，两边都在同时读取并发送文件，从微观上，两个进程在交替着访问硬盘 虚拟：是指把一个物理上的实体变为若干逻辑上的对应物。物理实体实际存在的，而逻辑上对应物是用户感受到的 一个程序需要放入内存并分配给CPU才能执行 一个电脑内存4GB，GTA5运行需要4GB，QQ运行需要256MB，但是还是可以此电脑上运行。 这是因为使用了虚拟存储器技术，虚拟技术中的“空分复用技术” 在单核CPU的计算机中，打开多个的软件，依旧能运行，实际上只有一个单核CPU，但是用户认为有多个CPU在为自己服务。 这是运用了虚拟处理器技术中的“时分复用技术”，微观上处理机在各个微小的时间段内交替着为各个进程服务 虚拟技术： 空分复用技术 时分复用技术 如果失去并发性一段时间只能运行一个程序，则失去了虚拟性的意义(没有并发就谈不上虚拟性) 异步：在多道程序环境下，允许多个程序并发执行，但由于资源有限，进程的执行不是一贯到底的。而是走走停停的，已不可预知的速度向前推进，这就是进程的异步。 只有系统拥有并发性，才有可能导致异步性 并发与共享的关系： 如果失去并发性，则共享性失去存在意义(不需要两个进程交替着访问硬盘了) 如果失去共享性，则无法并发(QQ与微信无法同时读取硬盘资源) 并发性与共线性互为存在条件 没有并发和共享，就没有虚拟和异步，因此并发和共享是操作系统的两个最基本的特征 1.2 发展与分类发展： 手工操作阶段 主要缺点：用户独占全机，人机速度矛盾导致资源利用率极低 批处理阶段 单道批处理系统 引入脱机输入&#x2F;输出技术(用磁带完成)，并监督程序(操作系统的雏形)负责控制作业的输入、输出 主要优点：缓解了一定程度的人机速度矛盾，资源利用率有所提升。 主要缺点：内存中仅能有一道程序运行，只有该程序运行结束后才会进入下一道程序。CPU有大量的时间是在空闲等待IO完成，资源利用率依然很低 多道批处理系统 主要优点：多道程序并发执行，共享计算加资源。资源利用率大幅提升，CPU和其他资源保持”忙碌”状态，系统吞吐量增大 主要缺点：用户响应时间长，没有人机交互功能(用户提交作业后只能等待计算机处理完成，中间不能控制自己的作业执行) 分时操作系统：计算机以时间片为单位轮流为各个用户&#x2F;作业服务，各个用户可通过终端与计算机进行交互 主要优点：用户请求可以被即时响应，解决了人机交互问题，允许多个用户同时使用一台计算机，并且用户对计算机的操作相互独立，感受不到别人的存在 主要缺点：不能优先处理一些紧急任务，操作系统对各个用户&#x2F;作业完全公平，不区分任务的紧急性 实时操作系统 主要优点：能够优先响应一些紧急任务 ，某些紧急任务不需要时间片排队 在实时操作系统的控制下，计算机接收到信号后及时处理，并且在严格的时间内限时完成任务，实时操作系统的主要特点是：及时性和可靠性 硬实时系统：必须在绝对严格的规定时间内完成处理 软实时系统：能接受偶尔违反时间规定 其他几种操作系统： 网络操作系统：能够把网络中各个计算机有机的结合起来，实现数据传送等功能，实现网络中的各种资源的共享和各个计算机之间的通信 分布式操作系统：主要特点是分布式与并行性，任何工作都可以分布在这些计算机上，由它们并行、协同完成这个任务 个人计算机操作系统：如Windows、MacOS等 1.3 运行机制与体系结构运行机制： 指令：处理器能够识别、执行的最基本命令 特权指令：如内存清零指令(不允许用户程序使用) 非特权指令：如普通的运算指令 判断是否可以执行特权指令可以通过两种处理器状态： 用户态(目态)：此时CPU只能执行非特权指令 核心态(管态)：特权和非特权都可以执行 用程序状态寄存器(PSW)来标识当前处理器处于什么状态。如0为用户态，1为核心态 两种程序： 内核程序：操作系统的内核程序是系统发管理者，运行在核心态 应用程序：为了保证系统的安全运行，普通应用程序只能运行在用户态 操作系统内核又细分为：非内核功能和内核 内核：计算机上配置的底层软件，是操作系统最基本、最核心的部分 对系统资源进行管理功能(有的操作系统不会把这部分功能当作内核功能)： 进程管理、存储器管理、设备管理等功能 时钟管理：实现计时功能 中断处理：负责实现中断机制 原语(设备驱动、CPU切换等) 一种特殊的程序。 是最接近硬件的部分， 这种程序的运行具有原子性(要么不执行，要么一直执行到结束) 操作系统的体系结构：大内核和微内核 大内核：将操作系统的主要功能模块都作为系统内核，运行在核心态 优点：高性能 缺点：内核代码庞大、结构混乱、难以维护 微内核：只把最基本的功能保留在内核 优点：内核功能少、结构清晰、方便维护 缺点：需要频繁地在核心态和用户态之间切换、性能低 1.4 中断与异常中断： 当中断发生时，CPU立即进入核心态 当中断发生后，当前运行的进程暂停运行，并由操作系统内核对中断进行处理 对于不同的中断信号，会进行不同的处理 发生了中断，就意味着需要操作系统介入，开展管理工作。由于操作系统的管理工作(比如进程切换、分配IO设备等)需要使用特权指令，因此CPU要从用户态转换为核心态。 中断可以使CPU从用户态切换为核心态，使用操作系统获得计算机的控制权。有了中断，才能实现多道程序并发执行 用户态与核心态的转换： 用户态-&gt;核心态：通过中断实现的，并且只能是中断 核心态-&gt;用户态：通过执行一个特权指令，将程序状态标志设置为用户态 中断的分类： 内中断： 外中断： 二、进程与线程OS中进程作为资源分配与独立运行的基本单位出现。OS的四大特征(并发、共享、虚拟、异步)都是基于进程而形成的。所以在OS中，进程是一个及其重要的概念 到了80年代中期，又出现了比进程更小的基本单位——线程。用来提高程序并发执行程度，以进一步改善系统的服务质量。现代OS无一例外的引入了线程，线程也是一个重要的概念 2.1 进程的描述进程控制块PCB 为了方便控制和管理参与并发执行的每个程序的独立运行，在操作系统中为之配置一种专门的数据结构，称为进程控制块：PCB(Process Control Block)。 系统利用PCB来描述进程的基本信息与活动过程，进而控制和管理程。 PCB、程序段、数据段三部分构成了进程实体(进程映像)，也叫进程 PCB在进程切换的作用操作系统就是根据PCB来感知进程的存在的。 PCB在进程切换过程中起着非常重要的作用，操作系统可以通过对PCB的修改来达到对进程的控制。 以下是PCB结构体的部分描述属性： 123456789101112131415struct task_struct &#123;long state; // 进程运行状态：-1不可运行，0可运行，&gt;0已停止long priority; // 进程运行优先级long counter; // 已运行时间计数器long exit_code; // 进程停止执行后退出码，其父进程需要读取unsigned long start_code; // 代码段起始地址unsigned long end_code; // 代码段长度，单位字节unsigned long next_code; // 下一条要执行代码的地址unsigned long start_data; // 数据段起始地址unsigned long end_data; // 代码段长度+数据段长度，单位字节unsigned long next_data; // 下一条要读取数据的地址long pid; // 进程标识long father; // 父进程标识...&#125;； 进程定义 从不同的角度，进程可以有不同的定义，比较传统典型的定义有： 进程是程序的一次执行的过程 进程是一个程序以及数据在处理顺序执行时所发生的活动 进程是具有独立功能的程序在数据集合上的运行的过程，它是系统进行资源分配和调度的一个独立单位 这3个定义都强调了**”动态性”** 引入进程实体的概念后，可以把进程定义为： 进程是进程实体的运行程序，是系统进行资源分配和调度的一个独立单位 注意：严格来说，进程实体和进程并不一样，进程实体是静态的，进程则是动态的。不过，除非题目刻意考察二者区别，否则是可以认为进程就是进程实体 引入进程后使得作业的并发执行得以实现， 同时也带来了一些问题： 增加了空间开销 需要为进程创建PCB 增加了时间开销 管理、协调、跟踪进程的执行需要时间 创建、更新、回收PCB需要时间 进程切换、保护、恢复CPU现场需要时间 增加了控制难度 协调多个进程对资源的竞争与共享增加了控制难度 对可能由进程引发的异常进行处理增加了控制难度 2.2 进程状态五种状态根据进程所拥有资源的不同，可以将进程所处的状态划分为五种状态： 就绪状态：进程已经获取到了除处理器之外执行所需的所有资源的状态。 执行状态：进程已经获取到了包括处理器在内的执行所需的所有资源的状态。 阻塞状态：进程在执行过程中因等待某事件的发生而无法继续执行的状态。 创建状态：进程缺少完整PCB与运行所需资源的状态。 终止状态：进程释放所拥有资源的过程的状态。 其中，就绪状态、执行状态、阻塞状态，称为进程的基本状态 状态转换flowchart LR A(创建状态) B(就绪状态) C(执行状态) D(阻塞状态) E(终止状态) A--资源分配-->B--获得CPU-->C--请求I/O-->D D--I/O完成-->B C--释放CPU-->B C--释放PCB-->E 状态转换的特点： 创建好的进程直接到达的是就绪态 就绪态进程无法直接转换为阻塞态 阻塞态只能是进程执行过程中由于等待某事件的发生而引发的 进程只能是在执行时终止 挂起与激活PCB的组织方式不同应用可以产生很多异类进程，一个应用可以产生很多同类进程。无论是何类进程，其会按照它们的 状态将它们组织到一起。 常见的组织方式有两种： 链表方式：同一状态的进程的PCB组成一个链表，所以多种状态的进程PCB组成多个链表。此时就会产生诸如就绪链表、阻塞链表等不同链表。 索引表方式：所有PCB都放入同一链表，再为每种状态创建出不同的PCB索引链表，其中存放的就是该状态的所有PCB的索引 粗俗的理解就是，无论就绪队列，还是阻塞队列中的元素就是PCB 2.3 进程控制进程控制是进程管理中最基本的功能。如，进程的创建与终止、进程状态转换等。进程控制一般是由 OS内核中的原语实现的。 进程控制就是实现进程状态的转换。 进程的创建无论是OS内核创建进程，还是用户进程创建子进程，都是调用了进程创建原语完成的。 进程创建过程 进程创建原语的创建过程如下： 生成进程标识符PID 这是一个数字标识符，用于区分系统中的所有进程，在系统中具有唯一 性。 申请空白PCB。 为进程分配其运行所需的一切资源（除CPU外） 这些资源要么从OS直接获得，要么从父进程获 得。 初始化PCB。 这些初始化信息包括自己的PID及父进程的PID，当前处理器的状态数据，进程的状态数据。 将进程写入就绪队列 (创建态-&gt;就绪态) 进程创建事件 一个进程可以由系统内核创建，也可以由另一个进程创建。发生进程创建的典型事件有三类： 用户登录：在分时系统中，用户登录后，系统内核会为该用户创建一个进程。 作业调度：在多道批处理系统中，当作业调度程序调度到某作业后，会将其装入内存，并由系统 内核为该作业创建一个进程。 提供服务：当某进程在运行过程中提出某种请求后，系统内核或主进程将会创建一个相应的子进程来处理该请求，以使主进程与子进程可以并发执行。 例如，用户进程提交了一个文件打印请求后，系统内核会创建一个打印进程来处理该请求。 应用请求：由用户主动请求创建一个子进程 进程的终止进程终止过程 系统中发生进程终止事件，OS就会调用进程终止原语去终止进程。 进程终止原语的终止过程如下： 根据被终止进程的PID，找出其PCB。 从PCB中读取其状态，若该进程处于执行态，则立即终止其执行，并置调度标志为真，用于标志该进程可被重新调度。 从PCB中读取其子进程PID，若该进程还有子进程，则要将其所有子进程全部终止。 从PCB中读取其所拥有的全部资源，并全部释放，归还给其父进程或系统。 这个资源释放的过程主要包含两步： 将其PCB赋值为null 在其父进程或系统的资源数量上增加相应释放的数量。 将该进程的PCB从PCB队列或链表中移出。 释放该PCB空间。 进程终止事件 引起进程终止的事件典型的有三类： 正常结束：进程的任务正常执行完毕后的进程终止。当进程的任务执行完毕后，进程会发出一条终止指令，此时会产生一个中断，以通知OS进程马上终止。 异常结束：进程在运行过程中发生了某种异常事件，导致进程无法继续运行。 常见的异常事件有： 访问越界 非法指令 权限异常 运行超时 等待超时 运算异常 IO异常 外界干预：进程被外界干预终止。 外界干预主要指三方面： 用户直接终止 OS终止 父进程终止 进程的堵塞与唤醒进程阻塞 阻塞是进程自身的一种主动行为。当系统中发生进程阻塞事件后，进程自己会调用进程阻塞原语将自 己阻塞。 进程阻塞原语的阻塞过程如下： 立即暂停CPU的执行，保留当前CPU的现场。 将PCB中的状态由执行态修改为阻塞态。 将PCB写入到相应阻塞原因的阻塞队列。 启动调度程序进行重新调度，即将CPU分配给另一就绪进程。 按照新进程的PCB设置CPU新的环境。 引发进程阻塞的事件 进程发生阻塞是由于**正在执行的进程突然发生执行条件缺失事件(需要等待系统分配资源和等待相互合作的进程的完成工作)**，进而暂停执行等待条件的满足 进程唤醒 进程唤醒过程 当被阻塞进程所期待的事件发生时，由“相关进程（促使执行条件满足的进程）”调用唤醒原语，将阻塞进程唤醒（唤醒是进程的被动行为）。 进程唤醒原语的唤醒过程如下： 将该进程的PCB从阻塞队列移出。 修改PCB中的状态由阻塞变为就绪。 将PCB插入到就绪队列 阻塞进程被唤醒则是由于发生了某些事件，从而具备了执行条件，到达了执行时机。 2.4 进程通信共享存储为了保证安全，一个进程不能直接访问另一个进程的地址空间 在通信的进程之间存在一块可直接访问的共享空间，通过对这片共享空间进行写&#x2F;读操作实现进程之间的信息交换。 两个进程对共享空间的访问必须是互斥的(互斥访问通过操作系统提供的工具实现)。 互斥访问就是在同一时间只能有一个进程对同一资源进行访问 操作系统只负责提供共享空间和同步互斥工具(如P、V操作)。 共享方式分为两种： 低级方式的共享是基于数据结构的共享 基于数据结构的共享：比如共享空间里只能发放一个长度为10的数组，这种共享方式速度慢，限制多，是一种低级通信方式。 高级方式的共享则是基于存储区的共享 基于存储区的共享：在内存中画出一块共享存储区，数据的形式、存放的位置都由进程决定，而不是操作系统。相比之下，这种共享方式速度更快，是一种高级通信方式。 管道通信 “管道”是指用于连接读写进程的一个共享文件，又名pipe文件，其实就是在内存中开辟的一个大小固定的缓冲区。 管道通信只能采用半双工通信，某一个时段内只能实现单向的传输，如果要实现双向同时通信，则需要设置两个管道。 各个进程要互斥的访问管道。write 数据以字符流的形式写入管道，当管道写满时，写进程的write()系统调用将被阻塞，等待读进程将数据取走。当读进程将数据全部取走后，管道变空，此时读进程的read()系统调用将被阻塞。 注意：如果没有写满，是不允许读的，如果没有读空，是不允许写的。 数据一旦被读出，就会从管道中被抛弃，这就意味着读进程最多只能有一个，否则可能会有读错数据的情况。 消息传递进程间的数据交换以格式化的消息(Message)为单位。 进程通过操作系统提供的”发送消息&#x2F;接收消息”两个原语进行数据交换 格式化的消息分为：消息头和消息体 消息头：包括发送的进程ID、接受进程ID、消息类型、消息长度等格式化信息 直接通信方式：A进程发送消息(原语)直接挂到接收进程B的消息缓冲队列上 间接通信方式：发送消息(原语)要先发送到**中间实体(信箱)**中，因此也称”信箱通信方式”。如：计网中的电子邮箱系统 2.5 线程的描述为什么要引入线程 进程是资源分配的基本单位，也是调度的基本单位 引入线程之后，线程是CPU调度的基本单位 由于切换进程时，需要保存&#x2F;恢复进程运行环境，还需要切换内存地址空间(更新快表、更新缓冲) 引入线程后，同一个进程内各个线程间并发，不需要切换进程运行环境和内存地址空间，省时省力。 注意：从属于不同进程的线程间的切换，也会导致进程的切换，开销也大 引入进程的目的是： 为了更好的让多道程序并发执行，提高资源利用率和系统吞吐量 为了减少程序在并发执行时所付出的时空开销，提高操作系统的并发性能。 进程可能需要”同时”做很多事情，而传统的进程只能 线程的特点 各个进程的内存地址空间相互独立，只能通过请求操作系统内核的帮助来完成进程之间的通信。 但同一个进程下的各个线程之间共享内存地址空间，可以直接通过读&#x2F;写内存空间进行通信。 从属于同一个进程各个线程共享进程的所有资源。 进程之间的通信必须请求操作系统服务(CPU要求换到核心态)，开销大。 同进程下的线程间通信不需要操作系统干预，开销更小。 引入线程前，进程既是资源分配的基本单位，也是调度的基本单位。 但是引入线程后，进程是资源分配的基本单位，而线程是调度的基本单位。同样线程也有运行态，就绪态和阻塞态。 而线程几乎不拥有资源，只拥有极少量的资源(线程控制块TCB、寄存器信息、堆栈等) 在多核CPU环境下，各个线程也可以分配到不同的CPU上并行的执行。 2.6 线程的实现方式线程分为：用户级线程和内核级线程 用户级线程 用户级线程由应用程序通过线程库实现，所有的线程管理工作都由应用程序负责（包括线程切换） 用户级线程中，线程切换可以在用户态下即可完成，无需操作系统干预。 在用户看来，是有多个线程，但是在操作系统的内核来看，并不意识到线程的存在。 “用户级线程”就是从用户视角所能看到的线程。 优点：用户级线程的切换在用户空间即可完成，不需要切换到核心态，线程管理的系统开销小，效率高。 缺点：当一个用户级线程被阻塞后，整个线程都会被阻塞，并发度不高。多个线程必须在多核处理机上并行运行。 在用户级线程中，CPU调度的基本单位依旧是进程，并非线程 ​ 内核级线程 内核级线程：又称”内核支撑的线程”，是由操作系统支撑的线程。 大多数的现代操作系统都实现了内核级线程，如Windows、Linux。 内核级线程的管理工作是由操作系统内核完成。 线程调度和切换等工作都是由内核负责，因此内核级线程的切换必然需要在核心态下才能完成。 操作系统会为**每个内核级线程建立相应的TCB(进程控制块)**，通过TCB对线程进行管理”。 “内核级线程”就是从操作系统内核视角看到的线程。 优点：当一个线程被阻塞后，别的线程还可以继续执行，并发能力强。多线程可在多核处理机上并行执行。 缺点：一个用户进程会占用多个内核程序，线程切换由操作系统内核完成，需要从用户态变为核心态，因此线程管理的成本高，开销大。 2.7 多线程模型一对一模型一对一模型： 一个用户及线程映射到一个肉核级线程。每个用户进程有与用户级线程同数量的内核级线程。 优点：当一个线程被阻塞后，别的线程还可以继续执行，并发能力强。多线程可在多核处理机上并行执行。 缺点：一个用户进程会占用多个内核级线程，线程切换由操作系统内核完成，需要切换到核心态，因此线程管理的成本高，开销大。 多对一模型多对一模型： 多个用户及线程映射到一个内核级线程。每个用户进程只对应一个内核级线程。 优点：用户级线程的切换在用户空间即可完成，不需要切换到核心态，线程管理的系统开销小，效率高 缺点：当一个用户级线程被阻塞后，整个进程都会被阻塞，并发度不高。多个线程不可在多核处理机上并行运行 多对多模型多对多模型： n用户及线程映射到m个内核级线程(n&gt;&#x3D;m)。每个用户进程对应m个内核级线程。 克服了多对一模型并发度不高的缺点，又克服了一对一模型中一个用户进程占用太多内核级线程，开销太大的缺点。 2.8 处理机调度 当有一堆任务要处理，但由于资源有限，这些事情没法同时处理。这就需要确定某种规则(时间短优先、先来先服务等)来决定这些任务的顺序，这就是“调度”研究的问题。 在多道程序系统中，进程的数量往往是多于处理机的个数的，这样不可能同时并行的处理各个进程。 处理机调度：就是从就绪队列中按照一定的算法选择一个进程并将处理机分配给它运行，以实现进程的并发执行。 高级调度高级调度是，也称为作业调度，根据不同的作业调度算法，将磁盘中后备队列中的不同的若干作业调入 内存的过程。作业一旦被调入内存，就会将其创建为进程，并为之分配必要的资源，进入就绪队列。 高级调度，主要存在于多道批处理系统，实时系统与分时系统中没有该调度方式 中级调度中级调度，也称为内存调度，也是OS中最基本的一种调度，是为提高内存利用率与系统吞吐量而引入 的一类调度。其功能是，将内存中暂时不能运行的进程，调到外存等待。当具备运行条件且内存有空闲 时，再根据不同的调度算法将其重新调入到内存。 中级调度，无论是多道批处理系统，还是分时系统、实时系统，都存在该调度方式 低级调度低级调度是，也称为进程调度，是OS中最基本的一种调度，是一个根据不同的进程调度算法，选择不 同的进程为其分配处理机的过程。 低级调度，无论是多道批处理系统，还是分时系统、实时系统，都存在该调度方式 2.9 进程调度进程调度的时机进程调度(低级调度)，就是按照某种算法从就绪队列中选择一个进程为其分配处理机。 需要进行进程调度与切换的情况： 当前运行的进程主动放弃处理机 进程正常终止 运行过程中发生异常而终止 进程主动请求阻塞，如等待I&#x2F;O 当前运行的进程被动放弃处理机 分给进程的时间片用完 有更紧急的事需要处理，如I&#x2F;O中断 有更高优先级的进程进入就绪队列 不能进行进程调度与切一换的情况： 在处理中断的过程中。中断处理过程复杂，与硬件密切相关，很难做到在中断处理过程中进行进程切换。 进程在操作系统内核程序临界区中。 在原子操作过程中(原语)。原子操作不可中断，要一气呵成。如之前讲过的修改PCB中进程状态标志，并把PCB放到相应队列 进程调度的方式 非剥夺调度方式，又称非抢占方式： 即，只允许进程主动放弃处理机。在运行过程中即便有更紧迫的任务到达，当前进程依然会继续使用处理机，直到该进程终止或主动要求进入阻塞态。特点：实现简单，系统开的小但是无法及时处理紧急任务，适合于早期的批处理系统 剥夺调度方式，又称抢占方式： 当一个进程正在处理机上执行时，如果有一个更重要或更紧迫的进程需要使用处理机，则立即暂停正在执行的进程，将处理机分配给更重要紧迫的那个进程。特点：可以优先处理更紧急的进程，也可实现让各进程按时间片轮流执行的功能（通过时钟中断）。适合于分时操作系统、实时操作系统 进程的切换与过程“狭义的进程调度”与“进程切换”的区别： 狭义的进程调度：指的是从就绪队列中选中一个要运行的进程(这个进程可以是刚刚被暂停执行的进程，也可能是另一个进程，后一种情况就需要进程切换) 进程切换：是指一个进程让出处理机，由另一个进程占用处理机的过程。 广义的进程调度：包含了选择一个进程和进程切换两个步骤。 进程切换过程完成后： 对原来运行进程各种数据的保存 对新的进程各种数据的恢复 如：程序计数器、程序状态字、各种数据寄存器等处理机现场信息，这些信息一班保存在进程控制块PCB中 注意：进程切换是有代价的，不能说进程切换越频繁系统并发性就越好，因为如果过于频繁的进行进程调度、切换，必然会使得整个系统的效率降低，使得系统大部分时间都花在了进程的切换上，而真正用于执行进程的时间减少。 2.10 调度算法调度算法的评价指标调度算法的评价指标主要有：CPU利用率，系统吞吐量、周转时间、等待时间和响应时间 CPU利用率：指的是CPU”忙碌”的时间占总时间的比例 利用率 = CPU忙碌的时间 / 总时间 系统吞吐量：单位时间内完成作业的数量 系统吞吐量 = 总共完成了多少道作业 / 总共花了多少时间 周转时间：是指从作业被提交给系统开始，到作业完成为止的这段时间间隔 周转时间 = 作业完成时间 - 作业提交时间 对于用户，更关心自己的单个作业的周转时间 平均周转时间 = 各个作业周转时间之和 / 作业数 对于操作系统，更关心系统的整体表现，因此更关心所有作业的周转时间的平均值 带权周转时间 = 作业周转时间 / 作业实际运行时间 ​ = (作业完成时间 - 作业提交时间) / 作业实际运行时间 带权周转时间与周转时间都是越小越好(带权周转时间必然 &gt;&#x3D; 1) 平均带权周转时间 = 各个带权周转时间之和 / 作业数 等待时间：指进程&#x2F;作业处于等待处理机状态时间之和，等待时间越短，用户越满意 对于进程来说，等待时间就是指进程建立后等待被服务的时间之和，在等待I&#x2F;O完成的期间其实进程也是被服务的，所以不计入等待时间。 而对于作业来说，不仅要考虑建立进程后的等待时间，还要加上作业在外存后备队列中的等待时间。 一个作业总共需要被CPU服务多久，被I&#x2F;O设备服务多久一般是确定不变的，因此调度算法其实只能影响作业或者进程的等待时间。当然，与前面指标类似，也有”平均等待时间”来评价整体性能。 响应时间：指从用户请求到首次产生响应所用的时间 调度算法先来先服务(FCFS)： 短作业优先(SJF)： 高响应比优先(HRRN)： 三、内存四、文件五、I-O设备","categories":[{"name":"计算机4件套","slug":"计算机4件套","permalink":"http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA4%E4%BB%B6%E5%A5%97/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"","slug":"小技巧/@Autowired与@Resource","date":"2022-08-06T11:11:16.336Z","updated":"2022-09-08T00:30:02.078Z","comments":true,"path":"2022/08/06/小技巧/@Autowired与@Resource/","link":"","permalink":"http://example.com/2022/08/06/%E5%B0%8F%E6%8A%80%E5%B7%A7/@Autowired%E4%B8%8E@Resource/","excerpt":"","text":"@Autowired和@Resource区别1.提供方不同： @Autowired是由Spring提供，属于第三方 @Resource是由J2EE提供，属于Java的 2.装配时默认类型不同： @Autowired默认按type装配 默认情况下必须要求依赖对象存在，如果要允许null值，可以设置它的required属性为false。 如果想使用名称装配可以结合@Qualifier注解进行使用。 @Resource默认按name装配 名称可以通过name属性进行指定，如果没有指定name属性，当注解写在字段上时，默认取字段名进行名称查找。 如果注解写在setter方法上默认取属性名进行装配。 当找不到与名称匹配的bean时才按照类型进行装配。 但是需要注意的是，如果name属性一旦指定，就只会按照名称进行装配。 3.使用注意： @Autowired @Qualifier(“userService”) 是直接按照名字进行搜索，也就是说，对于UserServiceImpl 上面@Service注解必须写名字，不写就会报错，而且名字必须是@Autowired @Qualifier(“userService”) 保持一致。如果@Service上面写了名字，而@Autowired @Qualifier() ，一样会报错。 @Resource 根据这个注解的匹配效果可以看出，它进行了两次匹配，也就是说，如果你在UserService这个类上面这样写注解@Service。首先是找相同名字的，如果没有找到，再找相同类型的，而这里的@Service没有写名字，这个时候就进行了两次搜索，显然，速度就下降了许多。 @Resource根据名字搜索是这样写@Resource(“userService”)，如果你写了这个名字叫userService，那么UserServiceImpl的@Service注解也必须也是这个名字，不然还是会报错。","categories":[],"tags":[]},{"title":"","slug":"Python/图形处理","date":"2022-08-06T11:11:16.328Z","updated":"2022-07-29T04:19:15.388Z","comments":true,"path":"2022/08/06/Python/图形处理/","link":"","permalink":"http://example.com/2022/08/06/Python/%E5%9B%BE%E5%BD%A2%E5%A4%84%E7%90%86/","excerpt":"","text":"1.计算机眼中的图像彩色图像中每一个小格叫做像素点，由R(红)G(绿)B(蓝)组成 导包： 123import cv2import matplotlib.pyplot as pltimport numpy as np 12img = cv2.imread(&#x27;scenery.jpg&#x27;)print(img) 运行结果： 1234567891011121314151617[[[23 14 11] [23 14 11] [24 15 12] ... [15 10 9] [14 9 8] [14 9 8]] ... [[ 0 0 0] [ 0 0 0] [ 0 0 0] ... [ 0 0 0] [ 0 0 0] [ 0 0 0]]] 展示图像函数： 123456def show_img(name, img): cv2.imshow(name, img) # 等待时间，毫秒级，0表示任意键终止 cv2.waitKey(0) # 关闭所有窗口 cv2.destroyAllWindows() 1show_img(&quot;111&quot;, img) # 展示图像 1print(img.shape) # 获取图像的三维数值 运行结果： 1(799, 1200, 3) 展示灰度图像： 1234img = cv2.imread(&#x27;scenery.jpg&#x27;, cv2.IMREAD_GRAYSCALE)print(img)show_img(&quot;111&quot;, img)print(img.shape) 运行结果： 12345678[[14 14 15 ... 10 9 9] [14 14 15 ... 10 9 9] [14 14 15 ... 10 9 9] ... [ 0 0 0 ... 0 0 0] [ 0 0 0 ... 0 0 0] [ 0 0 0 ... 0 0 0]](799, 1200) 保存图片： 1cv2.imwrite(&quot;sc.jpg&quot;, img)","categories":[],"tags":[]},{"title":"Spring框架的学习笔记","slug":"Java/Spring框架","date":"2022-08-06T11:11:16.323Z","updated":"2022-08-06T14:16:47.670Z","comments":true,"path":"2022/08/06/Java/Spring框架/","link":"","permalink":"http://example.com/2022/08/06/Java/Spring%E6%A1%86%E6%9E%B6/","excerpt":"","text":"1.初识Spring 官网：spring官网 Spring已经发展成了一种开发的生态圈，Spring提供了若干个项目，每个项目用于完成特定的功能 Spring Framework Spring Boot Spring Cloud …. 目前已经发展到Spring 5.0，需要JDK8以上支持 2.Spring Framework架构 Spring Framework是Spring生态圈中最基础的项目，是其他项目的根基 Data Access：数据访问 Data Integeration：数据集成 Web：web开发 AOP：面向切面编程 Aspects：AOP思想实现 Core Container：核心容器 Test：单元测试与集成测试 3.核心概念3.1 项目结构 java包 com包 spring包 dao包 BookDao.java impl包 BookDaoImpl.java service包 BookSerive.java impl包 BookServiceImpl.java App.java主函数 resources包 applicationContext.xml jdbc.properties 3.2 初识IOC和DI12345public class BookDaoImpl implements BookDao &#123; public void save() &#123; System.out.println(&quot;book dao save...&quot;); &#125;&#125; 123456public class BookServiceImpl implements BookService &#123; private BookDao bookDao = new BookDaoImpl; public void save() &#123; bookDao.save(); &#125;&#125; 这是一种很常见的写法。但是这样的写法耦合度太高，耦合度可以简单的理解为：两个类之间的关联程度，耦合度高就代表两个类之间关联程度很高，动其中一个类，就不得不动另外一个类。 所以就需要解耦 123456public class BookServiceImpl implements BookService &#123; private BookDao bookDao;//service:我免费啦！ public void save() &#123; bookDao.save(); &#125;&#125; IOC(Inversion of Control) 控制反转 使用对象时，由以前主动new一个对象转换为由外部提供对象，创建对象的控制权交给了外部，此思想为控制反转。 Spring技术对IOC进行实现 Spring提供一个容器，称为IOC容器，用来当作IOC思想中的**”外部”** IOC容器负责对象的创建、初始化等工作 在IOC容器中被创建或被管理的对象称之为Bean DI(Dependency Injection) 依赖注入 在容器中建立的bean与bean之间的依赖关系的整个过程，称之为依赖注入。 例：service层需要依赖dao层运行，但无需自己new一个dao层，它会自动生成dao层。 目标：充分解耦 使用IOC容器管理bean(IOC思想) 在ICO容器内将依赖关系的bean进行关系绑定(DI思想) 在使用对象时不仅可以从IOC容器中获取，并且也可以获取到bean已经绑定的所有依赖关系 4.IOC入门 pom.xml导入spring的坐标 12345&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;5.3.18&lt;/version&gt;&lt;/dependency&gt; resources目录创建Spring配置文件applicationContext.xml 配置bean bean标签：配置bean id属性：给bean起名字 class属性：给bean定义类型 123&lt;bean id=&quot;bookDao&quot; class=&quot;com.spring.dao.impl.BookDaoImpl&quot;/&gt;&lt;bean id=&quot;bookService&quot; class=&quot;com.spring.service.impl.BookServiceImpl&quot;/&gt; 创建名为启动类App 1234567891011121314151617import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;import com.spring.dao.BookDao;public class App &#123; public static void main(String[] args) &#123; //获取ICO容器 ApplicationContext ac = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); //获取bean BookDao bookDao = (BookDao) ac.getBean(&quot;bookDao&quot;); bookDao.save(); BookService bookService = (BookService) ac.getBean(&quot;bookService&quot;); bookService.save(); &#125;&#125; 5.DI入门 基于IOC管理bean 不能保留Service层中用new创建的对象 通过spring配置文件进行配置Service与Dao的关系 12345678910111213public class BookServiceImpl implements BookService &#123; //删除业务层中用new创建对象的方式 //private BookDao bookDao = new BookDaoImpl(); private BookDao bookDao; //提供相应的set的方法 public void setBookDao(BookDao bookDao) &#123; this.bookDao = bookDao; &#125; public void save() &#123; bookDao.save(); &#125;&#125; 在spring配置文件applicationContext.xml中，配置property property标签：配置当前bean的属性 name属性：配置哪个具体的属性 ref属性：参照spring配置文件中的哪个bean的id 123456&lt;bean id=&quot;bookDao&quot; class=&quot;com.spring.dao.impl.BookDaoImpl&quot;/&gt;&lt;bean id=&quot;bookService&quot; class=&quot;com.spring.service.impl.BookServiceImpl&quot;&gt; &lt;!-- 配置service与dao的关系 --&gt; &lt;property name=&quot;bookDao&quot; ref=&quot;bookDao&quot;/&gt;&lt;/bean&gt; 配置完成后，BookDao无需使用new来手动创建对象，而是通过spring来自动创建 6.bean基础配置6.1 bean别名配置 name属性：可以起多个别名用;分号 空格,逗号分隔 123&lt;bean id=&quot;bookDao&quot; name=&quot;dao Dao&quot; class=&quot;com.spring.dao.impl.BookDaoImpl&quot;/&gt;&lt;bean id=&quot;bookService&quot; name=&quot;Service service&quot; class=&quot;com.spring.service.impl.BookServiceImpl&quot;/&gt; 别名可以用于getBean()方法 1234567891011public class App &#123; public static void main(String[] args) &#123; //获取ICO容器 ApplicationContext ac = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); //获取bean //BookService bookService=(BookService)ac.getBean(&quot;bookService&quot;); //通过别名获取BookService BookService bookService=(BookService)ac.getBean(&quot;Service&quot;); bookService.save(); &#125;&#125; 别名也可以用于ref属性，不建议用别名，建议使用id 123&lt;bean id=&quot;bookService&quot; class=&quot;com.spring.service.impl.BookServiceImpl&quot;&gt; &lt;property name=&quot;bookDao&quot; ref=&quot;Dao&quot;/&gt;&lt;/bean&gt; 6.2 bean的作用范围创建的bean是否为多个对象 123456789101112public class App &#123; public static void main(String[] args) &#123; //获取ICO容器 ApplicationContext ac = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); //获取bean BookDao bookDao1 = (BookDao) ac.getBean(&quot;bookDao&quot;); BookDao bookDao2 = (BookDao) ac.getBean(&quot;bookDao&quot;); System.out.println(bookDao1); System.out.println(bookDao2); &#125;&#125; 123运行结果：com.spring.dao.impl.BookDaoImpl@7219ec67com.spring.dao.impl.BookDaoImpl@7219ec67 结论：两个对象地址相同，spring默认创建的bean是单例的 需要在配置文件的bean标签里添加一个scope属性 scope属性有singleton单例模式和prototype非单例模式 scope属性默认为singleton单例模式 1&lt;bean id=&quot;bookDao&quot; class=&quot;com.spring.dao.impl.BookDaoImpl&quot; scope=&quot;prtotype&quot;/&gt; 123再次运行后，运行结果：com.spring.dao.impl.BookDaoImpl@7219ec67com.spring.dao.impl.BookDaoImpl@45018215 结论：两个对象地址不同，为非单例模式 bean作用范围说明 单例bean的优势 减少了新生成实例的消耗，可以快速获取到bean，更大程度的复用 适合交给容器进行管理的bean 表现层对象，业务层对象，数据层对象，工具对象 不适合交给容器进行管理的bean 封装实体的域对象(存在变量的) 7.bean实例化 bean的本质就是对象，创建bean都需要使用构造方法完成 7.1 构造方法实例化bean(常用) 在BookDaoImpl类中创建构造方法： 123456789101112public class BookDaoImpl implements BookDao &#123; public BookDaoImpl()&#123; System.out.println(&quot;BookDaoImpl构造函数&quot;); &#125; /*private BookDaoImpl()&#123; System.out.println(&quot;BookDaoImpl构造函数&quot;); &#125;*/ public void save() &#123; System.out.println(&quot;BookDao~~~~~&quot;); &#125;&#125; AppForInstanceBook类进行测试： 12345678public class AppForInstanceBook &#123; public static void main(String[] args) &#123; ApplicationContext ac = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); BookDao bookDao = (BookDao) ac.getBean(&quot;bookDao&quot;); bookDao.save(); &#125;&#125; 123运行结果：BookDaoImpl构造函数BookDao~~~~~ 并且BookDaoImpl中的构造方法无论是否私有都可以被调用，这就是反射。 无参构造方法不存在，将会抛出异常 在BookDaoImpl类中构造方法改为有参构造： 123public BookDaoImpl(int i)&#123; System.out.println(&quot;BookDaoImpl构造函数&quot;);&#125; 运行后会报错，同时说明Spring创建bean的时候，调用的是无参构造。 7.2 静态工厂实例化bean(早期实例化bean 了解) 创建一个factory软件包，并在里面创建一个BookDaoFactory类： 123456public class BookDaoFactory &#123; public static BookDao getBookDao()&#123; System.out.println(&quot;factory is running&quot;); return new BookDaoImpl(); &#125;&#125; AppForInstanceBook类运行： 1234567public class AppForInstanceBook &#123; public static void main(String[] args) &#123; BookDao bookDao = BookDaoFactory.getBookDao(); bookDao.save(); &#125;&#125;//运行成功 通过配置文件使用静态工厂实例化bean： Spring配置文件中： factory-method属性：选择工厂里的bean实例方法 12&lt;bean id=&quot;bookDao&quot; class=&quot;com.spring.factory.BookDaoFactory&quot; factory-method=&quot;getBookDao&quot;/&gt; AppForInstanceBook类运行： 12345678public class AppForInstanceBook &#123; public static void main(String[] args) &#123; ApplicationContext ac = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); BookDao bookDao = (BookDao) ac.getBean(&quot;bookDao&quot;); bookDao.save(); &#125;&#125; 1234运行结果：factory is runningBookDaoImpl构造函数BookDao~~~~~ 7.3 实例工厂实例化bean(非静态工厂 了解) BookDaoFactory类中，将方法改为非静态方法 123456public class BookDaoFactory &#123; public BookDao getBookDao()&#123; System.out.println(&quot;factory is running~~~~~&quot;); return new BookDaoImpl(); &#125;&#125; AppForInstanceBook类运行： 1234567public class AppForInstanceBook &#123; public static void main(String[] args) &#123; BookDaoFactory bookDaoFactory = new BookDaoFactory(); BookDao bookDao = bookDaoFactory.getBookDao(); bookDao.save(); &#125;&#125; 1234运行结果：factory is running~~~~~BookDaoImpl构造函数BookDao~~~~~ 通过配置文件使用静态工厂实例化bean： Spring配置文件中： 12345&lt;!-- 先要造出工厂的bean --&gt;&lt;bean id=&quot;bookDaoFactory&quot; class=&quot;com.spring.factory.BookDaoFactory&quot;/&gt;&lt;bean id=&quot;bookDao&quot; factory-bean=&quot;bookDaoFactory&quot; factory-method=&quot;getBookDao&quot; /&gt; AppForInstanceBook类运行： 12345678public class AppForInstanceBook &#123; public static void main(String[] args) &#123; ApplicationContext ac = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); BookDao bookDao = (BookDao) ac.getBean(&quot;bookDao&quot;); bookDao.save(); &#125;&#125; 1234运行结果：factory is running~~~~~BookDaoImpl构造函数BookDao~~~~~ 配置文件中beanbookDaoFactory只是为了配合使用，实际没有意义。 Spring对这种实例化bean方法进行了改良： 4.通过FactoryBean实例化bean(实用) 创建BookDaoFactoryBean类实现接口FactoryBean&lt;T&gt; 123456789101112public class BookDaoFactoryBean implements FactoryBean&lt;BookDao&gt; &#123; //代替原始实例工厂中创建对象的方法 @Override public BookDao getObject() throws Exception &#123; return new BookDaoImpl(); &#125; @Override public Class&lt;?&gt; getObjectType() &#123; return BookDao.class; &#125;&#125; Spring配置文件中： 1&lt;bean id=&quot;bookDao&quot; class=&quot;com.spring.factory.BookDaoFactoryBean&quot;/&gt; AppForInstanceBook类运行： 12345678public class AppForInstanceBook &#123; public static void main(String[] args) &#123; ApplicationContext ac = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); BookDao bookDao = (BookDao) ac.getBean(&quot;bookDao&quot;); bookDao.save(); &#125;&#125; 123运行结果：BookDaoImpl构造函数BookDao~~~~~ 并且BookDaoFactoryBean类中可以重写isSinglenton方法： 1234567891011121314151617181920212223242526272829&lt;table&gt; &lt;th align=&quot;center&quot;&gt; &lt;td rowspan=&quot;2&quot;&gt;Key&lt;/td&gt; &lt;td colspan=&quot;2&quot;&gt;Value&lt;/td&gt; &lt;/th&gt; &lt;tr align=&quot;center&quot;&gt; &lt;td&gt;field&lt;/td&gt; &lt;td&gt;value&lt;/td&gt; &lt;/tr&gt; &lt;tr align=&quot;center&quot;&gt; &lt;td rowspan=&quot;2&quot;&gt;REQUIRES_NEW&lt;/td&gt; &lt;td&gt;开启T&lt;/td&gt; &lt;td&gt;新建T2&lt;/td&gt; &lt;/tr&gt; &lt;tr align=&quot;center&quot;&gt; &lt;td&gt;无&lt;/td&gt; &lt;td&gt;新建T2&lt;/td&gt; &lt;/tr&gt; &lt;tr align=&quot;center&quot;&gt; &lt;td rowspan=&quot;2&quot;&gt;SUPPORTS&lt;/td&gt; &lt;td&gt;开启T&lt;/td&gt; &lt;td&gt;加入T&lt;/td&gt; &lt;/tr&gt; &lt;tr align=&quot;center&quot;&gt; &lt;td&gt;无&lt;/td&gt; &lt;td&gt;无&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt; 8.bean的生命周期 bean生命周期：bean从创建到销毁的整体过程 bean生命周期控制：在bean创建后到销毁前做一些事 在BookDaoImpl类中，创建init和destroy方法 1234567891011121314public class BookDaoImpl implements BookDao &#123; public void save() &#123; System.out.println(&quot;BookDao~~~~~&quot;); &#125; public void init()&#123; System.out.println(&quot;init~~~&quot;); &#125; public void destroy()&#123; System.out.println(&quot;destroy~~~&quot;); &#125;&#125; 在Spring配置文件中： init-method和destroy-method属性 12&lt;bean id=&quot;bookDao&quot; class=&quot;com.spring.dao.impl.BookDaoImpl&quot; init-method=&quot;init&quot; destroy-method=&quot;destroy&quot;/&gt; 调用主函数： 123456789public class App &#123; public static void main(String[] args) &#123; //获取ICO容器 ApplicationContext ac = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); //获取bean BookDao bookDao = (BookDao) ac.getBean(&quot;bookDao&quot;); bookDao.save(); &#125;&#125; 123运行结果：init~~~BookDao~~~~~ 控制台并没有输出destroy~~~； 因为销毁函数还没有来得及调用，程序就被杀死了； 所以需要进行手动关闭； 我们调用主函数中的ac中的close()方法，但是ApplicationContext接口中并没有提供close()方法，所以我们要改用ClassPathXmlApplicationContext类。 12345678910public class App &#123; public static void main(String[] args) &#123; //获取ICO容器 ClassPathXmlApplicationContext ac = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); //获取bean BookDao bookDao = (BookDao) ac.getBean(&quot;bookDao&quot;); bookDao.save(); ac.close(); &#125;&#125; 12345运行结果：init~~~BookDao~~~~~destroy~~~ 成功！！！！ 容器还提供另外一种方式关闭容器：设置关闭钩子 调用ac的registerShutdownHook()方法 1234567891011public class App &#123; public static void main(String[] args) &#123; //获取ICO容器 ClassPathXmlApplicationContext ac = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); //获取bean BookDao bookDao = (BookDao) ac.getBean(&quot;bookDao&quot;); bookDao.save(); ac.registerShutdownHook(); &#125;&#125; 1234运行结果：init~~~BookDao~~~~~destroy~~~ close()和registerShutdownHook()的区别 将registerShutdownHook()放到上面： 12345678910public class App &#123; public static void main(String[] args) &#123; //获取ICO容器 ClassPathXmlApplicationContext ac = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); ac.registerShutdownHook(); //获取bean BookDao bookDao = (BookDao) ac.getBean(&quot;bookDao&quot;); bookDao.save(); &#125;&#125; 1234运行成功：init~~~BookDao~~~~~destroy~~~ 将close()放到上面： 12345678910public class App &#123; public static void main(String[] args) &#123; //获取ICO容器 ClassPathXmlApplicationContext ac = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); ac.close(); //获取bean BookDao bookDao = (BookDao) ac.getBean(&quot;bookDao&quot;); bookDao.save(); &#125;&#125; 123456运行结果：init~~~destroy~~~报错：BeanFactory not initialized or already closed - call &#x27;refresh&#x27; before accessing beans via the ApplicationContext BeanFactory没有被初始化或者已经被关闭了 运行失败！！ 或者通过接口的方式实现： BookServiceImpl类实现接口InitializingBean和DisposableBean的方法 1234567891011121314151617181920212223public class BookServiceImpl implements BookService, InitializingBean, DisposableBean &#123; private BookDao bookDao; public void setBookDao(BookDao bookDao) &#123; System.out.println(&quot;BookDao set~~~&quot;); this.bookDao = bookDao; &#125; public void save() &#123; bookDao.save(); &#125; @Override public void destroy() throws Exception &#123; System.out.println(&quot;service destroy~~~~&quot;); &#125; @Override public void afterPropertiesSet() throws Exception &#123; System.out.println(&quot;service init~~~~&quot;); &#125;&#125; 配置文件： 123456&lt;bean id=&quot;bookDao&quot; class=&quot;com.spring.dao.impl.BookDaoImpl&quot; init-method=&quot;init&quot; destroy-method=&quot;destroy&quot;/&gt;&lt;bean id=&quot;bookService&quot; class=&quot;com.spring.service.impl.BookServiceImpl&quot;&gt;&lt;property name=&quot;bookDao&quot; ref=&quot;bookDao&quot;/&gt;&lt;/bean&gt; 主函数运行： 12345678910public class App &#123; public static void main(String[] args) &#123; //获取ICO容器 ClassPathXmlApplicationContext ac = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); //获取bean BookDao bookDao = (BookDao) ac.getBean(&quot;bookDao&quot;); bookDao.save(); ac.registerShutdownHook(); &#125;&#125; 1234567运行结果：init~~~BookDao set~~~service init~~~~BookDao~~~~~service destroy~~~~destroy~~~ BookServiceImpl类中destroy()方法和afterPropertiesSet()方法被调用 并且setBookDao()方法之后才调用的afterPropertiesSet()方法 9.依赖注入方式向一个类传递数据的方式有：set方法、构造方法 9.1 setter注入 引用类型 在bean中定义引用类型属性并提供可访问的set方法 BookServiceImpl类中： 1234567public class BookServiceImpl implements BookService &#123; private BookDao bookDao; //提供相应的set的方法 public void setBookDao(BookDao bookDao) &#123; this.bookDao = bookDao; &#125;&#125; 在配置文件中使用property标签ref属性注入引用类型对象 12345&lt;bean id=&quot;bookDao&quot; class=&quot;com.spring.dao.impl.BookDaoImpl&quot;/&gt;&lt;bean id=&quot;bookService&quot; class=&quot;com.spring.service.impl.BookServiceImpl&quot;&gt; &lt;property name=&quot;bookDao&quot; ref=&quot;bookDao&quot;/&gt;&lt;/bean&gt; 简单类型 在bean中定义引用类型属性并提供可访问的set方法 BookDaoImpl类中： 1234567891011121314public class BookDaoImpl implements BookDao &#123; private String name; private int age; public void setName(String name) &#123; this.name = name; &#125; public void setAge(int age) &#123; this.age = age; &#125; public void save() &#123; System.out.println(&quot;BookDao~~~~~&quot;+&quot;姓名：&quot;+name+&quot;年龄：&quot;+age); &#125;&#125; 配置文件中，在property标签value属性注入简单类型数据 1234&lt;bean id=&quot;bookDao&quot; class=&quot;com.spring.dao.impl.BookDaoImpl&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;DaHuang&quot;/&gt; &lt;property name=&quot;age&quot; value=&quot;18&quot;/&gt;&lt;/bean&gt; 运行主函数： 12345678910public class App &#123; public static void main(String[] args) &#123; //获取ICO容器 ClassPathXmlApplicationContext ac = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); //获取bean BookDao bookDao = (BookDao) ac.getBean(&quot;bookDao&quot;); bookDao.save(); ac.registerShutdownHook(); &#125;&#125; 12运行结果：BookDao~~~~~姓名：DaHuang年龄：18 9.2 构造器注入 引用类型 在bean中定义引用类型属性并提供可访问的构造方法 12345678public class BookServiceImpl implements BookService &#123; private BookDao bookDao; public BookServiceImpl(BookDao bookDao) &#123; System.out.println(&quot;BookServiceImpl构造器运行~~~&quot;); this.bookDao = bookDao; &#125;&#125; 配置文件中，使用constructor-arg标签中的ref属性注入引用类型对象 12345678&lt;bean id=&quot;bookDao&quot; class=&quot;com.spring.dao.impl.BookDaoImpl&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;DaHuang&quot;/&gt; &lt;property name=&quot;age&quot; value=&quot;18&quot;/&gt; &lt;/bean&gt;&lt;bean id=&quot;bookService&quot; class=&quot;com.spring.service.impl.BookServiceImpl&quot;&gt; &lt;constructor-arg name=&quot;bookDao&quot; ref=&quot;bookDao&quot;/&gt;&lt;/bean&gt; 运行主函数： 123456789public class App &#123; public static void main(String[] args) &#123; //获取ICO容器 ClassPathXmlApplicationContext ac = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); //获取bean BookDao bookDao = (BookDao) ac.getBean(&quot;bookDao&quot;); bookDao.save(); &#125;&#125; 12运行结果：BookServiceImpl构造器运行~~~ 简单类型 BookDaoImpl类中： 123456789public class BookDaoImpl implements BookDao &#123; private String name; private int age; public BookDaoImpl(String name, int age) &#123; this.name = name; this.age = age; &#125;&#125; 配置文件中： 1234&lt;bean id=&quot;bookDao&quot; class=&quot;com.spring.dao.impl.BookDaoImpl&quot;&gt; &lt;constructor-arg name=&quot;name&quot; value=&quot;DaHei&quot;/&gt; &lt;constructor-arg name=&quot;age&quot; value=&quot;20&quot;/&gt;&lt;/bean&gt; 如果要更改BookDaoImpl类中的形参名字，还要更改配置文件中的name属性的名字； 存在形参与name属性名不耦合的问题。 constructor-arg标签还有type和index属性 type：形参的数据类型(存在多个同数据类型的形参，无法使用) index：形参的位置顺序 在配置文件中，使用index属性设置按形参位置顺序注入 1234&lt;bean id=&quot;bookDao&quot; class=&quot;com.spring.dao.impl.BookDaoImpl&quot;&gt; &lt;constructor-arg index=&quot;0&quot; value=&quot;DaHei&quot;/&gt; &lt;constructor-arg index=&quot;1&quot; value=&quot;20&quot;/&gt;&lt;/bean&gt; 运行主函数： 123456789public class App &#123; public static void main(String[] args) &#123; //获取ICO容器 ClassPathXmlApplicationContext ac = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); BookDao bookDao = (BookDao) ac.getBean(&quot;bookDao&quot;); bookDao.save(); &#125;&#125; 12运行结果：BookDao~~~~~姓名：DaHei年龄：20 9.3 依赖注入方式的选择 强制依赖使用构造器注入，使用setter注入有概率不注入导致null对象出现。 bean必须要的东西，要用构造器注入。因为构造器必须被执行，必须注入，否则报错 而setter方法可以执行也可以不执行，如果没有进行setter注入，会导致null对象 可选依赖使用setter注入进行，灵活性强。 setter注入可以执行也可以不执行 Spring框架倡导使用构造器。 第三方框架大多采用构造器注入的形式初始化数据，更加严谨 setter注入和构造器注入可以同时使用。 使用构造器完成强制依赖注入，使用setter注入完成可选依赖注入 自己开发的模块推荐使用setter注入 10.依赖自动装配IOC容器根据bean都依赖的资源在容器中自动查找并注入到bean中的过程称为自动装配 自动装配的方式： 按类型(常用) 按名称 按构造方法(不推荐) 不启用自动装配 10.1 按类型需要提供相应的setter方法 123456789public class BookServiceImpl implements BookService &#123; private BookDao bookDao; public void setBookDao(BookDao bookDao) &#123; System.out.println(&quot;BookDao set~~~&quot;); this.bookDao = bookDao; &#125;&#125; 配置文件中，要提前写好bookDao的bean否则无法装配， autowire属性设置为byTpye 通过类型自动装配 1234&lt;bean id=&quot;bookDao&quot; class=&quot;com.spring.dao.impl.BookDaoImpl&quot;/&gt;&lt;bean id=&quot;bookService&quot; class=&quot;com.spring.service.impl.BookServiceImpl&quot; autowire=&quot;byType&quot; /&gt; 主函数： 123456789public class App &#123; public static void main(String[] args) &#123; ClassPathXmlApplicationContext ac = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); BookService bookService = (BookService) ac.getBean(&quot;bookService&quot;); bookService.save(); &#125;&#125; 12运行结果：BookDao set~~~ 如果出现一下这种情况： 12345&lt;bean id=&quot;bookDao1&quot; class=&quot;com.spring.dao.impl.BookDaoImpl&quot;/&gt;&lt;bean id=&quot;bookDao2&quot; class=&quot;com.spring.dao.impl.BookDaoImpl&quot;/&gt;&lt;bean id=&quot;bookService&quot; class=&quot;com.spring.service.impl.BookServiceImpl&quot; autowire=&quot;byType&quot; /&gt; 出现了两个BookDao的bean，导致Spring无法区分了，这时就需要按名称装配 10.2 按名称123456789public class BookServiceImpl implements BookService &#123; private BookDao bookDao; public void setBookDao(BookDao bookDao) &#123; System.out.println(&quot;BookDao set~~~&quot;); this.bookDao = bookDao; &#125;&#125; 配置文件中，autowire属性设置为byName 通过名称自动装配 是通过BookServiceImpl类的变量名bookDao与配置文件的bean中id相同名称的进行绑定 12345&lt;bean id=&quot;bookDao&quot; class=&quot;com.spring.dao.impl.BookDaoImpl&quot;/&gt;&lt;bean id=&quot;bookDao2&quot; class=&quot;com.spring.dao.impl.BookDaoImpl&quot;/&gt;&lt;bean id=&quot;bookService&quot; class=&quot;com.spring.service.impl.BookServiceImpl&quot; autowire=&quot;ByName&quot; /&gt; 10.3 总结 自动装配用于引用类型依赖注入，不能对简单类型进行操作 使用按类型装配byType，必须保障容器中相同类型的bean唯一，推荐使用 使用按名称装配byName，必须保障容器中具有指定名称的bean，变量名要与配置耦合， 不推荐使用 自动装配优先级低于setter注入和构造器注入，同时出现时自动装配配置失效 11.集合注入123456789101112131415161718192021222324252627public class BookDaoImpl implements BookDao &#123; private int[] array; private List&lt;String&gt; list; private Set&lt;String&gt; set; private Map&lt;String, String&gt; map; private Properties properties; public void setArray(int[] array) &#123;this.array = array;&#125; public void setList(List&lt;String&gt; list) &#123;this.list = list;&#125; public void setSet(Set&lt;String&gt; set) &#123;this.set = set;&#125; public void setMap(Map&lt;String, String&gt; map) &#123;this.map = map;&#125; public void setProperties(Properties properties) &#123;this.properties = properties;&#125; public void save() &#123; System.out.println(&quot;BookDaoImpl&#123;&quot; + &quot;\\narray=&quot; + Arrays.toString(array) + &quot;, \\nlist=&quot; + list + &quot;, \\nset=&quot; + set + &quot;, \\nmap=&quot; + map + &quot;, \\nproperties=&quot; + properties + &#x27;&#125;&#x27;); &#125;&#125; 配置文件中： 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;bean id=&quot;bookDao&quot; class=&quot;com.spring.dao.impl.BookDaoImpl&quot;&gt; &lt;property name=&quot;array&quot; &gt; &lt;array&gt; &lt;value&gt;100&lt;/value&gt; &lt;value&gt;200&lt;/value&gt; &lt;value&gt;300&lt;/value&gt; &lt;/array&gt; &lt;/property&gt; &lt;property name=&quot;list&quot; &gt; &lt;list&gt; &lt;value&gt;唱&lt;/value&gt; &lt;value&gt;跳&lt;/value&gt; &lt;value&gt;Rap&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;property name=&quot;set&quot; &gt; &lt;set&gt; &lt;value&gt;唱&lt;/value&gt; &lt;value&gt;跳&lt;/value&gt; &lt;value&gt;Rap&lt;/value&gt; &lt;value&gt;Rap&lt;/value&gt; &lt;/set&gt; &lt;/property&gt; &lt;property name=&quot;map&quot; &gt; &lt;map&gt; &lt;entry key=&quot;county&quot; value=&quot;china&quot;/&gt; &lt;entry key=&quot;province&quot; value=&quot;tianjin&quot;/&gt; &lt;entry key=&quot;city&quot; value=&quot;baodi&quot;/&gt; &lt;/map&gt; &lt;/property&gt; &lt;property name=&quot;properties&quot;&gt; &lt;props&gt; &lt;prop key=&quot;county&quot;&gt;china&lt;/prop&gt; &lt;prop key=&quot;province&quot;&gt;tianjin&lt;/prop&gt; &lt;prop key=&quot;city&quot;&gt;baodi&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt; &lt;/bean&gt; 运行主函数： 12345678public class App &#123; public static void main(String[] args) &#123; ClassPathXmlApplicationContext ac = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); BookDao bookDao = (BookDao) ac.getBean(&quot;bookDao&quot;); bookDao.save(); &#125;&#125; 1234567运行结果：BookDaoImpl&#123;array=[100, 200, 300], list=[唱, 跳, Rap], set=[唱, 跳, Rap], map=&#123;county=china, province=tianjin, city=baodi&#125;, properties=&#123;province=tianjin, city=baodi, county=china&#125;&#125; 12.数据源对象管理在pom.xml导入druid坐标 12345678910&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.2.8&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8.0.28&lt;/version&gt;&lt;/dependency&gt; 配置文件中，管理DruidDataSouurce对象 123456&lt;bean id=&quot;dataSource&quot; class=&quot;com.alibaba.druid.pool.DruidDataSource&quot;&gt; &lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/demo&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;123456&quot;/&gt;&lt;/bean&gt; 运行主函数： 12345678910public class App &#123; public static void main(String[] args) &#123; //获取ICO容器 ClassPathXmlApplicationContext ac = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); DataSource dataSource = (DataSource) ac.getBean(&quot;dataSource&quot;); System.out.println(dataSource); &#125;&#125; 123456789101112运行结果：&#123; CreateTime:&quot;2022-06-24 22:27:03&quot;, ActiveCount:0, PoolingCount:0, CreateCount:0, DestroyCount:0, CloseCount:0, ConnectCount:0, Connections:[ ]&#125; 13.加载properties配置信息在rescource资源包中创建jdbc.properties文件： 1234567jdbc.driver=com.mysql.jdbc.Driverjdbc.url=jdbc:mysql://localhost:3306/demojdbc.username=rootjdbc.password=123456username=dahuangage=18 配置文件中: 在beans标签中开启context命名空间 使用context空间加载properties文件 12345678910111213141516171819202122232425262728293031&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot; http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt; &lt;!-- 1.开启context命名空间 --&gt; &lt;!-- 2.使用context空间加载properties文件 --&gt; &lt;context:property-placeholder location=&quot;jdbc.properties&quot; system-properties-mode=&quot;NEVER&quot;/&gt; &lt;bean id=&quot;dataSource&quot; class=&quot;com.alibaba.druid.pool.DruidDataSource&quot;&gt; &lt;!-- 使用占位符$&#123;&#125;读取properties中的属性 --&gt; &lt;property name=&quot;driverClassName&quot; value=&quot;$&#123;jdbc.driver&#125;&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;$&#123;jdbc.url&#125;&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;$&#123;jdbc.username&#125;&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot;/&gt; &lt;/bean&gt; &lt;bean id=&quot;bookDao&quot; class=&quot;com.spring.dao.impl.BookDaoImpl&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;$&#123;username&#125;&quot;/&gt; &lt;property name=&quot;age&quot; value=&quot;$&#123;age&#125;&quot;/&gt; &lt;/bean&gt;&lt;/beans&gt; 加载properties文件格式： 不加载系统属性： 12&lt;context:property-placeholder location=&quot;jdbc.properties&quot; system-properties-mode=&quot;NEVER&quot;/&gt; 加载多个properties文件： 1&lt;context:property-placeholder location=&quot;jdbc.properties, jdbc2.properties&quot;/&gt; 加载所有properties文件： 1&lt;context:property-placeholder location=&quot;*.properties&quot;/&gt; 加载properties文件标准格式： 1&lt;context:property-placeholder location=&quot;classpath:*.properties&quot;/&gt; 从类路径或jar包中搜索加载properties文件： 1&lt;context:property-placeholder location=&quot;classpath*:*.properties&quot;/&gt; 14.容器14.1 创建容器的几种方式 类路径下的加载配置文件 1ApplicationContext ac = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); 文件系统下加载的配置文件 1ApplicationContext ac = new ClassPathXmlApplicationContext(&quot;E:\\Java_Web\\Spring\\spring_01_IOC\\src\\main\\resources\\applicationContext.xml&quot;); 加载多个配置文件： 1ApplicationContext ac = new ClassPathXmlApplicationContext(&quot;applicationContext1.xml&quot;,&quot;applicationContext2.xml&quot;); 14.2 获取bean的几种方式 使用bean名称获取 1BookDao bookDao = (BookDao) ac.getBean(&quot;bookDao&quot;); 使用bean名称获取并指定类型 1BookDao bookDao = ac.getBean(&quot;bookDao&quot;,BookDao.class); 使用bean类型获取 1BookDao bookDao = ac.getBean(BookDao.class);//对应的容器中只能有一个该类型，唯一 14.3 容器类层次结构使用ctrl+H打开容器类的层次结构图： BeanFactory：是IOC容器的顶层接口，初始化BeanFactory对象时，加载的bean延迟加载 ApplicationContext：是Spring容器的核心接口，初始化时bean立即加载 ​ 提供基础的bean操作相关的方法，通过其他接口扩展其功能 ConfigurableApplicationContext：提供关闭容器功能 ClassPathXmlApplicationContext：常用实现类 14.4 BeanFactory初始化类路径加载配置文件： 12345678public class App &#123; public static void main(String[] args) &#123; Rescoure rescoure = new ClassPathRescoure(&quot;applicationContext.xml&quot;); BeanFactory bf = new XmlBeanFactory(rescoure); BookDao bookDao = bf.getBean(&quot;bookDao&quot;,BookDao.class); bookDao.save(); &#125;&#125; BeanFactory创建完毕后，所有bean均为延迟加载 15.注解开发*15.1 用注释定义bean123456@component(&quot;bookDao&quot;) //等价于&lt;bean id=&quot;bookDao&quot; class=&quot;com.spring.dao.impl.BookDaoImpl&quot;/&gt;public class BookDaoImpl implements BookDao &#123; public void save() &#123; System.out.println(&quot;BookDao~~~~~&quot;); &#125;&#125; 123456@Component //没有写bean名，要通过类型获取beanpublic class BookServiceImpl implements BookService &#123; public void save() &#123; System.out.println(&quot;BookService~~~~&quot;); &#125;&#125; 但是，Spring怎么感知到注释呢？ 配置文件中，需要添加扫描组件： 123456789101112&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot; http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt; &lt;!-- 扫描@component组件 --&gt; &lt;!-- base-package为扫描的位置 --&gt; &lt;context:component-scan base-package=&quot;com.spring&quot;/&gt;&lt;/beans&gt; 主函数： 123456789101112public class App &#123; public static void main(String[] args) &#123; //获取ICO容器 ClassPathXmlApplicationContext ac = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); //获取bean BookDao bookDao = (BookDao) ac.getBean(&quot;bookDao&quot;); bookDao.save(); //因为@component，并没有写bean名，所以要用类型获取bean BookService bookService = ac.getBean(BookService.class); bookService.save(); &#125;&#125; 123运行结果：BookDao~~~~~BookService~~~~ Spring提供@component注解的三个衍生注解 @Repository：用于数据层bean定义(Dao层) ​ 也可以加括号来指定bean名，如：@Repository(“bookDao2”) @Service：用于业务层bean定义(Service层) @Controller：用于表现层bean定义(Controller层) @Service,@Repository不能写在接口上,需要写在接口的实现类上 1234@Repositorypublic class BookDaoImpl implements BookDao &#123; &#125; 1234@Servicepublic class BookServiceImpl implements BookService &#123;&#125; 1234@Controllerpublic class BookController &#123;&#125; 15.2 纯注释开发新建一个SpringConfig类，用来替代配置文件。 其位置：com.spring.config.SpringConfig.java com包 spring包 config包 SpringConfig.java @Configuration ：用于设定当前类为配置类@ComponentScan(&quot;com.spring&quot;) ：用用于设定扫描路径，此注释只能添加一次，多个数据用数组格式 123456//用来替代 &lt;context:component-scan base-package=&quot;com.spring&quot;/&gt;@Configuration //用于设定当前类为配置类@ComponentScan(&quot;com.spring&quot;) //用用于设定扫描路径，此注释只能添加一次，多个数据用数组格式public class SpringConfig &#123; &#125; 主函数： 1234567891011public class AppForAnnotation &#123; public static void main(String[] args) &#123; //改用注释配置初始化容器 ApplicationContext ac = new AnnotationConfigApplicationContext(SpringConfig.class); BookDao bookDao = ac.getBean(BookDao.class); bookDao.save(); BookService bookService = ac.getBean(BookService.class); bookService.save(); &#125;&#125; 123运行结果：BookDao~~~~~BookService~~~~ 15.3 bean管理 作用范围 @Scope(&quot;singleton&quot;)：单例，默认单例 @Scope(&quot;prototype&quot;)：多例 bean生命周期控制 @PostConstruct注解：init @PreDestroy注解：destory 123456789101112@Repository@Scope(&quot;prototype&quot;) //多例public class BookDaoImpl implements BookDao &#123; @PostConstruct public void init()&#123; System.out.println(&quot;init~~~&quot;); &#125; @PreDestroy public void destroy()&#123; System.out.println(&quot;destroy~~~&quot;); &#125;&#125; 15.4 依赖注入1.引用类型 1234567891011@Servicepublic class BookServiceImpl implements BookService &#123; @Autowired private BookDao bookDao; public void save() &#123; System.out.println(&quot;BookService~~~~&quot;); bookDao.save(); &#125;&#125; 主函数： 12345678public class AppForAnnotation &#123; public static void main(String[] args) &#123; ApplicationContext ac = new AnnotationConfigApplicationContext(SpringConfig.class); BookService bookService = ac.getBean(BookService.class); bookService.save(); &#125;&#125; 123运行结果：BookService~~~~ //在创建好BookService的bean,并注入BookDaoBookDao~~~~~ //调用BookDao的方法save(); 123@Repository(&quot;bookDao&quot;)public class BookDaoImpl implements BookDao &#123;&#125; 123@Repository(&quot;bookDao2&quot;)public class BookDaoImpl2 implements BookDao &#123;&#125; 当有多个同类型的bean，使用@Qualifier(&quot;bookDao2&quot;)来指定bean名 并且需要@Autowired和@Qualifier(&quot;bookDao2&quot;)一起使用 1234567891011@Servicepublic class BookServiceImpl implements BookService &#123; @Autowired @Qualifier(&quot;bookDao2&quot;) private BookDao bookDao; public void save() &#123; System.out.println(&quot;BookService~~~~&quot;); bookDao.save(); &#125;&#125; 注意： 自动装配基于反射设计创建对象并暴力反射对应属性为私有属性初始化数据，无需提供setter方法 自动装配建议使用无参构造方法创建对象，如果不提供对应的构造方法，请提供唯一的构造方法 @Qualifier注解无法单独使用，必须配合@Autowired注解使用 2.简单类型 123456789@Repositorypublic class BookDaoImpl implements BookDao &#123; @Value(&quot;dahuang&quot;) private String name; public void save()&#123; System.out.println(&quot;BookDao~~~~~&quot;+&quot;姓名：&quot;+name); &#125;&#125; 主函数： 1234567public class AppForAnnotation &#123; public static void main(String[] args) &#123; ApplicationContext ac = new AnnotationConfigApplicationContext(SpringConfig.class); BookDao bookDao = ac.getBean(BookDao.class); bookDao.save(); &#125;&#125; 12运行结果：BookDao~~~~~姓名：dahaung 但是，我们为什么不直接赋值，为什么要用@Value注解呢？ 我们可以用properties文件，向其传值。 3.读取properties文件 通过创建一个jdbc.properties文件： 1name=dahei 在配置类中新加注解@PropertySource()，括号中指定文件名： 如：@PropertySource(&quot;jdbc.properties&quot;)或者@PropertySource(&quot;classpath:jdbc.properties&quot;) 也可以指定多个文件： 如：@PropertySource(&#123;&quot;jdbc.properties&quot;,&quot;jdbc1.properties&quot;,&quot;jdbc2.properties&quot;&#125;) 12345@Configuration@ComponentScan(&quot;com.spring&quot;)@PropertySource(&quot;jdbc.properties&quot;)public class SpringConfig &#123;&#125; 在BookDaoImpl中将注解改为：@Value(&quot;$&#123;&#125;&quot;)，在&#123;&#125;中填入properties文件中的属性 如：@Value(&quot;$&#123;name&#125;&quot;) 123456789@Repositorypublic class BookDaoImpl implements BookDao &#123; @Value(&quot;$&#123;name&#125;&quot;) private String name; public void save()&#123; System.out.println(&quot;BookDao~~~~~&quot;+&quot;姓名：&quot;+name); &#125;&#125; 15.5 第三方bean管理1.使用独立的配置管理第三方bean 1234567891011121314@Configurationpublic class SpringConfig &#123; //定义一个方法获得想要管理的bean @Bean // 表示当前方法返回值是一个bean public DruidDataSource dataSource()&#123; DruidDataSource ds = new DruidDataSource(); //相关配置 ds.setDriverClassName(&quot;com.mysql.jdbc.Driver&quot;); ds.setUrl(&quot;jdbc:mysql://localhost:3306/demo&quot;); ds.getUsername(&quot;root&quot;); ds.setPassword(&quot;123456&quot;); return ds; &#125;&#125; 但是不建议将独立配置直接写在核心配置类中： 方法一：导入式(建议使用) 在config包创建一个JdbcConfig.java配置类： 12345678910111213public class JdbcConfig &#123; //定义一个方法获得想要管理的bean @Bean // 表示当前方法返回值是一个bean public DruidDataSource dataSource()&#123; DruidDataSource ds = new DruidDataSource(); //相关配置 ds.setDriverClassName(&quot;com.mysql.jdbc.Driver&quot;); ds.setUrl(&quot;jdbc:mysql://localhost:3306/demo&quot;); ds.setUsername(&quot;root&quot;); ds.setPassword(&quot;123456&quot;); return ds; &#125;&#125; 在SpringConfig.java核心配置类中导入： 使用注解@Import()在括号中添加要导入的配置类的类型 如：@Import(JdbcConfig.class) 此注解只能添加一次，导入多个配置类，可以使用数组格式导入 如：@Import(&#123;JdbcConfig.class, XXXConfig.class, XXXConfig.calss&#125;) 12345@Configuration@Import(JdbcConfig.class) //导入JdbcConfigpeipublic class SpringConfig &#123; &#125; 方式二：扫描式(不建议使用) 注意：使用扫描式需要在独立的配置类加入注解@Configuration 1234567891011121314@Configurationpublic class JdbcConfig &#123; //定义一个方法获得想要管理的bean @Bean // 表示当前方法返回值是一个bean public DataSource dataSource()&#123; DruidDataSource ds = new DruidDataSource(); //相关配置 ds.setDriverClassName(&quot;com.mysql.jdbc.Driver&quot;); ds.setUrl(&quot;jdbc:mysql://localhost:3306/demo&quot;); ds.setUsername(&quot;root&quot;); ds.setPassword(&quot;123456&quot;); return ds; &#125;&#125; 在SpringConfig.java核心配置类中扫描： 使用注解@ComponentScan()在括号中添加要扫描的路径 如：@@ComponentScan(&quot;com.spring.config&quot;) 扫描多个路径，可以使用数组格式导入 如：@Import(&#123;&quot;com.spring.config&quot;,&quot;com.spring.dao&quot;&#125;) 12345@Configuration@ComponentScan(&quot;com.spring.config&quot;)public class SpringConfig &#123; &#125; 2.第三方bean注入资源 简单类型依赖注入(成员变量)： 利用注解@PropertySource(&quot;jdbc.properties&quot;)和@Import(JdbcConfig.class)导入核心主配置文件中 123456@Configuration@ComponentScan(&quot;com.spring&quot;)@PropertySource(&quot;jdbc.properties&quot;)@Import(JdbcConfig.class)public class SpringConfig &#123;&#125; 利用注解@Value(&quot;$&#123;&#125;&quot;)注入数据 12345678910111213141516171819202122public class JdbcConfig &#123; @Value(&quot;$&#123;jdbc.driver&#125;&quot;) private String driver; @Value(&quot;$&#123;jdbc.url&#125;&quot;) private String url; @Value(&quot;$&#123;jdbc.username&#125;&quot;) private String userName; @Value(&quot;$&#123;jdbc.password&#125;&quot;) private String password; //定义一个方法获得想要管理的bean @Bean // 表示当前方法返回值是一个bean public DataSource dataSource()&#123; DruidDataSource ds = new DruidDataSource(); ds.setDriverClassName(driver); ds.setUrl(url); ds.setUsername(userName); ds.setPassword(password); return ds; &#125;&#125; 引入类型依赖注入(方法形参)： 引用类型注入只需要为bean定义的方法设置形参，容器会根据类型自动装配对象 123456789//定义一个方法获得想要管理的bean @Bean // 表示当前方法返回值是一个bean public DataSource dataSource(BookDao bookDao)&#123; System.out.println(&quot;已引用：&quot;+bookDao); DruidDataSource ds = new DruidDataSource(); //对ds进行相关设置 return ds; &#125; 15.6 总结XML配置与注解配置的比较： 功能 XML配置 注解 定义bean bean标签：&gt;id属性&gt;class属性 @Component &gt;@Controller &gt;@Service &gt;@Repository@ComponentScan 设置依赖注入 setter注入(set方法)&gt;引用&#x2F;简单构造器注入(构造方法)&gt;自动装配 @Autowird&gt;@Qualifier@Value 配置第三方bean bean标签&gt;静态工厂&gt;实例工厂&gt;FactoryBean @Bean 作用范围 scope属性 @Scope 生命周期 标准接口&gt;init-method&gt;destory-method @PostConstructor@PreDestroy 16.AOP16.1 AOP简介 AOP(Aspect Oriented Programming)面向切面编程，一种编程范式，指导开发者如何组织程序结构 OOP(Object Oriented Programing)面向对象编程 作用：在不惊动原始设计的基础上为其进行功能增强 Spring理念：无入侵式&#x2F;无侵入式 执行save()方法 运行结果： 打印出一万次的book dao save … 和消耗的时间 执行update()方法没有图中蓝色区域的代码， 但是，运行结果： 仍会打印打印出一万次的book dao update … 和消耗的时间 连接点(JoinPoint)：程序执行过程中的任意位置，粒度为执行方法，抛出异常，设置变量等(代表所有的方法) 在SpringAOP中，理解方法的执行 切入点(Pointcut)：匹配连接点的式子(代表要追加功能的方法) 在SpringAOP中，一个切入点只描述一个具体方法，也可以匹配多个方法 一个具体方法：com.spring.dao包下的BookDao接口中的五星参无返回值的save()方法 匹配多个方法：所有save方法，所有的get开头的方法，所有以Dao结尾的接口中的任意方法，所有带有一个形参的方法 通知(Advice)：在切入点执行的操作，也就是共性功能(代表追加的功能) 在SpringAOP中，功能最终以方法的形式呈现 通知类：定义通知的类 切面(Aspect)：描述通知与切入的对应关系 16.2 AOP入门 案例设定：测试接口执行效率 简化设定：在接口执行当前输出当前的系统时间 开发模式：XML or 注解(此入门案例采用注解的方式) 思路分析： 导入坐标(pom.xml) 制作连接点方法(原始操作，Dao接口与实现类) 制作共性功能(通知类与通知) 定义切入点 绑定切入点与通知关系(切面) pom.xml： 1234567891011&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;5.3.18&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;version&gt;1.9.9.1&lt;/version&gt;&lt;/dependency&gt; 创建一个MyAdivice.java类 其位置：com.spring.aop.MyAdivice.java @Component注解：定义为Spring加载的bean @Aspect注解：把当前类标识为⼀个切⾯供容器读取 @Pointcut(&quot;execution()&quot;)注解：定义切入点，⽅法签名必须是public及void型。 @Before(&quot;pt()&quot;)注解：标识⼀个前置增强⽅法 切入点pt()的定义依托一个不具有实际意义的方法进行，即无参数、无返回值、方法无实际逻辑 1234567891011@Component@Aspectpublic class MyAdvice &#123; @Pointcut(&quot;execution(void com.spring.dao.BookDao.update())&quot;) private void pt()&#123;&#125; @Before(&quot;pt()&quot;) public void method()&#123; System.out.println(System.currentTimeMillis()); &#125;&#125; @EnableAspectJAutoProxy注解：开启AOP代理自动配置 123456@Configuration@ComponentScan(&quot;com.spring&quot;)@EnableAspectJAutoProxypublic class SpringConfig &#123;&#125; 主函数： 1234567public class App &#123; public static void main(String[] args) &#123; ApplicationContext ac = new AnnotationConfigApplicationContext(SpringConfig.class); BookDao bookDao = ac.getBean(BookDao.class); bookDao.update(); &#125;&#125; 123运行结果：1656341601464book dao update~~~ 16.3 AOP工作流程 Spring容器启动 读取所有切面配置中的切入点 初始化bean，判定bean对应的类中的方法是否匹配到任意切入点 匹配失败，创建对象 获取bean，调用方法并执行，完成操作 匹配成功，调用方法并执行，完成操作 获取的bean是代理对象时，根据代理对象的运行模式运行原始方法与增强内容，完成操作 AOP核心本质：代理模式 目标对象(Target)：原始功能去掉共性功能对应的类产生的对象，这种对象是无法直接完成最终工作的 代理(proxy)：目标对象无法直接完成工作，需要进行功能回填，通过原始对象的代理对象实现 代码依旧是入门案例的 但是将主函数修改，打印bookDao的类型： 12345678public class App &#123; public static void main(String[] args) &#123; ApplicationContext ac = new AnnotationConfigApplicationContext(SpringConfig.class); BookDao bookDao = ac.getBean(BookDao.class); System.out.println(bookDao); System.out.println(bookDao.getClass()); &#125;&#125; 123运行结果：com.spring.dao.impl.BookDaoImpl@d23e042class jdk.proxy2.$Proxy20 System.out.println(bookDao)打印出com.spring.dao.impl.BookDaoImpl@d23e042 是因为AOP对BookDao的toString()方法进行了重写 class jdk.proxy2.$Proxy20：最终用的是代理的对象 16.4 AOP切入点表达式切入点：要进行增强的方法 切入点表达式：要进行增强的方法的描述方法 1.语法格式 切入点标准格式：动作关键字(访问修饰符 返回值 包名.接口/类名.方法(参数) 异常名) 12execution(public User com.spring.service.UserService.findById(int))execution(public User com.spring.service.impl.UserServiceImpl.findById(int)) 动作关键字：描述切入点行为动作，如execution表示执行到指定切入点 访问修饰符：public，private等，可以省略 返回值 包名 接口&#x2F;类名：接口名或者类名都可以 方法名 参数 异常名：方法定义中抛出指定异常，可以省略 2.通配符 可以使用通配符描述切入点，快速描述 *：单个独立的任意符号，可以独立出现，也可以作为前缀或者后缀的匹配符出现 1execution(public * com.spring.*.UserService.find*(*)) 解释：匹配com.spring包下的任意包中含有UserService类或接口中所有含有find开头的带有任意一个参数的方法 ..：多个连续的任意符号，可以独立出现，常用于简化包名与参数的书写 1execution(public User com..UserService.findById(..)) 解释：匹配com包中的任意包中的UserService类或接口中的所有名称为findById的方法 +：专用于匹配子类类型 1execution(* *..*Service+.*(..)) 解释：匹配·任意包下的以Service结尾的类或接口的子类中业务层的所有方法 常用写法 1execution(* com.spring.*.*Service.save(..)) 解释：匹配业务层所有的名为save的方法 3.书写技巧 所有代码按照标准规范开发，否则一下技巧全部失效 描述切入点通常描述接口，而不描述实现类 访问控制修饰符针对接口开发均采用public描述(可省略) 返回值类型对应增删改类使用精准类型加速匹配，对于查询类返回值使用*通配符快速描述 包名书写尽量不使用..匹配，效率过低，常用*做单个包描述匹配，或精准匹配 接口名&#x2F;类名书写名称与模块的采用*匹配 如：UserService书写成*Service，绑定业务层接口名 方法名书写以动词进行精准匹配，名词采用*匹配 如：getById书写成getBy*，selectAll书写成selectAll 参数规则较为复杂，根据业务方法灵活调整 通常不使用异常作为匹配规则 16.5 AOP通知类型AOP通知描述了抽取的共性功能，根据共性功能抽取的位置不同，最终运行代码时要将其加入到合理的位置 AOP通知共分为5钟类型 前置通知 1234567891011@Component@Aspectpublic class MyAdvice &#123; @Pointcut(&quot;execution(void com.spring.dao.BookDao.update())&quot;) private void pt()&#123;&#125; @Before(&quot;pt()&quot;) public void method()&#123; System.out.println(&quot;before~~~&quot;); &#125;&#125; 123运行结果：before~~~book dao update~~~ 后置通知 ​ 1234567891011@Component@Aspectpublic class MyAdvice &#123; @Pointcut(&quot;execution(void com.spring.dao.BookDao.update())&quot;) private void pt()&#123;&#125; @Before(&quot;pt()&quot;) public void method()&#123; System.out.println(&quot;after~~~&quot;); &#125;&#125; 123运行结果：book dao update~~~after~~~ 环绕通知(重点) 1.无返回值 1234567891011121314@Component@Aspectpublic class MyAdvice &#123; @Pointcut(&quot;execution(void com.spring.dao.BookDao.update())&quot;) private void pt()&#123;&#125; @Around(&quot;pt()&quot;) public void method(ProceedingJoinPoint pjp) throws Throwable &#123; System.out.println(&quot;before~~~&quot;); //表示对原始操作的调用 pjp.proceed(); System.out.println(&quot;after~~~&quot;); &#125;&#125; 1234运行结果：before~~~book dao update~~~after~~~ 2.有返回值 在BookDaoImpl中新写一个有返回值的select方法 12345678@Repositorypublic class BookDaoImpl implements BookDao &#123; @Override public int select() &#123; System.out.println(&quot;book dao select~~~&quot;); return 100; &#125;&#125; 123456789101112131415@Component@Aspectpublic class MyAdvice &#123; @Pointcut(&quot;execution(void com.spring.dao.BookDao.select())&quot;) private void pt()&#123;&#125; @Around(&quot;pt()&quot;) public Object method(ProceedingJoinPoint pjp) throws Throwable &#123; System.out.println(&quot;before~~~&quot;); //表示对原始操作的调用，并获得返回值 Object ret = pjp.proceed(); System.out.println(&quot;after~~~&quot;); return ret; &#125;&#125; 主函数： 12345678public class App &#123; public static void main(String[] args) &#123; ApplicationContext ac = new AnnotationConfigApplicationContext(SpringConfig.class); BookDao bookDao = ac.getBean(BookDao.class); int num = bookDao.select(); System.out.println(num); &#125;&#125; 12345运行结果：before~~~book dao select~~~after~~~100 并且有无返回值都建议这样的写法： 1234567@Around(&quot;pt()&quot;) public Object method(ProceedingJoinPoint pjp) throws Throwable &#123; System.out.println(&quot;before~~~&quot;); Object ret = pjp.proceed(); System.out.println(&quot;after~~~&quot;); return ret; &#125; @Around注意事项 环绕通知必须依赖形参ProceedingJoinPoint才能实现对原始方法的调用 ,进而实现原始方法调用前后同时添加通知 通知中如果未使用ProceedingJoinPoint对原始方法进行调用将跳过原始方法的执行 对原始方法的调用可以不接收返回值 ,通知方法设置成void即可, 如果接收返回值, 必须设定为Object类型 原始方法的返回值如果 是void类型,通知方法的返回值类型可以设置成void ,也可以设置成Object 由于无法预知原始方法运行后是否会抛出异常 ,因此环绕通知方法必须抛出Throwable对象 返回后通知(了解) 1234567891011@Component@Aspectpublic class MyAdvice &#123; @Pointcut(&quot;execution(int com.spring.dao.BookDao.select())&quot;) private void pt()&#123;&#125; @AfterReturning(&quot;pt()&quot;) public void method()&#123; System.out.println(&quot;afterReturn~~~&quot;); &#125;&#125; 1234运行结果：book dao select~~~afterReturn~~~100 @after和@AfterReturning的区别： 原始方法有异常时： @after也会打印通知的方法 @AfterReturning不会打印通知的方法 抛出异常后通知(了解) 1234567891011@Component@Aspectpublic class MyAdvice &#123; @Pointcut(&quot;execution(int com.spring.dao.BookDao.select())&quot;) private void pt()&#123;&#125; @AfterThrowing(&quot;pt()&quot;) public void method()&#123; System.out.println(&quot;afterThrowing~~~&quot;); &#125;&#125; 123运行结果：book dao select~~~100 @AfterThrowing注解：只有原始方法抛出异常，才会执行通知的方法 16.6 AOP通知获取数据 获取切入点方法的参数 JoinPoint：适用于前置、后置、返回后、抛出异常后通知 ProceedJointPoint：适用于环绕通知 获取切入点方法返回值 返回后通知 环绕通知 获取切入点方法运行异常信息 抛出异常后通知 环绕通知 123456789@Repositorypublic class BookDaoImpl implements BookDao &#123; @Override public int select(int id, String name) &#123; System.out.println(&quot;book dao select~~~&quot;); System.out.println(&quot;id:&quot;+id+&quot; name:&quot;+name); return 100; &#125;&#125; AOP通知获取参数数据 joinPoint对象描述了连接点方法的运行状态，可以获取到原始方法的调用参数 1234567891011121314@Component@Aspectpublic class MyAdvice &#123; @Pointcut(&quot;execution(int com.spring.dao.BookDao.select(..))&quot;) private void pt()&#123;&#125; @Before(&quot;pt()&quot;) public void method(JoinPoint jp)&#123; Object[] args = jp.getArgs(); System.out.println(Arrays.toString(args)); &#125;&#125; 主函数调用select方法： 1234567public class App &#123; public static void main(String[] args) &#123; ApplicationContext ac = new AnnotationConfigApplicationContext(SpringConfig.class); BookDao bookDao = ac.getBean(BookDao.class); bookDao.select(100, &quot;dahuang&quot;); &#125;&#125; 123运行结果：[100, dahuang]book dao select~~~ ProceedingJoinPoint是JoinPoint的子类 12345678@Around(&quot;pt()&quot;) public Object method(ProceedingJoinPoint pjp) throws Throwable &#123; Object[] args = pjp.getArgs(); System.out.println(Arrays.toString(args)); args[0] = 666; Object ret = pjp.proceed(args); return ret; &#125; 1234运行结果：[100, dahuang]book dao select~~~id:666 name:dahuang AOP通知获取返回数据 抛出异常后通知可以获取切入点方法中出现的异常信息，使用形参可以接收对应的异常对象 1234@AfterReturning(value = &quot;pt()&quot;, returning = &quot;ret&quot;)public void method(JoinPoint jp, int ret)&#123; System.out.println(&quot;afterReturn~~~&quot;+ret);&#125; 环绕通知中可以手工书写对原始方法的调用，得到的结果即为原始方法的返回值 12345@Around(&quot;pt()&quot;) public Object method(ProceedingJoinPoint pjp) throws Throwable &#123; Object ret = pjp.proceed(); return ret; &#125; AOP通知获取异常数据(了解) 抛出异常后通知可以获取切入点方法中出现的异常信息，使用形参可以接收对应的异常对象 1234@AfterThrowing(value = &quot;pt()&quot;, throwing = &quot;t&quot;)public void method(JoinPoint jp, Throwable t)&#123; System.out.println(&quot;afterThrowing~~~&quot;+t);&#125; 抛出异常后通知可以获取切入点方法运行的异常信息，使用形参可以接收运行时抛出的异常对象 1234567891011@Around(&quot;pt()&quot;) public Object method(ProceedingJoinPoint pjp) throws Throwable &#123; Object ret = null; try&#123; ret = pjp.proceed(); &#125; catch(Throwable t)&#123; t.printStackTrace(); &#125; return ret; &#125; 16.7 AOP总结1.基本概念： 概念：AOP(Aspect Oriented Programming) 面向切面编程，一种编程范式 作用：在不惊动原始设计的基础上为方法进行功能增强 核心概念 代理(Proxy)：SpringAOP的核心本质是采用代理模式实现的 连接点(JoinPoint )：在SpringAOP中 ,理解为任意方法的执行 切入点( Pointcut )：匹配连接点的式子,也是具有共性功能的方法描述 通知(Advice)：若干个方法的共性功能,在切入点处执行,最终体现为-一个方法 切面( Aspect )：描述通知与切入点的对应关系 目标对象 ( Target )：被代理的原始对象成为目标对象 2.切入点： 切入点表达式标准格式： 动作关键字(访问修饰符 返回值 包名.类&#x2F;接口名.方法名(参数) 异常名) execution(* com.spring.service.*Service.*(..)) 切入点表达式描述通配符： 作用: 用于快速描述,范围描述 *：匹配任意符号(常用) ..：匹配多个连续的任意符号(常用) +：匹配子类类型 切入点表达式书写技巧 按标准规范开发 查询操作的返回值建议使用*匹配 减少使用..的形式描述包 对接口进行描述,使用*表示模块名,例如UserService的匹配描述为*Service 方法名书写保留动词,例如get ,使用*表示名词,例如getById匹配描述为getBy* 参数根据实际情况灵活调整 3.通知类型： 前置通知 后置通知 环绕通知(重点) 环绕通知依赖形参ProceedingJoinPoint才能实现对原始方法的调用 环绕通知可以隔离原始方法的调用执行 环绕通知返回值设置为0bject类型 环绕通知中可以对原始方法调用过程中出现的异常进行处理 返回后通知 抛出异常后通知 4.通知获取数据： 获取切入点方法的参数 JoinPoint：适用于前置、后置、返回后、抛出异常后通知,设置为方法的第一个形参 ProceedJointPoint：适用于环绕通知 获取切入点方法返回值 返回后通知 . 环绕通知 获取切入点方法运行异常信息 抛出异常后通知 环绕通知 17.Spring事务17.1 Spring事务简介事务作用：在数据层保障一系列的数据库操作同成功同失败 Spring事务作用：在数据层或业务层保障一系列的数据库操作同成功同失败 案例：银行转账 需求:实现任意两个账户间转账操作 需求微缩: A账户减钱, B账户加钱 分析: ①数据层提供基础操作, 指定账户减钱( outMoney ) , 指定账户加钱( inMoney ) ②业务层提供转账操作( transfer ) , 调用减钱与加钱的操作 ③提供2个账号和操作金额执行转账操作 ④基于Spring整合MyBatis环境搭建上述操作 JDK版本：8 项目结构： pom.xml 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;5.2.10.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.1.16&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.5.6&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.47&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;5.2.10.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt; &lt;version&gt;1.3.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;5.2.10.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; com.spring.config包下： JdbcConfig 12345678910111213141516171819202122232425262728public class JdbcConfig &#123; @Value(&quot;$&#123;jdbc.driver&#125;&quot;) private String driver; @Value(&quot;$&#123;jdbc.url&#125;&quot;) private String url; @Value(&quot;$&#123;jdbc.username&#125;&quot;) private String userName; @Value(&quot;$&#123;jdbc.password&#125;&quot;) private String password; @Bean public DataSource dataSource()&#123; DruidDataSource ds = new DruidDataSource(); ds.setDriverClassName(driver); ds.setUrl(url); ds.setUsername(userName); ds.setPassword(password); return ds; &#125; //配置事务管理器，mybatis使用的是jdbc事务 @Bean public PlatformTransactionManager transactionManager(DataSource dataSource)&#123; DataSourceTransactionManager transactionManager = new DataSourceTransactionManager(); transactionManager.setDataSource(dataSource); return transactionManager; &#125;&#125; MybatisConfig 1234567891011121314151617public class MybatisConfig &#123; @Bean public SqlSessionFactoryBean sqlSessionFactory(DataSource dataSource)&#123; SqlSessionFactoryBean ssfb = new SqlSessionFactoryBean(); ssfb.setTypeAliasesPackage(&quot;com.itheima.p&quot;); ssfb.setDataSource(dataSource); return ssfb; &#125; @Bean public MapperScannerConfigurer mapperScannerConfigurer()&#123; MapperScannerConfigurer msc = new MapperScannerConfigurer(); msc.setBasePackage(&quot;com.itheima.dao&quot;); return msc; &#125;&#125; 核心配置类：SpringConfig 12345678@Configuration@ComponentScan(&quot;com.itheima&quot;)@PropertySource(&quot;classpath:jdbc.properties&quot;)@Import(&#123;JdbcConfig.class,MybatisConfig.class&#125;)//开启注解式事务驱动@EnableTransactionManagementpublic class SpringConfig &#123;&#125; Account 123456789101112131415161718192021222324252627282930313233343536373839public class Account implements Serializable &#123; private Integer id; private String name; private Double money; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public Double getMoney() &#123; return money; &#125; public void setMoney(Double money) &#123; this.money = money; &#125; @Override public String toString() &#123; return &quot;Account&#123;&quot; + &quot;id=&quot; + id + &quot;, name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &quot;, money=&quot; + money + &#x27;&#125;&#x27;; &#125;&#125; com.spring.dao包下： AccountDao 12345678public interface AccountDao &#123; @Update(&quot;update demo.account set money = money + #&#123;money&#125; where name = #&#123;name&#125;&quot;) void inMoney(@Param(&quot;name&quot;) String name, @Param(&quot;money&quot;) Double money); @Update(&quot;update demo.account set money = money - #&#123;money&#125; where name = #&#123;name&#125;&quot;) void outMoney(@Param(&quot;name&quot;) String name, @Param(&quot;money&quot;) Double money);&#125; AccountService 12345public interface AccountService &#123; //配置当前接口方法具有事务 @Transactional public void transfer(String out,String in ,Double money) ;&#125; AccountServiceImpl 12345678910@Servicepublic class AccountServiceImpl implements AccountService &#123; @Autowired private AccountDao accountDao; public void transfer(String out,String in ,Double money) &#123; accountDao.outMoney(out,money); accountDao.inMoney(in,money); &#125;&#125; 测试类：AccountServiceTest 1234567891011@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(classes = SpringConfig.class)public class AccountServiceTest &#123; @Autowired private AccountService accountService; @Test public void testTransfer() throws IOException &#123; accountService.transfer(&quot;Tom&quot;,&quot;Jerry&quot;,100D); &#125;&#125; 17.2 Spring事务角色事务角色 事务管理员：发起事务方，在Spring中通常代指业务层开启事务的方法 事务协调员：加入事务方，在Spring中通常代指数据层方法，也可以是业务层的方法 17.3 Spring事务属性 属性 作用 示例 readOnly 设置是否为只读事务 readOnly&#x3D;true 只读事务 timeout 设置事务超时时间 timeout&#x3D;-1 永不超时 rollbackFor 设置事务回滚异常(class) rollbackFor&#x3D;{NullPointException.class} rollbackForClassName 设置事务回滚异常(String) 同上字符串格式 noRollbackFor 设置事务不回滚异常(class) norollbackFor&#x3D;{NullPointException.class} noRollbackForClassName 设置事务不回滚异常(String) 同上字符串格式 propagation 设置事务传播行为 ….. 12345678910111213@Servicepublic class AccountServiceImpl implements AccountService &#123; @Autowired private AccountDao accountDao; @Override public void transfer(String out, String in, Double money) throws IOException &#123; accountDao.outMoney(out,money); //添加IOException类型错误 if(true) throw new IOException(); accountDao.inMoney(in,money); &#125;&#125; 运行后，报错，outMoney方法执行了，但inMoney方法没有执行。 并不是所有错误类型都会回滚， 我们希望transfer方法，调用的事务同失败。 在@Transactional注解中的属性rollbackFor添加错误的类型： 12345public interface AccountService &#123; @Transactional(rollbackFor = &#123;IOException.class&#125;) void transfer(String out, String in, Double money) throws IOException;&#125; 再次运行后，报错，outMoney和inMoney方法都没有执行 案例：转账业务追加日志 需求:实现任意两个账户间转账操作,并对每次转账操作在数据库进行留痕 需求微缩: A账户减钱, B账户加钱,数据库记录日志 分析: ①:基于转账操作案例添加日志模块,实现数据库中记录日志 ②:业务层转账操作( transfer ) ,调用减钱、加钱与记录日志功能 实现效果预期： ​ 无论转账操作是否成功,均进行转账操作的日志留痕 123456789101112131415161718192021@Servicepublic class AccountServiceImpl implements AccountService &#123; @Autowired private AccountDao accountDao; @Autowired private LogService logService; @Override public void transfer(String out, String in, Double money) throws IOException &#123; try&#123; accountDao.outMoney(out,money); int i = 1/0; accountDao.inMoney(in,money); &#125; finally&#123; logService.log(out,in,money); &#125; &#125;&#125; 运行后，outMoney方法和inMoney方法进行回滚，同时log方法也进行了回滚，未将日志记录到数据库中 存在问题： 日志的记录与转账操作隶属同一个事务，同成功同失败 事务传播行为：事务协调员对事物管理员所携带事务的处理态度 在业务层接口添加Spring事务， @Transactional注解中的propagation属性设置事务传播行为REQIRES_NEW(需要新事务) 123456@Servicepublic interface LogService &#123; //设置为新事务 @Transactional(propagation=Propagation.REQIRES_NEW) public void log(String out, String in, Double money);&#125; 运行后，outMoney方法和inMoney方法进行回滚，事务成功。 log方法执行，将日志记录到数据库中 传播属性 事务管理员 事务协调员 REQUIRED(默认) 开启T 加入T 无 新建T2 REQUIRES_NEW 开启T 新建T2 无 新建T2 SUPPORTS 开启T 加入T 无 无 NOT_SUPPORTED 开启T 无 无 无 MANDATORY 开启T 加入T 无 ERROR NEVER 开启T ERROR 无 无 NESTED 设置savePoint，一旦事务回滚，事务将回滚到savePoint处，交由客户端提交/回滚 ​ 18.结语你竟然看完了(不敢相信！！)，真的人会看吗！真的吗！ゞ◎Д◎ヾ 本人也是初学Spring，笔记中如果有什么遗漏或错误的地方欢迎大佬指正（≧∀≦） 本人QQ：2691936018 备注：Spring 另外关于Spring框架，如果有新的内容需要补充，本人也会进行更新的 本笔记的学习视频：黑马2022最新SSM框架 我们SpringMVC见！！(还是不太相信能有人看╮(╯▽╰)╭)","categories":[{"name":"Java","slug":"Java","permalink":"http://example.com/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"},{"name":"框架","slug":"框架","permalink":"http://example.com/tags/%E6%A1%86%E6%9E%B6/"}]},{"title":"SpringMVC框架的学习笔记","slug":"Java/SpringMCV框架","date":"2022-08-06T11:11:16.322Z","updated":"2022-07-07T06:25:56.557Z","comments":true,"path":"2022/08/06/Java/SpringMCV框架/","link":"","permalink":"http://example.com/2022/08/06/Java/SpringMCV%E6%A1%86%E6%9E%B6/","excerpt":"","text":"1.初认SpringMVC1.1 SpringMVC简介 SpringMVC技术与Servlet技术功能等同，均属于web层开发技术 SpringMVC是一种基于java实现MVC模型的轻量级Web框架 优点： 使用简单，开发便捷(相比与Servlet) 灵活性强 项目结构： 1.2 SpringMVC入门1.使用SpringMVC技术需要先导入SpringMVC坐标与Servlet 不需要导入spring-context包，spring-webmvc包中包含spring-context包 2.导入Tomcat插件 12345678910111213141516171819202122232425&lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;version&gt;3.1.0&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;!-- 和Tomcat有冲突 --&gt; &lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;5.2.10.RELEASE&lt;/version&gt; &lt;/dependency&gt;&lt;!--Tomcat插件--&gt;&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.tomcat.maven&lt;/groupId&gt; &lt;artifactId&gt;tomcat7-maven-plugin&lt;/artifactId&gt; &lt;version&gt;2.1&lt;/version&gt; &lt;configuration&gt; &lt;port&gt;8888&lt;/port&gt; &lt;!--端口可任意只要没有被占用--&gt; &lt;path&gt;/&lt;/path&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; 3.创建SpringMVC控制器类(等同于Servlet功能) 1234567891011@Controllerpublic class UserController &#123; //设置当前控制器方法的请求路径 @RequestMapping(&quot;/save&quot;) //设置当前控制器方法响应内容为当前返回值，无需解析 @ResponseBody public String save()&#123; System.out.println(&quot;user is saving~~&quot;); return &quot;&#123;&#x27;info&#x27;:&#x27;springmvc&#x27;&#125;&quot;; &#125;&#125; 4.初始化SpringMVC环境(同Spring环境)，设定SpringMVC加载对应的bean 12345//创建SpringMVC的配置文件，加载controller对应的bean@Configuration@ComponentScan(&quot;com.springmvc.controller&quot;)public class SpringMvcConfig &#123;&#125; 5.初始化Servlet容器，加载SpringMVC环境，并设置SpringMVC技术处理的请求 123456789101112131415161718192021//定义一个servlet容器启动的配置类，在里面加载Spring的配置public class ServletContainerInitConfig extends AbstractDispatcherServletInitializer &#123; //加载SpringMVC容器的配置 @Override protected WebApplicationContext createServletApplicationContext() &#123; AnnotationConfigWebApplicationContext acwac = new AnnotationConfigWebApplicationContext(); acwac.register(SpringMvcConfig.class); return acwac; &#125; //设定SpringMVC对应的请求的映射路径 @Override protected String[] getServletMappings() &#123; //设置为/表示拦截所有请求，任意请求都将转入到SpringMVC中进行处理 return new String[]&#123;&quot;/&quot;&#125;; &#125; //加载Spring容器配置，现在不需要 @Override protected WebApplicationContext createRootApplicationContext() &#123; return null; &#125;&#125; 右键找到Run Maven再找到tomcat7:run点击运行，打开浏览器打开http://localhost:8888/save 页面即可出现内容： 1&#123;&#x27;info&#x27;:&#x27;springmvc&#x27;&#125; 此时控制台打印出： 1user is saving~~ 1.3 入门总结 SpringMVC入门程序开发总结(1+N) 一次性工作 创建工程, 设置服务器，加载工程 导入坐标 创建web容器启动类, 加载SpringMVC配置， 并设置SpringMVC请求拦截路径 SpringMVC核心配置类 (设置配置类,扫描controller包, 加载Controller控制器bean) 多次工作 定义处理请求的控制器类 定义处理请求的控制器方法， 并配置映射路径@RequestMapping与返回json数据@ResponseBody 1.4 工作流程入门案例工作流程分析 启动服务器初始化过程 服务器启动, 执行ServletContainersInitConfig类,初始化web容器 执行createServletApplicationContext方法，创建了WebApplicationContext对象 加载SpringMvcConfig配置文件 执行@ComponentScan加载对应的bean 加载UserController, 每个@RequestMapping的名称对应一 个具体的方法 执行getServletMappings方法, 定义所有的请求都通过SpringMVC 单次请求过程 发送请求http:localhost:8888/save web容器发现所有请求都经过SpringMVC, 将请求交给SpringMVC处理 解析请求路径&#x2F;save 由&#x2F;save匹配执行对应的方法save() 执行save() 检测到有@ResponseBody直接将save()方法的返回值作为响应求体返回给请求方 1.5 bean加载控制 com springmvc config controller service dao Controller加载控制业务与业务bean加载控制 SpringMVC相关bean 表现层bean(Controller) Spring控制的bean 业务bean(Service) 功能bean(DataSourse等) SpringMVC相关的bean加载控制 SpringMVC加载的bean对应的包均在com.springnvc.controller包内 Spring相关bean加载控制 Spring加载的bean设定范围为com.springmvc，排除controller包内的bean Spring加载的bean设定范围为精准范围，如：com.springmvc.dao、com.springmvc.service等(常用) 不区分Spring与SpringMVC的环境，加载到同一个环境中 方式一(常用)： 1234@Configuration@ComponentScan(&#123;&quot;com.springmvc.dao&quot;,&quot;com.springmvc.service&quot;&#125;)public class SpringConfig &#123;&#125; 方式二： 123456789@Configuration@ComponentScan(value = &quot;com.springmvc&quot;, excludeFilters = @ComponentScan.Filter( type = FilterType.ANNOTATION, //按照注解排除 classes = Controller.class //需要排除的注解类型 ))public class SpringConfig &#123;&#125; 加载SpringMVC和Spring配置 123456789101112131415161718192021public class ServletContainerInitConfig extends AbstractDispatcherServletInitializer &#123; //加载SpringMVC配置 @Override protected WebApplicationContext createServletApplicationContext() &#123; AnnotationConfigWebApplicationContext acwac = new AnnotationConfigWebApplicationContext(); acwac.register(SpringMvcConfig.class); return acwac; &#125; @Override protected String[] getServletMappings() &#123; return new String[]&#123;&quot;/&quot;&#125;; &#125; //加载SpringMVC配置 @Override protected WebApplicationContext createRootApplicationContext() &#123; AnnotationConfigWebApplicationContext acwac = new AnnotationConfigWebApplicationContext(); acwac.register(SpringConfig.class); return acwac; &#125;&#125; 简化操作(常用)： 1234567891011121314151617public class ServletContainerInitConfig extends AbstractAnnotationConfigDispatcherServletInitializer &#123; @Override protected Class&lt;?&gt;[] getRootConfigClasses() &#123; return new Class[]&#123;SpringConfig.class&#125;; &#125; @Override protected Class&lt;?&gt;[] getServletConfigClasses() &#123; return new Class[]&#123;SpringMvcConfig.class&#125;; &#125; @Override protected String[] getServletMappings() &#123; return new String[]&#123;&quot;/&quot;&#125;; &#125;&#125; 2.请求与响应2.1 请求映射路径项目结构： BookController： 123456789@Controllerpublic class BookController &#123; @RequestMapping(&quot;/save&quot;) @ResponseBody public String save()&#123; System.out.println(&quot;book is saving~~&quot;); return &quot;&#123;&#x27;info&#x27;:&#x27;springmvc&#x27;&#125;&quot;; &#125;&#125; UserController： 123456789@Controllerpublic class UserController &#123; @RequestMapping(&quot;/save&quot;) @ResponseBody public String save()&#123; System.out.println(&quot;user is saving~~&quot;); return &quot;&#123;&#x27;info&#x27;:&#x27;springmvc&#x27;&#125;&quot;; &#125;&#125; 运行程序后报错，无法启动。 因为路径都为/save的话，在网页请求/save，程序会不知道调用哪个控制器方法 改进： BookController： 123456789@Controllerpublic class BookController &#123; @RequestMapping(&quot;/book/save&quot;) @ResponseBody public String save()&#123; System.out.println(&quot;book is saving~~&quot;); return &quot;&#123;&#x27;info&#x27;:&#x27;springmvc&#x27;&#125;&quot;; &#125;&#125; UserController： 123456789@Controllerpublic class UserController &#123; @RequestMapping(&quot;/user/save&quot;) @ResponseBody public String save()&#123; System.out.println(&quot;user is saving~~&quot;); return &quot;&#123;&#x27;info&#x27;:&#x27;springmvc&#x27;&#125;&quot;; &#125;&#125; 还可以更加精简，增加模块的请求路径前缀： @RequestMapping注解： 设置在控制器方法上：请求访问路径 设置在类上：统一设置当前类中控制器方法请求路径前缀 BookController： 12345678910@Controller@RequestMapping(&quot;/book&quot;)public class BookController &#123; @RequestMapping(&quot;/save&quot;) @ResponseBody public String save()&#123; System.out.println(&quot;book is saving~~&quot;); return &quot;&#123;&#x27;info&#x27;:&#x27;springmvc&#x27;&#125;&quot;; &#125;&#125; UserController： 12345678910@Controller@RequestMapping(&quot;/user&quot;)public class UserController &#123; @RequestMapping(&quot;/save&quot;) @ResponseBody public String save()&#123; System.out.println(&quot;user is saving~~&quot;); return &quot;&#123;&#x27;info&#x27;:&#x27;springmvc&#x27;&#125;&quot;; &#125;&#125; 2.2 请求方式 Get请求 Post请求 所要访问的控制器方法： 1234567891011@Controller@RequestMapping(&quot;/user&quot;)public class UserController &#123; @RequestMapping(&quot;/save&quot;) @ResponseBody public String save(String name, int age)&#123; System.out.println(&quot;user is saving~~&quot;); System.out.println(&quot;name=&quot;+name+&quot; age=&quot;+age); return &quot;&#123;&#x27;info&#x27;:&#x27;springmvc&#x27;&#125;&quot;; &#125;&#125; get请求： url地址传参，地址参数要与形参变量名相同，定义形参几个接收参数 访问链接：http://localhost:8888/user/save?name=dahuang&amp;age=18 控制台打印： 12user is saving~~name=dahuang age=18 post请求： form表单post请求传参，表单参数名要与形参变量名相同，定义形参几个接收参数 访问链接：http://localhost:8888/user/save 提交数据形式：x-www-form-urlencoded 控制台打印： 12user is saving~~name=dahei age=20 如果参数为中文呢？ 控制台打印，会乱码： 12user is saving~~name=å¤§é» age=20 Post请求中文乱码处理： 在ServletContainerInitConfig配置文件中重写getServletFilters()方法 为web容器添加过滤器并指定字符集，Spring-web包中提供了专用的字符过滤器 123456@Overrideprotected Filter[] getServletFilters() &#123; CharacterEncodingFilter aef = new CharacterEncodingFilter(); aef.setEncoding(&quot;UTF-8&quot;); return new Filter[]&#123;aef&#125;;&#125; 再次运行后，控制台打印： 12user is saving~~name=大黄 age=20 2.3 5种类型参数传递 参数种类 普通参数 POJO参数 嵌套POJO参数 数组类型参数 集合类型参数 普通参数：请求参数名与形参变量名不同，使用@RequestParam注解绑定参数关系 1234567891011@Controller@RequestMapping(&quot;/user&quot;)public class UserController &#123; @RequestMapping(&quot;/save&quot;) @ResponseBody public String save(@RequestParam(&quot;name&quot;) String userName, int age)&#123; System.out.println(&quot;user is saving~~&quot;); System.out.println(&quot;name=&quot;+userName+&quot; age=&quot;+age); return &quot;&#123;&#x27;info&#x27;:&#x27;springmvc&#x27;&#125;&quot;; &#125;&#125; POJO参数：请求参数名与形参对象名相同，定义POJO类型形参即可接收参数 创建一个实体类User 1234567891011121314151617public class User &#123; private String name; private int age; public String getName() &#123;return name;&#125; public void setName(String name) &#123;this.name = name;&#125; public int getAge() &#123;return age;&#125; public void setAge(int age) &#123;this.age = age;&#125; @Override public String toString() &#123; return &quot;User&#123;&quot; + &quot;name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &quot;, age=&quot; + age + &#x27;&#125;&#x27;; &#125;&#125; UserController中： 1234567891011@Controller@RequestMapping(&quot;/user&quot;)public class UserController &#123; @RequestMapping(&quot;/save&quot;) @ResponseBody public String save(User user)&#123; System.out.println(&quot;user is saving~~&quot;); System.out.println(user.toString()); return &quot;&#123;&#x27;info&#x27;:&#x27;springmvc&#x27;&#125;&quot;; &#125;&#125; get请求： url地址：http://localhost:8888/user/save?name=dahei&amp;age=16 控制台打印： 12user is saving~~User&#123;name=&#x27;dahei&#x27;, age=16&#125; 嵌套POJO参数：POJO对象中包含POJO对象 创建一个新实体类Address： 1234567891011121314151617public class Address &#123; private String province; private String city; public String getProvince() &#123;return province;&#125; public void setProvince(String province) &#123;this.province = province;&#125; public String getCity() &#123;return city;&#125; public void setCity(String city) &#123;this.city = city;&#125; @Override public String toString() &#123; return &quot;Address&#123;&quot; + &quot;province=&#x27;&quot; + province + &#x27;\\&#x27;&#x27; + &quot;, city=&#x27;&quot; + city + &#x27;\\&#x27;&#x27; + &#x27;&#125;&#x27;; &#125;&#125; 将Address对象加入到User对象中： 123456789101112131415161718192021public class User &#123; private String name; private int age; private Address address; public Address getAddress() &#123;return address;&#125; public void setAddress(Address address) &#123;this.address = address;&#125; public String getName() &#123;return name;&#125; public void setName(String name) &#123;this.name = name;&#125; public int getAge() &#123;return age;&#125; public void setAge(int age) &#123;this.age = age;&#125; @Override public String toString() &#123; return &quot;User&#123;&quot; + &quot;name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &quot;, age=&quot; + age + &quot;, address=&quot; + address + &#x27;&#125;&#x27;; &#125;&#125; get请求： url地址：http://localhost:8888/user/save?name=dahuang&amp;age=20&amp;address.province=tianjin&amp;address.city=baodi 控制台打印： 12user is saving~~User&#123;name=&#x27;dahuang&#x27;, age=20, address=Address&#123;province=&#x27;tianjin&#x27;, city=&#x27;baodi&#x27;&#125;&#125; 数组参数： 1234567891011@Controller@RequestMapping(&quot;/user&quot;)public class UserController &#123; @RequestMapping(&quot;/save&quot;) @ResponseBody public String save(String[] hobbies)&#123; System.out.println(&quot;user is saving~~&quot;); System.out.println(Arrays.toString(hobbies)); return &quot;&#123;&#x27;info&#x27;:&#x27;springmvc&#x27;&#125;&quot;; &#125;&#125; get请求： url地址：http://localhost:8888/user/save?hobbies=TV&amp;hobbies=game&amp;hobbies=food 控制台打印： 12user is saving~~[TV, game, food] 集合参数： 1234567891011@Controller@RequestMapping(&quot;/user&quot;)public class UserController &#123; @RequestMapping(&quot;/save&quot;) @ResponseBody public String save(@RequestParam List&lt;String&gt; hobbies)&#123; System.out.println(&quot;user is saving~~&quot;); System.out.println(hobbies.toString()); return &quot;&#123;&#x27;info&#x27;:&#x27;springmvc&#x27;&#125;&quot;; &#125;&#125; get请求： url地址：http://localhost:8888/user/save?hobbies=TV&amp;hobbies=game&amp;hobbies=food 控制台打印： 12user is saving~~[TV, game, food] 2.4 传递json数据*导入jackson坐标： 12345&lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;2.9.0&lt;/version&gt;&lt;/dependency&gt; json有两种格式： 对象格式：&#123;&quot;key1&quot;:obj,&quot;key2&quot;:obj,&quot;key3&quot;:obj...&#125; 数组&#x2F;集合格式：[obj,obj,obj...] 在SpringMvcConfig配置文件中，添加注解@EnableWebMvc： @EnableWebMvc注解：开启json数据转换成对象的功能 12345@Configuration@ComponentScan(&quot;com.springmvc.controller&quot;)@EnableWebMvcpublic class SpringMvcConfig &#123;&#125; 集合参数：json格式 @RequestBody注解：将请求中请求体所包含的数据传递给请求参数，此注解一个处理器方法只能使用一次 1234567891011@Controller@RequestMapping(&quot;/user&quot;)public class UserController &#123; @RequestMapping(&quot;/save&quot;) @ResponseBody public String save(@RequestBody List&lt;String&gt; hobbies)&#123; System.out.println(&quot;user is saving~~&quot;); System.out.println(hobbies.toString()); return &quot;&#123;&#x27;info&#x27;:&#x27;springmvc&#x27;&#125;&quot;; &#125;&#125; 控制台打印： 12user is saving~~[TV, game, food] POJO参数：json格式 1234567891011@Controller@RequestMapping(&quot;/user&quot;)public class UserController &#123; @RequestMapping(&quot;/save&quot;) @ResponseBody public String save(@RequestBody User user)&#123; System.out.println(&quot;user is saving~~&quot;); System.out.println(user.toString()); return &quot;&#123;&#x27;info&#x27;:&#x27;springmvc&#x27;&#125;&quot;; &#125;&#125; 控制台打印： 12user is saving~~User&#123;name=&#x27;dahuang&#x27;, age=20, address=Address&#123;province=&#x27;tianjin&#x27;, city=&#x27;baodi&#x27;&#125;&#125; 集合对象参数：json格式 1234567891011@Controller@RequestMapping(&quot;/user&quot;)public class UserController &#123; @RequestMapping(&quot;/save&quot;) @ResponseBody public String save(@RequestBody List&lt;User&gt; list)&#123; System.out.println(&quot;user is saving~~&quot;); System.out.println(list.toString()); return &quot;&#123;&#x27;info&#x27;:&#x27;springmvc&#x27;&#125;&quot;; &#125;&#125; 控制台打印： 12user is saving~~[User&#123;name=&#x27;dahei&#x27;, age=20, address=Address&#123;province=&#x27;tianjin&#x27;, city=&#x27;baodi&#x27;&#125;&#125;, User&#123;name=&#x27;dahuang&#x27;, age=20, address=Address&#123;province=&#x27;guizhou&#x27;, city=&#x27;zunyi&#x27;&#125;&#125;] @RequestBody与@RequestParam的区别： 区别 @RequestParam用于url地址传参，表单传参 application/x-www-form-urlencoded @RequestBody用于接收json数据 application/json 应用 后期开发，发送json格式数据为主，@RequestBody拥有较广 如果发送非json格式数据，选用@RequestParam接收请求参数 2.5 日期类型参数传递日期类型数据基于系统不同格式也不尽相同 2022-07-04 2022&#x2F;07&#x2F;04 07&#x2F;04&#x2F;2022 接收形参时，根据不同的日期格式设置不同的接收方式 @DataTimeFormat注解中的pattern属性来自定义日期时间型数据格式 1234567891011121314@Controller@RequestMapping(&quot;/user&quot;)public class UserController &#123; @RequestMapping(&quot;/date&quot;) @ResponseBody public String save(Date date1, @DateTimeFormat(pattern = &quot;yyyy-mm-dd&quot;) Date date2, @DateTimeFormat(pattern = &quot;yyyy/mm/dd HH:mm:ss&quot;) Date date3)&#123; System.out.println(&quot;date1==&gt;&quot;+date1); System.out.println(&quot;date2==&gt;&quot;+date2); System.out.println(&quot;date3==&gt;&quot;+date3); return &quot;&#123;&#x27;info&#x27;:&#x27;springmvc&#x27;&#125;&quot;; &#125;&#125; 控制台打印： 123date1==&gt;Mon Jul 04 00:00:00 CST 2022date2==&gt;Tue Jan 04 00:07:00 CST 2022date3==&gt;Tue Jan 04 23:10:00 CST 2022 类型转换器： Converter接口 1234public interface Converter&lt;S, T&gt; &#123; @Nullable T convert(S val);&#125; 请求参数年龄数据(String&#x3D;&#x3D;&gt;Integer) 日期格式转换(String&#x3D;&#x3D;&gt;Date) @EnableWebMvc注解作用之一：根据类型匹配对应的类型转换器 2.6 响应数据 响应页面 响应数据 文本数据 json数据 响应页面： 在webapp资源包中新建文件：page.jsp 12345&lt;html&gt;&lt;body&gt;&lt;h2&gt;Hello SpringMVC!&lt;/h2&gt;&lt;/body&gt;&lt;/html&gt; 页面跳转： 123456789@Controllerpublic class UserController &#123; @RequestMapping(&quot;/jumpPage&quot;) public String jumpPage()&#123; System.out.println(&quot;页面跳转&quot;); return &quot;page.jsp&quot;; &#125;&#125; url地址：http://localhost:8888/jumpPage 会自动跳转到page.jsp页面 响应文本数据： 123456789@Controllerpublic class UserController &#123; @RequestMapping(&quot;/toText&quot;) @ResponseBody public String toText()&#123; System.out.println(&quot;返回纯文本数据&quot;); return &quot;hello SpringMVC&quot;; &#125;&#125; url地址：http://localhost:8888/toText 页面数据： 1hello SpringMVC 响应POJO对象： 123456789101112@Controllerpublic class UserController &#123; @RequestMapping(&quot;/toPojo&quot;) @ResponseBody public User toPojo()&#123; System.out.println(&quot;返回POJO数据&quot;); User user = new User(); user.setName(&quot;大黄&quot;); user.setAge(18); return user; &#125;&#125; url地址：http://localhost:8888/toPojo 页面数据： 12345&#123; &quot;name&quot;: &quot;大黄&quot;, &quot;age&quot;: 18, &quot;address&quot;: null&#125; 其中是jackson自动将对象转换成json数据 所以一定要导入jackson坐标 响应POJO集合对象： 123456789101112131415161718@Controllerpublic class UserController &#123; @RequestMapping(&quot;/toPojoList&quot;) @ResponseBody public List&lt;User&gt; toPojoList()&#123; System.out.println(&quot;返回POJO集合对象数据&quot;); User user1 = new User(); user1.setName(&quot;大黄&quot;); user1.setAge(18); User user2 = new User(); user2.setName(&quot;大黑&quot;); user2.setAge(20); List&lt;User&gt; list = new ArrayList&lt;&gt;(); list.add(user1); list.add(user2); return list; &#125;&#125; url地址：http://localhost:8888/toPojoList 页面数据： 123456789101112[ &#123; &quot;name&quot;: &quot;大黄&quot;, &quot;age&quot;: 18, &quot;address&quot;: null &#125;, &#123; &quot;name&quot;: &quot;大黑&quot;, &quot;age&quot;: 20, &quot;address&quot;: null &#125;] @ResponseBody注解： 设置当前控制器返回值作为响应体 控制器方法返回值数据类型为String，则返回文本数据 控制器方法返回值数据类型为对象，则自动将对象转换成json数据 类型转换器： web请求专用类型转换器：HttpMessageConverter接口 3.REST风格3.1 REST简介 REST(Representational State Transfer)：表现形式状态转换 传统风格资源描述形式 http://localhost:8888/user/getById?id=1 http://localhost:8888/user/saveUser REST风格描述形式 http://localhost:8888/user/1 http://localhost:8888/user 优点： 隐藏资源的访问行为，无法通过地址得知对资源是如何操作 书写简化 按照REST风格访问资源时使用行为动作区分对资源进行了何种操作 http://localhost:8888/users 查询全部用户信息(get) http://localhost:8888/users/1 查询指定用户信息(post) http://localhost:8888/users 添加用户信息(post) http://localhost:8888/users 修改用户信息(put) http://localhost:8888/users/1 删除用户信息(delete) 描述模块的名称通常使用复数，也就是加s的格式描述，表示此类资源，而非单个资源。 例如：users、books…. 根据REST风格对资源进行访问称为RESTFul 3.2 REST入门@RequestMapping注解中method属性可以设定http请求地址，例如：GET、POST、PUT、DELETE… @PathVariable注解：绑定路径参数与处理器方法形参间的关系，要求路径参数名与形参名一一对应 12345678910111213141516171819202122232425262728293031323334353637@Controllerpublic class UserController &#123; @RequestMapping(value = &quot;/users&quot;, method = RequestMethod.POST) @ResponseBody public String save()&#123; System.out.println(&quot;save~~&quot;); return &quot;save success&quot;; &#125; @RequestMapping(value = &quot;/users&quot;, method = RequestMethod.PUT) @ResponseBody public String update()&#123; System.out.println(&quot;update~~&quot;); return &quot;update success&quot;; &#125; @RequestMapping(value = &quot;/users/&#123;id&#125;&quot;, method = RequestMethod.DELETE) @ResponseBody public String delete(@PathVariable Integer id)&#123; //路径变量 System.out.println(&quot;delete~~&quot;); return &quot;delete success&quot;; &#125; @RequestMapping(value = &quot;/users&quot;, method = RequestMethod.GET) @ResponseBody public String getAll()&#123; System.out.println(&quot;getAll~~&quot;); return &quot;getAll success&quot;; &#125; @RequestMapping(value = &quot;/users/&#123;id&#125;&quot;, method = RequestMethod.POST) @ResponseBody public String getById(@PathVariable Integer id)&#123; System.out.println(&quot;getById~~&quot;); return &quot;getById success&quot;; &#125;&#125; @RequestBody @RequestParam @PathVariable 区别 @RequestParam用于接收url地址传参或表单传参 @RequestBody用于接收json数据 @PathVariab1e用于接收路径参数, 使用{参数名称}描述路径参数 应用 后期开发中，发送请求参数超过1个时，以json格式为主, @RequestBody应用较广 如果发送非json格式数据 ,选用@RequestParam接收请求参数 采用RESTful进行开发，当参数数量较少时，例如1个， 可以采用@PathVariable接收请求路径变量，通常用于传递id值 3.3 REST快速开发@ResponseBody： 设置当前控制器类为RESTful风格，等同于@Controller与@ResponseBody两个注解组合功能 标准请求动作映射： @GetMapping：对应GET请求 @PostMapping：对应POST请求 @PutMapping：对应PUT请求 @DeleteMapping：对应DELETE请求 12345678910111213141516171819202122232425262728293031323334//@ResponseBody + @Controller ==&gt; @RestController@RestController@RequestMapping(&quot;/users&quot;)public class UserController &#123; @PostMapping public String save()&#123; System.out.println(&quot;save~~&quot;); return &quot;save success&quot;; &#125; @PutMapping public String update()&#123; System.out.println(&quot;update~~&quot;); return &quot;update success&quot;; &#125; @DeleteMapping(&quot;/&#123;id&#125;&quot;) public String delete(@PathVariable Integer id)&#123; //路径变量 System.out.println(&quot;delete~~&quot;); return &quot;delete success&quot;; &#125; @GetMapping public String getAll()&#123; System.out.println(&quot;getAll~~&quot;); return &quot;getAll success&quot;; &#125; @PostMapping(&quot;/&#123;id&#125;&quot;) public String getById(@PathVariable Integer id)&#123; System.out.println(&quot;getById~~&quot;); return &quot;getById success&quot;; &#125;&#125; 4.SSM整合5.拦截器5.1 拦截器的概念 拦截器(Interceptor)是一种动态拦截方法调用的机制，再SpringMVC中动态拦截控制器方法的执行 作用： 在指定的方法调用前后执行预先设定的代码 阻止原始方法的执行 拦截器与过滤器的区别： 归属不同：Filter属于Servlet技术，Interceptor属于SpringMVC技术 拦截内容不同：Filter对所有访问进行数据增强，Interceptor仅针对SpringMVC的访问进行增强 5.2 拦截器入门 制作拦截器功能类 配置拦截器的执行位置 项目结构： ProjectInterceptor： 此时preHandle方法的返回值为true：执行请求的方法 123456789101112131415161718@Componentpublic class ProjectInterceptor implements HandlerInterceptor &#123; @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; System.out.println(&quot;preHandle~~~&quot;); return true; &#125; @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123; System.out.println(&quot;postHandle~~~&quot;); &#125; @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123; System.out.println(&quot;afterCompletion~~~&quot;); &#125;&#125; SpringMvcSupport： 12345678910@Configurationpublic class SpringMvcSupport extends WebMvcConfigurationSupport &#123; @Autowired private ProjectInterceptor projectInterceptor; @Override protected void addInterceptors(InterceptorRegistry registry) &#123; registry.addInterceptor(projectInterceptor).addPathPatterns(&quot;/users&quot;); &#125;&#125; SpringMvcConfig中添加扫描路径”com.springmvc.config” 12345@Configuration@ComponentScan(&#123;&quot;com.springmvc.controller&quot;,&quot;com.springmvc.config&quot;&#125;)@EnableWebMvcpublic class SpringMvcConfig &#123;&#125; UserController： 123456789101112131415161718192021222324252627282930313233@RestController@RequestMapping(&quot;/users&quot;)public class UserController &#123; @PostMapping public String save()&#123; System.out.println(&quot;save~~&quot;); return &quot;save success&quot;; &#125; @PutMapping public String update()&#123; System.out.println(&quot;update~~&quot;); return &quot;update success&quot;; &#125; @DeleteMapping(&quot;/&#123;id&#125;&quot;) public String delete(@PathVariable Integer id)&#123; //路径变量 System.out.println(&quot;delete~~&quot;); return &quot;delete success&quot;; &#125; @GetMapping public String getAll()&#123; System.out.println(&quot;getAll~~&quot;); return &quot;getAll success&quot;; &#125; @PostMapping(&quot;/&#123;id&#125;&quot;) public String getById(@PathVariable Integer id)&#123; System.out.println(&quot;getById~~&quot;); return &quot;getById success&quot;; &#125;&#125; 页面展示： 1getAll success 控制台打印： 1234preHandle~~~getAll~~postHandle~~~afterCompletion~~~ 如果preHandle方法的返回值为false：不会执行请求的方法 123456789101112131415161718@Componentpublic class ProjectInterceptor implements HandlerInterceptor &#123; @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; System.out.println(&quot;preHandle~~~&quot;); return false; &#125; @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123; System.out.println(&quot;postHandle~~~&quot;); &#125; @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123; System.out.println(&quot;afterCompletion~~~&quot;); &#125;&#125; 页面无内容，被拦截 控制台打印： 1preHandle~~~ 所以可以通过if语句进行某种判断，返回true或false，来是否执行请求的方法 5.3 拦截器参数前置处理： 1234567@Overridepublic boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; System.out.println(&quot;preHandle~~~&quot;); return true;&#125; 参数： request：请求对象 response：响应对象 handle：被调用的处理器对象，本质为一个方法对象，对反射技术中的Method对象进行了再包装 返回值： 返回值为false，被拦截的处理将不执行 返回值为true，被拦截的处理将会执行 后置处理： 1234567@Overridepublic void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123; System.out.println(&quot;postHandle~~~&quot;);&#125; 参数： modelAndView：如果处理器执行完成具有返回结果，可以读取到对应数据与页面信息，并进行调整(了解即可) 完成后处理： 1234567@Overridepublic void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123; System.out.println(&quot;afterCompletion~~~&quot;);&#125; 参数： ex：如果处理执行过程中出现异常对象，可以针对异常情况进行单独处理(了解即可) 5.4 拦截器链配置(了解) 当配置多个拦截器时，形成拦截链 拦截器链的运行顺序： preHandle：与配置顺序相同，必定运行 postHandle：与配置顺序相反，可能不运行 afterCompletion：与配置顺序相反，可能不运行 但拦截器出现对原始处理器的拦截，后面的拦截器均终止运行 当拦截器运行中断，仅运行配置再前面的拦截器的afterCompletion操作 通常开发项目时，很少会用到拦截器链，一般一个拦截器就可以解决问题 按照1、2、3的顺序配置 12345678910111213141516@Configurationpublic class SpringMvcSupport extends WebMvcConfigurationSupport &#123; @Autowired private ProjectInterceptor1 projectInterceptor1; @Autowired private ProjectInterceptor2 projectInterceptor2; @Autowired private ProjectInterceptor3 projectInterceptor3; @Override protected void addInterceptors(InterceptorRegistry registry) &#123; registry.addInterceptor(projectInterceptor1).addPathPatterns(&quot;/users&quot;); registry.addInterceptor(projectInterceptor2).addPathPatterns(&quot;/users&quot;); registry.addInterceptor(projectInterceptor3).addPathPatterns(&quot;/users&quot;); &#125;&#125; 全部的preHandle方法返回值都为true： graph LR; pre1-->pre2-->pre3-->c(controller)-->post3-->post2-->post1-->after3-->after2-->after1; 3的preHandle方法返回值为false： graph LR; pre1-->pre2-->pre3-->after2-->after1; 2的preHandle方法返回值为false： graph LR; pre1-->pre2-->after1; 1的preHandle方法返回值为false： graph LR; pre1;","categories":[{"name":"Java","slug":"Java","permalink":"http://example.com/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"},{"name":"框架","slug":"框架","permalink":"http://example.com/tags/%E6%A1%86%E6%9E%B6/"}]},{"title":"SpringCloud框架的学习笔记","slug":"Java/SpringCloud框架","date":"2022-08-06T11:11:16.320Z","updated":"2022-09-27T14:18:51.088Z","comments":true,"path":"2022/08/06/Java/SpringCloud框架/","link":"","permalink":"http://example.com/2022/08/06/Java/SpringCloud%E6%A1%86%E6%9E%B6/","excerpt":"","text":"微服务技术栈： 实用篇1.微服务治理1.1 认识微服务单体架构： 单体架构：将业务的所有功能集中在一个项目开发，打成一个包部署 优点： 架构简单 部署成本低 缺点： 耦合度高 特点： 简单方便、高度耦合、拓展性差、适合小型项目 分布式架构： 分布式架构：根据业务功能对系统进行拆分，每个业务模块作为独立项目开发，称为一个服务 优点： 降低服务耦合 有利于服务升级拓展 分布式架构所要考虑的问题： 服务拆分粒度如何？ 服务集群地址如何维护？ 服务之间如何实现远程调用？ 服务健康状态如何感知？ 特点： 松耦合、拓展性好，但架构复杂、难度大，适合大型互联网项目 微服务特点： 微服务是一种经过良好架构设计的分布式架构 微服务架构特征： 单一职责： 微服务拆分粒度更小，每一个服务都对应唯一的业务能力，做到单一职责，避免单一职责，避免重复开发 面向服务： 微服务对外暴露业务接口 自治： 团队独立、技术独立、数据独立、部署独立 隔离性强： 服务调用做好隔离、容错、降级、避免出现级联问题 优点： 拆分粒度更小、服务更独立、耦合度更低 缺点： 架构非常复杂、运维、监控、部署难度更高 微服务技术： 微服务这种方案需要技术落地，全球的互联网公司都在积极尝试自己的微服务落地技术 在国内最知名的就是SpringCloud和阿里巴巴的Dubbo 微服务技术对比： Dubbo SpringCloud SpringCloudAlibaba 注册中心 zookeeper、Redis Eureka、Consul Nacos、Eureka 服务远程调用 Dubbo协议(RFC协议) Feign(http协议) Dubbo、Feign 配置中心 无 SpringCloudConfig SpringCloudConfig、Nacos 服务网关 无 SpringCloudGateway、Zuul SpringCloudGatway、Zuul 服务监控和保护 dubbo-admin(功能弱) Hystrix Sentinel 企业需求： SpringCloud+Feign 使用SpringCloud技术栈 服务接口采用Restful风格 服务调用采用Feign方式 SpringCloudAlibaba+Feign 使用SpringCloudAlibaba技术栈 服务接口采用Restful风格 服务调用采用Feign方式 SpringCloudAlibaba+Dubbo 使用SpringCloudAlibaba技术栈 服务接口采用Dubbo协议标准 服务调用采用Dubbo方式 Dubbo原始模式 基于Dubbo老旧技术体系 服务接口采用Dubbo协议标准 服务调用采用Dubbo方式 SpringCloud： SpringCloud是目前国内使用最广泛的微服务框架 SpringCloud集成了各种微服务功能组件，并基于SpringBoot实现了这些组件的自动装配，从而提供了良好的开箱即用体验： SpringCloud与SpringBoot的存在版本兼容关系 本次学习采用的版本为 Hoxton.SR10，因此对应的SpringBoot版本为2.3.x版本 1.2 分布式服务架构案例服务拆分注意事项： 不同微服务，不要重复开发相同业务 微服务数据独立，不要访问其他微服务的数据库 微服务可以将自己的业务暴露为接口，供其他的服务调用 1.3 服务拆分服务拆分注意事项： 1.不同微服务，不要重复开发相同业务 2.微服务数据独立，不要访问其它微服务的数据库 3.微服务可以将自己的业务暴露为接口，供其他微服务调用 案例：根据订单id查询订单功能 需求：根据订单id查询订单的同时，把订单所属的用户信息一起返回 查询订单信息：http://localhost:8080/order/101 1234567&#123; &quot;id&quot;:101, &quot;price&quot;:699900, &quot;name&quot;:&quot;Apple 苹果 iPhone 12 &quot;, &quot;num&quot;:1,&quot;userId&quot;:1, &quot;user&quot;:null&#125; user信息为null，我们需要在查询订单信息的同时，也可以获得订单所属用户信息 我们可以调用user服务的接口 在order-service服务的OrderApplication中注册RestTemplate： 1234567891011121314@MapperScan(&quot;cn.itcast.order.mapper&quot;)@SpringBootApplicationpublic class OrderApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(OrderApplication.class, args); &#125; //创建RestTemplate对象并注入Spring容器 @Bean public RestTemplate restTemplate()&#123; return new RestTemplate(); &#125;&#125; OrderService中添加http请求： 12345678910111213141516171819202122@Servicepublic class OrderService &#123; @Autowired private OrderMapper orderMapper; @Autowired private RestTemplate restTemplate; public Order queryOrderById(Long orderId) &#123; // 1.查询订单 Order order = orderMapper.findById(orderId); // 2.利用restTemplate向user服务发送http请求 String url = &quot;http://localhost:8081/user/&quot; + order.getUserId(); User user = restTemplate.getForObject(url, User.class); order.setUser(user); // 3.返回 return order; &#125;&#125; 重新查询订单信息：http://localhost:8080/order/101 123456789101112&#123; &quot;id&quot;:101, &quot;price&quot;:699900, &quot;name&quot;:&quot;Apple 苹果 iPhone 12 &quot;, &quot;num&quot;:1, &quot;userId&quot;:1, &quot;user&quot;:&#123; &quot;id&quot;:1, &quot;username&quot;:&quot;柳岩&quot;, &quot;address&quot;:&quot;湖南省衡阳市&quot; &#125;&#125; 成功获得user信息！ 3.Eureka3.1 提供者与消费者 服务提供者：一次业务，被其他微服务调用的服务(提供接口给其他微服务) 服务消费者：一次业务，调用其他微服务的服务(调用其他微服务提供的接口) 服务A调用了服务B，服务B又调用服务C，服务B属于什么？ 相对于A，就是消费者；相对于C，就是提供者 提供者与消费者其实是相对的 3.2 Eureka原理分析在OrderService中： 1String url = &quot;http://localhost:8081/user/&quot; + order.getUserId(); 如果每次更改服务端口，都需要重新修改代码吗？ 如果有多个user服务实例，但是总是调用一个端口，其余的user服务怎么办？ 服务消费者该如何获取服务提供者的地址信息呢？ 如果有多个服务提供者，消费者该如何选择呢？ 消费者如何得到服务提供者的健康状态呢？ Eureka的作用： 服务消费者该如何获取服务提供者的地址信息呢？ 服务提供者启动时间向Eureka注册自己的信息 Eureka保存这些信息 消费者根据服务名称向Eureka拉取提供者信息 如果有多个服务提供者，消费者该如何选择呢？ 服务消费者利用负载均衡算法，从服务列表中挑选一个 消费者如何得到服务提供者的健康状态呢？ 服务提供者会每隔30秒向EurekaServer发送心跳请求，报告健康状况 Eureka会更新记录服务列表信息，心跳不会正常会被踢出 消费者就可以拉取到最新的信息 在Eureka架构中，微服务角色有两类： EurekaServer：服务端，注册中心 记录服务信息 心跳监控 EurekaClient： 客户端 provider：服务提供省，例如案例中的 user-service 注册自己的信息到EurekaServer 每隔30秒向Eureka Server发送心跳 consumer：服务消费者，例如案例中的 order-service 根据服务名称从Eurekaserver拉取服务列表 基于服务列表做负载均衡，选中一个微服务后发起远程调用 3.3 搭建Eureka服务 创建项目，引入spring-cloud-starter-netflix-eureka-server依赖 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;/artifactId&gt;&lt;/dependency&gt; 编写启动类，添加@EnableEurekaServer注解 1234567@EnableEurekaServer@SpringBootApplicationpublic class EurekaApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(EurekaApplication.class, args); &#125;&#125; 添加applcation.yaml文件，配置信息： 123456789server: port: 10086 #服务端口spring: application: name: eurekaserver #eureka的服务名称eureka: client: service-url: #eureka的地址信息 defaultZone: http://127.0.0.1:10086/eureka 3.4 服务注册注册user-service服务注册到EurekaServer： 在user-service项目引入spring-cloud-starter-netflix-eureka-client的依赖 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;&lt;/dependency&gt; 在application.yaml文件，添加下面的配置： 1234567spring: application: name: userserviceeureka: client: service-url: defaultZone: http://localhost:10086/eureka 注册多个user-service服务： 在idea中，找到user-service服务，右键选择复制配置： 第一个user-service服务的端口为8081， 我将第二个user-service服务的端口设置为8082(可随意设置，但不要使用占用的端口) 3.5 服务发现在order-service完成服务拉取 服务拉取基于服务名称获取服务列表，然后在对服务列表做负载均衡 修改OrderService的代码，修改访问的url路径，用服务名替代ip、端口： 1String url = &quot;http://userservice/user/&quot; + order.getUserId(); 完整代码： 12345678910111213141516171819202122@Servicepublic class OrderService &#123; @Autowired private OrderMapper orderMapper; @Autowired private RestTemplate restTemplate; public Order queryOrderById(Long orderId) &#123; // 1.查询订单 Order order = orderMapper.findById(orderId); //利用restTemplate向user服务发送http请求 String url = &quot;http://userservice/user/&quot; + order.getUserId(); User user = restTemplate.getForObject(url, User.class); order.setUser(user); // 4.返回 return order; &#125;&#125; 在order-service项目的启动类OrderApplication中RestTemplate添加负载均衡注解： 12345@Bean@LoadBalanced //负载均衡注解public RestTemplate restTemplate()&#123; return new RestTemplate();&#125; 完整代码： 1234567891011121314@MapperScan(&quot;cn.itcast.order.mapper&quot;)@SpringBootApplicationpublic class OrderApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(OrderApplication.class, args); &#125; @Bean @LoadBalanced public RestTemplate restTemplate()&#123; return new RestTemplate(); &#125;&#125; 3.6 总结 搭建EurekaServer注册中心 引入eureka-server依赖 添加@EnableEurekaServer注解 在application.yaml中配置eureka地址 服务注册 引入eureka-client依赖 在application.yaml中添加eureka地址 服务发现 引入eureka-client依赖 在application.yaml中添加eureka地址 给RestTemplate配置bean中添加@LoadBalanced注解 用服务提供者在eureka注册的服务名称远程调用 4.Ribbon4.1 负载均衡原理负载均衡流程： graph LR A[order-service] B{Ribbon负载均衡} C(eureka-service) D[user-service:8081] E[user-service:8082] A--1.发起请求http://userservice/user/1-->B B--2.拉取userservice-->C C--3.返回服务列表localhost:8081localhost:8082-->B B--4.轮询到8081-->D B-->E 负载均衡原理： graph LR A[order-service] B[RibbonLoadBalancerClient] C[DynamicServerListLoadBalancer] D(eureka-service) E[IRule] F[user-service:8081] G[user-service:8082] A--1.发起请求http://userservice/user/1-->B C--3.拉取userservice-->D D--4.返回服务列表localhost:8081localhost:8082-->C subgraph LoadBalancerInterceptor负载均衡拦截器 B--2.获取url中的服务iduserservice-->C C--5.服务负载均衡localhost:8081localhost:8082-->E E--6.选择某个服务localhost:8081-->B end subgraph 请求 B-->F B-.->G end 4.2 负载均衡策略(IRule)Ribbon的负载均衡是一个叫做IRule的接口来定义的，每一个子接口都是一种规则： classDiagram IRule A A-.非临时实例nacos主动询问.->C A--主动推送变更信息push-->B 在nacos里创建的实例默认为临时实例 服务注册到Nacos时，可以选择注册为临时或非临时实例，通过下面的配置来设置： 1234567spring: application: name: orderservice cloud: nacos: discovery: ephemeral: false #flase为非临时实例，默认为true临时实例 总结： Nacos与eureka的共同点 都支持服务注册和服务拉取 都支持服务提供者心跳方式做健康检测 Nacos与Eureka的区别 Nacos支持服务端主动检测提供者状态：临时实例采用心跳模式，非临时实例采用主动检测模式 临时实例心跳不正常会被剔除，非临时实例则不会被剔除 Nacos支持服务列表变更的消息推送模式，服务列表更新更及时 Nacos集群默认采用AP方式，当集群中存在非临时实例时，采用CP模式；Eureka采用AP方式 6.Nacos配置管理6.1 Nacos实现配置管理统一配置管理 配置更改热更新： 新建配置： 打开Nacos控制台，点击配置管理-&gt;配置列表，点击右边的+ 号 填入配置： 配置文件id名：[服务名称]-[profile].[后缀名] 后缀名与配置格式一致 分组：默认即可 配置格式：推荐使用yaml格式 示例： 获取配置步骤： graph LR A{项目启动} B(读取本地配置文件application.yaml) C(创建Spring容器) D(加载bean) E(读取nacos中的配置文件) A--naocs地址bootstrap.yaml-->E E-->B-->C-->D 引入Nacos的配置管理客户端依赖： 在user-service项目引入依赖： 1234&lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-config&lt;/artifactId&gt;&lt;/dependency&gt; 在配置文件同级文件包中新建bootstrap.yaml，并删除application.yaml中的nacos的相关配置 bootstrap.yaml内容如下： 12345678910spring: application: name: userservice #服务名称 profiles: active: dev #环境 cloud: nacos: server-addr: 43.142.167.75:8848 #nacos地址 config: file-extension: yaml #文件后缀为yaml 在UserController中，测试读取Nacos中的配置： 123456789101112@RestController@RequestMapping(&quot;/user&quot;)public class UserController &#123; //注入nacos中的配置属性 @Value(&quot;$&#123;pattern.dateformat&#125;&quot;) private String dateformat; //通过dateformat的时间格式，返回格式化的时间 @GetMapping(&quot;/now&quot;) public String getDateformat()&#123; return LocalDateTime.now().format(DateTimeFormatter.ofPattern(dateformat)); &#125;&#125; 总结： 将配置交给Nacos管理的步骤： 在Nacos中添加配置文件 在微服务中引入nacos的config依赖 在微服务中添加bootstrap.yml， 配置nacos地址当前环境、服务名称、文件后缀名。这些决定了程序启动时去nacos读取哪个文件 6.2 配置热更新Nacos中都配置文件变更后，微服务无需重启就可以感知。不过需要通过两种配置实现： 方式一：在@Value注入的变量所在类上添加注解@RefreshScope 123456789101112@RestController@RequestMapping(&quot;/user&quot;)@RefreshScopepublic class UserController &#123; @Value(&quot;$&#123;pattern.dateformat&#125;&quot;) private String dateformat; @GetMapping(&quot;/now&quot;) public String getDateformat()&#123; return LocalDateTime.now().format(DateTimeFormatter.ofPattern(dateformat)); &#125;&#125; 方式二：使用@ConfigurationProperties(prefix = &quot;&quot;)注解 新建config包，创建PatternProperties类： 123456@Data@Component //交给spring管理@ConfigurationProperties(prefix = &quot;pattern&quot;)public class PatternProperties &#123; private String dateformat;&#125; 在UserController注入PatternProperties： 123456789101112@RestController@RequestMapping(&quot;/user&quot;)public class UserController &#123; //注入PatternProperties @Autowired private PatternProperties patternProperties; @GetMapping(&quot;/now&quot;) public String getDateformat()&#123; return LocalDateTime.now().format(DateTimeFormatter.ofPattern(patternProperties.getDateformat())); &#125;&#125; 总结： Nacos配置更改后，微服务可以实现热更新，方式如下： 通过@value注解注入，结合@Refreshscope来刷新 通过@ConfiqurationProperties注入，自动刷新 注意事项： 不是所有的配置都适合放到配置中心，维护起来比较麻烦 建议将一些关键参数，需要运行时调整的参数放到nacos配置中心，一般都是自定义配置 6.3 多环境配置共享微服务启动会从nacos读取多个配置文件： [spring.application.name]-[spring.profile.active].yaml，例如：userservice-dev.yaml [spring.application.name].yaml，例如：userservice.yaml 无论profile如何变化，[spring.application.name].yaml这个文件一定会加载的，因此可以多环境共享配置可以写入这个文件 多配置的优先级： 服务名-profile.yaml &gt; 服务名.yaml &gt; 本地配置 总结： 微服务会从nacos读取的配置文件： [服务名]-[spring-profile.active].yaml，环境配置 [服务名].yaml，默认配置，多环境共享 优先级 [服务名]-[环境].yaml &gt; [服务名].yaml＞本地配置 6.4 Nacos集群搭建Nacos生产环境下一定要部署为集群状态 graph TB A(Nacosclient) B[Nginx] C(Nacosnode1) D(Nacosnode2) E(Nacosnode3) F[(MySQL主)] G[(MySQL从)] H[(MySQL从)] A-->B B-->C-->F B-->D-->F B-->E-->F subgraph . F-.-G F-.-H end 7.Feign7.1 远程调用RestTemplate方式存在的问题： RestTemplate发起远程调用，示例代码： 123//利用restTemplate向user服务发送http请求String url = &quot;http://userservice/user/&quot; + order.getUserId();User user = restTemplate.getForObject(url, User.class); 存在问题： 代码可读性差，编程体验不统一 参数复杂，URL难以维护 不够优雅！！！ 优雅的Feign 介绍： Feign是一个声明式的http客户端。 其作用就是帮助我们优雅的实现http请求的发送，解决上面提到的问题。 使用Feign步骤： 引入依赖 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt;&lt;/dependency&gt; 在order-service的启动管理类添加开启Feign功能的注解@EnableFeignClients： 123456789@EnableFeignClients@MapperScan(&quot;cn.itcast.order.mapper&quot;)@SpringBootApplicationpublic class OrderApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(OrderApplication.class, args); &#125;&#125; 新建clients包，包中创建UserClient，来编写Feign客户端： 123456@FeignClient(&quot;userservice&quot;)public interface UserClient &#123; @GetMapping(&quot;/user/&#123;id&#125;&quot;) User findById(@PathVariable Long id);&#125; 使用Feign进行远程调用 1234567891011121314151617181920@Servicepublic class OrderService &#123; @Autowired private OrderMapper orderMapper; @Autowired private UserClient userClient; public Order queryOrderById(Long orderId) &#123; // 1.查询订单 Order order = orderMapper.findById(orderId); //使用Feign远程调用 User user = userClient.findById(order.getUserId()); order.setUser(user); // 4.返回 return order; &#125;&#125; 总结： Feign的使用步骤： 引入依赖 添加@EnableFeignClients注解 编写FeignClient接口 使用FiegnClient中定义的方法代替RestTemplate 7.2 自定义配置Feign运行自定义配置来覆盖默认配置，可以修改的配置如下： 类型 作用 说明 feign.Logger.Level 修改日志级别 包含四种不同的级别：NONE、BASIC、HEADERS、FULL feign.codec.Decoder 响应结果的解析器 http远程调用的结果做解析，例如解析json字符串为java对象 feign.codec.Encoder 请求参数编码 将请求参数编码，便于通过http请求发送 feign.Contract 请求参数编码 默认是SpringMVC的注解 feign.Retryer 失败重试机制 请求失败的重试机制，默认是没有，不过会使用Ribbon的重试 一般我们需要配置的就是日志级别 配置Feign日志的两种方式： 方式一：配置文件方式 全局生效： 12345feign: client: config: default: #default就是全局配置，如果写的是服务名称，就是针对此服务的配置 loggerLevel: FULL #日志级别 局部生效 12345feign: client: config: userservice: #default就是全局配置，如果写的是服务名称，就是针对此服务的配置 loggerLevel: FULL #日志级别 方式二：注解方式 先声明一个Bean： 123456public class FeignClientConfig &#123; @Bean public Logger.Level feignLogLevel() &#123; return Logger.Level.BASIC; &#125;&#125; 全局配置，将bean放到@EnableFeignClients注解中： 1@EnableFeignClients(defaultConfiguration = FeignClientConfig.class) 局部配置，将bean放到@FeignClient注解中： 1@FeignClient(value = &quot;userservice&quot;, configuration = FeignClientConfig.class) 总结： Feign的日志配置： 方式一是配置文件，feign.client.config.xxx.loggerLevel 如果xxx是default则代表全局 如果xxx是服务名称，例如userservice则代表某服务 方式二是java代码配置Logger.Level这个Bean 如果在@EnableFeignClients注解声明则代表全局 如果在@FeignClient注解中声明则代表某服务 7.3 性能优化Feign底层的客户端实现： URLConnection：默认实现，不支持连接池 Apache HttpClient：支持连接池 OKHttp：支持连接池 因此优化Feign的性能主要包括： 使用连接池代替默认的URLConnection 日志级别，最好为basic或none Feign添加HttpClient的支持： 引入依赖 1234&lt;dependency&gt; &lt;groupId&gt;io.github.openfeign&lt;/groupId&gt; &lt;artifactId&gt;feign-httpclient&lt;/artifactId&gt;&lt;/dependency&gt; 配置连接池： 12345feign: httpclient: enabled: true #开启feign对HttpClient的支持 max-connections: 200 #最大连接数 max-connections-per-route: 50 #每个路径的最大连接数 总结： Feign的优化： 日志级别尽量用basic 使用HttpClient或OKHttp代替URLConnection 引入feign-httpclient依赖 配置文件开启httpClient功能，设置连接池参数 7.4 最佳实践Feign的最佳实践 方式一：继承 给消费者的FeignClient和提供者的Controller定义统一的父接口作为标准 2.Docker3.异步通信4.分布式搜索0","categories":[{"name":"Java","slug":"Java","permalink":"http://example.com/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"},{"name":"框架","slug":"框架","permalink":"http://example.com/tags/%E6%A1%86%E6%9E%B6/"}]},{"title":"SpringBoot框架的学习笔记","slug":"Java/SpringBoot框架","date":"2022-08-06T11:11:16.318Z","updated":"2022-09-27T14:17:53.588Z","comments":true,"path":"2022/08/06/Java/SpringBoot框架/","link":"","permalink":"http://example.com/2022/08/06/Java/SpringBoot%E6%A1%86%E6%9E%B6/","excerpt":"","text":"1.热部署2.配置高级2.1 自定义bean属性绑定导入lombok坐标： 1234&lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt;&lt;/dependency&gt; application.yaml配置中： 1234servers: ipAddress: 127.0.0.1 port: 2345 timeout: -1 ServerConfig类中： @ConfigurationProperties注解将application.yaml配置中的属性进行绑定 12345678@Component@Data@ConfigurationProperties(prefix = &quot;servers&quot;)public class ServerConfig &#123; private String ipAddress; private int port; private long timeout;&#125; 测试： 12345678910@SpringBootTestclass ApplicationTests &#123; @Autowired private ServerConfig serverConfig; @Test void testGetServer() &#123; System.out.println(serverConfig); &#125;&#125; 2.2 第三方bean属性绑定导入druid坐标： 12345&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.1.16&lt;/version&gt;&lt;/dependency&gt; application.yaml中： 12dataSource: driverClassName: com.mysql.jdbc.driver123 配置bean： 123456789101112@Configurationpublic class DataSourceConfig &#123; @Bean @ConfigurationProperties(prefix = &quot;datasource&quot;) public DruidDataSource dataSource() &#123; DruidDataSource dataSource = new DruidDataSource(); //使用配置文件中的属性进行注入 //dataSource.setDriverClassName(&quot;com.mysql.jdbc.driver&quot;); return dataSource; &#125;&#125; 测试： 12345678910@SpringBootTestclass ApplicationTests &#123; @Autowired private DruidDataSource dataSource; @Test void testDataSource() &#123; System.out.println(dataSource.getDriverClassName()); &#125;&#125; @EnableConfigurationProperties注解： 开启属性绑定并设置对应的目标 可以将使用的@ConfigurationProperties注解对应的类加入Spring容器 @EnableConfigurationProperties注解与@Component注解不能同时使用 123456789101112@Configuration@EnableConfigurationProperties(ServerConfig.class)public class DataSourceConfig &#123; @Bean @ConfigurationProperties(prefix = &quot;datasource&quot;) public DruidDataSource dataSource() &#123; DruidDataSource dataSource = new DruidDataSource(); //dataSource.setDriverClassName(&quot;123456&quot;); return dataSource; &#125;&#125; 此时要将ServerConfig中的@Component注释删除： 如果不删除@Component注释，则会造成bean加载两次，报错 12345678//@Component@Data@ConfigurationProperties(prefix = &quot;servers&quot;)public class ServerConfig &#123; private String ipAddress; private int port; private long timeout;&#125; 如果idea出现Spring Boot Configuration Annotation Processor not configured问题： 导入坐标即可： 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt;&lt;/dependency&gt; 2.3 松散绑定@ConfigurationProperties注解：绑定属性支持属性名宽松绑定 12345678@Component@Data@ConfigurationProperties(prefix = &quot;servers&quot;)public class ServerConfig &#123; private String ipAddress; private int port; private long timeout;&#125; 支持多种格式： 12345678servers: #ipAddress: 127.0.0.1 #驼峰格式 #ipaddress: 127.0.0.1 #ip_address: 127.0.0.1 #unline格式 #IPADDRESS: 127.0.0.1 #IP_ADDRESS: 127.0.0.1 #常量格式 #IP_ADD_RE_SS: 127.0.0.1 ip-address: 127.0.0.1 #烤肉串格式 注意：宽松绑定不支持@value 注解引用单个属性的方式 @ConfigurationProperties注解：绑定属性支持属性名宽松绑定 绑定前缀规范： 指的是：prefix = &quot;datasource&quot;中的datasource 仅能用使用小写字母、数字、中划线作为合法字符 1234567@Bean@ConfigurationProperties(prefix = &quot;datasource&quot;)public DruidDataSource dataSource() &#123; DruidDataSource dataSource = new DruidDataSource(); //dataSource.setDriverClassName(&quot;123456&quot;); return dataSource;&#125; 2.4 常用计量单位的应用123456servers: ipAddress: 127.0.0.1 #驼峰格式 port: 2345 timeout: -1 serverTimeout: 3 dataSize: 10 指定单位： 123456789101112@Component@Data@ConfigurationProperties(prefix = &quot;servers&quot;)public class ServerConfig &#123; private String ipAddress; private int port; private long timeout; //long类型描述时间单位为毫秒 @DurationUnit(ChronoUnit.HOURS) //指定描述时间单位为小时 private Duration serverTimeout; @DataSizeUnit(DataUnit.MEGABYTES) //指定内存大小单位为MB private DataSize dataSize;&#125; 2.4 bean属性校验导入JSR303规范接口的坐标： 1234&lt;dependency&gt; &lt;groupId&gt;javax.validation&lt;/groupId&gt; &lt;artifactId&gt;validation-api&lt;/artifactId&gt;&lt;/dependency&gt; 导入使用hibernate框架提供的校验器做实现类的坐标： 1234&lt;dependency&gt; &lt;groupId&gt;org.hibernate.validator&lt;/groupId&gt; &lt;artifactId&gt;hibernate-validator&lt;/artifactId&gt;&lt;/dependency&gt; @Validated注解为开启bean的校验功能： @Min注解为设置最小值，并设置提示信息 @Max注解为设置最大值，并设置提示信息 等等还有很多… 123456789@Component@Data@ConfigurationProperties(prefix = &quot;servers&quot;)@Validatedpublic class ServerConfig &#123; @Min(value = 1000, message = &quot;最小值不能超过1000&quot;) @Max(value = 8888, message = &quot;最大值不能超过8888&quot;) private int port;&#125; 2.5 进制数据转换规则配置文件的dataSource中的password设置为012345： 123dataSource: driverClassName: com.mysql.jdbc.driver123 password: 012345 测试： 123456789@SpringBootTestclass ApplicationTests &#123; @Autowired private DruidDataSource dataSource; @Test void testDataSource() &#123; System.out.println(dataSource.getPassword()); &#125;&#125; 获取的passord为5347，明显与设置的密码不符 这是因为0开头的密码被当成八进制进行处理了 将密码用改用字符串形式，用双引号包裹： 123dataSource: driverClassName: com.mysql.jdbc.driver123 password: &quot;012345&quot; yaml语法规则 字面值表达方式： 12345678boolean: TRUE #TRUE true True FALSE False false均可float: 3.14 #支持科学计数法 6.5201314e+5int: 123 #支持二进制 八进制 十六进制null: ~ #使用 ~ 表示nullstring1: HelloWord #字符串可以直接书写string2: &quot;Hello Word&quot; #可以使用双引号包裹特殊字符data: 2022-07-27 #日期格式必须使用yyyy-MM-dd格式datatime: 2022-07-27T20:37:30+08:00 #日期与时间之间使用T连接，最后使用+代表时区 3.测试3.1 加载测试专用属性application.yaml配置文件中： 12test: prop: testVal 测试，读取prop值： 1234567891011@SpringBootTestpublic class PropertiesAndArgsTest &#123; @Value(&quot;$&#123;test.prop&#125;&quot;) private String val; @Test void testProperties() &#123; System.out.println(val); &#125;&#125; 运行结果：testVal 第一种方式：properties属性 可以使用@SpringBootTest注解中： properties属性可以为当前测试用例添加临时的属性配置 并且可以覆盖主配置文件的属性配置 优点：比多环境开发中的测试环境影响范围更小，仅对当前测试类有效 1234567891011@SpringBootTest(properties = &#123;&quot;test.prop=test1&quot;&#125;)public class PropertiesAndArgsTest &#123; @Value(&quot;$&#123;test.prop&#125;&quot;) private String val; @Test void testProperties() &#123; System.out.println(val); &#125;&#125; 运行结果：test1 第二种方式：args属性 可以使用@SpringBootTest注解中： args属性可以为当前测试用例添加临时命令行参数 并且可以覆盖主配置文件的属性配置 1234567891011@SpringBootTest(args = &#123;&quot;--test.prop=test2&quot;&#125;)public class PropertiesAndArgsTest &#123; @Value(&quot;$&#123;test.prop&#125;&quot;) private String val; @Test void testProperties() &#123; System.out.println(val); &#125;&#125; 运行结果：test2 第三种方式：同时使用properties属性以及args属性 1234567891011@SpringBootTest(properties = &#123;&quot;test.prop=test1&quot;&#125;, args = &#123;&quot;--test.prop=test2&quot;&#125;)public class PropertiesAndArgsTest &#123; @Value(&quot;$&#123;test.prop&#125;&quot;) private String val; @Test void testProperties() &#123; System.out.println(val); &#125;&#125; 运行结果：test2 所以，优先级为命令行参数args属性 &gt; properties属性 &gt; application.yaml配置文件 3.2 加载测试专用配置在test包下创建MsgConfig配置类： 仅服务于测试下的，不能定义在main包下，如果定义到main包下就属于源码级别了 导入第三方bean太麻烦，简单的定义一个bean 1234567@Configurationpublic class MsgConfig &#123; @Bean public String Msg()&#123; return &quot;bean msg&quot;; &#125;&#125; 使用@Import注解加载当前测试类专用的配置： 1234567891011@SpringBootTest@Import(&#123;MsgConfig.class&#125;)public class ConfigTest &#123; @Autowired private String Msg; @Test void testGetMsg() &#123; System.out.println(Msg); &#125;&#125; 3.3 测试类启动Web环境导入坐标： 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt; 创建一个UserController： 12345678910@RestController@RequestMapping(&quot;/users&quot;)public class UserController &#123; @GetMapping public String getById()&#123; System.out.println(&quot;getById is running&quot;); return &quot;UserId&quot;; &#125;&#125; 测试： webEnvironment属性： SpringBootTest.WebEnvironment.NONE为默认关闭web环境 SpringBootTest.WebEnvironment.DEFINED_PORT为配置文件中定义的端口 SpringBootTest.WebEnvironment.RANDOM_PORT为随机端口 1234567@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)public class MvcTest &#123; @Test void testRandomPort() &#123; &#125;&#125; 虚拟发送请求： 12345678910111213@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.DEFINED_PORT)@AutoConfigureMockMvc //开启虚拟Mvc的调用public class MvcTest &#123; @Test //注入虚拟Mvc调用对象 void testWeb(@Autowired MockMvc mockMvc) throws Exception &#123; //创建虚拟请求，当前访问/books，get请求 MockHttpServletRequestBuilder builder = MockMvcRequestBuilders.get(&quot;/users&quot;); //执行请求 mockMvc.perform(builder); &#125;&#125; 3.4 虚拟请求匹配响应虚拟请求状态匹配： 12345678910111213141516@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.DEFINED_PORT)@AutoConfigureMockMvcpublic class MvcTest &#123; @Test void testStatus(@Autowired MockMvc mockMvc) throws Exception &#123; MockHttpServletRequestBuilder builder = MockMvcRequestBuilders.get(&quot;/users&quot;); ResultActions actions = mockMvc.perform(builder); //定义本次调用的预期值 StatusResultMatchers status = MockMvcResultMatchers.status(); //预计本次调用成功，状态为200 ResultMatcher ok = status.isOk(); //添加预计值到本次调用中进行比较 actions.andExpect(ok); &#125;&#125; 虚拟请求体匹配： 12345678910111213141516@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.DEFINED_PORT)@AutoConfigureMockMvcpublic class MvcTest &#123; @Test void testBody(@Autowired MockMvc mockMvc) throws Exception &#123; MockHttpServletRequestBuilder builder = MockMvcRequestBuilders.get(&quot;/users&quot;); ResultActions actions = mockMvc.perform(builder); //定义本次调用的预期值 ContentResultMatchers content = MockMvcResultMatchers.content(); //预计本次调用成功，响应值为&quot;UserId&quot; ResultMatcher result = content.string(&quot;UserId&quot;); //添加预计值到本次调用中进行比较 actions.andExpect(result); &#125;&#125; 虚拟请求体(Json)匹配： 导入坐标： 123456789&lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;cn.hutool&lt;/groupId&gt; &lt;artifactId&gt;hutool-all&lt;/artifactId&gt; &lt;version&gt;5.7.17&lt;/version&gt;&lt;/dependency&gt; 创建User实体类： 123456@Datapublic class User &#123; private int id; private String name; private int age;&#125; UserController中： 1234567891011121314@RestController@RequestMapping(&quot;/users&quot;)public class UserController &#123; @GetMapping public User getById()&#123; System.out.println(&quot;getById is running&quot;); User user = new User(); user.setId(1); user.setAge(18); user.setName(&quot;大黄&quot;); return user; &#125;&#125; 测试： 123456789101112131415161718192021@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.DEFINED_PORT)@AutoConfigureMockMvc //开启虚拟Mvc的调用public class MvcTest &#123; @Test void testJson(@Autowired MockMvc mockMvc) throws Exception &#123; MockHttpServletRequestBuilder builder = MockMvcRequestBuilders.get(&quot;/users&quot;); ResultActions actions = mockMvc.perform(builder); //定义本次调用的预期值 ContentResultMatchers content = MockMvcResultMatchers.content(); //预计本次调用成功，返回的值 User user = new User(); user.setId(1); user.setAge(18); user.setName(&quot;大黄&quot;); String userJson = JSONUtil.toJsonStr(user); //转换成Json ResultMatcher result = content.json(userJson); //添加预计值到本次调用中进行比较 actions.andExpect(result); &#125;&#125; 虚拟请求头匹配： 测试： 12345678910111213141516@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.DEFINED_PORT)@AutoConfigureMockMvc //开启虚拟Mvc的调用public class MvcTest &#123; @Test void testContentType(@Autowired MockMvc mockMvc) throws Exception &#123; MockHttpServletRequestBuilder builder = MockMvcRequestBuilders.get(&quot;/users&quot;); ResultActions actions = mockMvc.perform(builder); //定义本次调用的预期值 HeaderResultMatchers header = MockMvcResultMatchers.header(); //预计本次调用成功，返回的值 ResultMatcher contentType = header.string(&quot;Content-Type&quot;, &quot;application/json&quot;); //添加预计值到本次调用中进行比较 actions.andExpect(contentType); &#125;&#125; 通常测试，会写到一起： 123456789101112131415161718192021222324252627@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.DEFINED_PORT)@AutoConfigureMockMvc //开启虚拟Mvc的调用public class MvcTest &#123; @Test void testGetById(@Autowired MockMvc mockMvc) throws Exception &#123; MockHttpServletRequestBuilder builder = MockMvcRequestBuilders.get(&quot;/users&quot;); ResultActions actions = mockMvc.perform(builder); StatusResultMatchers status = MockMvcResultMatchers.status(); ResultMatcher ok = status.isOk(); actions.andExpect(ok); HeaderResultMatchers header = MockMvcResultMatchers.header(); ResultMatcher contentType = header.string(&quot;Content-Type&quot;, &quot;application/json&quot;); actions.andExpect(contentType); ContentResultMatchers content = MockMvcResultMatchers.content(); User user = new User(); user.setId(1); user.setAge(18); user.setName(&quot;大黄&quot;); String userJson = JSONUtil.toJsonStr(user); //转换成Json ResultMatcher result = content.json(userJson); actions.andExpect(result); &#125;&#125; 3.5 业务层测试事务回滚导入坐标： 12345678910111213141516&lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt; &lt;version&gt;3.5.2&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.2.11&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;&lt;/dependency&gt; 配置文件： 1234567891011121314151617spring: datasource: druid: driver-class-name: com.mysql.cj.jdbc.Driver url: jdbc:mysql://localhost:3306/demo?serverTimezone=UTC username: root password: 123456mybatis-plus: global-config: db-config: table-prefix: tbl_ #将id设为自动增长 id-type: auto configuration: #开启日志，标准输出：将数据打印到控制台 log-impl: org.apache.ibatis.logging.stdout.StdOutImpl Dao层： 1234@Mapperpublic interface BookDao extends BaseMapper&lt;Book&gt;&#123;&#125; Service层： 123public interface BookService extends IService&lt;Book&gt; &#123; boolean saveBook(Book book);&#125; 12345678@Servicepublic class BookServiceImpl extends ServiceImpl&lt;BookDao, Book&gt; implements BookService &#123; @Override public boolean saveBook(Book book) &#123; return save(book); &#125;&#125; 测试： @Transactional：为测试用例添加事务，SpringBoot会对测试用例对应的事务提交操作进行回滚@Rollback：默认为true(可不写此注释)，改为false为提交事务，不回滚 1234567891011121314151617@SpringBootTest@Transactional //开启SpringBoot事务@Rollback(value = true) //默认value值为true，开启回滚(可不写)；value值为false，关闭回滚public class DaoTest &#123; @Autowired private BookService bookService; @Test void testSave() &#123; Book book = new Book(); book.setName(&quot;springboot&quot;); book.setType(&quot;java&quot;); book.setDescription(&quot;这是书&quot;); bookService.saveBook(book); &#125;&#125; 3.6 测试用例设置随机数据在配置文件中添加： 123456testcase: book: id: $&#123;random.int&#125; name: 用户$&#123;random.value&#125; #可加前缀 uuid: $&#123;random.uuid&#125; time: $&#123;random.long&#125; 测试： 1234@Testvoid testBookCase(@Autowired BookCase bookCase) &#123; System.out.println(bookCase);&#125; 多次运行： 1BookCase(id=-1723189530, name=用户36fc0553fae0662a1398f194a79d702c, uuid=c4f742bf-85b8-4416-836d-ab656e20c050, time=9037975923279012585) 1BookCase(id=1758479696, name=用户4952f34e3caadde83261a58b5c9a439f, uuid=4a5747f7-80ff-4161-8771-8dfdce6c470a, time=-2080170540354815861) 1BookCase(id=1773052492, name=用户88777f3bd07cb35dfe29b18b4873e7ed, uuid=3bd7d980-d5d6-46f2-bbf3-c190cdfe28ec, time=-4024744750514505719) 测试通常采用随机值进行测试，使用SpringBoot提供的随机数为其赋值： 12345678testcase: book: id: $&#123;random.int&#125; # 随机整数 id2: $&#123;random.int(10)&#125; # 10以内的整数 id3: $&#123;random.int(5,10)&#125; # 5~10之间的整数 name: 用户$&#123;random.value&#125; # 随机字符串，MD5字符串，32位 可加前缀 uuid: $&#123;random.uuid&#125; # 随机uuid time: $&#123;random.long&#125; # 随机整数，long范围 其中，random.int(5,10)的括号()可以是任意字符，如[]、@@、!!等均可 4.数据层解决方案现有数据层解决方案技术选型： Druid + MyBatis-Plus + MySQL 数据源：DruidDataSource 持久化技术：MyBatis / MyBatis-Plus 数据库：MySQL 4.1 内置数据源数据源配置格式： 格式一： 1234567spring: datasource: druid: driver-class-name: com.mysql.cj.jdbc.Driver url: jdbc:mysql://localhost:3306/demo?serverTimezone=UTC username: root password: 123456 格式二： 1234567spring: datasource: driver-class-name: com.mysql.cj.jdbc.Driver url: jdbc:mysql://localhost:3306/demo?serverTimezone=UTC username: root password: 123456 type: com.alibaba.druid.pool.DruidDataSource 以上两种格式都指定数据源为druid， 如果未指定数据源呢？ 123456spring: datasource: driver-class-name: com.mysql.cj.jdbc.Driver url: jdbc:mysql://localhost:3306/demo?serverTimezone=UTC username: root password: 123456 运行后，采用的数据源依旧是druid 因为导入druid-spring-boot-starter的坐标，会自动配置数据源： 12345&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.2.11&lt;/version&gt;&lt;/dependency&gt; 将druid-spring-boot-starter坐标注释或删除，不提供数据源， SpringBoot会提供3种内嵌的数据源对象供开发者选择： HikariCP：默认内置数据源对象 Tomcat提供DataSource：HikariCP在不可用的情况下，且在Web环境中，将使用Tomcat服务器配置的数据源对象 Commons DBCP：HikariCP和Tomcat数据源都不可用，将使用dbcp数据源 HikariCP数据源配置： 12345678spring: datasource: url: jdbc:mysql://localhost:3306/demo?serverTimezone=UTC hikari: driver-class-name: com.mysql.cj.jdbc.Driver username: root password: 123456 maximum-pool-size: 8 4.2 JdbcTemplateSpringBoot内置JdbcTemplate持久化解决方案： 导入坐标： 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt;&lt;/dependency&gt; 此外，MyaBtis-Plus坐标已经包含了上面的坐标 测试： 123456789101112131415161718192021222324252627282930313233343536@SpringBootTestpublic class JdbcTest &#123; @Autowired private JdbcTemplate jdbcTemplate; @Test void testQueryForList() &#123; String sql = &quot;select * from tbl_book where id = 1&quot;; List&lt;Map&lt;String, Object&gt;&gt; books = jdbcTemplate.queryForList(sql); System.out.println(&quot;books = &quot; + books); &#125; @Test void testQuery() &#123; RowMapper&lt;Book&gt; rm = new RowMapper&lt;Book&gt;() &#123; @Override public Book mapRow(ResultSet resultSet, int i) throws SQLException &#123; Book book = new Book(); book.setId(resultSet.getInt(&quot;id&quot;)); book.setName(resultSet.getString(&quot;name&quot;)); book.setType(resultSet.getString(&quot;type&quot;)); book.setDescription(resultSet.getString(&quot;description&quot;)); return book; &#125; &#125;; String sql = &quot;select * from tbl_book&quot;; List&lt;Book&gt; books = jdbcTemplate.query(sql, rm); System.out.println(&quot;books = &quot; + books); &#125; @Test void testSave() &#123; String sql = &quot;insert into tbl_book values (null, &#x27;sss&#x27;, &#x27;aaa&#x27;, &#x27;bbb&#x27;)&quot;; jdbcTemplate.update(sql); &#125;&#125; JdbcTemplate配置： 123456spring: jdbc: template: fetch-size: -1 # 缓存行数 query-timeout: -1 # 查询超时时间 max-rows: -1 # 最大行数 4.3 内嵌数据库SpringBoot提供了3种内嵌数据库供开发者选择，提高开发测试效率： H2 HSQL Derby 以H2数据库为例： 导入坐标： 123456789&lt;dependency&gt; &lt;groupId&gt;com.h2database&lt;/groupId&gt; &lt;artifactId&gt;h2&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;&lt;/dependency&gt; 同时还需要Web环境，所以还要导入坐标： 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt; 配置文件： 1234567server: port: 8080spring: h2: console: path: /h2 enabled: true 访问用户名为sa，默认密码为123456 在浏览器请求链接：http://localhost:8080/h2 点击连接，第一次连接会报错，需要初始化添加上面的相关配置 添加H2数据库配置： 12345678910111213server: port: 8080spring: h2: console: path: /h2 enabled: true datasource: url: jdbc:h2:~/test hikari: driver-class-name: org.h2.Driver username: sa password: 123456 连接成功后： 在上方的空白框中执行下面的语句，创建表： 1create table tbl_book (id int, type varchar, name varchar, description varchar) 查询语句： 1select * from tbl_book 需要停止SpringBoot项目服务，才可以进行测试 测试： 1234567891011121314151617181920212223242526272829303132@SpringBootTestpublic class JdbcTest &#123; @Autowired private JdbcTemplate jdbcTemplate; @Test void testQuery() &#123; //查询所有 RowMapper&lt;Book&gt; rm = new RowMapper&lt;Book&gt;() &#123; @Override public Book mapRow(ResultSet resultSet, int i) throws SQLException &#123; Book book = new Book(); book.setId(resultSet.getInt(&quot;id&quot;)); book.setName(resultSet.getString(&quot;name&quot;)); book.setType(resultSet.getString(&quot;type&quot;)); book.setDescription(resultSet.getString(&quot;description&quot;)); return book; &#125; &#125;; String sql = &quot;select * from tbl_book&quot;; List&lt;Book&gt; books = jdbcTemplate.query(sql, rm); System.out.println(&quot;books = &quot; + books); &#125; @Test void testSave() &#123; //插入 String sql = &quot;insert into tbl_book values (2, &#x27;sss&#x27;, &#x27;aaa&#x27;, &#x27;bbb&#x27;)&quot;; jdbcTemplate.update(sql); &#125;&#125; 改用MyBatis-Plus技术也是可以的，并且无缝衔接，只需导入MyBatis-Plus坐标： 12345&lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt; &lt;version&gt;3.5.2&lt;/version&gt;&lt;/dependency&gt; 添加MyBatis-Plus的配置： 123456789mybatis-plus: global-config: db-config: table-prefix: tbl_ #将id设为自动增长 id-type: auto configuration: #开启日志，标准输出：将数据打印到控制台 log-impl: org.apache.ibatis.logging.stdout.StdOutImpl 测试： 1234567891011@SpringBootTestpublic class DaoTest &#123; @Autowired private BookService bookService; @Test void testSelectAll() &#123; List&lt;Book&gt; list = bookService.list(); System.out.println(&quot;list = &quot; + list); &#125;&#125; H2数据库控制台仅用于开发阶段，线上项目请务必关闭控制台功能： 将enabled改为false 1234567server: port: 8080spring: h2: console: path: /h2 enabled: false 5.整合第三方技术6.监控","categories":[{"name":"Java","slug":"Java","permalink":"http://example.com/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"},{"name":"框架","slug":"框架","permalink":"http://example.com/tags/%E6%A1%86%E6%9E%B6/"}]},{"title":"Redis的学习笔记","slug":"Java/Redis","date":"2022-08-06T11:11:16.304Z","updated":"2022-08-13T09:42:41.489Z","comments":true,"path":"2022/08/06/Java/Redis/","link":"","permalink":"http://example.com/2022/08/06/Java/Redis/","excerpt":"","text":"基础篇1.初识Redis1.1 认识NoSql键值数据库是一种NoSql数据库 key value 1001 { “id”:1001, “name”:”张三”, “age”:20,} SQL：关系型数据库 NoSQL：非关系型数据库 SQL与NoSQl的比较： SQL NoSQL 数据结构 结构化 非结构化：1.键值类型(Redis)2.文档类型(MongoDB)3.列类型(HBase)4.Graph类型(Neo4j) 数据关联 关联的(数据有关联) 无关联的 查询方式 SQL查询(SQL语法通用) 非SQL(语法不统一) 事务特性 ACID BASE 存储方式 磁盘 内存 扩展性 垂直 水平 使用场景 1.数据结构固定2.相关业务数据安全性、一致性要求较高 1.数据结构不固定2.相关业务数据安全性、一致性要求不高3.对性能要求 1.2 认识RedisRedis诞生于2009年全称时Remote Dictionary Server，远程词典服务器，是一个基于内存的键值型NoSQL数据库。 特征： 键值(key-value)型：value支持多种不同数据结构，功能丰富 单线程：每个命令具备原子性 低延迟、速度快：基于内存、IO多路复用、良好的编码(C语言开发) 支持数据持久化 支持主从集群、分片集群 支持多语言客户端 1.3 Redis的安装及其配置(不要看这个教程安装，有问题我还要改)​ 大多企业都是基于Linux服务器来部署项目，而且Redis官方也没有提供Windows版本的安装包。因此会使用基于Linux系统来安装Redis。 Redis官网：Redis Linux版本为：CentOS7 注意：下面的安装Redis方法不适用于Ubuntu 打开命令行，依次输入一下内容： 123456789101112131415#转换成root权限su - #输入密码#安装gcc依赖yum install -y gcc tcl#进入到src目录cd /usr/local/src#下载redis-6.2.6.tar.gzwget https://download.redis.io/releases/redis-6.2.6.tar.gz#解压redis-6.2.6.tar.gztar -zxvf redis-6.2.6.tar.gz#进入redis-6.2.6cd redis-6.2.6#运行编译命令make &amp;&amp; make install 默认安装路径为/usr/local/bin目录下： 1ll /usr/local/bin 看到这个样子安装基本成功了 Redis的配置文件： 重新打开命令行： 12345678su -#输入密码#进入到redis-6.2.6目录cd /usr/local/src/redis-6.2.6#备份redis.confcp redis.conf redis.conf.bck#打开redis.conf配置文件vi redis.conf 修改redis.conf文件的一些配置： 123456#bind 127.0.0.1 -::会导致只能在本地访问，修改为0.0.0.0就可以在任意ip访问，生产环境不要设置为0.0.0.0bind 0.0.0.0#守护进程，修改为yes即可后台运行daemonize yes#设置密码为123456requirepass 123456 查找：/+所要查找的字符串；按n向下查找，按N向上查找 输入i即可修改数据，修改完成后按ESC退出编辑 :wq为保存并退出 退出后： 12345redis-server redis.conf#查看redis进程ps -ef|grep redis #杀死进程kill -9 端口号 接着设置开机自启： 12#新建一个系统服务文件vi /etc/systemd/system/redis.service 将下面内容全部复制到redis.service文件中： 1234567891011[Unit]Description=redis-serverAfter=network.target[Service]Type=forkingExecStart=/usr/local/bin/redis-server /usr/local/src/redis-6.2.6/redis.confPrivateTmp=true[Install]WantedBy=multi-user.target 保存退出后， 接着: 12345678910#重载系统服务systemctl daemon-reload#启动redissystemctl start redis#查看redis状态systemctl status redis#停止redissystemctl stop redis#redis开机自启systemctl enable redis 2.Redis命令2.1 Redis数据结构介绍Redis是一个key-value的数据库，key一般是String类型，不过value的类型多种多样： 数据类型 格式 String hello Redis Hash {name: “jack”, age: 21} List [A -&gt; B -&gt; C -&gt; D] Set {A, B, C} SortSet {A: 1, B: 2, C: 3} GEO(地理坐标) {A: (120.3, 30.5)} BitMap 0101001001100101011001000110100101110011 HyperLog 0101001001100101011001000110100101110011 基本类型：String、Hash、List、Set、SortSet 特殊类型：GEO、BitMap、HyperLog 2.2 Redis通用命令 命令 解释 举例 KEYS 查看符合模板的所有key，不建议在生产环境设备上使用(效率低) KEYS *：查看所有keyKEYS n*：查看所有n开头的key DEL 删除一个指定key DEL name：删除name EXISTS 判断key是否存在 EXISTS name：存在返回1，否则返回0 EXPIRE 给一个key设置有效期，有效期到期key会被自动删除 EXPIRE name 20：设置name的有效期为20秒 TTL 查看一个key的剩余有效期 TTL name：查看name的有效期，如果返回-2，则说明到期了如果返回-1，则说明永久有效 2.3 String类型String类型、也就是字符串类型，是Redis中最简单的存储类型 其value是字符串，不过根据字符串的格式不同，又可以分类为3类： string：普通字符串 int：整数类型，可以做自增、自减操作 float：浮点类型，可以做自增、自减操作 不管是哪种格式，底层都是字节数组形式存储，字符串类型的最大空间不能超过512m Key Value msg hello Redis num 10 score 98.5 String类型常见命令： 命令 SET key value 添加或修改已经存在的一个String类型的键值对 SET name Jerry：把name的value设置为Jerry GET key 根据key获取String类型的value GET name：获取到value为”Jerry” MSET 批量添加多个String类型的键值对 MSET score 12.5 age 18：添加多个键值对 MGET 根据多个key获取多个String类型的value MGET name score age：得到多个value为”Jreey” “12.5” “18” INCR 让一个整型的key自增1 INCR age：age的value加1，由18变为19 INCRBY 让一个整型的key自增并指定步长 INCRBY age 2：age的value加2，由19变为21 INCRBYFLOAT 让一个浮点类型的数字自增并指定步长 INCRBYFLOAT score 0.5：score的value加0.5，由12.5变为13.0 SETNX 添加一个String类型的键值对，前提是这个key不存在，否则不执行(新增效果) SETNX name Tom：不执行，返回0SETNX k1 v1：执行，返回1 SETEX 添加一个String类型的键值对，并且指定有效期 SETEX name 10 jerry ：添加键值对，并将有效期设置为10秒 2.4 Key的层级格式Redis没有类似于MySQL中的Table表的概念 Redis的Key允许有多个单词形成层级结构，多个单词之间用:隔开，格式(不固定)如下： 项目名:业务名:类型:id 例如项目名叫demo，有user和book两种不同类型的数据，我们可以这样定义Key： user相关的Key：demo:user:1 book相关的Key：demo:book:1 如果Value是一个java对象，例如一个User对象，则可以将对象序列化为json字符串后存储： Key Value demo:user:1 {“id”: 1, “name”: “Jerry”, “age”: 18} demo:book:1 {“id”: 1, “name”: “BOOK”, “price”: 15} 插入操作(注意：Value值要加&#39;&#39;)： set demo:user:1 &#39;&#123;&quot;id&quot;: 1, &quot;name&quot;: &quot;Jerry&quot;, &quot;age&quot;: 18&#125;&#39; set demo:book:1 &#39;&#123;&quot;id&quot;: 1, &quot;name&quot;: &quot;BOOK&quot;, &quot;price&quot;: 15&#125;&#39; 打开图形界面客户端查看： 2.5 Hash类型Hash类型，也叫散列，其value是一个无序字典，类似于java中的HashMap结构 String结构是将对象序列化为json字符串后存储，当需要修改对象某个字段时很不方便(需要修改整个字符串)： Key Value demo:user:1 {“id”: 1, “name”: “Jerry”, “age”: 18} demo:user:2 {“id”: 2, “name”: “Tom”, “price”: 20} 而Hash结构可以将对象中每个字段独立存储，可以针对单个字段做CRUD： Key Value field value demo:user:1 name Jerry age 18 demo:user:2 name Tom age 20 Hash类型常见命令： 命令 HSET key field value 添加或修改hash类型key的field的值 HSET demo:user:2 name LiHua：把name的value设置为Lihua HGET key field 获取一个hash类型key的field的值 HGET demo:user:2 name：获取到value为”LiHua” HMSET 批量添加多个hash类型key的field的值 HMSET demo:user:3 name LiLei age 22：添加多个field的值 HMGET 批量获取根据多个hash类型key的field的值 HMGET demo:user:3 name age：得到多个field的值为”LiLei” “22” HGETALL 获取一个hash类型的key中的所有的field和value HGETALL demo:user:3：获取到key中所有的field和value HKEYS 获取一个hash类型的key中的所有的field HKEYS demo:user:3：获取key中所有的field HVALS 获取一个hash类型的key中的所有的value HVALS demo:user:3：获取key中所有的value HINCRBY 让一个hash类型的key的字段自增并指定步长 HINCRBY demo:user:3 age 2：age的value加2，由22变为24 HSETNX 添加一个hash类型的key的field值，前提是这个field不存在，否则不执行(新增效果) HSETNX demo:user:3 name XXX：存在field值不执行，返回0HSETNX demo:user:3 sex man：不存在field值执行，返回1 2.6 List类型Redis中的List类型与java中的LinkList类似，可以看作是一个双向链表结构，既可以支持正向检索也可以支持反向检索。 特征与LinkList也类似： 有序 元素可以重复 插入和删除快 查询速度一般 常用来存储一个有序数据，如：评论列表、点赞列表等 List类型的常见命令： LPUSH key element 向列表左侧插入一个或多个元素 LPUSH user 1 2 3：表中从第一位依次为 “3” “2” “1” LPOP key 移除并返回列表左侧的第一个元素，没有则返回nil LPOP user 1 RPUSH key element 向列表右侧插入一个或多个元素 RPUSH user 4 5 6：表中从第一位依次为 “4” “5” “6” RPOP key 移除并返回列表右侧的第一个元素 LRANGE key star end 返回一段角标范围内的所有元素 LRANGE 1 star 2：从0开始，获取到1~2之间的元素 BLPOP 与LPOP类似，只不过在没有元素时等待指定时间，而不是直接返回nil BLPOP user2 1 100：移除并返回到左侧的第一个元素，没有则等待100秒，超时返回nil BRPOP 与RPOP类似，只不过在没有元素时等待指定时间，而不是直接返回nil List结构模拟一个栈 入口和出口在同一边 如：LPUSH和LPOP或者 RPUSH和RPOP List结构模拟一个队列 入口和出口不在同一边 如：LPUSH和RPOP 或者 RPUSH和LPOP List结构模拟一个阻塞队列 入口和出口不在同一边 出队采用BLPOP或者BRPOP 如：LPUSH和BRPOP 或者 RPUSH和BLPOP 2.7 Set类型Redis的Set结构与Java中的Hashset类似，可以看做是一个value为null的HashMap。因为也是一个hash表，因此具备与Hashset类似的特征： 无序 元素不可重复 查找快 支持交集、并集、差集等功能 Set类型的常见命令： SADD key member 向set中添加一个或多个元素 SADD s1 a b c SREM key member 移除set中的指定元素 SREM s1 a SCARD key 返回set中元素的个数 SCARD s1 SISMEMBER key member 判断一个元素是否存在于set中 SISMEMBER s1 a SMEMBERS 获取set中的所有元素 SMEMBERS SINTER key1 key2 求key1与key2的交集 SDIFF key1 key2 求key1与key2的差集 SUNION key1 key2 求key1与key2的并集 2.8 SortedSet类型Redis的SortedSet是一个可排序的set集合，与java中的TreeSet有些类似，但底层数据结构却差别很大Sortedset中的每一个元素都带有一个score属性，可以基于score属性对元素排序，底层的实现是一个跳表(SkipList)加hash表。SortedSet具备下列特性： 可排序 元素不重复 查询速度快 因为Sortedset的可排序特性，经常被用来实现排行榜这样的功能。 SortedSet类型的常见命令： ZADD key score member 添加一个或多个元素到sorted set，如果已经存在则更新其score值 ZADD SSet 85 Tom 98 Jerry 77 Rose 78 Jack：向SSet中添加元素，并按照升序排列 ZREM key member 删除sorted set中的一个指定元素 ZREM SSet Tom：删除Tom ZSCORE key member 获取sorted set中的指定元素的score值 ZRANK key member 获取sorted set 中的指定元素升序的排名 ZRANK SSet Rose：按照升序的序列，从0开始，返回Rose的排名 ZREVRANK key member 获取sorted set 中的指定元素降序的排名 ZRANK SSet Rose：按照降序的序列，从0开始，返回Rose的排名 ZCARD key 获取sorted set中的元素个数 ZCOUNT key min max 统计score值在给定范国内的所有元素的个数 ZINCRBY key increment member 让sorted set中的指定元素自增，步长为指定的increment值 ZRANGE key min max 按照score升序排序后，获取指定排名范围内的元素 ZCOUNT SSet 0 2：按照升序的情况，获取0~2范围的元素 ZREVRANGE key min max 按照score的降序排序后，获取指定排名范围内的元素 ZCOUNT SSet 0 2：按照降序的情况，获取0~2范围的元素 ZRANGEBYSCORE key min max 按照score排序后，获取指定score范国内的元素 ZRANGEBYSCORE SSet 0 80：返回0~80分数的元素 ZDIFF、ZINTER、ZUNION 求差集、交集、并集 注意：所有排名默认都是升序，如果降序则在命令的Z后面添加REV即可 例如：ZREVRANK 3.Redis的java客户端Redis官网中提供了各种语言的客户端 Java： Jedis：以Redis命令作为方法名称，学习成本低，简单实用但是Jedis实例是线程不安全的，多线程环境下需要基于连接池来使用 Lettuce：基于Netty实现的，支持同步、异步和响应式编程方式，并且是线程安全的。支持Redis的哨兵模式、集群模式和管道模式 Redisson：是一个基于Redis实现的分布式、可伸缩的Java数据结构集合。包含了诸如Map、Queue、LockSemaphore、Atomiclong等强大功能 其中Spring整合了Jedis和Lettuce，只需导入坐标Spring Data Redis 3.1 Jedis快速入门Jedis：Jedis官网 引入jedis依赖： 12345&lt;dependency&gt; &lt;groupId&gt;redis.clients&lt;/groupId&gt; &lt;artifactId&gt;jedis&lt;/artifactId&gt; &lt;version&gt;3.7.0&lt;/version&gt;&lt;/dependency&gt; 完整依赖： 123456789101112131415&lt;dependencies&gt; &lt;!-- jedis依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;redis.clients&lt;/groupId&gt; &lt;artifactId&gt;jedis&lt;/artifactId&gt; &lt;version&gt;3.7.0&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 测试依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.junit.jupiter&lt;/groupId&gt; &lt;artifactId&gt;junit-jupiter&lt;/artifactId&gt; &lt;version&gt;5.7.0&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 以下在Test中进行： 建立连接 123456789@BeforeEach //在测试方法执行之前执行的方法 void setUp() &#123; //建立连接 jedis = new Jedis(&quot;127.0.0.1&quot;,6379); //设置密码 jedis.auth(&quot;123456&quot;); //选择库 jedis.select(0); &#125; 测试String类型 12345@Testvoid testString() &#123; jedis.set(&quot;name&quot;,&quot;Tom&quot;); System.out.println(jedis.get(&quot;name&quot;));&#125; 释放资源 123456@AfterEach //在测试方法执行之后执行的方法void tearDown() &#123; if (jedis != null)&#123; jedis.close(); &#125;&#125; 完整测试： 12345678910111213141516171819202122232425262728293031323334public class JedisTest &#123; private Jedis jedis; @BeforeEach //在测试方法执行之前执行的方法 void setUp() &#123; //建立连接 jedis = new Jedis(&quot;127.0.0.1&quot;,6379); //设置密码 jedis.auth(&quot;123456&quot;); //选择库 jedis.select(0); &#125; @Test void testString() &#123; jedis.set(&quot;name&quot;,&quot;Tom&quot;); System.out.println(jedis.get(&quot;name&quot;)); &#125; @Test void testHash() &#123; jedis.hset(&quot;demo:user:2&quot;,&quot;name&quot;,&quot;Jerry&quot;); jedis.hset(&quot;demo:user:2&quot;,&quot;age&quot;,&quot;18&quot;); Map&lt;String, String&gt; map = jedis.hgetAll(&quot;demo:user:2&quot;); System.out.println(map); &#125; @AfterEach //在测试方法执行之后执行的方法 void tearDown() &#123; if (jedis != null)&#123; jedis.close(); &#125; &#125;&#125; jedis使用的基本步骤： 引入依赖 创建jedis对象，建立连接 使用jedis的方法名与Redis命令一致 释放资源 3.2 Jedis的连接池Jedis本身线程是不安全的，并且频繁的创建和销毁连接会有性能损耗，因此推荐使用Jedis连接池替代Jedis的直连方法 创建JedisConnectionFactory工具类： 12345678910111213141516171819202122232425262728public class JedisConnectionFactory &#123; private static final JedisPool jedisPool; static &#123; //配置连接池 JedisPoolConfig jedisPoolConfig = new JedisPoolConfig(); //最大连接数 jedisPoolConfig.setMaxTotal(8); //最大空闲连接 jedisPoolConfig.setMaxIdle(8); //最小空闲连接 jedisPoolConfig.setMinIdle(0); //等待时长 jedisPoolConfig.setMaxWaitMillis(1000); //创建连接池对象 jedisPool = new JedisPool(jedisPoolConfig, &quot;127.0.0.1&quot;, 6379, 1000, &quot;123456&quot;); &#125; public static Jedis getJedis()&#123; return jedisPool.getResource(); &#125;&#125; 测试类中： 123456789101112131415161718192021222324252627public class JedisTest &#123; private Jedis jedis; @BeforeEach //在测试方法执行之前执行的方法 void setUp() &#123; //建立连接 jedis = JedisConnectionFactory.getJedis(); //选择库 jedis.select(0); &#125; @Test void testHash() &#123; jedis.hset(&quot;demo:user:2&quot;,&quot;name&quot;,&quot;Jerry&quot;); jedis.hset(&quot;demo:user:2&quot;,&quot;age&quot;,&quot;18&quot;); Map&lt;String, String&gt; map = jedis.hgetAll(&quot;demo:user:2&quot;); System.out.println(map); &#125; @AfterEach //在测试方法执行之后执行的方法 void tearDown() &#123; if (jedis != null)&#123; //close方法当检测到是连接池时，并不是真正的关闭连接，而是将对象归还给连接池 jedis.close(); &#125; &#125;&#125; 3.3 初识SpringDataRedisSpringData是Spring中数据操作的模块，包含对各种数据库的集成，其中对Redis的集成模块就叫做SpringDataRedis 提供了对不同Redis客户端的整合 （Lettuce和Jedis） 提供了RedisTemplate统一API来操作Redis 支持Redis的发布订阅模型 支持Redis哨兵和Redis集群 支持基于Lettuce的响应式编程 支持基于JDK、JSON、字符串、Spring对象的数据序列化及反序列化 支持基于Redis的JDKCollection实现 SpringDataRedis中提供了RedisTemplate工具类，其中封装了各种对Redis的操作。并且将不同数据类型的操作API封装到了不同的类型中： API 返回值类型 解释 redisTemplate.opsForValue() ValueOperations 操作String类型数据 redisTemplate.opsForHash() HashOperations 操作Hash类型数据 redisTemplate.opsForList() ListOperations 操作List类型数据 redisTemplate.opsForSet() SetOperations 操作Set类型数据 redisTemplate.opsForZSet() ZSetOperations 操作SortedSet类型数据 redisTemplate 通用命令 3.4 SpringDataRedis快速入门SpringBoot已经提供了对SpringDataRedis的支持，其中Spring默认支持Lettuce，如需使用Jedis需要额外导入依赖 导入依赖 12345678910&lt;!-- Redis依赖 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!-- 连接池依赖 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.commons&lt;/groupId&gt; &lt;artifactId&gt;commons-pool2&lt;/artifactId&gt;&lt;/dependency&gt; 配置文件 1234567891011spring: redis: host: 127.0.0.1 port: 6379 password: 123456 lettuce: pool: max-active: 8 # 最大连接数 max-idle: 8 #最大空闲连接数 min-idle: 0 #最小空闲连接数 max-wait: 100ms # 连接等待时间 注入RedisTemplate，进行测试： 12345678910111213@SpringBootTestpublic class RedisTemplateTest &#123; @Autowired private RedisTemplate redisTemplate; @Test void testString() &#123; //插入一条String类型的数据 redisTemplate.opsForValue().set(&quot;name&quot;,&quot;dahuang&quot;); //获取String类型的数据 System.out.println(redisTemplate.opsForValue().get(&quot;name&quot;)); &#125;&#125; SpringDataRedis的使用步骤： 引入spring-boot-starter-data-redis依赖 在application.yml配置Redis以及连接池信息 注入RedisTemplate 3.5 SpringDataRedis的序列化方式RedisTemplate可以接收任意Object作为值写入Redis，只不过写入前会把Object序列化为字节形式，默认采用JDK序列化，刚才存入的数据的结果是这样： 缺点： 可读性差 内存占用较大 需要导入jackson依赖： 1234&lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;&lt;/dependency&gt; 可以自定义RedisTemplate的序列化方式： 123456789101112131415161718192021@Configurationpublic class RedisConfig &#123; @Bean public RedisTemplate&lt;String, Object&gt; redisTemplate(RedisConnectionFactory redisConnectionFactory)&#123; //创建RedisTemplate RedisTemplate&lt;String,Object&gt; redisTemplate = new RedisTemplate&lt;&gt;(); //设置连接工厂 redisTemplate.setConnectionFactory(redisConnectionFactory); //设置json序列化 GenericJackson2JsonRedisSerializer gjjrs = new GenericJackson2JsonRedisSerializer(); //设置key的序列化 redisTemplate.setKeySerializer(RedisSerializer.string()); redisTemplate.setHashKeySerializer(RedisSerializer.string()); //设置value的序列化 redisTemplate.setValueSerializer(gjjrs); redisTemplate.setHashValueSerializer(gjjrs); return redisTemplate; &#125;&#125; 创建一个实体类： 123456789101112@Datapublic class User &#123; private String name; public Integer age; public User()&#123;&#125; public User(String name, Integer age) &#123; this.name = name; this.age = age; &#125;&#125; 进行测试： 123456@Testvoid testString() &#123; redisTemplate.opsForValue().set(&quot;demo:user:3&quot;,new User(&quot;dahuang&quot;,18)); User u = (User) redisTemplate.opsForValue().get(&quot;demo:user:3&quot;); System.out.println(&quot;u = &quot; + u);&#125; 控制台打印： 1u = User(name=dahuang, age=18) Redis中的数据： 12345&#123; &quot;@class&quot;: &quot;com.redis.pojo.User&quot;, &quot;name&quot;: &quot;dahuang&quot;, &quot;age&quot;: 18&#125; 3.6 StringRedisTemplate 尽管json的序列化方式可以满足需求，但仍然存在一些问题 为了在反序列化时知道对象的类型，json序列化器会将类的class类型写入json结果中，存入Redis，会带来额外的内存开销 为了节省空间，并不会使用json序列化器来处理value，而是统一使用String序列化器，要求只能存储String类型的key和value 当存储java对象时，手动完成对象的序列化和反序列化 graph LR; 实体类 --> |手动序列化|json字符串 --> |插入|Redis Redis -->|获取| json字符串 --> |手动反序列化|实体类 Spring默认提供了一个SpringRedisTemplate类，它的key和value的序列化方式默认就是String方式。省去了自定义RedisTemplate的过程： 12345678910111213141516171819202122@SpringBootTestpublic class StringRedisTemplateTest &#123; @Autowired private StringRedisTemplate stringRedisTemplate; //json工具 private static final ObjectMapper mapper = new ObjectMapper(); @Test void testStringTemplate() throws JsonProcessingException &#123; User user = new User(&quot;dahei&quot;, 22); //手动序列化 String json = mapper.writeValueAsString(user); //插入数据 stringRedisTemplate.opsForValue().set(&quot;demo:user:5&quot;,json); //获取数据 String val = stringRedisTemplate.opsForValue().get(&quot;demo:user:5&quot;); //手动反序列化 User u = mapper.readValue(val, User.class); //打印user System.out.println(&quot;u = &quot; + u); &#125;&#125; RedisTemplate的两种序列化实践方案： 方案一： 自定义RedisTemplate 修改RedisTemplate的序列化器为GenericJackson2JsonRedisSerializer 方案二： 使用StringRedisTemplate 写入Redis时，需手动把对象序列化为json 读取Redis时，手动把读取到的json反序列化为对象 3.7 RedisTemplate操作Hash类型12345678@Testvoid testHash() &#123; stringRedisTemplate.opsForHash().put(&quot;user:6&quot;,&quot;name&quot;,&quot;dahei&quot;); stringRedisTemplate.opsForHash().put(&quot;user:6&quot;,&quot;age&quot;,&quot;22&quot;); Map&lt;Object, Object&gt; entries = stringRedisTemplate.opsForHash().entries(&quot;user:6&quot;); System.out.println(&quot;entries = &quot; + entries);&#125; 实战篇 此项目为黑马点评，如需请到vx搜索黑马程序员获取资源 项目结构： application.yaml的配置： 123456789101112131415161718192021222324252627server: port: 8081spring: application: name: hmdp datasource: driver-class-name: com.mysql.jdbc.Driver url: jdbc:mysql://localhost:3306/hmdp?useSSL=false&amp;serverTimezone=UTC username: root password: 123456 redis: host: 127.0.0.1 port: 6379 password: 123456 lettuce: pool: max-active: 10 max-idle: 10 min-idle: 1 time-between-eviction-runs: 10s jackson: default-property-inclusion: non_null # JSON处理时忽略非空字段mybatis-plus: type-aliases-package: com.hmdp.entity # 别名扫描包logging: level: com.hmdp: debug 1.短信登录1.1 基于Session实现短信登录流程发送短信验证码： 短信验证码登录、注册： 校验登录状态： 1.2 实现发送短信验证码IUserService： 1234public interface IUserService extends IService&lt;User&gt; &#123; Result sendCode(String phone, HttpSession session);&#125; UserServiceImpl中实现sendCode方法： 12345678910111213141516@Overridepublic Result sendCode(String phone, HttpSession session) &#123; //校验手机号 if (RegexUtils.isPhoneInvalid(phone)) &#123; //不符合，返回错误信息 return Result.fail(&quot;手机号格式错误&quot;); &#125; //符合，生成验证码 String code = RandomUtil.randomNumbers(6); //保存验证码到Session session.setAttribute(&quot;code&quot;,code); //发送验证码，模拟一下 log.debug(&quot;发送验证码成功，验证码为：&quot;+code); //返回OK return Result.ok();&#125; UserController： 12345@PostMapping(&quot;code&quot;)public Result sendCode(@RequestParam(&quot;phone&quot;) String phone, HttpSession session) &#123; //发送短信验证码并保存验证码 return userService.sendCode(phone, session);&#125; 日志打印： 1发送验证码成功，验证码为：608824 1.3 实现短信验证登录与注册1234public interface IUserService extends IService&lt;User&gt; &#123; Result sendCode(String phone, HttpSession session); Result login(LoginFormDTO loginForm, HttpSession session);&#125; 1234567891011121314151617181920212223242526272829303132@Overridepublic Result login(LoginFormDTO loginForm, HttpSession session) &#123; //校验手机号 if (RegexUtils.isPhoneInvalid(loginForm.getPhone())) &#123; //不符合，返回错误信息 return Result.fail(&quot;手机号格式错误&quot;); &#125; //校验验证码 String code = (String) session.getAttribute(&quot;code&quot;); if (code == null || !code.equals(loginForm.getCode())) &#123; //不一致，返回错误信息 return Result.fail(&quot;验证码错误&quot;); &#125; //一致，查询手机号是否存在 User user = query().eq(&quot;phone&quot;, loginForm.getPhone()).one(); if (user == null) &#123; //不存在，插入到数据库，完成注册 user = createUserByPhone(loginForm.getPhone()); &#125; //保存用户到Session session.setAttribute(&quot;user&quot;,user); //每个session都有唯一的id，不需要登陆凭证 return Result.ok();&#125;private User createUserByPhone(String phone) &#123; User user = new User(); user.setPhone(phone); user.setNickName(USER_NICK_NAME_PREFIX + RandomUtil.randomNumbers(10)); save(user); return user;&#125; 12345@PostMapping(&quot;/login&quot;)public Result login(@RequestBody LoginFormDTO loginForm, HttpSession session)&#123; //实现登录功能 return userService.login(loginForm,session);&#125; 1.4 实现登录校验拦截器调用/user/me接口获取用户信息时，响应中包含了手机号、密码等敏感信息，并且发送的多余信息增加了服务器的压力。所以我们只需要用户昵称、头像和id等的部分信息。 定义一个UserDto： 123456@Datapublic class UserDTO &#123; private Long id; //id private String nickName;//昵称 private String icon;//头像&#125; 将UserServiceImpl的login方法中存入session的User转换成UserDto类型： 1session.setAttribute(&quot;user&quot;, BeanUtil.copyProperties(user, UserDTO.class)); 新建LoginInterceptor拦截器： 12345678910111213141516171819202122232425public class LoginInterceptor implements HandlerInterceptor &#123; @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; //获取session HttpSession session = request.getSession(); //获取用户信息 UserDTO user = (UserDTO) session.getAttribute(&quot;user&quot;); //不存在，拦截 if (user == null)&#123; //返回状态码401，未授权 response.setStatus(401); return false; &#125; //存在，保存到TheadLocal UserHolder.saveUser(user); //放行 return true; &#125; @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123; //移除用户 UserHolder.removeUser(); &#125;&#125; 新建MvcConfig配置类，添加拦截器并添加排序路径： 12345678910111213141516@Configurationpublic class MvcConfig implements WebMvcConfigurer &#123; @Override public void addInterceptors(InterceptorRegistry registry) &#123; registry.addInterceptor(new LoginInterceptor()) .excludePathPatterns( //排除路径 &quot;/user/login&quot;, &quot;/user/code&quot;, &quot;/shop/**&quot;, &quot;/shop-type/**&quot;, &quot;/blog/hot&quot;, &quot;/upload/**&quot;, &quot;/voucher/**&quot; ); &#125;&#125; UserController中实现获取用户信息： 123456@GetMapping(&quot;/me&quot;)public Result me()&#123; //获取当前登录的用户并返回 UserDTO user = UserHolder.getUser(); return Result.ok(user);&#125; 1.5 Session共享问题分析session共享问题：多台Tomcat不能共享session存储空间，当请求切换到不同的Tomcat服务器时导致数据对是问题 session的替代方案应该满足： 数据共享 内存存储 key、value结构 Redis都能解决以上问题，并且延时低 1.6 基于Redis实现共享Session登录流程发送短信验证码： 可以采用String数据类型存储： key value 手机号 验证码 短信验证登录、注册： 保存登录用户信息，可以使用String结构，以json字符串来保存，比较直观 Hash结构可以将对象中的每一个字段独立存储，可以针对单个字段做CRUD，并且内存占用少(推荐) 保存用户到Redis： key value 随机token为key存储用户数据 {name:Tom} 校验登录状态： 1.7 基于Redis实现短信登录*修改UserServiceImpl中的sendCode方法： 12345678910111213141516171819202122@Resourceprivate StringRedisTemplate stringRedisTemplate;@Overridepublic Result sendCode(String phone, HttpSession session) &#123; //校验手机号 if (RegexUtils.isPhoneInvalid(phone)) &#123; //不符合，返回错误信息 return Result.fail(&quot;手机号格式错误&quot;); &#125; //符合，生成验证码 String code = RandomUtil.randomNumbers(6); //保存验证码到Redis，设置有效期 stringRedisTemplate.opsForValue().set(RedisConstants.LOGIN_CODE_KEY +phone, //key code, //value RedisConstants.LOGIN_CODE_TTL, // 2 TimeUnit.MINUTES);//指定单位为分钟 //发送验证码，模拟一下 log.debug(&quot;发送验证码成功，验证码为：&quot;+code); //返回OK return Result.ok();&#125; 修改UserServiceImpl中的login方法： 1234567891011121314151617181920212223242526272829303132333435363738394041@Resourceprivate StringRedisTemplate stringRedisTemplate;@Overridepublic Result login(LoginFormDTO loginForm, HttpSession session) &#123; //校验手机号 if (RegexUtils.isPhoneInvalid(loginForm.getPhone())) &#123; //不符合，返回错误信息 return Result.fail(&quot;手机号格式错误&quot;); &#125; //校验验证码 String code = stringRedisTemplate.opsForValue().get(RedisConstants.LOGIN_CODE_KEY + loginForm.getPhone()); if (code == null || !code.equals(loginForm.getCode())) &#123; //不一致，返回错误信息 return Result.fail(&quot;验证码错误&quot;); &#125; //一致，查询手机号是否存在 User user = query().eq(&quot;phone&quot;, loginForm.getPhone()).one(); if (user == null) &#123; //不存在，插入到数据库，完成注册 user = createUserByPhone(loginForm.getPhone()); &#125; //随机生成登录令牌token， String token = UUID.randomUUID().toString(true); //将User对象转成UserDto在转换成Map数据类型 UserDTO userDTO = BeanUtil.copyProperties(user, UserDTO.class); //map数据类型的键值对都需要是String类型的 Map&lt;String, Object&gt; userMap = BeanUtil.beanToMap(userDTO, new HashMap&lt;&gt;(), CopyOptions.create().setIgnoreNullValue(true) //忽略空的值 .setFieldValueEditor((fieldName, fieldValue) -&gt; fieldValue.toString()));//所有value值转换为String //保存用户到Redis String key = RedisConstants.LOGIN_USER_KEY + token; stringRedisTemplate.opsForHash().putAll(key, userMap); //设置有效期30分钟 stringRedisTemplate.expire(key, //key RedisConstants.LOGIN_USER_TTL, // 30 TimeUnit.MINUTES); //分钟 //返回token return Result.ok(token); &#125; MVcConfig配置类中注入StringRedisTemplate： 12345678910111213141516171819@Configurationpublic class MvcConfig implements WebMvcConfigurer &#123; @Resource private StringRedisTemplate stringRedisTemplate; @Override public void addInterceptors(InterceptorRegistry registry) &#123; registry.addInterceptor(new LoginInterceptor(stringRedisTemplate)) .excludePathPatterns( //排除路径 &quot;/user/login&quot;, &quot;/user/code&quot;, &quot;/shop/**&quot;, &quot;/shop-type/**&quot;, &quot;/blog/hot&quot;, &quot;/upload/**&quot;, &quot;/voucher/**&quot; ); &#125;&#125; LoginInterceptor中获取Redis中的数据： 12345678910111213141516171819202122232425262728293031323334353637383940414243public class LoginInterceptor implements HandlerInterceptor &#123; private StringRedisTemplate stringRedisTemplate; public LoginInterceptor(StringRedisTemplate stringRedisTemplate) &#123; this.stringRedisTemplate = stringRedisTemplate; &#125; @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; //获取token，前端会将token放入到请求头中 String token = request.getHeader(&quot;authorization&quot;); if (StrUtil.isBlank(token)) &#123; //返回状态码401，未授权 response.setStatus(401); return false; &#125; //获取用户信息 Map&lt;Object, Object&gt; userMap = stringRedisTemplate.opsForHash().entries(RedisConstants.LOGIN_USER_KEY + token); //不存在，拦截 if (userMap.isEmpty())&#123; //返回状态码401，未授权 response.setStatus(401); return false; &#125; //将map转换成UserDto UserDTO user = BeanUtil.fillBeanWithMap(userMap,new UserDTO(),false); //存在，保存到TheadLocal UserHolder.saveUser(user); //刷新有效期 stringRedisTemplate.expire(RedisConstants.LOGIN_USER_KEY + token, //key RedisConstants.LOGIN_USER_TTL, // 30 TimeUnit.MINUTES); //分钟 //放行 return true; &#125; @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123; //移除用户 UserHolder.removeUser(); &#125;&#125; 1.8 解决状态登录刷新问题拦截器 获取token 查询Redis的用户信息 不存在，则拦截 存在，则继续 保存到ThreadLocal 刷新token的有效期 放行 拦截器只会拦截登录的路径，从而刷新token有效期。 但是其他的一些不需要登录也可以查看的页面，比如首页，则不会刷新token有效期。 有可能长时间查看其他页面，导致在查看需要登录的路径，token过了有效期，需要重新登录的问题 sequenceDiagram 用户-->>拦截器1:发送请求 note over 拦截器1:拦截一切路径1. 获取token2. 查询Redis的用户3. 保存到ThreadLocal4. 刷新token的有效期5. 放行 拦截器1->>拦截器2:进入 note over 拦截器2:拦截需要登录的路径查看token存在，则拦截不存在，则继续 拦截器2->>UserController:进入 RefreshTokenInterceptor中： 12345678910111213141516171819202122232425262728293031323334353637383940public class RefreshTokenInterceptor implements HandlerInterceptor &#123; private StringRedisTemplate stringRedisTemplate; public RefreshTokenInterceptor(StringRedisTemplate stringRedisTemplate) &#123; this.stringRedisTemplate = stringRedisTemplate; &#125; @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; //获取token String token = request.getHeader(&quot;authorization&quot;); //token不存在，直接放行，不添加到ThreadLocal if (StrUtil.isBlank(token)) &#123; return true; &#125; //获取用户信息 Map&lt;Object, Object&gt; userMap = stringRedisTemplate.opsForHash().entries(RedisConstants.LOGIN_USER_KEY + token); //用户信息不存在，直接放行，不添加到ThreadLocal if (userMap.isEmpty())&#123; return true; &#125; //将map转换成UserDto UserDTO user = BeanUtil.fillBeanWithMap(userMap,new UserDTO(),false); //保存到TheadLocal UserHolder.saveUser(user); //刷新有效期 stringRedisTemplate.expire(RedisConstants.LOGIN_USER_KEY + token, //key RedisConstants.LOGIN_USER_TTL, // 30 TimeUnit.MINUTES); //分钟 //放行 return true; &#125; @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123; //移除用户 UserHolder.removeUser(); &#125;&#125; LoginInterceptor中： 1234567891011121314public class LoginInterceptor implements HandlerInterceptor &#123; @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; //判断ThreadLocal是否存在用户 if (UserHolder.getUser() == null)&#123; //没有，拦截，设置状态码 response.setStatus(401); return false; &#125; //有用户放行 return true; &#125;&#125; MvcConfig配置类中： 123456789101112131415161718192021222324@Configurationpublic class MvcConfig implements WebMvcConfigurer &#123; @Resource private StringRedisTemplate stringRedisTemplate; @Override public void addInterceptors(InterceptorRegistry registry) &#123; //token刷新拦截器 registry.addInterceptor(new RefreshTokenInterceptor(stringRedisTemplate)) .addPathPatterns(&quot;/**&quot;) //拦截所有路径 .order(0); // 注册顺序为0 //登录拦截器 registry.addInterceptor(new LoginInterceptor()) .excludePathPatterns( //排除路径 &quot;/user/login&quot;, &quot;/user/code&quot;, &quot;/shop/**&quot;, &quot;/shop-type/**&quot;, &quot;/blog/hot&quot;, &quot;/upload/**&quot;, &quot;/voucher/**&quot; ).order(1); //注册顺序为1 &#125;&#125; 2.商户查询缓存2.1 什么是缓存缓存就是数据交换的缓冲区(称作Cache)，是贮存数据的临时地方，一般读写性能较高 graph LR 浏览器缓存 --> Tomcat应用层缓存 --> 数据库缓存 --> CPU缓存 数据库缓存 --> 磁盘缓存 缓存的作用 降低后端的负载 提高读写效率，降低响应时间 缓存的成本 数据一致性成本 代码维护成本 运维成本 2.2 添加Redis缓存缓存的作用模型： sequenceDiagram 客户端->>Redis:请求 Redis->>客户端:命中(分支1) Redis->>数据库:未命中(分支2) 数据库->>Redis:写缓存 数据库->>客户端:响应 根据id查询商铺缓存的流程： IShopService创建一个queryById方法： 1234public interface IShopService extends IService&lt;Shop&gt; &#123; // ctrl+b转到实现类 Result queryById(Long id);&#125; 在ShopServiceImpl中实现queryById方法，从而实现商铺信息缓存： 这里选择获取和存储Redis的数据类型为String 12345678910111213141516171819202122232425@Resourceprivate StringRedisTemplate stringRedisTemplate;@Overridepublic Result queryById(Long id) &#123; String key = RedisConstants.CACHE_SHOP_KEY + id; //从Redis查询商铺缓存，Redis数据类型为String String shopJson = stringRedisTemplate.opsForValue().get(key); //判断是否存在 if (StrUtil.isNotBlank(shopJson)) &#123; //存在，返回信息 Shop shop = JSONUtil.toBean(shopJson, Shop.class); return Result.ok(shop); &#125; //不存在，根据id查询 Shop shop = getById(id); //id不存在，返回错误信息 if (shop == null) &#123; return Result.fail(&quot;店铺不存在&quot;); &#125; //id存在，将数据写入Redis stringRedisTemplate.opsForValue().set(key, JSONUtil.toJsonStr(shop)); //返回商铺信息 return Result.ok(shop);&#125; ShopController中： 12345@GetMapping(&quot;/&#123;id&#125;&quot;)public Result queryShopById(@PathVariable(&quot;id&quot;) Long id) &#123; //通过id获取商铺信息 return shopService.queryById(id);&#125; 这里选择获取和存储Redis的数据类型为Hash 2.3 缓存更新策略 内存淘汰 超时剔除 主动更新 说明 不用自己维护，利用Redis的内存淘汰机制，当内存不足时自动淘汰部分数据。下次查询时更新缓存。 给缓存数据添加TTL时间，到期后自动删除缓存。下次查询时更新缓存。 编写业务逻辑，在修改数据库的同时，更新缓存。 一致性 差 一般 好 维护成本 无 低 高 业务场景： 低一致性需求： 使用内存淘汰机制。例如：店铺类型的查询缓存 高一致性需求： 主动更新，并以超时剔除为兜底方案。例如：店铺详情查询的缓存 主动更新策略： 方案一：Cache Aside Pattern(可控性高，企业开发常用) 由缓存的调用者，在更新数据库的同时更新缓存。 方案二：Read&#x2F;Write Through Pattern 缓存与数据库整合为一个服务，由服务来维护一致性。调用者调用该服务，无需关心缓存一致性问题。 方案三：Write Behind Caching Pattern 调用者只操作缓存，由其它线程异步的将缓存数据持久化到数据库，保证最终一致。 说明： 可以多次修改缓存中的数据，在将缓存的数据一次性更新到数据库中 如果缓存中的数据未更新到数据库时，出现宕机数据就会完全丢失 :cherry_blossom:方案一：Cache Aside Pattern 操作缓存和数据库时有三个问题需要考虑： 删除缓存还是更新缓存？ 更新缓存：每次更新数据库都要更新缓存，无效写操作较多:negative_squared_cross_mark: 删除缓存：更新数据库时让缓存失效，查询时在更新缓存:white_check_mark: 如何保证缓存与数据库的操作的同时成功或失败？ 单体系，将缓存与数据库的操作放在一个事务 分布式系统，利用TTC等分布式事务方案 先操作缓存还是先操作数据库？(数据库的数据操作相比Redis的数据操作慢) 先删除缓存，在操作数据库 异常情况：(出现情况高) 线程1删除缓存后，线程2查询缓存未命中，再查询数据库。将数据库中的旧数据又写入了缓存后，线程1才将数据库的数据进行了更新。导致线程2之前拿到的数据库的数据为旧数据。 先操作数据库，在删除缓存:cherry_blossom:(胜出) 异常情况：(出现情况低) 线程1查询缓存未命中，再查询数据库获取到旧数据后，线程2这时更新了数据库的数据，删除了缓存后，线程1才开始写入缓存。导致线程1之前拿到的数据库的数据为旧数据。 总结： 缓存更新策略的最佳实践方案 低一致性需求：使用Redis自带的内存淘汰机制 高一致性需求：主动更新，并以超时剔除为兜底方案 读操作： 缓存命中直接返回 缓存未命中则查询数据库，并写入缓存，设置超时时间 写操作： 先写数据库，然后再删除缓存 要确保数据库与缓存操作的原子性 2.4 添加缓存更新策略给查询商铺的缓存添加超时剔除和主动更新的策略 修改ShopController中的业务逻辑，满足一下的需求： 根据id查询店铺时，如果缓存未命中，则查询数据库，将数据库的结果写入缓存，并设置超时时间 根据id修改店铺时，先修改数据库，在删除缓存 修改ShopServiceImpl中的queryById方法，将写入Redis的数据设置有效期： 12345678910111213141516171819202122232425262728@Resourceprivate StringRedisTemplate stringRedisTemplate;@Overridepublic Result queryById(Long id) &#123; String key = RedisConstants.CACHE_SHOP_KEY + id; //从Redis查询商铺缓存 String shopJson = stringRedisTemplate.opsForValue().get(key); //判断是否存在 if (StrUtil.isNotBlank(shopJson)) &#123; //存在，返回信息 Shop shop = JSONUtil.toBean(shopJson, Shop.class); return Result.ok(shop); &#125; //不存在，根据id查询 Shop shop = getById(id); //id不存在，返回错误信息 if (shop == null) &#123; return Result.fail(&quot;店铺不存在&quot;); &#125; //id存在，将数据写入Redis，设置有效期 stringRedisTemplate.opsForValue().set(key, //key JSONUtil.toJsonStr(shop), // value RedisConstants.CACHE_SHOP_TTL, // 30 TimeUnit.MINUTES); //分钟 //返回商铺信息 return Result.ok(shop);&#125; IShopService中创建update方法： 123456public interface IShopService extends IService&lt;Shop&gt; &#123; // ctrl+b转到实现类 Result queryById(Long id); Result update(Shop shop);&#125; ShopServiceImpl中,实现update方法： 12345678910111213141516171819@Resourceprivate StringRedisTemplate stringRedisTemplate;@Override@Transactionalpublic Result update(Shop shop) &#123; Long id = shop.getId(); //判断商铺是否存在 if (id == null) &#123; //返回cu return Result.fail(&quot;商铺id不能为空&quot;); &#125; //更新数据库 updateById(shop); //删除缓存，下次用再取 stringRedisTemplate.delete(RedisConstants.CACHE_SHOP_KEY + id); //返回成功信息 return Result.ok();&#125; ShopController中： 12345@PutMappingpublic Result updateShop(@RequestBody Shop shop) &#123; //更新数据 return shopService.update(shop);&#125; 2.5 缓存穿透缓存穿透是指客户端请求的数据在缓存中和数据库中都不存在，这样缓存永远不会生效，这些请求到会打到数据库。(多次查询不存在的信息，频繁请求数据库，有可能导致数据库崩溃) 常见的解决方案有两种： 缓存空对象 优点：实现简单，维护方便 缺点： 额外的内存消耗 可能造成短期的不一致 (查询一个id未命中，Redis写入一个空对象，此时数据库插入这个id，导致信息不一致) sequenceDiagram 客户端->>Redis:请求 note left of Redis:未命中 Redis->>数据库:请求 note left of 数据库:未命中 数据库->>Redis:缓存null设置TTL 布隆过滤 优点：内存占用较少，没有多余的key 缺点： 实现复杂 存在误判可能 sequenceDiagram 客户端->>布隆过滤:请求 布隆过滤->>客户端:拒绝 note left of 布隆过滤:不存在 布隆过滤->>Redis:放行，请求 note left of Redis:存在 Redis->>客户端:返回 note over Redis,客户端:命中 Redis->>数据库:请求 note left of 数据库:未命中 数据库->>Redis:缓存数据 数据库->>客户端:返回数据 2.6 解决缓存穿透问题就是将之前判断商铺不存在时，返回404信息改为将空值写入Redis 123456789101112131415161718192021222324252627282930313233343536373839@Resourceprivate StringRedisTemplate stringRedisTemplate;@Overridepublic Result queryById(Long id) &#123; String key = RedisConstants.CACHE_SHOP_KEY + id; //从Redis查询商铺缓存 String shopJson = stringRedisTemplate.opsForValue().get(key); //判断是否存在 if (StrUtil.isNotBlank(shopJson)) &#123; //存在，返回信息 Shop shop = JSONUtil.toBean(shopJson, Shop.class); return Result.ok(shop); &#125; //命中的是否为空字符串 if (&quot;&quot;.equals(shopJson)) &#123; //返回错误信息 return Result.fail(&quot;店铺不存在&quot;); &#125; //不存在，根据id查询 Shop shop = getById(id); //id不存在，返回错误信息 if (shop == null) &#123; //将空值写入Redis stringRedisTemplate.opsForValue().set(key,//key &quot;&quot;, //空值 RedisConstants.CACHE_NULL_TTL,// 2 TimeUnit.MINUTES); //分钟 //返回错误信息 return Result.fail(&quot;店铺不存在&quot;); &#125; //id存在，将数据写入Redis，设置有效期 stringRedisTemplate.opsForValue().set(key, //key JSONUtil.toJsonStr(shop), // value RedisConstants.CACHE_SHOP_TTL, // 30 TimeUnit.MINUTES); //分钟 //返回商铺信息 return Result.ok(shop);&#125; 缓存穿透产生的原因是什么？ 用户请求的数据再缓存和数据库中都不存在，不断发起这样的请求，给数据库带来了巨大压力 缓存穿透的解决方案有哪些？ 缓存null值 布隆过滤 增加id的复杂度，避免被猜到id规律 做好数据的基础格式校验 2.7 缓存雪崩缓存雪崩是指同一时间大量的缓存key同时失效或者Redis服务宕机，导致大量请求到达数据库，带来压力。 sequenceDiagram 客户端->>Redis:请求 note over Redis:宕机或大量缓存同时失效 Redis->>数据库:大量请求 note left of 数据库:带来巨大压力 数据库->>客户端:返回 解决方案： 给不同的key的TTL添加随机值 利用Redis集群提高服务的可用性 给缓存业务添加降级限流策略 给业务添加多级缓存 2.X 缓存击穿2.X 缓存工具封装3.达人探店4.优惠券秒杀5.好友关注6.附近的商户7.用户签到8.UV统计高级篇原理篇st=>start: 开始 op=>operation: 提交手机号 cond=>condition: 校验手机号 code=>operation: 生成验证码 save=>operation: 验证码保存到Session send=>operation: 发送验证码 e=>end: 结束 st->op->cond(yes)->code->save->send->e cond(no)->op{\"scale\":1,\"line-width\":2,\"line-length\":50,\"text-margin\":10,\"font-size\":12} var code = document.getElementById(\"flowchart-0-code\").value; var options = JSON.parse(decodeURIComponent(document.getElementById(\"flowchart-0-options\").value)); var diagram = flowchart.parse(code); diagram.drawSVG(\"flowchart-0\", options);st=>start: 开始 op=>operation: 提交手机号和验证码 cond1=>condition: 校验验证码 code=>operation: 根据手机号查询用户 cond2=>condition: 用户是否存在 login=>operation: 登录 register=>operation: 创建新用户 save1=>operation: 保存用户到Session save2=>operation: 保存用户到数据库 e=>end: 结束 st->op->cond1(yes)->code->cond2(yes)->login->save1->e cond1(no)->op cond2(no)->register->save2->save1{\"scale\":1,\"line-width\":2,\"line-length\":50,\"text-margin\":10,\"font-size\":12} var code = document.getElementById(\"flowchart-1-code\").value; var options = JSON.parse(decodeURIComponent(document.getElementById(\"flowchart-1-options\").value)); var diagram = flowchart.parse(code); diagram.drawSVG(\"flowchart-1\", options);st=>start: 开始 op=>operation: 请求并携带cookie get=>operation: 从Session获取用户 cond=>condition: 判断用户是否存在 save=>operation: 保存用户到TreadLocal pass=>operation: 放行 intercept=>operation: 拦截 e=>end: 结束 st->op->get->cond(yes)->save->pass->e cond(no)->intercept->e{\"scale\":1,\"line-width\":2,\"line-length\":50,\"text-margin\":10,\"font-size\":12} var code = document.getElementById(\"flowchart-2-code\").value; var options = JSON.parse(decodeURIComponent(document.getElementById(\"flowchart-2-options\").value)); var diagram = flowchart.parse(code); diagram.drawSVG(\"flowchart-2\", options);st=>start: 开始 op=>operation: 提交手机号 cond=>condition: 校验手机号 code=>operation: 生成验证码 save=>operation: 验证码保存到Redis send=>operation: 发送验证码 e=>end: 结束 st->op->cond(yes)->code->save->send->e cond(no)->op{\"scale\":1,\"line-width\":2,\"line-length\":50,\"text-margin\":10,\"font-size\":12} var code = document.getElementById(\"flowchart-3-code\").value; var options = JSON.parse(decodeURIComponent(document.getElementById(\"flowchart-3-options\").value)); var diagram = flowchart.parse(code); diagram.drawSVG(\"flowchart-3\", options);st=>start: 开始 op=>operation: 提交手机号和验证码 cond1=>condition: 校验验证码 code=>operation: 根据手机号查询用户 cond2=>condition: 用户是否存在 login=>operation: 登录 register=>operation: 创建新用户 save1=>operation: 保存用户到Redis save2=>operation: 保存用户到数据库 back=>operation: 返回token给客户端 e=>end: 结束 st->op->cond1(yes)->code->cond2(yes)->login->save1->back->e cond1(no)->op cond2(no)->register->save2->save1{\"scale\":1,\"line-width\":2,\"line-length\":50,\"text-margin\":10,\"font-size\":12} var code = document.getElementById(\"flowchart-4-code\").value; var options = JSON.parse(decodeURIComponent(document.getElementById(\"flowchart-4-options\").value)); var diagram = flowchart.parse(code); diagram.drawSVG(\"flowchart-4\", options);st=>start: 开始 op=>operation: 请求并携带token get=>operation: 从Redis获取用户 cond=>condition: 判断用户是否存在 save=>operation: 保存用户到TreadLocal pass=>operation: 放行 intercept=>operation: 拦截 e=>end: 结束 st->op->get->cond(yes)->save->pass->e cond(no)->intercept->e{\"scale\":1,\"line-width\":2,\"line-length\":50,\"text-margin\":10,\"font-size\":12} var code = document.getElementById(\"flowchart-5-code\").value; var options = JSON.parse(decodeURIComponent(document.getElementById(\"flowchart-5-options\").value)); var diagram = flowchart.parse(code); diagram.drawSVG(\"flowchart-5\", options);st=>start: 开始 op=>operation: 提交商铺id get=>operation: 从Redis查询商铺缓存 cond1=>condition: 缓存是否命中 resp=>operation: 返回商铺信息 select=>operation: 根据id查询数据库 cond2=>condition: 判断商铺是否存在 exist=>operation: 将商铺数据写入Redis non-existent=>operation: 返回404 e=>end: 结束 st->op->get->cond1(yes)->resp->e cond1(no)->select->cond2(yes)->exist(left)->resp cond2(no)->non-existent->e{\"scale\":1,\"line-width\":2,\"line-length\":50,\"text-margin\":10,\"font-size\":12} var code = document.getElementById(\"flowchart-6-code\").value; var options = JSON.parse(decodeURIComponent(document.getElementById(\"flowchart-6-options\").value)); var diagram = flowchart.parse(code); diagram.drawSVG(\"flowchart-6\", options);st=>start: 开始 op=>operation: 提交商铺id get=>operation: 从Redis查询商铺缓存 cond1=>condition: 缓存是否命中 resp=>operation: 返回商铺信息 select=>operation: 根据id查询数据库 cond2=>condition: 判断商铺是否存在 exist=>operation: 将商铺数据写入Redis non-existent=>operation: 将空值写入Redis e=>end: 结束 st->op->get->cond1(yes)->resp->e cond1(no)->select->cond2(yes)->exist(left)->resp cond2(no)->non-existent->e{\"scale\":1,\"line-width\":2,\"line-length\":50,\"text-margin\":10,\"font-size\":12} var code = document.getElementById(\"flowchart-7-code\").value; var options = JSON.parse(decodeURIComponent(document.getElementById(\"flowchart-7-options\").value)); var diagram = flowchart.parse(code); diagram.drawSVG(\"flowchart-7\", options);","categories":[{"name":"Java","slug":"Java","permalink":"http://example.com/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"},{"name":"数据库","slug":"数据库","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}]},{"title":"","slug":"Java/MyBatis-Plus框架","date":"2022-08-06T11:11:16.302Z","updated":"2022-07-15T01:04:44.519Z","comments":true,"path":"2022/08/06/Java/MyBatis-Plus框架/","link":"","permalink":"http://example.com/2022/08/06/Java/MyBatis-Plus%E6%A1%86%E6%9E%B6/","excerpt":"","text":"1.初识MyBatis-PlusMyBatis-Plus是MyBatis的增强工具，在MyBatis的基础上只做增强不做改变，为了简化开发，提高效率而生 官网：MyBatis-Plus 特性： 无入侵：只做增强不做改变，导入它不会对现有工程产生影响。 损耗小：启动即会自动注入基本CRUD，性能基本不损耗，直接面向对象操作 强大的CRUD操作：内置通用Mapper、通用Service ,仅仅通过少量配置即可实现单表大部分CRUD操作，更有强大的条件构造器，满足各类使用需求 支持Lambda形式调用：通过Lambda表达式，方便的编写各类查询条件，无需再担心字段写错 支持多种数据库：支持MySQL、MariaDB、 Oracle、 DB2、 H2、 HSQL、 SQLite、 Postgre、SQL Server等多种数据库 支持主键自动生成：支持多达4种主键策略(内含分布式唯一ID生成器- Sequence)，可自由配置，完美解决主键问题 支持XML热加载：Mapper对应的XML支持热加载，对于简单的CRUD操作，甚至可以无XML启动 支持ActiveRecord模式：支持ActiveRecord形式调用，实体类只需继承Model类即可进行强大的CRUD操作 支持自定义全局通用操作：支持全局通用方法注入(Write once，use anywhere) 支持关键词自动转义：支持数据库关键词( order、 key…. )自动转义，还可自定义关键词 内置代码生成器：采用代码或者Maven插件可快速生成Mapper、 Model、Service、Controller层代码，支持模板引擎，更有超多自定义配置等您来使用 内置分页插件：基于MyBatis物理分页，开发者无需关心具体操作，配置好插件之后，写分页等同于普通List查询 内置性能分析插件：可输出Sql语句以及其执行时间，建议开发测试时启用该功能，能快速揪出慢查询 内置全局拦截插件：提供全表delete、update 操作智能分析阻断，也可自定义拦截规则，预防误操作 内置Sql注入剥离器：支持Sql注入剥离，有效预防Sql注入攻击 2.创建数据库创建数据库： 数据名：mp 字符集：utf-8 创建表： 123456789101112131415161718192021-- 创建测试表CREATE TABLE `tb_user` (`id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT &#x27;主键ID&#x27;,`user_name` varchar(20) NOT NULL COMMENT &#x27;用户名&#x27;,`password` varchar(20) NOT NULL COMMENT &#x27;密码&#x27;,`name` varchar(30) DEFAULT NULL COMMENT &#x27;姓名&#x27;,`age` int(11) DEFAULT NULL COMMENT &#x27;年龄&#x27;,`email` varchar(50) DEFAULT NULL COMMENT &#x27;邮箱&#x27;,PRIMARY KEY (`id`)) ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8;-- 插入测试数据INSERT INTO `tb_user` (`id`, `user_name`, `password`, `name`, `age`, `email`) VALUES(&#x27;1&#x27;, &#x27;zhangsan&#x27;, &#x27;123456&#x27;, &#x27;张三&#x27;, &#x27;18&#x27;, &#x27;test1@itcast.cn&#x27;);INSERT INTO `tb_user` (`id`, `user_name`, `password`, `name`, `age`, `email`) VALUES(&#x27;2&#x27;, &#x27;lisi&#x27;, &#x27;123456&#x27;, &#x27;李四&#x27;, &#x27;20&#x27;, &#x27;test2@itcast.cn&#x27;);INSERT INTO `tb_user` (`id`, `user_name`, `password`, `name`, `age`, `email`) VALUES(&#x27;3&#x27;, &#x27;wangwu&#x27;, &#x27;123456&#x27;, &#x27;王五&#x27;, &#x27;28&#x27;, &#x27;test3@itcast.cn&#x27;);INSERT INTO `tb_user` (`id`, `user_name`, `password`, `name`, `age`, `email`) VALUES(&#x27;4&#x27;, &#x27;zhaoliu&#x27;, &#x27;123456&#x27;, &#x27;赵六&#x27;, &#x27;21&#x27;, &#x27;test4@itcast.cn&#x27;);INSERT INTO `tb_user` (`id`, `user_name`, `password`, `name`, `age`, `email`) VALUES(&#x27;5&#x27;, &#x27;sunqi&#x27;, &#x27;123456&#x27;, &#x27;孙七&#x27;, &#x27;24&#x27;, &#x27;test5@itcast.cn&#x27;); 3.Mybatis-Plus快速入门导入所有依赖： 12345678910111213141516171819202122232425262728293031323334353637383940&lt;dependencies&gt; &lt;!-- mybatis-plus插件依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus&lt;/artifactId&gt; &lt;version&gt;3.1.1&lt;/version&gt; &lt;/dependency&gt; &lt;!-- mysql --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.47&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 数据库连接池 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.1.16&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 简化bean代码工具 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;version&gt;1.18.24&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 单元测试插件依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- 日志插件依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt; &lt;version&gt;1.7.36&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; resourses资源包中，新建log4j.properties文件： 1234log4j.rootLogger=DEBUG,A1log4j.appender.A1=org.apache.log4j.ConsoleAppenderlog4j.appender.A1.layout=org.apache.log4j.PatternLayoutlog4j.appender.A1.layout.ConversionPattern=[%t] [%c]-[%p] %m%n 创建User实体类： 1234567891011@Data //生成getter和setterd方法@NoArgsConstructor // 生成无参构造函数@AllArgsConstructor // 生成有参构造函数public class User &#123; private Long id; private String userName; private String password; private String name; private String age; private String email;&#125; 项目结构： 3.1 Mybatis实现查询在resources资源包中，创建mybatis-config.xml文件： 12345678910111213141516171819202122&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt; &lt;environments default=&quot;development&quot;&gt; &lt;environment id=&quot;development&quot;&gt; &lt;transactionManager type=&quot;JDBC&quot;/&gt; &lt;dataSource type=&quot;POOLED&quot;&gt; &lt;property name=&quot;driver&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/mp?useUnicode=true&amp;amp;characterEncoding=utf8&amp;amp;autoReconnect=true&amp;amp;allowMultiQueries=true&amp;amp;useSSL=false&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;123456&quot;/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;mappers&gt; &lt;mapper resource=&quot;UserMapper.xml&quot;/&gt; &lt;/mappers&gt;&lt;/configuration&gt; 创建UserMapper接口： 1234public interface UserMapper &#123; List&lt;User&gt; findAll(); &#125; 在resources资源包创建UserMapper.xml文件:： namespace为UserMapper接口的位置 id为UserMapper中的方法名 resultType为实体类的位置 123456789&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.mybatisp.mapper.UserMapper&quot;&gt; &lt;select id=&quot;findAll&quot; resultType=&quot;com.mybatisp.pojo.User&quot;&gt; select * from tb_user &lt;/select&gt;&lt;/mapper&gt; 单元测试： 1234567891011@Testpublic void testFindAll() throws IOException &#123; InputStream is = Resources.getResourceAsStream(&quot;mybatis-config.xml&quot;); SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(is); SqlSession sqlSession = sqlSessionFactory.openSession(); UserMapper userMapper = sqlSession.getMapper(UserMapper.class); System.out.println(userMapper.findAll());&#125; 控制台打印： 1[User(id=1, userName=null, password=123456, name=张三, age=18, email=test1@itcast.cn), User(id=2, userName=null, password=123456, name=李四, age=20, email=test2@itcast.cn), User(id=3, userName=null, password=123456, name=王五, age=28, email=test3@itcast.cn), User(id=4, userName=null, password=123456, name=赵六, age=21, email=test4@itcast.cn), User(id=5, userName=null, password=123456, name=孙七, age=24, email=test5@itcast.cn)] 3.2 Mybatis+MP实现查询将UserMapper继承BaseMapper，将拥有了BaseMapper中的所有方法： 1234public interface UserMapper extends BaseMapper&lt;User&gt; &#123; List&lt;User&gt; findAll();&#125; 单元测试： 123456789101112@Testpublic void testFindAll2() throws IOException &#123; InputStream is = Resources.getResourceAsStream(&quot;mybatis-config.xml&quot;); //这里使用的是MP中的MybatisSqlSessionFactoryBuilder SqlSessionFactory sqlSessionFactory = new MybatisSqlSessionFactoryBuilder().build(is); SqlSession sqlSession = sqlSessionFactory.openSession(); UserMapper userMapper = sqlSession.getMapper(UserMapper.class); System.out.println(userMapper.findAll()); &#125; 运行成功！ 改用BaseMapper中定义的方法查询所有： 1234567891011@Testpublic void testFindAll2() throws IOException &#123; InputStream is = Resources.getResourceAsStream(&quot;mybatis-config.xml&quot;); SqlSessionFactory sqlSessionFactory = new MybatisSqlSessionFactoryBuilder().build(is); SqlSession sqlSession = sqlSessionFactory.openSession(); UserMapper userMapper = sqlSession.getMapper(UserMapper.class); //System.out.println(userMapper.findAll()); System.out.println(userMapper.selectList(null));&#125; 报错： 1Cause: com.mysql.jdbc.exceptions.jdbc4.MySQLSyntaxErrorException: Table &#x27;mp.user&#x27; doesn&#x27;t exist 报错原因是没有找到user表，因为数据库中的表名为tb_user所以导致没有找到该表。需要指定表： 在User实体类中与数据库中的表进行映射： 123456789101112@Data //生成getter和setter方法@NoArgsConstructor // 生成无参构造函数@AllArgsConstructor // 生成有参构造函数@TableName(&quot;tb_user&quot;) //指定为tb_user表public class User &#123; private Long id; private String userName; private String password; private String name; private String age; private String email;&#125; 再次运行，成功！ 3.3 Spring+Mybatis+MP新建项目： 导入依赖： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;5.2.10.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;5.2.10.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;5.2.10.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus&lt;/artifactId&gt; &lt;version&gt;3.1.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.47&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.1.16&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;version&gt;1.18.24&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt; &lt;version&gt;1.7.36&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 在resources资源包中创建log4j.properties文件： 1234log4j.rootLogger=DEBUG,A1log4j.appender.A1=org.apache.log4j.ConsoleAppenderlog4j.appender.A1.layout=org.apache.log4j.PatternLayoutlog4j.appender.A1.layout.ConversionPattern=[%t] [%c]-[%p] %m%n 在resources资源包中创建jdbc.properties文件： 1234jdbc.driver=com.mysql.jdbc.driverjdbc.url=jdbc:mysql://localhost:3306/mp?useUnicode=true&amp;characterEncoding=utf8&amp;autoReconnect=true&amp;allowMultiQueries=true&amp;useSSL=falsejdbc.username=rootjdbc.password=123456 在resources资源包中创建applicationContext.xml文件 1234567891011121314151617181920212223242526272829&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beanshttp://www.springframework.org/schema/beans/spring-beans.xsdhttp://www.springframework.org/schema/contexthttp://www.springframework.org/schema/context/spring-context.xsd&quot;&gt; &lt;context:property-placeholder location=&quot;classpath*:*.properties&quot;/&gt; &lt;!-- 定义数据源 --&gt; &lt;bean id=&quot;dataSource&quot; class=&quot;com.alibaba.druid.pool.DruidDataSource&quot; destroy-method=&quot;close&quot;&gt; &lt;property name=&quot;url&quot; value=&quot;$&#123;jdbc.url&#125;&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;$&#123;jdbc.username&#125;&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot;/&gt; &lt;property name=&quot;driverClassName&quot; value=&quot;$&#123;jdbc.driver&#125;&quot;/&gt; &lt;property name=&quot;maxActive&quot; value=&quot;10&quot;/&gt; &lt;property name=&quot;minIdle&quot; value=&quot;5&quot;/&gt; &lt;/bean&gt; &lt;!--这里使用MP提供的sqlSessionFactory，完成了Spring与MP的整合--&gt; &lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;com.baomidou.mybatisplus.extension.spring.MybatisSqlSessionFactoryBean&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt; &lt;/bean&gt; &lt;!--扫描mapper接口，使用的依然是Mybatis原生的扫描器--&gt; &lt;bean class=&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt; &lt;property name=&quot;basePackage&quot; value=&quot;com.mybatisp.mapper&quot;/&gt; &lt;/bean&gt;&lt;/beans&gt; 创建User实体类： 123456789101112@Data //生成getter和setter方法@NoArgsConstructor // 生成无参构造函数@AllArgsConstructor // 生成有参构造函数@TableName(&quot;tb_user&quot;)public class User &#123; private Long id; private String userName; private String password; private String name; private String age; private String email;&#125; 创建UerMapper接口： 12public interface UserMapper extends BaseMapper&lt;User&gt; &#123;&#125; 单元测试： 1234567891011@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(locations = &quot;classpath:applicationContext.xml&quot;)public class MybatisTest &#123; @Autowired private UserMapper userMapper; @Test public void testSelectList()&#123; System.out.println(userMapper.selectList(null)); &#125;&#125; 运行成功！ 3.4 SpringBoot+Mybaits+MPxml版 项目结构： 创建springboot项目自动导入依赖： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt; &lt;version&gt;3.4.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.2.11&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.junit.vintage&lt;/groupId&gt; &lt;artifactId&gt;junit-vintage-engine&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt;&lt;/dependencies&gt;&lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-dependencies&lt;/artifactId&gt; &lt;version&gt;$&#123;spring-boot.version&#125;&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/dependencyManagement&gt;&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;version&gt;3.8.1&lt;/version&gt; &lt;configuration&gt; &lt;source&gt;1.8&lt;/source&gt; &lt;target&gt;1.8&lt;/target&gt; &lt;encoding&gt;UTF-8&lt;/encoding&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;version&gt;2.3.7.RELEASE&lt;/version&gt; &lt;configuration&gt; &lt;mainClass&gt;com.mybatisp.SpringbootMpApplication&lt;/mainClass&gt; &lt;/configuration&gt; &lt;executions&gt; &lt;execution&gt; &lt;id&gt;repackage&lt;/id&gt; &lt;goals&gt; &lt;goal&gt;repackage&lt;/goal&gt; &lt;/goals&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; application.yml： 1234567spring: datasource: druid: driver-class-name: com.mysql.cj.jdbc.Driver url: jdbc:mysql://localhost:3306/mp?serverTimezone=UTC username: root password: 123456 User实体类： 123456789101112@Data //生成getter和setter方法@NoArgsConstructor // 生成无参构造函数@AllArgsConstructor // 生成有参构造函数@TableName(&quot;tb_user&quot;)public class User &#123; private Long id; private String userName; private String password; private String name; private String age; private String email;&#125; UserMapper接口： 123@Mapperpublic interface UserMapper extends BaseMapper&lt;User&gt; &#123;&#125; 单元测试： 12345678910@SpringBootTestpublic class UserMapperTest &#123; @Autowired private UserMapper userMapper; @Test public void findAll() &#123; System.out.println(userMapper.selectList(null)); &#125;&#125; 运行成功！ 9.代码生成器创建Springboot项目： 添加下面的依赖： 1234567891011&lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-generator&lt;/artifactId&gt; &lt;version&gt;3.5.2&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.freemarker&lt;/groupId&gt; &lt;artifactId&gt;freemarker&lt;/artifactId&gt; &lt;version&gt;2.3.31&lt;/version&gt;&lt;/dependency&gt; 创建一个测试类： 12345678910111213141516171819202122232425public class FastAutoGeneratorTest &#123; public static void main(String[] args) &#123; FastAutoGenerator.create(&quot;jdbc:mysql://localhost:3306/mp?serverTimezone=UTC&quot;, &quot;root&quot;, &quot;123456&quot;) .globalConfig(builder -&gt; &#123; builder.author(&quot;baomidou&quot;) // 设置作者 //.enableSwagger() // 开启 swagger 模式 .fileOverride() // 覆盖已生成文件 .outputDir(&quot;E:\\\\Java_Web\\\\Mybatis-p\\\\mp_04_generator\\\\src\\\\main\\\\java&quot;); // 指定输出目录 &#125;) .packageConfig(builder -&gt; &#123; builder.parent(&quot;com&quot;) // 设置父包名 .moduleName(&quot;mybatisp&quot;) // 设置父包模块名 .pathInfo(Collections.singletonMap(OutputFile.xml, &quot;E:\\\\Java_Web\\\\Mybatis-p\\\\mp_04_generator\\\\src\\\\main\\\\resources\\\\mapper&quot;)); // 设置mapperXml生成路径 &#125;) .strategyConfig(builder -&gt; &#123; builder.addInclude(&quot;tb_user&quot;) // 设置需要生成的表名 .addTablePrefix(&quot;tb_&quot;, &quot;c_&quot;); // 设置过滤表前缀 &#125;) .templateEngine(new FreemarkerTemplateEngine()) // 使用Freemarker引擎模板，默认的是Velocity引擎模板 .execute(); &#125;&#125; 控制台打印： 12345608:57:51.095 [main] DEBUG com.baomidou.mybatisplus.generator.AutoGenerator - ==========================准备生成文件...==========================08:57:51.521 [main] DEBUG com.baomidou.mybatisplus.generator.config.querys.MySqlQuery - 执行SQL:show table status WHERE 1=1 AND NAME IN (&#x27;tb_user&#x27;)08:57:51.538 [main] DEBUG com.baomidou.mybatisplus.generator.config.querys.MySqlQuery - 返回记录数:1,耗时(ms):1608:57:51.550 [main] DEBUG com.baomidou.mybatisplus.generator.config.querys.MySqlQuery - 执行SQL:show full fields from `tb_user`08:57:51.559 [main] DEBUG com.baomidou.mybatisplus.generator.config.querys.MySqlQuery - 返回记录数:6,耗时(ms):908:57:51.652 [main] DEBUG com.baomidou.mybatisplus.generator.AutoGenerator - ==========================文件生成完成！！！========================== 以下为生成的文件：","categories":[],"tags":[]},{"title":"MongoDB的学习笔记","slug":"Java/MongoDB","date":"2022-08-06T11:11:16.300Z","updated":"2022-09-21T13:32:51.507Z","comments":true,"path":"2022/08/06/Java/MongoDB/","link":"","permalink":"http://example.com/2022/08/06/Java/MongoDB/","excerpt":"","text":"未完待续 1.MongoDB相关概念业务场景 传统的关系型数据库(如：MySQL)，在数据操作的“三高”需求以及应对Web2.0网站需求面前，显得力不从心。 “三高”需求： High performance：对数据库高并发读写的需求 Huge Storage：对海量数据的高效率存储和访问的需求。 High Scalability &amp;&amp; High Availability：对数据库的高可扩展性和高可用性的需求。 而MongoDB可应对”三高”需求，貝体的应用场景如： 社交场景：使用MongoDB 存储存储用户信息，以及用户发表的朋友圖信息，通过地理位置素引1实现附近的人、地点等功能。 游戏场景：使用 MongoDB 存储游戏用户信息，用户的装备、积分等直接以内嵌文档的形式存储，方便查询高效率存储和访问。 物流场员：使用 MongoDB 存储订单信息，订单状态在运送过程中会不断更新，以MongODB 内嵌数组的开式来存储，一次查询就能将订单所有的变更读取出来。 物联网场景：使用MongoDB 存储所有接入的智能设备信息，以及设备汇报的日志信息，并对这些信息进行多维度的分析。 视频直播：使用 MongoDB 存储用户信息、点赞互动信息等。 这些应用场景，对数据操作方面的共同特点是： 数据量大 写入操作频繁(读写很频繁) 价值较低的数据，对事务性要求不高(缺点) 对于这样的数据，我们更适合使用MongoDB来实现数据的存储 何时选择MongoDB？ 在架构选型上，除了上述的三个特点外，如果你还犹豫是否要选择它？可以考忠以下的一些问题： 应用不需要車务及复杂 ioin 支持 新应用，需求会变，数据模型无法确定，想快速迭代开发 应用需要2000-3000以上的读写OPS（更高也可以） 应用需要TB甚至 PB级别数据存储 应用发展迅速，需要能快速水平扩展 应用要求存储的数据不天失 应用需要99.999%高可用 应用需要大量的地理位置查询、文本查询 如果上述有1个符合，可以考虑MongoDB， 2个及以上的符合，选择MongoDB 绝不会后悔。 数据库：articledb 专栏文章评论(表)：comment 字段名称 字段含义 字段类型 备注 _id ID ObjectId或String Mongo的主键的字段 articleid 文章ID String content 评论内容 String userid 评论人ID String nickname 评论人昵称 String createdatetime 评论的日期时间 Date likenum 点赞数 Int32 replynum 回复数 Int32 state 状态 String 0：不可见1：可见 parentid 上级ID String 如果为0表示文章的顶级评论 2.MongoDB的相关命令2.1 数据库的创建与删除 命令 解释 例子 use 数据库名 选择数据库，如果不存在则创建 use articledb show dbs或show databases 查看所有数据库 db 查看当前正在使用的数据库 db.dropDatabase() 删除当前正在的使用的数据库 db.createCollection(name)name: 要创建的集合名称 显示创建集合(了解) db.createCollection(“mycollection”) show collections或show tables 查看当前数据库中的表 db.集合.drop() 删除当前正在的使用的数据库中的集合 db.mycollection.drop() 文档(document)的数据结构与JSON基本一致，所有存储在集合中的数据都是BSON格式 2.2 文档的插入1234567db.collection.insert( &lt;document or array of documents&gt;, &#123; writeConcern: &lt;document&gt;, ordered: &lt;boolean&gt; &#125;) 单个文档插入： 使用insert()或save()方法插入： db.collection.insert(document) 示例： 向comment集合中插入一条数据： 12345678db.comment.insert(&#123; &quot;articleid&quot;:&quot;100000&quot;, &quot;content&quot;:&quot;今天天气真好，阳光明媚&quot;, &quot;userid&quot;:&quot;1001&quot;, &quot;nickname&quot;:&quot;Tom&quot;, &quot;createdatetime&quot;:new Date(), &quot;likenum&quot;:NumberInt(10), &quot;state&quot;:null&#125;) comment集合如果不存在，则会隐式创建 。 mongo中的数字，默认情况下是double类型，如果要存整型，必须使用函数NumberInt(整型数字)，否则取出来就有问题了。 插入当前日期使用 new Date() 插入的数据没有指定 _id ，会自动生成主键值 如果某字段没值，可以赋值为null，或不写该字段。 如果出现：WriteResult(&#123; &quot;nInserted&quot; : 1 &#125;)，说明插入成功。 多条文档插入： db.comment.insertMany([document1,document2,…]) 示例： 向comment集合中插入多条数据： 123456789101112131415161718db.comment.insertMany([ &#123;&quot;_id&quot;:&quot;1&quot;, &quot;articleid&quot;:&quot;100001&quot;, &quot;content&quot;:&quot;我们不应该把清晨浪费在手机上，健康很重要，一杯温水幸福你我他。&quot;, &quot;userid&quot;:&quot;1002&quot;, &quot;nickname&quot;:&quot;相忘于江湖&quot;, &quot;createdatetime&quot;:new Date(&quot;2019-08-05T22:08:15.522Z&quot;), &quot;likenum&quot;:NumberInt(1000), &quot;state&quot;:&quot;1&quot;&#125;, &#123;&quot;_id&quot;:&quot;2&quot;, &quot;articleid&quot;:&quot;100001&quot;, &quot;content&quot;:&quot;我夏天空腹喝凉开水，冬天喝温开水&quot;, &quot;userid&quot;:&quot;1005&quot;, &quot;nickname&quot;:&quot;伊人憔悴&quot;, &quot;createdatetime&quot;:new Date(&quot;2019-08-05T23:58:51.485Z&quot;), &quot;likenum&quot;:NumberInt(888), &quot;state&quot;:&quot;1&quot;&#125;]) 插入时指定了 _id ，则主键就是该值。 如果某条数据插入失败，将会终止插入，但已经插入成功的数据不会回滚掉。 批量插入由于数据较多容易出现失败，因此，可以使用try catch进行异常捕捉处理，测试的时候可以不处理。如（了解）： 12345678910111213141516171819202122try &#123;db.comment.insertMany([ &#123;&quot;_id&quot;:&quot;1&quot;, &quot;articleid&quot;:&quot;100001&quot;, &quot;content&quot;:&quot;我们不应该把清晨浪费在手机上，健康很重要，一杯温水幸福你我他。&quot;, &quot;userid&quot;:&quot;1002&quot;, &quot;nickname&quot;:&quot;相忘于江湖&quot;, &quot;createdatetime&quot;:new Date(&quot;2019-08-05T22:08:15.522Z&quot;), &quot;likenum&quot;:NumberInt(1000), &quot;state&quot;:&quot;1&quot;&#125;, &#123;&quot;_id&quot;:&quot;2&quot;, &quot;articleid&quot;:&quot;100001&quot;, &quot;content&quot;:&quot;我夏天空腹喝凉开水，冬天喝温开水&quot;, &quot;userid&quot;:&quot;1005&quot;, &quot;nickname&quot;:&quot;伊人憔悴&quot;, &quot;createdatetime&quot;:new Date(&quot;2019-08-05T23:58:51.485Z&quot;), &quot;likenum&quot;:NumberInt(888), &quot;state&quot;:&quot;1&quot;&#125;])&#125; catch (e) &#123;print (e);&#125; 2.3 文档的查询1db.collection.find(&lt;query&gt;, [projection]) 查询所有： 查询comment集合的所有文档 12db.comment.find() 或 db.comment.find(&#123;&#125;) 条件查询： 查询询userid为1003的记录 1db.comment.find(&#123;userid:&#x27;1003&#x27;&#125;) 如果只需要返回第一条数据 1db.comment.findOne(&#123;userid:&#x27;1003&#x27;&#125;) 投影查询：查询结果返回部分字段 查询结果显示userid和nickname： 1db.comment.find(&#123;userid:&quot;1003&quot;&#125;,&#123;userid:1,nickname:1&#125;) 结果： 12&#123; &quot;_id&quot; : &quot;4&quot;, &quot;userid&quot; : &quot;1003&quot;, &quot;nickname&quot; : &quot;凯撒&quot; &#125;&#123; &quot;_id&quot; : &quot;5&quot;, &quot;userid&quot; : &quot;1003&quot;, &quot;nickname&quot; : &quot;凯撒&quot; &#125; 默认 _id 会显示。 查询结果只显示userid和nickname，不显示_id： 1db.comment.find(&#123;userid:&quot;1003&quot;&#125;,&#123;userid:1,nickname:1,_id:0&#125;) 结果： 12&#123; &quot;userid&quot; : &quot;1003&quot;, &quot;nickname&quot; : &quot;凯撒&quot; &#125; &#123; &quot;userid&quot; : &quot;1003&quot;, &quot;nickname&quot; : &quot;凯撒&quot; &#125; 2.4 文档的更新1234567891011121314db.collection.update(query, update, options)或db.collection.update(&lt;query&gt;,&lt;update&gt;,&#123;upsert: &lt;boolean&gt;,multi: &lt;boolean&gt;,writeConcern: &lt;document&gt;,collation: &lt;document&gt;,arrayFilters: [ &lt;filterdocument1&gt;, ... ],hint: &lt;document|string&gt; // Available starting in MongoDB 4.2&#125;) 覆盖修改： 修改_id为1的记录，点赞量为1001 1db.comment.update(&#123;_id:&quot;1&quot;&#125;,&#123;likenum:NumberInt(1001)&#125;) 执行后，这条文档除了likenum字段其它字段都不见了 局部修改：们需要使用修改器$set来实现 修改_id为2的记录，点赞量为889 1db.comment.update(&#123;_id:&quot;2&quot;&#125;,&#123;$set:&#123;likenum:NumberInt(889)&#125;&#125;) 批量修改： 更新用户id为1003的用户的昵称为大黄 1234//默认只修改第一条数据db.comment.update(&#123;userid:&quot;1003&quot;&#125;,&#123;$set:&#123;nickname:&quot;大黄&quot;&#125;&#125;)//修改所有符合条件的数据db.comment.update(&#123;userid:&quot;1003&quot;&#125;,&#123;$set:&#123;nickname:&quot;大黄&quot;&#125;&#125;,&#123;multi:true&#125;) 列值增长修改：使用$inc运算符来实现对某列值在原有值的基础上进行增加或减少 对3号数据的点赞数，每次递增1 1db.comment.update(&#123;_id:&quot;3&quot;&#125;,&#123;$inc:&#123;likenum:NumberInt(1)&#125;&#125;) 2.5 文档的删除1db.集合名称.remove(条件) 将数据全部删除：(谨慎使用) 1db.comment.remove(&#123;&#125;) 删除_id&#x3D;1的记录： 1db.comment.remove(&#123;_id:&quot;1&quot;&#125;) 2.6 文档的分页查询统计查询： 1db.collection.count(query, options) 统计所有记录数： 1db.comment.count() 按条件统计记录数： 统计userid为1003的记录条数 1db.comment.count(&#123;userid:&quot;1003&quot;&#125;) 分页列表查询：使用limit()方法来读取指定数量的数据，使用skip()方法来跳过指定数量的数据。 1db.COLLECTION_NAME.find().limit(NUMBER).skip(NUMBER) 返回指定条数的记录，可以在find方法后调用limit来返回结果(TopN)，默认值20 1db.comment.find().limit(3) skip方法同样接受一个数字参数作为跳过的记录条数。（前N个不要）,默认值是0 1db.comment.find().skip(3) 分页查询：需求：每页2个，第二页开始：跳过前两条数据，接着值显示3和4条数据 123456//第一页db.comment.find().skip(0).limit(2)//第二页db.comment.find().skip(2).limit(2)//第三页db.comment.find().skip(4).limit(2) 排序查询： sort() 方法对数据进行排序，sort() 方法可以通过参数指定排序的字段， 并使用 1 和 -1 来指定排序的方式，其中 1 为升序排列，而 -1 是用 于降序排列。 123db.COLLECTION_NAME.find().sort(&#123;KEY:1&#125;)或db.集合名称.find().sort(排序方式) 对userid降序排列，并对访问量进行升序排列 1db.comment.find().sort(&#123;userid:-1,likenum:1&#125;) skip(), limilt(), sort()三个放在一起执行的时候， 执行的顺序：sort()&#x3D;&gt;skip()&#x3D;&gt;limit()，和命令编写顺序无关 2.7 文档的更多查询正则的复杂条件查询： 正则表达式是js的语法，直接量的写法。 123db.collection.find(&#123;field:/正则表达式/&#125;)或db.集合.find(&#123;字段:/正则表达式/&#125;) 查询评论内容包含“开水”的所有文档 1db.comment.find(&#123;content:/开水/&#125;) 查询评论的内容中以“专家”开头的 1db.comment.find(&#123;content:/^专家/&#125;) 比较查询： 12345db.集合名称.find(&#123; &quot;field&quot; : &#123; $gt: value &#125;&#125;) // 大于: field &gt; valuedb.集合名称.find(&#123; &quot;field&quot; : &#123; $lt: value &#125;&#125;) // 小于: field &lt; valuedb.集合名称.find(&#123; &quot;field&quot; : &#123; $gte: value &#125;&#125;) // 大于等于: field &gt;= valuedb.集合名称.find(&#123; &quot;field&quot; : &#123; $lte: value &#125;&#125;) // 小于等于: field &lt;= valuedb.集合名称.find(&#123; &quot;field&quot; : &#123; $ne: value &#125;&#125;) // 不等于: field != value、 查询评论点赞数量大于700的记录 1db.comment.find(&#123;likenum:&#123;$gt:NumberInt(700)&#125;&#125;) 包含查询：包含使用$in操作符，不包含使用$nin操作符 查询评论集合中userid字段包含1003或1004的文档 1db.comment.find(&#123;userid:&#123;$in:[&quot;1003&quot;,&quot;1004&quot;]&#125;&#125;) 查询评论集合中userid字段不包含1003和1004的文档 1db.comment.find(&#123;userid:&#123;$nin:[&quot;1003&quot;,&quot;1004&quot;]&#125;&#125;) 条件连接查询： 查询同时满足两个以上条件，需要使用$and操作符将条件进行关联 1$and:[ &#123; &#125;,&#123; &#125;,&#123; &#125; ] 查询评论集合中likenum大于等于700 并且小于2000的文档 1db.comment.find(&#123;$and:[&#123;likenum:&#123;$gte:NumberInt(700)&#125;&#125;,&#123;likenum:&#123;$lt:NumberInt(2000)&#125;&#125;]&#125;) 两个以上条件之间是或者的关系，我们使用 $or 操作符进行关联 1$or:[ &#123; &#125;,&#123; &#125;,&#123; &#125; ] 查询评论集合中userid为1003，或者点赞数小于1000的文档记录 1db.comment.find(&#123;$or:[ &#123;userid:&quot;1003&quot;&#125; ,&#123;likenum:&#123;$lt:1000&#125; &#125;]&#125;) 2.8 常用命令小结*1234567891011121314151617181920212223242526272829303132//选择切换数据库：use articledb//插入数据：db.comment.insert(&#123;bson数据&#125;)//查询所有数据：db.comment.find();//条件查询数据：db.comment.find(&#123;条件&#125;)//查询符合条件的第一条记录：db.comment.findOne(&#123;条件&#125;)//查询符合条件的前几条记录：db.comment.find(&#123;条件&#125;).limit(条数)//查询符合条件的跳过的记录：db.comment.find(&#123;条件&#125;).skip(条数)//修改数据：db.comment.update(&#123;条件&#125;,&#123;修改后的数据&#125;) 或db.comment.update(&#123;条件&#125;,&#123;$set:&#123;要修改部分的字段:数据&#125;)//修改数据并自增某字段值：db.comment.update(&#123;条件&#125;,&#123;$inc:&#123;自增的字段:步进值&#125;&#125;)//删除数据：db.comment.remove(&#123;条件&#125;)//统计查询：db.comment.count(&#123;条件&#125;)//模糊查询：db.comment.find(&#123;字段名:/正则表达式/&#125;)//条件比较运算：db.comment.find(&#123;字段名:&#123;$gt:值&#125;&#125;)//包含查询：db.comment.find(&#123;字段名:&#123;$in:[值1，值2]&#125;&#125;)或db.comment.find(&#123;字段名:&#123;$nin:[值1，值2]&#125;&#125;)//条件连接查询：db.comment.find(&#123;$and:[&#123;条件1&#125;,&#123;条件2&#125;]&#125;)或db.comment.find(&#123;$or:[&#123;条件1&#125;,&#123;条件2&#125;]&#125;) 3.索引索引支持在MongoDB中高效地执行查询。 如果没有索引，MongoDB必须执行全集合扫描，即扫描集合中的每个文档，以选择与查询语句匹配的文档。 这种扫描全集合的查询效率是非常低的，特别在处理大量的数据时，查询可以要花费几十秒甚至几分钟，这对网站的性能是非常致命的。 索引是特殊的数据结构，它以易于遍历的形式存储集合数据集的一小部分。 索引存储特定字段或一组字段的值，按字段值排序。 索引项的排序支持有效的相等匹配和基于范围的查询操作。 此外，MongoDB还可以使用索引中的排序返回排序结果。 MongoDB索引使用B树数据结构（确切的说是B-Tree，MySQL是B+Tree） 3.1 索引的类型单字段索引： MongoDB支持在文档的单个字段上创建用户定义的升序&#x2F;降序索引，称为单字段索引(Single Field Index) 对于单个字段索引和排序操作，索引键的排序顺序(即升序或降序)并不重要，因为MongoDB可以在任何方向上遍历索引 复合索引： MongoDB还支持多个字段的用户定义索引，即复合索引(Compound Index) 复合索引中列出的字段顺序具有重要意义。 例如，如果复合索引由 { userid: 1, score: -1 } 组成，则索引首先按userid正序排序，然后 在每个userid的值内，再在按score倒序排序。 其他索引： 地理空间索引(Geospatial Index)、文本索引(Text Indexes)、哈希索引(Hashed Indexes)。 地理空间索引(Geospatial Index)： 为了支持对地理空间坐标数据的有效查询，MongoDB提供了两种特殊的索引：返回结果时使用平面几何的二维索引和返回结果时使用球面 几何的二维球面索引。 文本索引(Text Indexes)： MongoDB提供了一种文本索引类型，支持在集合中搜索字符串内容。这些文本索引不存储特定于语言的停止词（例如“the”、“a”、“or”）， 而将集合中的词作为词干，只存储根词。 哈希索引(Hashed Indexes)： 为了支持基于散列的分片，MongoDB提供了散列索引类型，它对字段值的散列进行索引。这些索引在其范围内的值分布更加随机，但只支 持相等匹配，不支持基于范围的查询。 3.2 索引的管理操作索引的查看：返回一个集合中的所有索引的数组 1db.collection.getIndexes() //该语法命令运行要求是MongoDB 3.0+ 例：查看comment集合中所有的索引情况 1db.comment.getIndexes() 结果： 12345678910[ &#123; &quot;v&quot; : 2, &quot;key&quot; : &#123; &quot;_id&quot; : 1 &#125;, &quot;name&quot; : &quot;_id_&quot;, &quot;ns&quot; : &quot;articledb.comment&quot; &#125;] 默认_id索引： MongoDB在创建集合的过程中，在 _id 字段上创建一个唯一的索引，默认名字为 _id_ ，该索引可防止客户端插入两个具有相同值的文 档，不能在_id字段上删除此索引。 注意：该索引是唯一索引，因此值不能重复，即 _id 值不能重复的。在分片集群中，通常使用 _id 作为片键。 索引的创建：在集合上创建索引 1db.collection.createIndex(keys, options) 在3.0.0版本前创建索引方法为db.collection.ensureIndex()，之后的版本使用了 db.collection.createIndex()方法，ensureIndex()还能用，但只是createIndex()的别名 单字段索引示例：对 userid 字段建立索引 1db.comment.createIndex(&#123;userid:1&#125;) 结果： 123456&#123; &quot;createdCollectionAutomatically&quot; : false, //按升序创建索引 &quot;numIndexesBefore&quot; : 1, &quot;numIndexesAfter&quot; : 2, &quot;ok&quot; : 1&#125; 查看索引： 1db.comment.getIndexes() 结果： 123456789101112131415161718[ &#123; &quot;v&quot; : 2, &quot;key&quot; : &#123; &quot;_id&quot; : 1 &#125;, &quot;name&quot; : &quot;_id_&quot;, &quot;ns&quot; : &quot;articledb.comment&quot; &#125;, &#123; &quot;v&quot; : 2, &quot;key&quot; : &#123; &quot;userid&quot; : 1 &#125;, &quot;name&quot; : &quot;userid_1&quot;, &quot;ns&quot; : &quot;articledb.comment&quot; &#125;] 索引的移除：可以移除指定的索引，或移除所有索引 指定索引的移除： 1db.collection.dropIndex(index) 例：删除 comment 集合中 userid 字段上的升序索引 1db.comment.dropIndex(&#123;userid:1&#125;) 所有索引的移除： 1db.collection.dropIndexes() 例：删除集合中所有索引 1db.comment.dropIndexes() //_id的字段的索引是无法删除的，只能删除非_id字段的索引 结果： 12345&#123; &quot;nIndexesWas&quot; : 2, &quot;msg&quot; : &quot;non-_id indexes dropped for collection&quot;, &quot;ok&quot; : 1&#125; 3.3 索引的使用执行计划： 分析查询性能（Analyze Query Performance）通常使用执行计划（解释计划、Explain Plan）来查看查询的情况，如：查询耗费的时间、是 否基于索引查询等。 建立的索引是否有效，效果如何，都需要通过执行计划查看： 1db.collection.find(query,options).explain(options) 例：查看根据userid查询数据的情况 1db.comment.find(&#123;userid:&quot;1003&quot;&#125;).explain() 结果： 1234567891011121314151617181920212223242526272829&#123; &quot;queryPlanner&quot; : &#123; &quot;plannerVersion&quot; : 1, &quot;namespace&quot; : &quot;articledb.comment&quot;, &quot;indexFilterSet&quot; : false, &quot;parsedQuery&quot; : &#123; &quot;userid&quot; : &#123; &quot;$eq&quot; : &quot;1003&quot; &#125; &#125;, &quot;winningPlan&quot; : &#123; &quot;stage&quot; : &quot;COLLSCAN&quot;, //表示全集合扫描 &quot;filter&quot; : &#123; &quot;userid&quot; : &#123; &quot;$eq&quot; : &quot;1003&quot; &#125; &#125;, &quot;direction&quot; : &quot;forward&quot; &#125;, &quot;rejectedPlans&quot; : [ ] &#125;, &quot;serverInfo&quot; : &#123; &quot;host&quot; : &quot;9ef3740277ad&quot;, &quot;port&quot; : 27017, &quot;version&quot; : &quot;4.0.10&quot;, &quot;gitVersion&quot; : &quot;c389e7f69f637f7a1ac3cc9fae843b635f20b766&quot; &#125;, &quot;ok&quot; : 1&#125; 例：对userid建立索引 1db.comment.createIndex(&#123;userid:1&#125;) 结果： 123456&#123; &quot;createdCollectionAutomatically&quot; : false, &quot;numIndexesBefore&quot; : 1, &quot;numIndexesAfter&quot; : 2, &quot;ok&quot; : 1&#125; 再次查看执行计划： 1db.comment.find(&#123;userid:&quot;1013&quot;&#125;).explain() 结果·： 1234567891011121314151617181920212223242526272829303132333435363738394041424344&#123; &quot;queryPlanner&quot; : &#123; &quot;plannerVersion&quot; : 1, &quot;namespace&quot; : &quot;articledb.comment&quot;, &quot;indexFilterSet&quot; : false, &quot;parsedQuery&quot; : &#123; &quot;userid&quot; : &#123; &quot;$eq&quot; : &quot;1013&quot; &#125; &#125;, &quot;winningPlan&quot; : &#123; &quot;stage&quot; : &quot;FETCH&quot;, &quot;inputStage&quot; : &#123; &quot;stage&quot; : &quot;IXSCAN&quot;, //基于索引的扫描 &quot;keyPattern&quot; : &#123; &quot;userid&quot; : 1 &#125;, &quot;indexName&quot; : &quot;userid_1&quot;, &quot;isMultiKey&quot; : false, &quot;multiKeyPaths&quot; : &#123; &quot;userid&quot; : [ ] &#125;, &quot;isUnique&quot; : false, &quot;isSparse&quot; : false, &quot;isPartial&quot; : false, &quot;indexVersion&quot; : 2, &quot;direction&quot; : &quot;forward&quot;, &quot;indexBounds&quot; : &#123; &quot;userid&quot; : [ &quot;[\\&quot;1013\\&quot;, \\&quot;1013\\&quot;]&quot; ] &#125; &#125; &#125;, &quot;rejectedPlans&quot; : [ ] &#125;, &quot;serverInfo&quot; : &#123; &quot;host&quot; : &quot;9ef3740277ad&quot;, &quot;port&quot; : 27017, &quot;version&quot; : &quot;4.0.10&quot;, &quot;gitVersion&quot; : &quot;c389e7f69f637f7a1ac3cc9fae843b635f20b766&quot; &#125;, &quot;ok&quot; : 1&#125; 涵盖的查询： 当查询条件和查询的投影仅包含索引字段时，MongoDB直接从索引返回结果，而不扫描任何文档或将文档带入内存。 这些覆盖的查询可以非常有效 1db.comment.find(&#123;userid:&quot;1003&quot;&#125;,&#123;userid:1,_id:0&#125;) 结果： 12&#123; &quot;userid&quot; : &quot;1003&quot; &#125;&#123; &quot;userid&quot; : &quot;1003&quot; &#125; 1db.comment.find(&#123;userid:&quot;1003&quot;&#125;,&#123;userid:1,_id:0&#125;).explain() 结果： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&#123; &quot;queryPlanner&quot; : &#123; &quot;plannerVersion&quot; : 1, &quot;namespace&quot; : &quot;articledb.comment&quot;, &quot;indexFilterSet&quot; : false, &quot;parsedQuery&quot; : &#123; &quot;userid&quot; : &#123; &quot;$eq&quot; : &quot;1003&quot; &#125; &#125;, &quot;winningPlan&quot; : &#123; &quot;stage&quot; : &quot;PROJECTION&quot;, &quot;transformBy&quot; : &#123; &quot;userid&quot; : 1, &quot;_id&quot; : 0 &#125;, &quot;inputStage&quot; : &#123; &quot;stage&quot; : &quot;IXSCAN&quot;, &quot;keyPattern&quot; : &#123; &quot;userid&quot; : 1 &#125;, &quot;indexName&quot; : &quot;userid_1&quot;, &quot;isMultiKey&quot; : false, &quot;multiKeyPaths&quot; : &#123; &quot;userid&quot; : [ ] &#125;, &quot;isUnique&quot; : false, &quot;isSparse&quot; : false, &quot;isPartial&quot; : false, &quot;indexVersion&quot; : 2, &quot;direction&quot; : &quot;forward&quot;, &quot;indexBounds&quot; : &#123; &quot;userid&quot; : [ &quot;[\\&quot;1003\\&quot;, \\&quot;1003\\&quot;]&quot; ] &#125; &#125; &#125;, &quot;rejectedPlans&quot; : [ ] &#125;, &quot;serverInfo&quot; : &#123; &quot;host&quot; : &quot;bobohost.localdomain&quot;, &quot;port&quot; : 27017, &quot;version&quot; : &quot;4.0.10&quot;, &quot;gitVersion&quot; : &quot;c389e7f69f637f7a1ac3cc9fae843b635f20b766&quot; &#125;, &quot;ok&quot; : 1&#125; 4.文章评论4.1 案例分析案例：实现某头条的文章评论 需要实现一下功能： 基本的增删改查API 根据文章id查询评论 评论点赞 数据库：articledb 专栏文章评论(表)：comment 字段名称 字段含义 字段类型 备注 _id ID ObjectId或String Mongo的主键的字段 articleid 文章ID String content 评论内容 String userid 评论人ID String nickname 评论人昵称 String createdatetime 评论的日期时间 Date likenum 点赞数 Int32 replynum 回复数 Int32 state 状态 String 0：不可见1：可见 parentid 上级ID String 如果为0表示文章的顶级评论 技术选型： mongodb-driver(了解) mongodb-driver是mongo官方推出的java连接mongoDB的驱动包，相当于JDBC驱动 SpringDataMongoDB SpringData家族成员之一，用于操作MongoDB的持久层框架，封装了底层的mongodb-driver。 项目结构： 4.2 文章微服务模块搭建导入坐标： 1234567891011121314151617181920212223242526&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-mongodb&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;aliyun-rds-spring-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.junit.vintage&lt;/groupId&gt; &lt;artifactId&gt;junit-vintage-engine&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 在application.yml中： 123456789spring: #数据源配置 data: mongodb: host: 127.0.0.1 #默认主机地址 database: articledb port: 27017 #默认端口27017 #也可以使用uri连接 #uri: mongodb://localhost:27017/articledb 4.3 文章评论基本的CRUDComment实体类中： 1234567891011121314151617181920212223242526/*把一个java类声明为mongodb的文档，可以通过collection参数指定这个类对应的文档。@Document(collection=&quot;mongodb 对应 collection 名&quot;) 若未加 @Document ，该 bean save 到 mongo 的 comment collection 若添加 @Document ，则 save 到 comment collection复合索引@CompoundIndex( def = &quot;&#123;&#x27;userid&#x27;: 1, &#x27;nickname&#x27;: -1&#125;&quot;) */@Document(collection=&quot;comment&quot;)//可以省略，如果省略，则默认使用类名小写映射集合@Datapublic class Comment &#123; @Id //主键标识，该属性的值会自动对应mongodb的主键字段&quot;_id&quot;，如果该属性名就叫“id”,则该注解可以省略，否则必须写 private String id;//主键 @Field(&quot;content&quot;) //该属性对应mongodb的字段的名字，如果一致，则无需该注解 private String content;//吐槽内容 private Date publishtime;//发布日期 @Indexed //添加了一个单字段的索引 private String userid;//发布人ID private String nickname;//昵称 private LocalDateTime createdatetime;//评论的日期时间 private Integer likenum;//点赞数 private Integer replynum;//回复数 private String state;//状态 private String parentid;//上级ID private String articleid;&#125; CommentRepository中： 123public interface CommentRepository extends MongoRepository&lt;Comment,String&gt; &#123; Page&lt;Comment&gt; findByParentid(String parentid, Pageable pageable);&#125; CommentService中： 1234567891011121314public interface CommentService &#123; //保存一个评论 void saveComment(Comment comment); //更新评论 void updateComment(Comment comment); //根据id删除评论 void deleteCommentById(String id); //查询所有评论 List&lt;Comment&gt; findCommentList(); //根据id查询评论 Comment findCommentById(String id); //根据父id，查询子评论的分页列表 Page&lt;Comment&gt; findCommentListPageByParentid(String parentid, int page, int size);&#125; CommentServiceImpl中： 1234567891011121314151617181920212223242526272829303132333435@Servicepublic class CommentServiceImpl implements CommentService &#123; @Autowired private CommentRepository commentRepository; @Override public void saveComment(Comment comment) &#123; commentRepository.save(comment); &#125; @Override public void updateComment(Comment comment) &#123; commentRepository.save(comment); &#125; @Override public void deleteCommentById(String id) &#123; commentRepository.deleteById(id); &#125; @Override public List&lt;Comment&gt; findCommentList() &#123; return commentRepository.findAll(); &#125; @Override public Comment findCommentById(String id) &#123; return commentRepository.findById(id).get(); &#125; @Override public Page&lt;Comment&gt; findCommentListPageByParentid(String parentid, int page, int size) &#123; return commentRepository.findByParentid(parentid, PageRequest.of(page-1,size)); &#125;&#125; 测试： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152@SpringBootTestpublic class CommentServiceTest &#123; @Autowired private CommentService commentService; @Test void testSave() &#123; Comment comment=new Comment(); comment.setArticleid(&quot;100001&quot;); comment.setContent(&quot;不要吃我&quot;); comment.setCreatedatetime(LocalDateTime.now()); comment.setUserid(&quot;1004&quot;); comment.setNickname(&quot;Jerry&quot;); comment.setState(&quot;1&quot;); comment.setParentid(&quot;62ddfe4c2f8d0c6ca75ba67f&quot;); //父评论id comment.setLikenum(0); comment.setReplynum(0); commentService.saveComment(comment); commentService.saveComment(comment); &#125; @Test void testFindById() &#123;//id查找 System.out.println(commentService.findCommentById(&quot;62ddfe4c2f8d0c6ca75ba67f&quot;)); &#125; @Test void testDeleteById() &#123;//删除 commentService.deleteCommentById(&quot;666&quot;); &#125; @Test void testFindAll() &#123;//查找所有 System.out.println(commentService.findCommentList()); &#125; @Test void testUpdate() &#123; //更新 Comment comment = commentService.findCommentById(&quot;62ddfe4c2f8d0c6ca75ba67f&quot;); comment.setLikenum(666); commentService.updateComment(comment); &#125; @Test void testFindCommentListByParentid() &#123; //分页查找 Page&lt;Comment&gt; commentPage = commentService.findCommentListPageByParentid(&quot;62ddfe4c2f8d0c6ca75ba67f&quot;, 1, 2); System.out.println(&quot;----总记录数：&quot;+commentPage.getTotalElements()); System.out.println(&quot;----当前页数据：&quot;+commentPage.getContent()); &#125;&#125; 4.4 MongoTemplate实现评论点赞以下为点赞的临时示例代码： CommentService 新增updateThumbup方法 12345public void updateCommentThumbupToIncrementingOld(String id)&#123; Comment comment = CommentRepository.findById(id).get(); comment.setLikenum(comment.getLikenum()+1); CommentRepository.save(comment);&#125; 以上方法虽然实现起来比较简单，但是执行效率并不高 我只需要将点赞数加1就可以了，没必要查询出所有字段修改后再更新所有字段。 可以使用MongoTemplate类来实现对某列的操作。 在CommentService声明一个updateCommentLikenum方法： 1234public interface CommentService &#123; //点赞数+1 void updateCommentLikenum(String id);&#125; CommentServiceImpl中实现updateCommentLikenum方法： 123456789101112131415@Autowiredprivate MongoTemplate mongoTemplate;public void updateCommentLikenum(String id)&#123; //查询对象 Query query = Query.query(Criteria.where(&quot;_id&quot;).is(id)); //更新对象 Update update =new Update(); //局部更新，相当于$set update.set(key,value) //递增$inc update.inc(&quot;likenum&quot;,1) 默认增加1 update.inc(&quot;likenum&quot;); //参数1：查询对象 参数2：更新对象 参数3：集合的名字或实体类的类型Comment.class mongoTemplate.updateFirst(query,update,&quot;comment&quot;);&#125; 测试： 1234@Testvoid testUpdateLikenum() &#123; //点赞加1 commentService.updateCommentLikenum(&quot;62ddfe4c2f8d0c6ca75ba67f&quot;);&#125;","categories":[{"name":"Java","slug":"Java","permalink":"http://example.com/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"},{"name":"数据库","slug":"数据库","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}]},{"title":"","slug":"Java/ELK搜索","date":"2022-08-06T11:11:16.298Z","updated":"2022-09-21T13:33:04.504Z","comments":true,"path":"2022/08/06/Java/ELK搜索/","link":"","permalink":"http://example.com/2022/08/06/Java/ELK%E6%90%9C%E7%B4%A2/","excerpt":"","text":"1.ELK简介ELK是包含但不限于Elasticsearch(简称ES)、Logstash、Kibana三个开源软件的组成的一个整体，这三个软件合成ELK。 本课程从分别对三个组件经行详细介绍： Elasticsearch：因为它是elk的核心。本课程从es底层对文档、索引、 搜索、聚合、集群经行介绍，从搜索和聚合分析实例来展现es的魅力。 Logstash：从内部如何采集数据到指定地方来展现它数据采集的功能。 Kibana：从数据绘图展现数据可视化的功能。 2.Elastic Stack概念随着ELK的发展，又有新成员Beats、elastic cloud的加入，所以就形成了Elastic Stack。 所以说，ELK是旧的称呼，Elastic Stack是新的名字 2.1 Elastic Stack特色 处理方式灵活：Elasticsearch是目前最流行的准实时全文检索引擎，具有高速检索大数据的能力 配置简单：安装ELK的每个组件，仅需配置每个组件的一个配置文件即可，修改处不多，因为大量参数已经默认配在系统中，修改想要修改的选项即可 接口简单：采用json形式RESTFUL APl接受数据并响应，无关语言 性能高效：Elasticsearch基于优秀的全文搜索技术Lucene，采用倒排索引，可以轻易地在百亿级别数据下，搜索出想要的内容，并且是秒级响应 灵活扩展：Elasticsearch和Logstash都可以根据集群规模线性拓展，Elasticsearch内部自动实现集群协作 数据展现华丽：Kibana作为前端展现工具，图表华丽，配置简单 2.2 Elastic Stack组件 Elasticsearch： Elasticsearch 是使用java开发，基于Lucene分布式、通过Restful方式进行交互的近实时搜泰平台框架。它的特点有：分布式，零配置，自动发现，索引自动分片，索引副本机制，restful风格接口，多数据源，自动搜索负载等。 Logstash： Logstash 基于java开发，是一个数据抽取转化工具。一般工作方式为C&#x2F;S架构，client端安装在需要收集信息的主机上，server端负责将收到的各节点日志进行过滤、 修改等操作在一并发往Elasticsearch或其他组件去。 Kibana： Kibana 基于nodejs，也是一个开源和免费的可视化工具，Kibana可以为Logstash和Elasticsearch 提供的日志分析友好的web界面，可以汇总、分析和搜索重要数据日志。 Beats： Beats平台集合了多种单一用途数据采集器。它们从成百上千或成千上万台机器和系统向Logstash或Elasticsearch发送数据。 Beats由如下组成： Packetbeat： 轻量型网络数据采集器，用于深挖网线上传输的数据，了解应用程序动态。Packetbeat 是一款轻量型网络数据包分析器，能够多将数据发送至Logstash 或 Elasticsearch。其支持ICMP (V4 and v6)、DNS、HTTP、MySQL、PostgreSQL、Redis、MongoDB、Memcache等协议。 Filebeat： 轻量型日志采集器， 当您要面对成百上千其至成千上万的的服务器、虚拟机和容器生成的志时，请告别 SSH 吧。Filebeat 将为您提供一种轻量型方法，用于转发和汇总日志与文件，让简单的事情不再繁杂。 Metricbeat： 轻量型指标采集器。Metricbeat 能够多以一种轻量型的方式输送各种系统和服务统计数据，从CPU到内存，从 Redis 到Nginx，不一而足。可定期获取外部系统的监控指标信息，其可以监控、收集 Apache、http、HAProxy、MongoDB、MySQL、Nginx、PostgreSQL、Redis、System、Zookeeper等服务。 Winlogbeat： 轻量型 Windows 事件日志采集器。用于密切监控基于Windows 的基础设施上发生的事件。Winlogbeat 能够多以一种轻量型的方式，将Windows 事件日志实时地流式传输至 Elasticsearch 和 Logstash。 Auditbeat： 轻量型申计日志采集器。收集您 Linux 审计框架的数据，监控文件完整性。Auditbeat 实时采集这些事件，然后发送到 Elastic Stack 其他部分做进一步分析。 Heartbeat： 面向运行状态监测的轻量型采集器。通过主动探测来监测服务的可用性。通过给定 URL列表，Heartbeat 仅仅询问：网站运行正常吗？Heartbeat 会将此信息和响应时间发送至 Elastic 的其他部分，以进行进一步分析。 Elastic cloud： 基于 Elasticsearch 的软件即服务(SaaS)解决方案。通过 Elastic 的官方合作伙伴使用托管的 Elasticsearch 服务。 3.Elasticsearch概念3.1 搜索是什么概念：用户输入想要的关键词，返回含有该关键词的所有信息 场景： 互联网搜索：谷歌、百度 站内搜索(垂直搜索)：搜索商品(淘宝、京东) 3.2 数据库搜索站内搜索(垂直搜索)： 数据量小、简单搜索，可以使用数据库 存在问题： 存储问题。电商网站商品上亿条时，涉及到单表数据过大必须拆分表，数据磁盘占用过大必须分库(mycat)。 性能问题：解决上面问题后，查询”笔记本电脑”等关键词时，上亿条数据的商品名字段逐行扫描，性能跟不上。 不能分词：如搜索&quot;笔记本电脑&quot;，只能搜索完全和关键词一样的数据，那么数据量小时，如果搜索&quot;笔记电脑&quot;，&quot;电脑&quot;数据要不要给用户。 互联网搜索：数据量过大(PB级)，不会使用数据库。 3.3 全文检索倒排索引： 数据存储时 ，经行分词建立term索引库。 倒排索引：源于实际应用中需要根据属性的值来查找记录。这种索引表中的每项都包括一个属性值和具有该属性值的各记录的地址。由于不是由记录来确定属性值，而是由属性值来确定记录的位置，因而称为倒排索引(inverted index)。带有倒排索引的文件我们称为倒排索引文任，简称倒排文任(inverted file)。 Lucene： 就是一个jar包，里面封装了全文检索的引擎、搜索的算法代码。 开发时，引入Lucene的jar包，通过api开发搜索相关业务。底层会在磁盘建立索引库。 3.4 初识ElasticsearchElasticsearch是一个基于Luncene的搜索服务器，并且是一个分布式、RESTful 风格的搜索和数据分析引擎 功能介绍： 分布式的搜索引擎和数据分析引擎 搜索：互联网搜索、电商网站站内搜索、OA系统查询 数据分析：电商网站查询近—周哪些品类的图书销售前十，新国网站，最近3天阅读量最高的十个关键词，舆情分析 全文检索，结构化检索，数据分析 全文检索： 搜索商品名称包含java的图书 select * from books where book_name like &quot;%java%&quot; 结构化检索： 搜索商品分类为spring的图书都有哪些 select * from books where category _id=&#39;spring&#39; 数据分析： 分析每一个分类下有多少种图书 select category _id,count(*) from books group by category_id 对海量数据进行近实时的处理 分布式：ES自动可以将海量数据分散到多台服务器上去存储和检索,经行并行查询，提高搜索效率。相对的，Lucene是单机应用。 近实时：数据库上亿条数据查询，搜索一次耗时几个小时，是批处理(batch-processing）。而ES只需秒级即可查询海量数据，所以叫近实时，秒级。 使用场景： 维基百科：全文搜索、高亮、搜索推荐 GitHub：搜索上千行代码 电商网站：检索商品、搜索推荐 日志数据分析：Logstash采集日志，ES进行复杂的数据分析，Kibana数据可视化 百度搜索：第一次查询使用es OA、ERP系统站内搜索 特点： 可拓展性高： 大型分布式集群（数百台服务器）技术，处理PB级数据，大公司可以使用。小公司数据量小，也可以部署在单机。大数据领域使用广泛。 技术整合： 将全文检索、数据分析、分布式相关技术整合在一起lucene(全文检索)、商用的数据分析软件(BI软件)、分布式数据库(mycat) 部署简单： 开箱即用，很多默认配置不需关心，解压完成直接运行即可，拓展时，只需多部署几个实例即可，负载均衡、分片迁移集群内部自己实施。 接口简单： 使用restful api经行交互，跨语言。 功能强大： Elasticsearch作为传统数据库的一个补充，提供了数据库所不不能提供的很多功能，如全文检索、同义词处理、相关度排名。 Lucene与Elasticsearch的关系： Luncene： 最先进、功能最强大的搜索库，直接基于lucene开发，非常复杂，api复杂 Elasticsearch： 基于lucene，封装了许多lucene底层功能，提供简单易用的restful api接口和许多语言的客户端，如java的高级客户端(Java High Level REST Client)和底层客户端(Java Low Level REST Client ) 3.5 Elasticsearch核心概念 NRT(Near Realtime)：进实时 写入数据时，过1秒才会被搜索到，因为内部在分词、录入索引。 es搜索时：搜索和分析数据需要秒级出结果。 Cluster：集群 包含一个或多个启动着es实例的机器群。通常一台机器起一个es实例。同一网络下，集名一样的多个es实例自动组成集群，自动均衡分片等行为。默认集群名为“elasticsearch”。 Node：节点 每个es实例称为一个节点。节点名自动分配，也可以手动配置。 Index：索引 包含一堆有相似结构的文档数据。 索引创建规则： 仅限小写字母 不能包含\\ / * ? &quot; &lt; &gt; | #以及空格符等特殊符号 从7.0版本开始不再包含冒号 不能以- _ +开头 不能超过255个字节（注意它是字节，因此多字节字符将计入255个限制） Document：文档 es中的最小数据单元。一个document就像数据库中的一条记录。通常以json格式显示。多个document存储于一个索引（Index）中。 12345678book document&#123; &quot;book_id&quot;: &quot;1&quot;, &quot;book_name&quot;: &quot;java编程思想&quot;, &quot;book_desc&quot;: &quot;从Java的基础语法到最高级特性（深入的[面向对象](https://baike.baidu.com/item/面向对象)概念、多线程、自动项目构建、单元测试和调试等），本书都能逐步指导你轻松掌握。&quot;, &quot;category_id&quot;: &quot;2&quot;, &quot;category_name&quot;: &quot;java&quot;&#125; Field：字段 就像数据库中的列（Columns），定义每个document应该有的字段。 Type：类型 每个索引里都可以有一个或多个type，type是index中的一个逻辑数据分类，一个type下的document，都有相同的field。 注意：6.0之前的版本有type（类型）概念，type相当于关系数据库的表，ES官方将在ES9.0版本中彻底删除type。本教程type都为_doc。 Shard：分片 index数据过大时，将index里面的数据，分为多个shard，分布式的存储在各个服务器上面。可以支持海量数据和高并发，提升性能和吞吐量，充分利用多台机器的cpu。 Replica：副本 在分布式环境下，任何一台机器都会随时宕机，如果宕机，index的一个分片没有，导致此index不能搜索。所以，为了保证数据的安全，我们会将每个index的分片经行备份，存储在另外的机器上。保证少数机器宕机es集群仍可以搜索。 能正常提供查询和插入的分片我们叫做主分片(primary shard)，其余的我们就管他们叫做备份的分片 (replica shard)。 es6默认新建索引时，5分片，2副本，也就是一主一备，共10个分片。所以，es集群最小规模为两台。 Elasticsearch与数据库比较： 关系型数据库(MySQL) 非关系型数据库(Elasticsearch) 数据库Database 索引Index 表Table 索引Index(原为Type) 数据行Row 文档Document 数据列Column 字段Field 约束 Schema 约束 Schema 4.ES快速入门4.1 文档(document)的数据格式 应用系统的数据结构都是面向对象的，具有复杂的数据结构 对象存储到数据库，需要将关联的复杂对象属性插到另一张表，查询时再拼接起来。 ES面向文档，文档中存储的数据结构，与对象一致。所以一个对象可以直接存成一个文档。 ES的document用json数据格式来表达。 123456789&#123; &quot;id&quot;:&quot;1&quot;, &quot;name&quot;: &quot;张三&quot;, &quot;last_name&quot;: &quot;zhang&quot;, &quot;classInfo&quot;: &#123; &quot;id&quot;: &quot;1&quot;, &quot;className&quot;: &quot;三年二班&quot;, &#125;&#125; 4.2 简单的集群管理使用kibana的控制台，浏览器访问：http://主机地址:5601/app/dev_tools#/console 检查集群的健康状况： 1GET /_cat/health?v 响应结果： 12epoch timestamp cluster status node.total node.data shards pri relo init unassign pending_tasks max_task_wait_time active_shards_percent1660972717 05:18:37 docker-cluster green 1 1 11 11 0 0 0 0 - 100.0% 健康状况的三种情况： green：每个索引的primary shard和replica shard都是active状态的 yellow：每个索引的primary shard都是active状态的，但是部分replica shard不是active状态，处于不可用的状态 red：不是所有索引的primary shard都是active状态的，部分索引有数据丢失了 查看集群中的索引： 1GET /_cat/indexes?v 响应结果： 123456789health status index uuid pri rep docs.count docs.deleted store.size pri.store.sizegreen open .geoip_databases dGx7TrfoTCuOqVS7y6CTRA 1 0 41 0 38.9mb 38.9mbgreen open .kibana_7.17.5_001 JGFQAr7hRWqaoIfIpo_Liw 1 0 438 2 6.7mb 6.7mbgreen open .apm-custom-link f8HqzrG-TWipwqbNoGLQEA 1 0 0 0 226b 226bgreen open kibana_sample_data_ecommerce -WV4YJoiTaWtfACqobRV9g 1 0 4675 0 4.2mb 4.2mbgreen open .apm-agent-configuration hoLYS7CRRTCooCP3ndNt6Q 1 0 0 0 226b 226bgreen open .kibana_task_manager_7.17.5_001 lSfnkGiSSzKTvesWhYZgaQ 1 0 17 77315 8.2mb 8.2mbgreen open .async-search _bMoH_6WQkKhHkGAcpl1MA 1 0 0 0 249b 249bgreen open .tasks jBJ9hH7TTn2TXtFwmYDjVw 1 0 6 0 23kb 23kb 简单的索引操作： 创建索引： 1PUT /demo_index 响应结果： 12345&#123; &quot;acknowledged&quot; : true, &quot;shards_acknowledged&quot; : true, &quot;index&quot; : &quot;demo_index&quot;&#125; 删除索引： 1DELETE /demo_index 响应结果： 123&#123; &quot;acknowledged&quot; : true&#125; 4.3 案例介绍有一个售卖图书的网站，需要为其基于ES构建一个后台系统，提供以下功能： 对商品信息进行CRUD（增删改查）操作 执行简单的结构化查询 可以执行简单的全文检索，以及复杂的phrase（短语）检索 对于全文检索的结果，可以进行高亮显示 对数据进行简单的聚合分析 4.4 商品的CRUD操作document的CRUD操作 **新建图书索引book**：PUT /index 1PUT /book **新增图书(文档)**：PUT /index/type/id 新增图书1： 12345678910PUT /book/_doc/1&#123;&quot;name&quot;: &quot;Bootstrap开发&quot;,&quot;description&quot;: &quot;Bootstrap是由Twitter推出的一个前台页面开发css框架，是一个非常流行的开发框架，此框架集成了多种页面效果。此开发框架包含了大量的CSS、JS程序代码，可以帮助开发者（尤其是不擅长css页面开发的程序人员）轻松的实现一个css，不受浏览器限制的精美界面css效果。&quot;,&quot;studymodel&quot;: &quot;201002&quot;,&quot;price&quot;:38.6,&quot;timestamp&quot;:&quot;2019-08-25 19:11:35&quot;,&quot;pic&quot;:&quot;group1/M00/00/00/wKhlQFs6RCeAY0pHAAJx5ZjNDEM428.jpg&quot;,&quot;tags&quot;: [ &quot;bootstrap&quot;, &quot;dev&quot;]&#125; 新增图书1： 12345678910PUT /book/_doc/2&#123;&quot;name&quot;: &quot;java编程思想&quot;,&quot;description&quot;: &quot;java语言是世界第一编程语言，在软件开发领域使用人数最多。&quot;,&quot;studymodel&quot;: &quot;201001&quot;,&quot;price&quot;:68.6,&quot;timestamp&quot;:&quot;2019-08-25 19:11:35&quot;,&quot;pic&quot;:&quot;group1/M00/00/00/wKhlQFs6RCeAY0pHAAJx5ZjNDEM428.jpg&quot;,&quot;tags&quot;: [ &quot;java&quot;, &quot;dev&quot;]&#125; 查看所有图书：GET /index/_search **查询图书(检索文档)**：GET /index/type/id 查看图书1 1GET /book/_doc/1 响应结果： 123456789101112131415161718192021&#123; &quot;_index&quot; : &quot;book&quot;, &quot;_type&quot; : &quot;_doc&quot;, &quot;_id&quot; : &quot;1&quot;, &quot;_version&quot; : 1, &quot;_seq_no&quot; : 0, &quot;_primary_term&quot; : 1, &quot;found&quot; : true, &quot;_source&quot; : &#123; &quot;name&quot; : &quot;Bootstrap开发&quot;, &quot;description&quot; : &quot;Bootstrap是由Twitter推出的一个前台页面开发css框架，是一个非常流行的开发框架，此框架集成了多种页面效果。此开发框架包含了大量的CSS、JS程序代码，可以帮助开发者（尤其是不擅长css页面开发的程序人员）轻松的实现一个css，不受浏览器限制的精美界面css效果。&quot;, &quot;studymodel&quot; : &quot;201002&quot;, &quot;price&quot; : 38.6, &quot;timestamp&quot; : &quot;2019-08-25 19:11:35&quot;, &quot;pic&quot; : &quot;group1/M00/00/00/wKhlQFs6RCeAY0pHAAJx5ZjNDEM428.jpg&quot;, &quot;tags&quot; : [ &quot;bootstrap&quot;, &quot;dev&quot; ] &#125;&#125; 修改图书： 全局替换： 12345678910PUT /book/_doc/1&#123; &quot;name&quot;: &quot;Bootstrap开发教程&quot;, &quot;description&quot;: &quot;Bootstrap是由Twitter推出的一个前台页面开发css框架，是一个非常流行的开发框架，此框架集成了多种页面效果。此开发框架包含了大量的CSS、JS程序代码，可以帮助开发者（尤其是不擅长css页面开发的程序人员）轻松的实现一个css，不受浏览器限制的精美界面css效果。&quot;, &quot;studymodel&quot;: &quot;201002&quot;, &quot;price&quot;:38.6, &quot;timestamp&quot;:&quot;2019-08-25 19:11:35&quot;, &quot;pic&quot;:&quot;group1/M00/00/00/wKhlQFs6RCeAY0pHAAJx5ZjNDEM428.jpg&quot;, &quot;tags&quot;: [ &quot;bootstrap&quot;, &quot;开发&quot;]&#125; 替换操作是整体覆盖，要带上所有信息。 每次执行后，返回结果中版本号_version在不断增加，此过程为全量替换。 实质：旧文档的内容不会立即删除，只是标记为deleted。适当的时机，集群会将这些文档删除。 局部替换： POST /index/_update/id或 POST /index/type/id/_update 123456POST /book/_update/1&#123; &quot;doc&quot;: &#123; &quot;name&quot;: &quot; Bootstrap开发教程高级&quot; &#125;&#125; 内部与全量替换是一样的，旧文档标记为删除，新建一个文档。 优点： 大大减少网络传输次数和流量，提升性能 减少并发冲突发生的概率 **删除图书(删除文档)**：DELETE /index/type/id 1DELETE /book/_doc/1 实质：旧文档的内容不会立即删除，只是标记为deleted。适当的时机，集群会将这些文档删除。 5.文档document入门1GET /book/_doc/1 响应结果： 123456789101112131415161718192021&#123; &quot;_index&quot; : &quot;book&quot;, &quot;_type&quot; : &quot;_doc&quot;, &quot;_id&quot; : &quot;1&quot;, &quot;_version&quot; : 1, &quot;_seq_no&quot; : 0, &quot;_primary_term&quot; : 1, &quot;found&quot; : true, &quot;_source&quot; : &#123; &quot;name&quot; : &quot;Bootstrap开发&quot;, &quot;description&quot; : &quot;Bootstrap是由Twitter推出的一个前台页面开发css框架，是一个非常流行的开发框架，此框架集成了多种页面效果。此开发框架包含了大量的CSS、JS程序代码，可以帮助开发者（尤其是不擅长css页面开发的程序人员）轻松的实现一个css，不受浏览器限制的精美界面css效果。&quot;, &quot;studymodel&quot; : &quot;201002&quot;, &quot;price&quot; : 38.6, &quot;timestamp&quot; : &quot;2019-08-25 19:11:35&quot;, &quot;pic&quot; : &quot;group1/M00/00/00/wKhlQFs6RCeAY0pHAAJx5ZjNDEM428.jpg&quot;, &quot;tags&quot; : [ &quot;bootstrap&quot;, &quot;dev&quot; ] &#125;&#125; 5.1 字段解析 _index 含义：此文档属于哪个索引 原则：类似数据放在一个索引中。数据库中表的定义规则。如图书信息放在book索引中，员工信息放在employee索引中。各个索引存储和搜索时互不影响。 定义规则：英文小写。尽量不要使用特殊字符。order user _type 含义：类别。book java node 注意：以后的es9将彻底删除此字段，所以当前版本在不断弱化type。不需要关注。见到_type都为_doc。 _id 含义：文档的唯一标识。就像表的id主键。结合索引可以标识和定义一个文档。 生成：手动（put &#x2F;index&#x2F;_doc&#x2F;id）、自动 5.2 自动生成文档id1234POST /book/_doc&#123; &quot;name&quot;:&quot;ELK&quot;&#125; 响应结果： 1234567891011121314&#123; &quot;_index&quot; : &quot;book&quot;, &quot;_type&quot; : &quot;_doc&quot;, &quot;_id&quot; : &quot;FrnSuoIB-YsVyRxk4XeZ&quot;, &quot;_version&quot; : 1, &quot;result&quot; : &quot;created&quot;, &quot;_shards&quot; : &#123; &quot;total&quot; : 2, &quot;successful&quot; : 1, &quot;failed&quot; : 0 &#125;, &quot;_seq_no&quot; : 3, &quot;_primary_term&quot; : 1&#125; 自动生成的id就为FrnSuoIB-YsVyRxk4XeZ 特点：长度为20个字符，URL安全，base64编码，GUID，分布式生成不冲突 5.3 定制返回字段就像sql一样不是查询所有select * from book，而是select name, price from book 查询id为1的书名以及价格： 1GET /book/_doc/1?_source_includes=name,price 注意：name与price中间只有,不能有空格 响应结果： 12345678910111213&#123; &quot;_index&quot; : &quot;book&quot;, &quot;_type&quot; : &quot;_doc&quot;, &quot;_id&quot; : &quot;1&quot;, &quot;_version&quot; : 2, &quot;_seq_no&quot; : 2, &quot;_primary_term&quot; : 1, &quot;found&quot; : true, &quot;_source&quot; : &#123; &quot;price&quot; : 38.6, &quot;name&quot; : &quot; Bootstrap开发教程高级&quot; &#125;&#125; 5.4 文档的强制替换强制创建：PUT /index/ _doc/id/_create 为防止覆盖原有数据，我们在新增时，设置为强制创建，不会覆盖原有文档。 123456POST /book/_doc/1/_create&#123; &quot;doc&quot;: &#123; &quot;name&quot;: &quot; Bootstrap开发教程高级666&quot; &#125;&#125; 响应结果： 12345678910111213141516171819&#123; &quot;error&quot; : &#123; &quot;root_cause&quot; : [ &#123; &quot;type&quot; : &quot;version_conflict_engine_exception&quot;, &quot;reason&quot; : &quot;[1]: version conflict, document already exists (current version [4])&quot;, &quot;index_uuid&quot; : &quot;_GEFBf0rSxG9GxzJtG8w5A&quot;, &quot;shard&quot; : &quot;0&quot;, &quot;index&quot; : &quot;book&quot; &#125; ], &quot;type&quot; : &quot;version_conflict_engine_exception&quot;, &quot;reason&quot; : &quot;[1]: version conflict, document already exists (current version [4])&quot;, &quot;index_uuid&quot; : &quot;_GEFBf0rSxG9GxzJtG8w5A&quot;, &quot;shard&quot; : &quot;0&quot;, &quot;index&quot; : &quot;book&quot; &#125;, &quot;status&quot; : 409&#125; 5.5 脚本更新es可以内置脚本执行复杂操作。例如painless脚本。 注意：groovy脚本在es6以后就不支持了。原因是耗内存，不安全远程注入漏洞。 内置脚本 需求1：修改文档1的num字段+1。 插入数据： 1234PUT /test/_doc/1&#123; &quot;num&quot;: 0&#125; 执行脚本： 1234POST /test/_update/1&#123; &quot;script&quot; : &quot;ctx._source.num+=1&quot;&#125; 查询文档1： 1GET /test/_doc/1 响应数据： 123456789101112&#123; &quot;_index&quot; : &quot;test&quot;, &quot;_type&quot; : &quot;_doc&quot;, &quot;_id&quot; : &quot;1&quot;, &quot;_version&quot; : 2, &quot;_seq_no&quot; : 1, &quot;_primary_term&quot; : 1, &quot;found&quot; : true, &quot;_source&quot; : &#123; &quot;num&quot; : 1 &#125;&#125; 需求2：搜索所有文档，将num字段乘以2输出 插入数据： 1234PUT /test/_doc/2&#123; &quot;num&quot;: 5&#125; 查询所有将num x 2： 注意：源数据不变，只是将查询的数据 x 2 1234567891011121314GET /test/_search&#123; &quot;script_fields&quot;: &#123; &quot;my_doubled_field&quot;: &#123; &quot;script&quot;: &#123; &quot;lang&quot;: &quot;expression&quot;, &quot;source&quot;: &quot;doc[&#x27;num&#x27;] * mul&quot;, &quot;params&quot;: &#123; &quot;mul&quot;: 2 &#125; &#125; &#125; &#125;&#125; 响应结果： 1234567891011121314151617181920212223242526272829303132333435363738394041&#123; &quot;took&quot; : 364, &quot;timed_out&quot; : false, &quot;_shards&quot; : &#123; &quot;total&quot; : 1, &quot;successful&quot; : 1, &quot;skipped&quot; : 0, &quot;failed&quot; : 0 &#125;, &quot;hits&quot; : &#123; &quot;total&quot; : &#123; &quot;value&quot; : 2, &quot;relation&quot; : &quot;eq&quot; &#125;, &quot;max_score&quot; : 1.0, &quot;hits&quot; : [ &#123; &quot;_index&quot; : &quot;test&quot;, &quot;_type&quot; : &quot;_doc&quot;, &quot;_id&quot; : &quot;1&quot;, &quot;_score&quot; : 1.0, &quot;fields&quot; : &#123; &quot;my_doubled_field&quot; : [ 2.0 #由1变成2 ] &#125; &#125;, &#123; &quot;_index&quot; : &quot;test&quot;, &quot;_type&quot; : &quot;_doc&quot;, &quot;_id&quot; : &quot;2&quot;, &quot;_score&quot; : 1.0, &quot;fields&quot; : &#123; &quot;my_doubled_field&quot; : [ 10.0 #由5变成10 ] &#125; &#125; ] &#125;&#125; 外部脚本： 注意：脚本性能低下，且容易发生注入，本教程忽略 自行了解：官方文档 6.ES的并发问题如同秒杀，多线程情况下，es同样会出现并发冲突问题。 6.1 乐观锁与悲观锁为控制并发问题，我们通常采用锁机制。 分为悲观锁和乐观锁两种机制： 悲观锁：很悲观，所有情况都上锁。此时只有一个线程可以操作数据。具体例子为数据库中的行级锁、表级锁、读锁、写锁等。 特点：优点是方便，直接加锁，对程序透明。缺点是效率低。 乐观锁：很乐观，对数据本身不加锁。提交数据时，通过一种机制验证是否存在冲突，如es中通过版本号验证。 特点：优点是并发能力高。缺点是操作繁琐，在提交数据时，可能反复重试多次。 6.2 基于_version乐观锁控制","categories":[],"tags":[]},{"title":"爬取某易云的免费音乐","slug":"Python/爬虫/爬取某易云音乐","date":"2022-08-06T10:59:00.000Z","updated":"2022-08-06T11:16:47.702Z","comments":true,"path":"2022/08/06/Python/爬虫/爬取某易云音乐/","link":"","permalink":"http://example.com/2022/08/06/Python/%E7%88%AC%E8%99%AB/%E7%88%AC%E5%8F%96%E6%9F%90%E6%98%93%E4%BA%91%E9%9F%B3%E4%B9%90/","excerpt":"","text":"获取加密的字符串： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253import jsonfrom base64 import b64encodefrom Crypto.Cipher import AES# 前端自定义的字符串常量_g = &quot;0CoJUm6Qyw8W8jud&quot;# 16位随机数# 必须要自己手动固定# 因为data中的params和encSecKey到了服务器解析后会对比随机数是否相同# 获取encSecKey过程中唯一的变量就是这个随机数，固定了随机数就是固定了encSecKey# 这样就只需要获取params了_i = &quot;Zrv1r2M2VOINoxIJ&quot;# 加密工具：转化为16的倍数def _to_16(data): pad = 16 - len(data) % 16 data += chr(pad) * pad return data# 获取加密的paramsdef _get_aes(a, b): key = b.encode(&quot;utf-8&quot;) iv = &quot;0102030405060708&quot;.encode(&quot;utf-8&quot;) aes = AES.new(key=key, IV=iv, mode=AES.MODE_CBC) # 创造加密器 a = _to_16(a) bs = aes.encrypt(a.encode(&quot;utf-8&quot;)) # 加密,加密内容长度必须是16的倍数， return str(b64encode(bs), &quot;utf-8&quot;) # 转化为字符串返回，# 获取encSecKeydef _get_encSecKey(): return &quot;d6b3977cdc2bf7c55093043afcc1037c7c9a52e0ee558aaa9afb4b6af&quot; \\ &quot;0078171aacc26f75e38da3cc754ac9e7c55b835f6a52496f0c7507445&quot; \\ &quot;8de571d3d5fa1c1d4ed2e8e91b95797030da6904e0a0b379fd1722665&quot; \\ &quot;29fab6d9ce2f10ead2880567491406334d7d4a90a39698eae9f886a22&quot; \\ &quot;7cdd18399533760d314d13281d3b&quot;# 获取加密参数def get_data(data): data = json.dumps(data) params = _get_aes(data, _g) params = _get_aes(params, _i) encSecKey = _get_encSecKey() data = &#123; &quot;params&quot;: params, &quot;encSecKey&quot;: encSecKey &#125; return data 获取歌曲列表： 1234567891011121314151617181920212223242526272829303132333435363738import requestsimport GetDatadef _search(content): data = &#123;&quot;hlposttag&quot;: &quot;&lt;/span&gt;&quot;, &quot;hlpretag&quot;: &#x27;&lt;span class=&quot;s-fc7&quot;&gt;&#x27;, &quot;limit&quot;: 30, &quot;offset&quot;: 0, &quot;s&quot;: f&quot;&#123;content&#125;&quot;, &quot;total&quot;: True, &quot;type&quot;: &quot;1&quot;&#125; url = &quot;https://music.163.com/weapi/cloudsearch/get/web?csrf_token=&quot; data = GetData.get_data(data) resp = requests.post(url=url, data=data) return resp.json()def show_list(content): search_list = _search(content) print(&quot;----------------------------------------------------------&quot;) print(&quot;序号 songId 歌手 歌曲 &quot;) index = 1 list = [] for i in search_list[&quot;result&quot;][&quot;songs&quot;]: print(f&quot;&#123;index&#125; &#123;i[&#x27;id&#x27;]&#125; &#123;i[&#x27;ar&#x27;][0][&#x27;name&#x27;]&#125; &#123;i[&#x27;name&#x27;]&#125;&quot;) index += 1 temp = &#123; &quot;id&quot;: i[&quot;id&quot;], &quot;song_name&quot;: i[&quot;name&quot;], &quot;singer&quot;:i[&quot;ar&quot;][0][&quot;name&quot;] &#125; list.append(temp) print(&quot;----------------------------------------------------------&quot;) return list 下载歌曲： 1234567891011121314151617181920212223242526272829import requestsimport GetDatadef _download_song(url, name): song_name = name + &quot;.m4a&quot; resp = requests.get(url=url) f = open(&quot;./&quot; + song_name, &quot;wb&quot;) f.write(resp.content) f.close() print(name + &quot;下载成功&quot;)def get_song_url(dic): data = &#123;&quot;csrf_token&quot;: &quot;&quot;, &quot;encodeType&quot;: &quot;aac&quot;, &quot;ids&quot;: f&quot;[&#123;dic[&#x27;id&#x27;]&#125;]&quot;, &quot;level&quot;: &quot;standard&quot; &#125; data = GetData.get_data(data) url = &quot;https://music.163.com/weapi/song/enhance/player/url/v1?csrf_token=&quot; resp = requests.post(url=url, data=data) song_url = resp.json()[&quot;data&quot;][0][&quot;url&quot;] _download_song(song_url, dic[&quot;song_name&quot;] + &quot;_&quot; + dic[&quot;singer&quot;]) 主函数调用： 12345678910if __name__ == &#x27;__main__&#x27;: print(&quot;仅供学习交流，严禁用于商业用途，请于24小时内删除！&quot;) search = input(&quot;请输入要搜索的歌曲或歌手&quot;) list = GetSongId.show_list(search) index = input(&quot;请选择以上的序号(-1取消)&quot;) if index != -1: Download.get_song_url(list[int(index)-1]) 目前2022&#x2F;8&#x2F;6为止，使用正常","categories":[{"name":"Python","slug":"Python","permalink":"http://example.com/categories/Python/"},{"name":"爬虫","slug":"Python/爬虫","permalink":"http://example.com/categories/Python/%E7%88%AC%E8%99%AB/"}],"tags":[{"name":"爬虫","slug":"爬虫","permalink":"http://example.com/tags/%E7%88%AC%E8%99%AB/"},{"name":"Python","slug":"Python","permalink":"http://example.com/tags/Python/"}]},{"title":"(每日LeetCode)1408. 数组中的字符串匹配","slug":"每日LeetCode/2022-8/1408 数组中的字符串匹配","date":"2022-08-06T10:43:00.000Z","updated":"2022-08-06T10:43:21.143Z","comments":true,"path":"2022/08/06/每日LeetCode/2022-8/1408 数组中的字符串匹配/","link":"","permalink":"http://example.com/2022/08/06/%E6%AF%8F%E6%97%A5LeetCode/2022-8/1408%20%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D/","excerpt":"","text":"题目：给你一个字符串数组 words ，数组中的每个字符串都可以看作是一个单词。请你按 任意 顺序返回 words 中是其他单词的子字符串的所有单词。 如果你可以删除 words[j] 最左侧和&#x2F;或最右侧的若干字符得到 word[i] ，那么字符串 words[i] 就是 words[j] 的一个子字符串。 示例： 输入：words &#x3D; [“mass”,”as”,”hero”,”superhero”]输出：[“as”,”hero”]解释：”as” 是 “mass” 的子字符串，”hero” 是 “superhero” 的子字符串。[“hero”,”as”] 也是有效的答案 思路：暴力枚举与每个字符串进行匹配 代码(cpp)：123456789101112131415class Solution &#123;public: vector&lt;string&gt; stringMatching(vector&lt;string&gt;&amp; words) &#123; vector&lt;string&gt; ans; for(int i = 0; i &lt; words.size(); i++)&#123; for(int j = 0; j &lt; words.size(); j++)&#123; if(i != j &amp;&amp; words[j].find(words[i]) != string::npos)&#123; ans.emplace_back(words[i]); break; &#125; &#125; &#125; return ans; &#125;&#125;; 复杂对分析： 时间复杂度：O(n^2 x L^2)，其中 n 是字符串数组的长度，L 是字符串数组中最长字符串的长度。使用 KMP 字符串匹配算法可以将时间复杂度优化到 O(n^2 × T)，其中 T 是字符串数组中所有字符串的平均长度。 空间复杂度：O(1)。返回值不计入空间复杂度。如果使用 KMP 字符串匹配算法，那么对应的空间复杂度为 O(T)。","categories":[{"name":"每日LeetCode","slug":"每日LeetCode","permalink":"http://example.com/categories/%E6%AF%8F%E6%97%A5LeetCode/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"},{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"(每日LeetCode)623. 在二叉树中增加一行","slug":"每日LeetCode/2022-8/623 在二叉树中增加一行","date":"2022-08-05T02:57:00.000Z","updated":"2022-08-05T03:03:21.698Z","comments":true,"path":"2022/08/05/每日LeetCode/2022-8/623 在二叉树中增加一行/","link":"","permalink":"http://example.com/2022/08/05/%E6%AF%8F%E6%97%A5LeetCode/2022-8/623%20%E5%9C%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%A2%9E%E5%8A%A0%E4%B8%80%E8%A1%8C/","excerpt":"","text":"题目：给定一个二叉树的根 root 和两个整数 val 和 depth ，在给定的深度 depth 处添加一个值为 val 的节点行。 注意，根节点 root 位于深度 1 。 加法规则如下: 给定整数 depth，对于深度为 depth - 1 的每个非空树节点 cur ，创建两个值为 val 的树节点作为 cur 的左子树根和右子树根。 cur 原来的左子树应该是新的左子树根的左子树。 cur 原来的右子树应该是新的右子树根的右子树。 如果 depth == 1 意味着 depth - 1 根本没有深度，那么创建一个树节点，值 val 作为整个原始树的新根，而原始树就是新根的左子树。 示例： 输入: root &#x3D; [4,2,6,3,1,5], val &#x3D; 1, depth &#x3D; 2输出: [4,1,1,2,null,null,6,3,1,5] 我自己写的递归很烂，不如官方的的规范、整洁！但是效率基本差不多！ 12345678910111213141516171819202122class Solution &#123;public: TreeNode* def(TreeNode* root, int&amp; val, int curDepth, int&amp; depth, int choice)&#123; if(curDepth == depth - 1) &#123; if(choice == 1) return new TreeNode(val, root, nullptr); else return new TreeNode(val, nullptr, root); &#125; if(root == nullptr) return nullptr; root-&gt;left = def(root-&gt;left, val, curDepth + 1, depth, 1); root-&gt;right = def(root-&gt;right, val, curDepth + 1, depth, 2); return root; &#125; TreeNode* addOneRow(TreeNode* root, int val, int depth) &#123; return def(root, val, 0, depth, 1); &#125;&#125;; 下面是官方的递归思路！ 思路：递归以示例中图片输出后的二叉树为例：[4,1,1,2,null,null,6,3,1,5] 如果要在深度depth为3的位置插入新元素： 第一次递归：这层元素由4 变成了元素4的左右节点1和1，深度depth减一变为2 如果深度depth为2的情况下，这层的节点的子节点就是要插入新元素的位置， 以这层左节点元素为例，元素1。创建新节点，新节点的左节点指向元素1的左节点，元素1的左节点变为新节点。这层右节点同理。到达深度为2的情况，直接返回不会到达深度为1的情况。 只有在初始化深度depth为1的情况下，说明要在根节点root处插入新元素，创建新节点，新节点的左节点为根节点root，将根节点root指向为新节点，完成插入。 并且深度为n(除了深度为1的情况)，只要递归到深度depth变为2就可以插入新元素。 代码(cpp)：12345678910111213141516171819202122class Solution &#123;public: TreeNode* addOneRow(TreeNode* root, int val, int depth) &#123; if(root == nullptr) return nullptr; //深度为1的情况，新节点的左节点指向根节点，根节点变为新节点 if(depth == 1) return new TreeNode(val, root, nullptr); if(depth == 2) &#123; //深度为2的情况 //新节点指向该节点的左节点，该节点的左节点指向新节点 root-&gt;left = new TreeNode(val, root-&gt;left, nullptr); //新节点指向该节点的右节点，该节点的右节点指向新节点 root-&gt;right = new TreeNode(val, nullptr, root-&gt;right); &#125; else &#123; //递归到该节点的左节点，深度减一 root-&gt;left = addOneRow(root-&gt;left, val, depth - 1); //递归到该节点的右节点，深度减一 root-&gt;right = addOneRow(root-&gt;right, val, depth - 1); &#125; return root; &#125;&#125;; 复杂度分析： 时间复杂度：O(n)，其中 n 为输入的树的节点数。最坏情况下，需要遍历整棵树。 空间复杂度：O(n)，递归的深度最多为 O(n)。","categories":[{"name":"每日LeetCode","slug":"每日LeetCode","permalink":"http://example.com/categories/%E6%AF%8F%E6%97%A5LeetCode/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"},{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"(每日LeetCode)1403. 非递增顺序的最小子序列","slug":"每日LeetCode/2022-8/1403 非递增顺序的最小子序列","date":"2022-08-04T04:09:00.000Z","updated":"2022-08-04T04:09:24.395Z","comments":true,"path":"2022/08/04/每日LeetCode/2022-8/1403 非递增顺序的最小子序列/","link":"","permalink":"http://example.com/2022/08/04/%E6%AF%8F%E6%97%A5LeetCode/2022-8/1403%20%E9%9D%9E%E9%80%92%E5%A2%9E%E9%A1%BA%E5%BA%8F%E7%9A%84%E6%9C%80%E5%B0%8F%E5%AD%90%E5%BA%8F%E5%88%97/","excerpt":"","text":"题目：给你一个数组 nums，请你从中抽取一个子序列，满足该子序列的元素之和 严格 大于未包含在该子序列中的各元素之和。 如果存在多个解决方案，只需返回 长度最小 的子序列。如果仍然有多个解决方案，则返回 元素之和最大 的子序列。 与子数组不同的地方在于，「数组的子序列」不强调元素在原数组中的连续性，也就是说，它可以通过从数组中分离一些（也可能不分离）元素得到。 注意，题目数据保证满足所有约束条件的解决方案是 唯一 的。同时，返回的答案应当按 非递增顺序 排列。 示例： 输入：nums &#x3D; [4,4,7,6,7]输出：[7,7,6]解释：子序列 [7,7] 的和为 14 ，不严格大于剩下的其他元素之和（14 &#x3D; 4 + 4 + 6）。因此，[7,6,7] 是满足题意的最小子序列。注意，元素按非递增顺序返回。 我自己的思路：双指针 123456789101112131415161718192021222324class Solution &#123;public: vector&lt;int&gt; minSubsequence(vector&lt;int&gt;&amp; nums) &#123; sort(nums.begin(), nums.end()); int right = nums.size() - 1; vector&lt;int&gt; ans; int left = 0; int ans_sum = 0; int temp = 0; while(left &lt;= right)&#123; ans.push_back(nums[right]); ans_sum += nums[right]; right--; while(temp &lt; ans_sum &amp;&amp; left &lt;= right)&#123; temp += nums[left]; left++; &#125; &#125; if(ans_sum &lt;= temp)&#123; ans.push_back(nums[right]); &#125; return ans; &#125;&#125;; 可以通过但是效率很低！下面是官方思路！ 思路：贪心先计算出数组中各个元素加起来的总合sum 再进行从大到小的遍历元素加起来的合cur，直到该子序列的元素之和cur大于未包含在该子序列中的各元素之和sum-cur停止。 代码(cpp)：1234567891011121314151617181920class Solution &#123;public: vector&lt;int&gt; minSubsequence(vector&lt;int&gt;&amp; nums) &#123; int sum = 0; for(auto num : nums)&#123; //计算总和 sum += num; &#125; sort(nums.begin(), nums.end()); //排序 vector&lt;int&gt; ans; int cur = 0; for(int i = nums.size() - 1; i &gt;= 0; i--)&#123; ans.emplace_back(nums[i]); //尾部插入 cur += nums[i]; //计算cur if(sum - cur &lt; cur)&#123; //如果该子序列合 大于 未在子序列中的合 break; &#125; &#125; return ans; &#125;&#125;; 复杂度分析： 时间复杂度：O(nlogn)，其中 n 为数组的长度。需要对数组进行排序，因此时间复杂度 O(nlogn)。 空间复杂度：O(logn)，其中 n 为数组的长度。排序需要的栈空间为 O(logn)。","categories":[{"name":"每日LeetCode","slug":"每日LeetCode","permalink":"http://example.com/categories/%E6%AF%8F%E6%97%A5LeetCode/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"},{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"(每日LeetCode)899. 有序队列","slug":"每日LeetCode/2022-8/899 有序队列","date":"2022-08-03T01:37:00.000Z","updated":"2022-08-03T01:37:42.753Z","comments":true,"path":"2022/08/03/每日LeetCode/2022-8/899 有序队列/","link":"","permalink":"http://example.com/2022/08/03/%E6%AF%8F%E6%97%A5LeetCode/2022-8/899%20%E6%9C%89%E5%BA%8F%E9%98%9F%E5%88%97/","excerpt":"","text":"题目：给定一个字符串 s 和一个整数 k 。你可以从 s 的前 k 个字母中选择一个，并把它加到字符串的末尾。 返回 在应用上述步骤的任意数量的移动后，字典上最小的字符串 。 示例： 输入：s &#x3D; “cba”, k &#x3D; 1输出：”acb”解释：在第一步中，我们将第一个字符（“c”）移动到最后，获得字符串 “bac”。在第二步中，我们将第一个字符（“b”）移动到最后，获得最终结果 “acb”。 思路：脑筋急转弯以s &#x3D; “cba”为例： 当k &#x3D; 1时，无论经过多少次移动，最小的字符串为”acb”，并不是”最终”最小的字符产”abc” 所以要依次遍历所有可能，找出最小的字符串 当k &gt; 1时，无论经历多少次移动，最终最小的一定是”abc” 只需对s进行排序 代码(cpp)：12345678910111213141516171819202122class Solution &#123;public: string orderlyQueue(string s, int k) &#123; if(k == 1)&#123; //k=1时 string min_s = s; //初始化最小的字符串 int size = s.size(); // 获取字符串长度 for(int i = 0; i &lt; size; i++)&#123; char temp = s[0]; //获取第一个字符 s = s.substr(1); //截取除第一个字符，剩下的字符串 s.push_back(temp); //将第一个字符，加到字符串的后面 if(min_s &gt; s)&#123; //进行比较 min_s = s; &#125; &#125; return min_s; &#125; else&#123; //k&gt;1时 sort(s.begin(), s.end()); //排序 return s; &#125; &#125;&#125;; 复杂度分析： 时间复杂度：O(n^2)，其中 n 是字符串 s 的长度。当 k &#x3D; 1 时需要遍历 n 个可能的字符串，每个字符串需要 O(n) 的时间生成和判断是否字典序最小，时间复杂度是 O(n^2)；当 k &gt; 1 时需要对字符串排序，时间复杂度是 O(nlogn)。最坏情况下时间复杂度是 O(n^2)。 空间复杂度：O(n) 或 O(logn)，其中 n 是字符串 s 的长度。空间复杂度取决于具体实现的语言。对于字符串不可变的语言，当 k &#x3D; 1 时生成每个字符串和当 k &gt; 1 时生成排序后的字符串都需要 O(n) 的空间；对于字符串可变的语言，可以省略 O(n) 的空间，只有当 k &gt; 1 时排序需要 O(logn) 的空间。","categories":[{"name":"每日LeetCode","slug":"每日LeetCode","permalink":"http://example.com/categories/%E6%AF%8F%E6%97%A5LeetCode/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"},{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"(每日LeetCode)622. 设计循环队列","slug":"每日LeetCode/2022-8/622 设计循环队列","date":"2022-08-02T04:15:00.000Z","updated":"2022-09-27T14:18:46.266Z","comments":true,"path":"2022/08/02/每日LeetCode/2022-8/622 设计循环队列/","link":"","permalink":"http://example.com/2022/08/02/%E6%AF%8F%E6%97%A5LeetCode/2022-8/622%20%E8%AE%BE%E8%AE%A1%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97/","excerpt":"","text":"题目：设计你的循环队列实现。 循环队列是一种线性数据结构，其操作表现基于 FIFO（先进先出）原则并且队尾被连接在队首之后以形成一个循环。它也被称为“环形缓冲器”。 循环队列的一个好处是我们可以利用这个队列之前用过的空间。在一个普通队列里，一旦一个队列满了，我们就不能插入下一个元素，即使在队列前面仍有空间。但是使用循环队列，我们能使用这些空间去存储新的值。 你的实现应该支持如下操作： MyCircularQueue(k)：构造器，设置队列长度为 k 。 Front()：从队首获取元素。如果队列为空，返回 -1 。 Rear()：获取队尾元素。如果队列为空，返回 -1 。 enQueue(value)：向循环队列插入一个元素。如果成功插入则返回真。 deQueue()：从循环队列中删除一个元素。如果成功删除则返回真。 isEmpty()：检查循环队列是否为空。 isFull()：检查循环队列是否已满。 示例： MyCircularQueue circularQueue &#x3D; new MyCircularQueue(3); &#x2F;&#x2F; 设置长度为 3circularQueue.enQueue(1); &#x2F;&#x2F; 返回 truecircularQueue.enQueue(2); &#x2F;&#x2F; 返回 truecircularQueue.enQueue(3); &#x2F;&#x2F; 返回 truecircularQueue.enQueue(4); &#x2F;&#x2F; 返回 false，队列已满circularQueue.Rear(); &#x2F;&#x2F; 返回 3circularQueue.isFull(); &#x2F;&#x2F; 返回 truecircularQueue.deQueue(); &#x2F;&#x2F; 返回 truecircularQueue.enQueue(4); &#x2F;&#x2F; 返回 truecircularQueue.Rear(); &#x2F;&#x2F; 返回 4 思路：数组初始化(空栈)： 以示例为例，设置长度k为3，但是初始化的实际容量capacity应该为k+1即为4 初始化头节点front以及尾节点rear为0号位置 注意：rear指向的位置不是末尾的元素，而是末尾的元素的下一位置 是否为空判断：front与rear是否再同一个位置，即front == rear front$\\Downarrow$ 0 1 2 3 空 空 空 空 $\\Uparrow$rear 如何循环？： 将rear指针所在的3号位置赋值为4后，需要将rear指针后移，但是rear+1后会导致越界 我们希望rear指针应该移动到0号位置，可以进行取余操作：(rear + 1) % capacity rear指针当前的位置为3，容量capacity为4，带入公式：(3 + 1) % 4 = 0 rear指针移动我们所想要的到达的0号位置 front$\\Downarrow$ 0 1 2 3 空 空 3 空 $\\Uparrow$rear front$\\Downarrow$ 0 1 2 3 空 空 3 4 $\\Uparrow$rear 满列的情况： 当存储的元素个数为3时，就达到满列的情况 判断是否为满列：rear指针后移，如果front与rear在同一位置，则说明满列 即(rear + 1) % capacity == front front$\\Downarrow$ 0 1 2 3 1 2 3 空 $\\Uparrow$rear 注意：也可以使用链表实现队列解决该问题！！用链表实现队列更简单 代码(cpp)：以下为数组实现： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859class MyCircularQueue &#123;private: vector&lt;int&gt; queue; // 队列 int capacity; //容量 int front; //头节点 int rear; //尾节点public: MyCircularQueue(int k) &#123; this-&gt;capacity = k + 1; this-&gt;queue = vector&lt;int&gt;(this-&gt;capacity); //初始化容量为k+1 this-&gt;front = 0; //初始化头节点 this-&gt;rear = 0; //初始化尾节点 &#125; //入列 bool enQueue(int value) &#123; //判断是否为满列 if(this-&gt;isFull()) return false; //插入队列 queue[this-&gt;rear] = value; //rear指针后移 this-&gt;rear = (this-&gt;rear + 1) % this-&gt;capacity; return true; &#125; //出列 bool deQueue() &#123; //判断是否为空 if(this-&gt;isEmpty()) return false; //front指针后移 this-&gt;front = (this-&gt;front + 1) % this-&gt;capacity; return true; &#125; int Front() &#123; //判断是否为空 if(this-&gt;isEmpty()) return -1; //返回头节点的元素 return queue[this-&gt;front]; &#125; int Rear() &#123; // 判断是否为空 if(this-&gt;isEmpty()) return -1; //rear指针为末尾元素的下一位，要回到上一位置 //如果rear=0，代入公式：(0 - 1 + 4) % 4 = 3；3为上一个位置 int temp = (this-&gt;rear - 1 + this-&gt;capacity) % this-&gt;capacity; //返回该位置的元素 return queue[temp]; &#125; bool isEmpty() &#123; //判断头节点与尾节点是否在同一位置 return this-&gt;front == this-&gt;rear; &#125; bool isFull() &#123; //判断尾节点的下一个位置是否与头节点在同一位置 return (this-&gt;rear + 1) % this-&gt;capacity == this-&gt;front; &#125;&#125;; 复杂度分析： 时间复杂度：初始化和每项操作的时间复杂度均为 O(1)。 空间复杂度：O(k)，其中 k 为给定的队列元素数目。","categories":[{"name":"每日LeetCode","slug":"每日LeetCode","permalink":"http://example.com/categories/%E6%AF%8F%E6%97%A5LeetCode/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"},{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"(每日LeetCode)1374. 生成每种字符都是奇数个的字符串","slug":"每日LeetCode/2022-8/1374 生成每种字符都是奇数个的字符串","date":"2022-08-01T03:00:00.000Z","updated":"2022-08-01T03:00:51.761Z","comments":true,"path":"2022/08/01/每日LeetCode/2022-8/1374 生成每种字符都是奇数个的字符串/","link":"","permalink":"http://example.com/2022/08/01/%E6%AF%8F%E6%97%A5LeetCode/2022-8/1374%20%E7%94%9F%E6%88%90%E6%AF%8F%E7%A7%8D%E5%AD%97%E7%AC%A6%E9%83%BD%E6%98%AF%E5%A5%87%E6%95%B0%E4%B8%AA%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2/","excerpt":"","text":"题目：给你一个整数 n，请你返回一个含 n 个字符的字符串，其中每种字符在该字符串中都恰好出现 奇数次 。 返回的字符串必须只含小写英文字母。如果存在多个满足题目要求的字符串，则返回其中任意一个即可。 示例： 输入：n &#x3D; 4输出：”pppz”解释：”pppz” 是一个满足题目要求的字符串，因为 ‘p’ 出现 3 次，且 ‘z’ 出现 1 次。当然，还有很多其他字符串也满足题目要求，比如：”ohhh” 和 “love”。 多说无益！ 代码(cpp)：1234567891011class Solution &#123;public: string generateTheString(int n) &#123; if(n%2 == 0)&#123; return string(n-1,&#x27;a&#x27;) + &#x27;b&#x27;; &#125; else&#123; return string(n, &#x27;a&#x27;); &#125; &#125;&#125;; 复杂度分析： 时间复杂度：O(n)。 空间复杂度：O(1)。这里不计入返回值需要的空间。","categories":[{"name":"每日LeetCode","slug":"每日LeetCode","permalink":"http://example.com/categories/%E6%AF%8F%E6%97%A5LeetCode/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"},{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"(每日LeetCode)1161. 最大层内元素和","slug":"每日LeetCode/2022-7/1161 最大层内元素和","date":"2022-07-31T03:29:00.000Z","updated":"2022-07-31T03:29:48.084Z","comments":true,"path":"2022/07/31/每日LeetCode/2022-7/1161 最大层内元素和/","link":"","permalink":"http://example.com/2022/07/31/%E6%AF%8F%E6%97%A5LeetCode/2022-7/1161%20%E6%9C%80%E5%A4%A7%E5%B1%82%E5%86%85%E5%85%83%E7%B4%A0%E5%92%8C/","excerpt":"","text":"题目：给你一个二叉树的根节点 root。设根节点位于二叉树的第 1 层，而根节点的子节点位于第 2 层，依此类推。 请返回层内元素之和 最大 的那几层（可能只有一层）的层号，并返回其中 最小 的那个。 示例： 输入：root &#x3D; [1,7,0,7,-8,null,null]输出：2解释：第 1 层各元素之和为 1，第 2 层各元素之和为 7 + 0 &#x3D; 7，第 3 层各元素之和为 7 + -8 &#x3D; -1，所以我们返回第 2 层的层号，它的层内元素之和最大。 思路：使用队列，层序遍历二叉树同时计算出每层的元素之和，比较每层的总和，得出最大总和所在的层数 代码(cpp)：12345678910111213141516171819202122232425262728293031323334353637class Solution &#123;public: int maxLevelSum(TreeNode* root) &#123; queue&lt;TreeNode*&gt; q; q.push(root); int max_sum = -999999; //设置最大元素之和 int max_level_sum = 1; //记录最大总和的所在的层 int level_sum = 1; //当前层数 while(!q.empty())&#123; //第一个循环，遍历层 int size = q.size(); //获取当前层的节点数 int sum = 0; //初始化该层的元素之和 while(size != 0)&#123; //第二个循环，遍历每层的节点 TreeNode* p = q.front(); //获取该节点 q.pop(); //移除在队列中的该节点 sum += p-&gt;val; //加上该节点的值，计算该层的元素之和 if(p-&gt;left != nullptr)&#123; q.push(p-&gt;left); //插入下一层的左节点 &#125; if(p-&gt;right != nullptr)&#123; q.push(p-&gt;right);//插入下一层的右节点 &#125; size--; //已遍历完gai该层节点数减一 &#125; if(max_sum &lt; sum)&#123; //如果该层的元素之和大于之前的 max_sum = sum; max_level_sum = level_sum; &#125; level_sum++; //层数加一，进入下一层 &#125; return max_level_sum; &#125;&#125;;","categories":[{"name":"每日LeetCode","slug":"每日LeetCode","permalink":"http://example.com/categories/%E6%AF%8F%E6%97%A5LeetCode/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"},{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"(每日LeetCode)1331. 数组序号转换","slug":"每日LeetCode/2022-7/1331 数组序号转换","date":"2022-07-28T01:26:00.000Z","updated":"2022-07-28T01:24:01.012Z","comments":true,"path":"2022/07/28/每日LeetCode/2022-7/1331 数组序号转换/","link":"","permalink":"http://example.com/2022/07/28/%E6%AF%8F%E6%97%A5LeetCode/2022-7/1331%20%E6%95%B0%E7%BB%84%E5%BA%8F%E5%8F%B7%E8%BD%AC%E6%8D%A2/","excerpt":"","text":"题目：给你一个整数数组 arr ，请你将数组中的每个元素替换为它们排序后的序号。 序号代表了一个元素有多大。序号编号的规则如下： 序号从 1 开始编号。一个元素越大，那么序号越大。如果两个元素相等，那么它们的序号相同。每个数字的序号都应该尽可能地小。 示例： 输入：arr &#x3D; [37,12,28,9,100,56,80,5,12]输出：[5,3,4,2,8,6,7,1,3] 思路：哈希表 首先用temp数组拷贝一份原数组arr 将temp数组进行排序 用一个哈希表保存temp数组各元素的排列序号 最后根据原数组arr各个元素的位置返回排列序号 代码(cpp)：123456789101112131415161718192021222324class Solution &#123;public: vector&lt;int&gt; arrayRankTransform(vector&lt;int&gt;&amp; arr) &#123; vector&lt;int&gt; temp(arr); //拷贝一份数组 sort(temp.begin(), temp.end()); //将temp排序 unordered_map&lt;int, int&gt; map; int count = 1; for(int i = 0; i &lt; temp.size(); i++)&#123; //如果map中已经存在，则跳过 if(!map.count(temp[i]))&#123; map[temp[i]] = count; count++; &#125; &#125; vector&lt;int&gt; ans; for(int j = 0; j &lt; arr.size(); j++)&#123; ans.emplace_back(map[arr[j]]); //插入序号 &#125; return ans; &#125;&#125;; 复杂度分析： 时间复杂度：O(n×logn)，其中 n 是输入数组 arr 的长度，排序消耗 O(n×logn) 时间。 空间复杂度：O(n)。有序数组和哈希表各消耗 O(n) 空间。","categories":[{"name":"每日LeetCode","slug":"每日LeetCode","permalink":"http://example.com/categories/%E6%AF%8F%E6%97%A5LeetCode/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"},{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"(每日LeetCode)919. 完全二叉树插入器","slug":"每日LeetCode/2022-7/919 完全二叉树插入器","date":"2022-07-25T01:51:00.000Z","updated":"2022-07-25T01:58:02.284Z","comments":true,"path":"2022/07/25/每日LeetCode/2022-7/919 完全二叉树插入器/","link":"","permalink":"http://example.com/2022/07/25/%E6%AF%8F%E6%97%A5LeetCode/2022-7/919%20%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E6%8F%92%E5%85%A5%E5%99%A8/","excerpt":"","text":"题目：完全二叉树： 是每一层（除最后一层外）都是完全填充（即，节点数达到最大）的，并且所有的节点都尽可能地集中在左侧。 设计一种算法，将一个新节点插入到一个完整的二叉树中，并在插入后保持其完整。 实现 CBTInserter 类： CBTInserter(TreeNode root) 使用头节点为 root 的给定树初始化该数据结构； CBTInserter.insert(int v) 向树中插入一个值为 Node.val &#x3D;&#x3D; val的新节点 TreeNode。使树保持完全二叉树的状态，并返回插入节点 TreeNode 的父节点的值； CBTInserter.get_root() 将返回树的头节点。 示例： 输入：[“CBTInserter”, “insert”, “insert”, “get_root”][[[1, 2]], [3], [4], []]输出：[null, 1, 2, [1, 2, 3, 4]] 解释：CBTInserter cBTInserter &#x3D; new CBTInserter([1, 2]);cBTInserter.insert(3); &#x2F;&#x2F; 返回父节点 1cBTInserter.insert(4); &#x2F;&#x2F; 返回父节点 2cBTInserter.get_root(); &#x2F;&#x2F; 返回根节点 [1, 2, 3, 4] 思路：应用队列实现树的层序遍历： 首先将二叉树的根节点进队，判断队列不为空，就输出队头的元素 判断节点如果有孩子，就将孩子进队 遍历过的节点出队 循环，直到q.empty() 代码(cpp)：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758class CBTInserter &#123;public: //存入最底层的节点方便以后插入 queue&lt;TreeNode*&gt; node; TreeNode* root; //获取底层节点 CBTInserter(TreeNode* root) &#123; this-&gt;root = root; queue&lt;TreeNode*&gt; q; //向队尾插入节点 q.push(root); while (!q.empty()) &#123; //返回队列中的第一个元素 TreeNode* n = q.front(); //删除队列第一个元素 q.pop(); if (n-&gt;left) &#123; q.push(n-&gt;left); &#125; if (n-&gt;right) &#123; q.push(n-&gt;right); &#125; if (!(n-&gt;left &amp;&amp; n-&gt;right)) &#123; //获取最底层的节点 node.push(n); &#125; &#125; &#125; int insert(int val) &#123; //创建一个新节点 TreeNode* new_node = new TreeNode(val); // 获得队列的第一个元素 TreeNode* n = node.front(); //获取该节点的值 int ret = n-&gt;val; // 如果不存在，就插入左节点 if(!(n-&gt;left))&#123; n-&gt;left = new_node; &#125; //存在，就插入到右节点 else&#123; n-&gt;right = new_node; //删除该节点，因为左右节点都已经存在 node.pop(); &#125; //将新节点插入到队列 node.push(new_node); return ret; &#125; TreeNode* get_root() &#123; return root; &#125;&#125;; 复杂度分析： 时间复杂度：初始化 CBTInserter(root) 需要的时间为 O(n)，其中 n 是给定的初始完全二叉树的节点个数。insert(v) 和 get_root() 的时间复杂度均为 O(1)。 空间复杂度：O(n+q)，其中 q 是 insert(v) 的调用次数。在调用了 q 次 insert(v) 后，完全二叉树中有 n+q 个节点，其中有一半的节点在队列中，需要 O(n+q) 的空间。","categories":[{"name":"每日LeetCode","slug":"每日LeetCode","permalink":"http://example.com/categories/%E6%AF%8F%E6%97%A5LeetCode/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"},{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"(每日LeetCode)1184. 公交站间的距离","slug":"每日LeetCode/2022-7/1184 公交站间的距离","date":"2022-07-24T00:24:00.000Z","updated":"2022-07-24T00:24:48.039Z","comments":true,"path":"2022/07/24/每日LeetCode/2022-7/1184 公交站间的距离/","link":"","permalink":"http://example.com/2022/07/24/%E6%AF%8F%E6%97%A5LeetCode/2022-7/1184%20%E5%85%AC%E4%BA%A4%E7%AB%99%E9%97%B4%E7%9A%84%E8%B7%9D%E7%A6%BB/","excerpt":"","text":"题目：环形公交路线上有 n 个站，按次序从 0 到 n - 1 进行编号。我们已知每一对相邻公交站之间的距离，distance[i] 表示编号为 i 的车站和编号为 (i + 1) % n 的车站之间的距离。 环线上的公交车都可以按顺时针和逆时针的方向行驶。 返回乘客从出发点 start 到目的地 destination 之间的最短距离。 示例： 输入：distance &#x3D; [1,2,3,4], start &#x3D; 0, destination &#x3D; 1输出：1解释：公交站 0 和 1 之间的距离顺时针是 1 ，逆时针是 9，所以最小值是 1。 思路：先计算总的距离all_sum，再计算start到destination的距离为positive_sum 返回顺时针的距离positive_sum以及逆时针的距离all_sum-positive_sum它们中的最小距离 代码(cpp)：123456789101112131415161718class Solution &#123;public: int distanceBetweenBusStops(vector&lt;int&gt;&amp; distance, int start, int destination) &#123; int all_sum = 0; for(int i =0; i &lt; distance.size(); i++)&#123; all_sum += distance[i]; &#125; if(start &gt; destination) swap(start, destination); int positive_sum = 0; for(start; start &lt; destination; start++)&#123; positive_sum += distance[start]; &#125; return min(positive_sum, all_sum - positive_sum); &#125;&#125;; 优化后：将两个循环合并在一起 123456789101112131415161718class Solution &#123;public: int distanceBetweenBusStops(vector&lt;int&gt;&amp; distance, int start, int destination) &#123; int all_sum = 0; int positive_sum = 0; if(start &gt; destination) swap(start, destination); for(int i =0; i &lt; distance.size(); i++)&#123; all_sum += distance[i]; if(i &gt;= start &amp;&amp; i &lt; destination)&#123; positive_sum += distance[i]; &#125; &#125; return min(positive_sum, all_sum - positive_sum); &#125;&#125;;","categories":[{"name":"每日LeetCode","slug":"每日LeetCode","permalink":"http://example.com/categories/%E6%AF%8F%E6%97%A5LeetCode/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"},{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"(每日LeetCode)814. 二叉树剪枝","slug":"每日LeetCode/2022-7/814 二叉树剪枝","date":"2022-07-21T00:36:00.000Z","updated":"2022-07-21T02:13:56.542Z","comments":true,"path":"2022/07/21/每日LeetCode/2022-7/814 二叉树剪枝/","link":"","permalink":"http://example.com/2022/07/21/%E6%AF%8F%E6%97%A5LeetCode/2022-7/814%20%E4%BA%8C%E5%8F%89%E6%A0%91%E5%89%AA%E6%9E%9D/","excerpt":"","text":"题目：给你二叉树的根结点 root ，此外树的每个结点的值要么是 0 ，要么是 1 。 返回移除了所有不包含 1 的子树的原二叉树。 节点 node 的子树为 node 本身加上所有 node 的后代。 示例： 输入：root &#x3D; [1,null,0,0,1]输出：[1,null,0,null,1]解释：只有红色节点满足条件“所有不包含 1 的子树”。 右图为返回的答案。 自底向上进行剪枝，如果某个节点不存在左右节点，并且该节点值为0的话就需要剪枝 代码(cpp)：123456789101112131415class Solution &#123;public: TreeNode* pruneTree(TreeNode* root) &#123; if(root == nullptr) return nullptr; root-&gt;left = pruneTree(root-&gt;left); root-&gt;right = pruneTree(root-&gt;right); if(root-&gt;left == nullptr &amp;&amp; root-&gt;right ==nullptr &amp;&amp; root-&gt;val == 0)&#123; return nullptr; &#125; return root; &#125;&#125;; 复杂度分析： 时间复杂度：O(n)，其中 n 是二叉树节点的个数。每个节点都需要遍历一次。 空间复杂度：O(n)，其中 n 是二叉树节点的个数。递归的深度最多为 O(n)。","categories":[{"name":"每日LeetCode","slug":"每日LeetCode","permalink":"http://example.com/categories/%E6%AF%8F%E6%97%A5LeetCode/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"},{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"(每日LeetCode)1252. 奇数值单元格的数目","slug":"每日LeetCode/2022-7/1252 奇数值单元格的数目","date":"2022-07-12T01:24:00.000Z","updated":"2022-07-12T01:26:30.157Z","comments":true,"path":"2022/07/12/每日LeetCode/2022-7/1252 奇数值单元格的数目/","link":"","permalink":"http://example.com/2022/07/12/%E6%AF%8F%E6%97%A5LeetCode/2022-7/1252%20%E5%A5%87%E6%95%B0%E5%80%BC%E5%8D%95%E5%85%83%E6%A0%BC%E7%9A%84%E6%95%B0%E7%9B%AE/","excerpt":"","text":"题目：给你一个 m x n 的矩阵，最开始的时候，每个单元格中的值都是 0。 另有一个二维索引数组 indices，indices[i] = [ri, ci] 指向矩阵中的某个位置，其中 ri 和 ci 分别表示指定的行和列（从 0 开始编号）。 对 indices[i] 所指向的每个位置，应同时执行下述增量操作： ri 行上的所有单元格，加 1 。ci 列上的所有单元格，加 1 。给你 m、n 和 indices 。请你在执行完所有 indices 指定的增量操作后，返回矩阵中 奇数值单元格 的数目。 示例： 输入：m &#x3D; 2, n &#x3D; 3, indices &#x3D; [[0,1],[1,1]]输出：6解释： [[0,0,0], &#x3D;&#x3D;&gt; [[1,2,1], &#x3D;&#x3D;&gt; [[1,3,1], [0,0,0]] [0,1,0]] [1,3,1]] 返回奇数的个数 代码(cpp)：1234567891011121314151617181920212223242526class Solution &#123;public: int oddCells(int m, int n, vector&lt;vector&lt;int&gt;&gt;&amp; indices) &#123; vector&lt;int&gt; dp(n); vector&lt;vector&lt;int&gt;&gt; dps(m, dp); for (int i = 0; i &lt; indices.size(); i++) &#123; for (int j = 0; j &lt; n; j++) &#123; dps[indices[i][0]][j] += 1; &#125; for (int k = 0; k &lt; m; k++) &#123; dps[k][indices[i][1]] += 1; &#125; &#125; int count = 0; for (int i = 0; i &lt; m; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; if (dps[i][j] % 2 != 0) &#123; count++; &#125; &#125; &#125; return count; &#125;&#125;; 复杂度分析： 时间复杂度：O(q×(m+n)+m×n), 其中 q 表示数组 indices 的长度，m,n 为矩阵的行数与列数。遍历数组时，每次都需要更新矩阵中一行加一列，需要的时间为 O(q×(m+n))，最后还需要遍历矩阵，需要的时间为 O(m×n)，总的时间复杂度为 O(q×(m+n)+m×n)。 空间复杂度：O(m×n)，其中 m,n 为矩阵的行数与列数。需要存储矩阵的所有元素。","categories":[{"name":"每日LeetCode","slug":"每日LeetCode","permalink":"http://example.com/categories/%E6%AF%8F%E6%97%A5LeetCode/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"},{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"(每日LeetCode)676. 实现一个魔法字典","slug":"每日LeetCode/2022-7/676 实现一个魔法字典","date":"2022-07-11T00:35:00.000Z","updated":"2022-07-11T04:04:29.012Z","comments":true,"path":"2022/07/11/每日LeetCode/2022-7/676 实现一个魔法字典/","link":"","permalink":"http://example.com/2022/07/11/%E6%AF%8F%E6%97%A5LeetCode/2022-7/676%20%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E9%AD%94%E6%B3%95%E5%AD%97%E5%85%B8/","excerpt":"","text":"题目：设计一个使用单词列表进行初始化的数据结构，单词列表中的单词 互不相同 。 如果给出一个单词，请判定能否只将这个单词中一个字母换成另一个字母，使得所形成的新单词存在于你构建的字典中。 实现 MagicDictionary 类： MagicDictionary() 初始化对象void buildDict(String[] dictionary) 使用字符串数组 dictionary 设定该数据结构，dictionary 中的字符串互不相同bool search(String searchWord) 给定一个字符串 searchWord ，判定能否只将字符串中 一个 字母换成另一个字母，使得所形成的新字符串能够与字典中的任一字符串匹配。如果可以，返回 true；否则，返回 false。 示例： 输入[“MagicDictionary”, “buildDict”, “search”, “search”, “search”, “search”][[], [[“hello”, “leetcode”]], [“hello”], [“hhllo”], [“hell”], [“leetcoded”]]输出[null, null, false, true, false, false] 解释MagicDictionary magicDictionary &#x3D; new MagicDictionary();magicDictionary.buildDict([“hello”, “leetcode”]);magicDictionary.search(“hello”); &#x2F;&#x2F; 返回 FalsemagicDictionary.search(“hhllo”); &#x2F;&#x2F; 将第二个 ‘h’ 替换为 ‘e’ 可以匹配 “hello” ，所以返回 TruemagicDictionary.search(“hell”); &#x2F;&#x2F; 返回 FalsemagicDictionary.search(“leetcoded”); &#x2F;&#x2F; 返回 False 思路：遍历词典，找到与searchWord单词长度一样的单词，再与之对比相同的位置的字母是否相同，记录不相同字母的次数，只有不相同的字母的次数为1时，才可以返回true 代码(cpp)：1234567891011121314151617181920212223242526class MagicDictionary &#123;public: vector&lt;string&gt; dic; MagicDictionary() &#123;&#125; void buildDict(vector&lt;string&gt; dictionary) &#123; this-&gt;dic= dictionary; &#125; bool search(string searchWord) &#123; int n = searchWord.size(); for(int i = 0; i &lt; dic.size(); i++)&#123; if(dic[i].size() == n)&#123; int count = 0; for(int j = 0; j &lt; n; j++)&#123; if(dic[i][j] != searchWord[j])&#123; count++; &#125; &#125; if(count == 1) return 1; &#125; &#125; return 0; &#125;&#125;; 复杂度分析： 时间复杂度：O(qnl)，其中 n 是数组 dictionary 的长度，l 是数组 dictionary 中字符串的平均长度，q 是函数 search(searchWord) 的调用次数。 空间复杂度：O(nl)，即为数组需要使用的空间。","categories":[{"name":"每日LeetCode","slug":"每日LeetCode","permalink":"http://example.com/categories/%E6%AF%8F%E6%97%A5LeetCode/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"},{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"(每日LeetCode)873. 最长的斐波那契子序列的长度","slug":"每日LeetCode/2022-7/873 最长的斐波那契子序列的长度","date":"2022-07-09T00:34:00.000Z","updated":"2022-07-09T03:38:53.250Z","comments":true,"path":"2022/07/09/每日LeetCode/2022-7/873 最长的斐波那契子序列的长度/","link":"","permalink":"http://example.com/2022/07/09/%E6%AF%8F%E6%97%A5LeetCode/2022-7/873%20%E6%9C%80%E9%95%BF%E7%9A%84%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E5%AD%90%E5%BA%8F%E5%88%97%E7%9A%84%E9%95%BF%E5%BA%A6/","excerpt":"","text":"题目：如果序列 $X_1, X_2, …, X_n$ 满足下列条件，就说它是 斐波那契式 的： n &gt;&#x3D; 3对于所有 i + 2 &lt;&#x3D; n，都有 $X_i + X_{i+1} &#x3D; X_{i+2}$给定一个严格递增的正整数数组形成序列 arr ，找到 arr 中最长的斐波那契式的子序列的长度。如果一个不存在，返回 0 。 （回想一下，子序列是从原序列 arr 中派生出来的，它从 arr 中删掉任意数量的元素（也可以不删），而不改变其余元素的顺序。例如， [3, 5, 8] 是 [3, 4, 5, 6, 7, 8] 的一个子序列） 示例： 输入: arr &#x3D; [1,3,7,11,12,14,18]输出: 3解释: 最长的斐波那契式子序列有 [1,11,12]、[3,11,14] 以及 [7,11,18] 。 思路：递归费劲尽心，最后运行超时！！ 代码(cpp)：12345678910111213141516171819202122232425262728class Solution &#123;public: int def(vector&lt;int&gt;&amp; arr, vector&lt;int&gt; dp, int pos)&#123; int ans = 0; int n = dp.size(); for(int i=pos; i &lt; arr.size(); i++)&#123; if(n &lt; 2)&#123; vector&lt;int&gt; n_dp(dp); n_dp.emplace_back(arr[i]); ans = max(def(arr, n_dp, i+1)+1, ans); &#125; else if(n &gt;= 2 &amp;&amp; dp[n-1] + dp[n-2] == arr[i])&#123; vector&lt;int&gt; n_dp(dp); n_dp.emplace_back(arr[i]); ans = max(def(arr, n_dp, i+1)+1, ans); &#125; &#125; if(ans &lt;= 2 &amp;&amp; pos &lt; 2) return 0; return ans; &#125; int lenLongestFibSubseq(vector&lt;int&gt;&amp; arr) &#123; vector&lt;int&gt; dp; return def(arr, dp, 0); &#125;&#125;; 思路：动态规划摆烂了！ arr[k]+arr[j]=arr[i] 大小：k&lt;j&lt;i 代码(cpp)：123456789101112131415161718192021222324252627282930class Solution &#123;public: int lenLongestFibSubseq(vector&lt;int&gt;&amp; arr) &#123; unordered_map&lt;int, int&gt; indices; int n = arr.size(); for (int i = 0; i &lt; n; i++) &#123; indices[arr[i]] = i; &#125; //创建全是0的n*n二维数组 vector&lt;vector&lt;int&gt;&gt; dp(n, vector&lt;int&gt;(n)); int ans = 0; for (int i = 0; i &lt; n; i++) &#123; for (int j = i - 1; j &gt;= 0 &amp;&amp; arr[j] * 2 &gt; arr[i]; j--) &#123; int k = -1; //如果indices中存在arr[i]-arr[j]这个数 if (indices.count(arr[i] - arr[j])) &#123; //获得获得此数 k = indices[arr[i] - arr[j]]; &#125; //如果k不等于-1 if (k &gt;= 0) &#123; dp[j][i] = max(dp[k][j] + 1, 3); &#125; //获得到最大的序列长度 ans = max(ans, dp[j][i]); &#125; &#125; return ans; &#125;&#125;; 复杂度分析： 时间复杂度：O(n^2)，其中 n 是数组 arr 的长度。动态规划的状态数是 O(n^2)，每个状态的计算时间都是 O(1) 空间复杂度：O(n^2)，其中 n 是数组 arr 的长度。需要创建二维数组 dp，空间是 O(n^2)","categories":[{"name":"每日LeetCode","slug":"每日LeetCode","permalink":"http://example.com/categories/%E6%AF%8F%E6%97%A5LeetCode/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"},{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"(每日LeetCode)1846. 减小和重新排列数组后的最大元素","slug":"每日LeetCode/2022-7/1846 减小和重新排列数组后的最大元素","date":"2022-07-08T00:34:00.000Z","updated":"2022-07-08T00:34:32.816Z","comments":true,"path":"2022/07/08/每日LeetCode/2022-7/1846 减小和重新排列数组后的最大元素/","link":"","permalink":"http://example.com/2022/07/08/%E6%AF%8F%E6%97%A5LeetCode/2022-7/1846%20%E5%87%8F%E5%B0%8F%E5%92%8C%E9%87%8D%E6%96%B0%E6%8E%92%E5%88%97%E6%95%B0%E7%BB%84%E5%90%8E%E7%9A%84%E6%9C%80%E5%A4%A7%E5%85%83%E7%B4%A0/","excerpt":"","text":"题目：给你一个正整数数组 arr 。请你对 arr 执行一些操作（也可以不进行任何操作），使得数组满足以下条件： arr 中 第一个 元素必须为 1 。任意相邻两个元素的差的绝对值 小于等于 1 ，也就是说，对于任意的 1 &lt;= i &lt; arr.length （数组下标从 0 开始），都满足 abs(arr[i] - arr[i - 1]) &lt;= 1 。abs(x) 为 x 的绝对值。你可以执行以下 2 种操作任意次： 减小 arr 中任意元素的值，使其变为一个 更小的正整数 。重新排列 arr 中的元素，你可以以任意顺序重新排列。请你返回执行以上操作后，在满足前文所述的条件下，arr 中可能的 最大值 。 示例： 输入：arr &#x3D; [100,1,1000]输出：3解释：一个可行的方案如下： 重新排列 arr 得到 [1,100,1000] 。 将第二个元素减小为 2 。 将第三个元素减小为 3 。现在 arr &#x3D; [1,2,3] ，满足所有条件。arr 中最大元素为 3 。 代码(cpp)：1234567891011121314151617181920212223class Solution &#123;public: int maximumElementAfterDecrementingAndRearranging(vector&lt;int&gt;&amp; arr) &#123; //将arr数组排序 sort(arr.begin(), arr.end()); //如果第一个元素不为1，则设置为1 if(arr[0] != 1) arr[0] = 1; 将最大数设置为数组第一个元素 int max = arr[0]; for(int i = 1; i &lt; arr.size(); i++)&#123; //当前的元素减去前面的元素，它们的绝对值肯定是大于0的 int temp = arr[i] - arr[i-1]; //如果绝对值大于1，则设置当前的元素为前面的元素+1 if(temp &gt; 1) arr[i] = arr[i-1]+1; //如果当前元素大于max的元素，将当前元素设置为最大数 if(arr[i] &gt; max) max = arr[i]; &#125; //返回最大数 return max; &#125; &#125;; 复杂度分析： 时间复杂度：O(nlogn)，其中 n 是数组 arr 的长度。时间复杂度即排序的复杂度。 空间复杂度：O(logn)。空间复杂度不考虑输入，因此空间复杂度主要取决于排序时产生的 O(logn) 的栈空间。","categories":[{"name":"每日LeetCode","slug":"每日LeetCode","permalink":"http://example.com/categories/%E6%AF%8F%E6%97%A5LeetCode/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"},{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"(每日LeetCode)593. 有效的正方形","slug":"每日LeetCode/2022-7/593 有效的正方形","date":"2022-07-08T00:34:00.000Z","updated":"2022-07-29T03:25:10.784Z","comments":true,"path":"2022/07/08/每日LeetCode/2022-7/593 有效的正方形/","link":"","permalink":"http://example.com/2022/07/08/%E6%AF%8F%E6%97%A5LeetCode/2022-7/593%20%E6%9C%89%E6%95%88%E7%9A%84%E6%AD%A3%E6%96%B9%E5%BD%A2/","excerpt":"","text":"题目：给定2D空间中四个点的坐标 p1, p2, p3 和 p4，如果这四个点构成一个正方形，则返回 true 。 点的坐标 pi 表示为 [xi, yi] 。输入 不是 按任何顺序给出的。 一个 有效的正方形 有四条等边和四个等角(90度角)。 示例： 输入：p1 &#x3D; [1,0], p2 &#x3D; [-1,0], p3 &#x3D; [0,1], p4 &#x3D; [0,-1]输出：true 思路：自己想出的一种很无脑的思路！ 先做一个判断，某一行或某一列是否存在三个以上的点，存在则不可能是正方形 选取其中一个最小的点，计算与其余点之间的距离。如果是正方形的话，一定有两个相等的边长，和一个较长的对角线，并且满足勾股定理。 代码(cpp)：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061class Solution &#123;public: bool judge(vector&lt;int&gt;&amp; p1, vector&lt;int&gt;&amp; p2, vector&lt;int&gt;&amp; p3, vector&lt;int&gt;&amp; p4)&#123; int count = 0; if(p1[0] == p2[0]) count++; if(p1[0] == p3[0]) count++; if(p1[0] == p4[0]) count++; //判断某行，是否存在三个点 if(count &gt;= 2) return false; count = 0; if(p1[1] == p2[1]) count++; if(p1[1] == p3[1]) count++; if(p1[1] == p4[1]) count++; //判断某列，是否存在三个点 if(count &gt;= 2) return false; return true; &#125; bool validSquare(vector&lt;int&gt;&amp; p1, vector&lt;int&gt;&amp; p2, vector&lt;int&gt;&amp; p3, vector&lt;int&gt;&amp; p4) &#123; //判断是否存在有三个点在一条线上 if(!is_duo(p1,p2,p3,p4)) return false; int n1 = p1[0] + p1[1]; int n2 = p2[0] + p2[1]; int n3 = p3[0] + p3[1]; int n4 = p4[0] + p4[1]; //选取一个最小的点作为计算与其余点之间的距离 int min_num = min(n1, n2); min_num = min(n3, min_num); min_num = min(n4, min_num); //与p1点交换，使p1点变为最小点 if(min_num == n2) p1.swap(p2); if(min_num == n3) p1.swap(p3); if(min_num == n4) p1.swap(p4); vector&lt;int&gt; nums; //计算p1点到其余三个点的距离，未取根号因为会产生小数 int num1 = pow(p1[0]-p2[0], 2) + pow(p1[1]-p2[1], 2); nums.push_back(num1); int num2 = pow(p1[0]-p3[0], 2) + pow(p1[1]-p3[1], 2); nums.push_back(num2); int num3 = pow(p1[0]-p4[0], 2) + pow(p1[1]-p4[1], 2); nums.push_back(num3); sort(nums.begin(), nums.end()); //排序，对角线大于边长 //如果存在对角线为0 if(nums[2] == 0) return false; //如果两条边长不相等 if(nums[0] != nums[1]) return false; //勾股定理，判断是否为直角 if(nums[0] + nums[1] != nums[2]) return false; return true; &#125;&#125;;","categories":[{"name":"每日LeetCode","slug":"每日LeetCode","permalink":"http://example.com/categories/%E6%AF%8F%E6%97%A5LeetCode/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"},{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"(每日LeetCode)729. 我的日程安排表 I","slug":"每日LeetCode/2022-7/729 我的日程安排表 I","date":"2022-07-05T04:50:00.000Z","updated":"2022-07-08T00:35:39.494Z","comments":true,"path":"2022/07/05/每日LeetCode/2022-7/729 我的日程安排表 I/","link":"","permalink":"http://example.com/2022/07/05/%E6%AF%8F%E6%97%A5LeetCode/2022-7/729%20%E6%88%91%E7%9A%84%E6%97%A5%E7%A8%8B%E5%AE%89%E6%8E%92%E8%A1%A8%20I/","excerpt":"","text":"题目：实现一个 MyCalendar 类来存放你的日程安排。如果要添加的日程安排不会造成 重复预订 ，则可以存储这个新的日程安排。 当两个日程安排有一些时间上的交叉时（例如两个日程安排都在同一时间内），就会产生 重复预订 。 日程可以用一对整数 start 和 end 表示，这里的时间是半开区间，即 [start, end), 实数 x 的范围为， start &lt;= x &lt; end 。 实现 MyCalendar 类： MyCalendar() 初始化日历对象。boolean book(int start, int end) 如果可以将日程安排成功添加到日历中而不会导致重复预订，返回 true。否则，返回 false 并且不要将该日程安排添加到日历中。 示例： 输入：[“MyCalendar”, “book”, “book”, “book”][[], [10, 20], [15, 25], [20, 30]]输出：[null, true, false, true] 思路：二分查找设已经插入了一些日程： $[[start_1,end_1),[start_2,end_2),[start_3,end_3)]$ 日程之间不交叉并且一定是有这样的排序： $start_1 &lt; end_1 \\leq start_2 &lt; end_2 \\leq start_3 &lt; end_3$ 如果要插入[start, end) 一定是在$end_i \\leq start&lt;end&lt; start_{i+1}$ 利用二分查找，找到恰比end大的元素：$start_{i+1}$ 再将$start_{i+1}$前面的元素$end_i$与start比较，看是否交叉。 代码(cpp)：123456789101112131415161718class MyCalendar &#123;public: //set默认的比较规则先按照first比较，如果first相同，再按照second比较 set&lt;pair&lt;int, int&gt;&gt; calendar; bool book(int start, int end) &#123; //获取比end恰好大的元素的迭代器，没有则返回迭代器end() //如果calendar没有元素，则返回迭代器begin() auto temp = calendar.lower_bound(&#123;end, 0&#125;); //如果temp为begin()说明没有元素直接插入 //如果不为begin()则与temp前面的元素的右区间比较，如果小于等于start说明没有交叉，插入 if(temp == calendar.begin() || (--temp)-&gt;second &lt;= start)&#123; calendar.insert(&#123;start, end&#125;); return true; &#125; return false; &#125;&#125;; 复杂度分析： 时间复杂度：O(nlogn), 其中 n 表示日程安排的数量。由于每次在进行预订时，都需要进行二分查找，需要的时间为 O(logn)。 空间复杂度：O(n)，其中 n 表示日程安排的数量。需要保存所有已经预订的行程。","categories":[{"name":"每日LeetCode","slug":"每日LeetCode","permalink":"http://example.com/categories/%E6%AF%8F%E6%97%A5LeetCode/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"},{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"set容器用法","slug":"C++/set容器","date":"2022-07-04T16:00:00.000Z","updated":"2022-08-15T01:16:14.261Z","comments":true,"path":"2022/07/05/C++/set容器/","link":"","permalink":"http://example.com/2022/07/05/C++/set%E5%AE%B9%E5%99%A8/","excerpt":"","text":"set容器：所有元素都会在插入时自动排序，底层结构采用二叉树实现。 set和multiset区别： set不可以插入重复数据，而multiset可以 set插入数据的同时会返回插入结果，表示插入是否成功 multiset不会检测数据，因此可以插入重复数据 set容器的使用： 头文件： 12#include&lt;set&gt; using namespace std; 构造函数： 构造函数 解释 set() 默认构造函数 set(const set &amp;st) 拷贝构造函数 成员函数： 成员函数 解释 void insert(T key) 插入key void emplace(T key) 插入key，比insert()效率高 erase() 删除 void clear() 清空 bool find(T key) 查找 int count(T key) 统计 int size() 获取大小 bool empty() 是否为空 void swap(set &amp;st) 交换 iterator lower_bound(T key) 如果set容器中没有元素，则返回迭代器begin()；如果set容器中存在元素，则返回恰好比key大的元素的迭代器，不存在则返回迭代器end() 自定义数据类型排序 set&lt;pair&lt;int,int&gt;&gt; set默认的比较规则先按照first比较，如果first相同，再按照second 比较。","categories":[{"name":"C++","slug":"C","permalink":"http://example.com/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"},{"name":"容器","slug":"容器","permalink":"http://example.com/tags/%E5%AE%B9%E5%99%A8/"},{"name":"STL","slug":"STL","permalink":"http://example.com/tags/STL/"}]},{"title":"(每日LeetCode)1200. 最小绝对差","slug":"每日LeetCode/2022-7/1200 最小绝对差","date":"2022-07-03T23:54:00.000Z","updated":"2022-07-08T00:36:23.299Z","comments":true,"path":"2022/07/04/每日LeetCode/2022-7/1200 最小绝对差/","link":"","permalink":"http://example.com/2022/07/04/%E6%AF%8F%E6%97%A5LeetCode/2022-7/1200%20%E6%9C%80%E5%B0%8F%E7%BB%9D%E5%AF%B9%E5%B7%AE/","excerpt":"","text":"题目：给你个整数数组 arr，其中每个元素都 不相同。 请你找到所有具有最小绝对差的元素对，并且按升序的顺序返回。 示例：示例1： 输入：arr &#x3D; [4,2,1,3]输出：[[1,2],[2,3],[3,4]] 示例2： 输入：arr &#x3D; [1,3,6,10,15]输出：[[1,3]] 思路：先将arr数组排序 再遍历arr数组，如果找到有比min更小的差值，将min改为该差值，将dp数组之前记录的数据清空(因为之前记录的都是差值大的)，重新插入差值更小的数据。 代码(cpp)：123456789101112131415161718192021222324class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; minimumAbsDifference(vector&lt;int&gt;&amp; arr) &#123; //将arr数组排序 sort(arr.begin(),arr.end()); int min = INT_MAX; vector&lt;vector&lt;int&gt;&gt; dp; for(int i = 1; i &lt; arr.size(); i++)&#123; //当前的差值 int temp = arr[i]-arr[i-1]; if(temp &lt; min)&#123; min = temp; //将dp数组清空 dp.clear(); //重新插入新的差值小的数据 dp.push_back(&#123;arr[i-1],arr[i]&#125;); &#125; else if(temp == min)&#123; dp.push_back(&#123;arr[i-1],arr[i]&#125;); &#125; &#125; return dp; &#125;&#125;; 复杂度分析： 时间复杂度：O(nlogn)，其中 n 是数组 arr 的长度。排序需要的时间为 O(nlogn)，遍历需要的是时间为 O(n)，因此总时间复杂度为 O(nlogn)。 空间复杂度：O(logn)，即为排序需要使用的栈空间。这里不计入返回值需要使用的空间。","categories":[{"name":"每日LeetCode","slug":"每日LeetCode","permalink":"http://example.com/categories/%E6%AF%8F%E6%97%A5LeetCode/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"},{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"(每日LeetCode)556. 下一个更大元素 III","slug":"每日LeetCode/2022-7/556 下一个更大元素 III","date":"2022-07-03T04:00:00.000Z","updated":"2022-07-08T00:35:35.528Z","comments":true,"path":"2022/07/03/每日LeetCode/2022-7/556 下一个更大元素 III/","link":"","permalink":"http://example.com/2022/07/03/%E6%AF%8F%E6%97%A5LeetCode/2022-7/556%20%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%9B%B4%E5%A4%A7%E5%85%83%E7%B4%A0%20III/","excerpt":"","text":"题目：给你一个正整数 n ，请你找出符合条件的最小整数，其由重新排列 n 中存在的每位数字组成，并且其值大于 n 。如果不存在这样的正整数，则返回 -1 。 注意 ，返回的整数应当是一个 32 位整数 ，如果存在满足题意的答案，但不是 32 位整数 ，同样返回 -1。 示例：示例 1： 输入：n &#x3D; 12324321输出：12331224 示例 2： 输入：n &#x3D; 21输出：-1 思路：以n = 12324321为例 ①.pos1指针从后往前遍历，找到第pos1位置的数比后面的数小的位置，pos1记录位置 1 2 3 2 4 3 2 1 $\\leftarrow\\Uparrow$pos1 2与1比较，2大，pos1向左移 循环直到： 1 2 3 2 4 3 2 1 $\\leftarrow\\Uparrow$pos1 2与4比较，2小，记录pos1的位置 ②.再定义pos2指针，从后往前遍历，找到比pos1位置后面的数中，有比pos1位置的数大的数，用pos2记录位置 1 2 3 2 4 3 2 1 $\\Uparrow$pos1 $\\leftarrow\\Uparrow$pos2 pos1大于pos2，pos2指针左移 循环直到： 1 2 3 2 4 3 2 1 $\\Uparrow$pos1 $\\leftarrow\\Uparrow$pos2 pos1小于pos2，记录指针pos2位置 ③.交换pos1和pos2的位置 1 2 3 3 4 2 2 1 ④.将pos1位置后面的数进行反转 1 2 3 3 1 2 2 4 结果：12331224 代码(cpp)：12345678910111213141516171819202122232425262728class Solution &#123;public: int nextGreaterElement(int n) &#123; //将n转换成字符串 string num = to_string(n); int pos1 = num.size()-2; //从后往前遍历，找到前面的数小于后面的数，前面数的位置 while(pos1 &gt;= 0 &amp;&amp; num[pos1] &gt;= num[pos1+1])&#123; pos1--; &#125; //遍历到字符串第0个位置，还没有小于的数，则不存在 if(pos1 &lt; 0) return -1; int pos2 = num.size()-1; //从后往前遍历，找到有比pos1位置的数小的数，返回pos2位置 while(pos2 &gt; pos1 &amp;&amp; num[pos1] &gt;= num[pos2])&#123; pos2--; &#125; //交换两个位置的数 swap(num[pos1],num[pos2]); //将pos1后面的字符串反转 reverse(num.begin() + pos1 + 1, num.end()); //防止溢出，先将temp转换成long型 long temp = stol(num); //如果超出int的范围，返回-1 if(temp &gt; INT_MAX) return -1; return temp; &#125;&#125;; 复杂度分析： 时间复杂度：O(logn)。 空间复杂度：O(logn)。","categories":[{"name":"每日LeetCode","slug":"每日LeetCode","permalink":"http://example.com/categories/%E6%AF%8F%E6%97%A5LeetCode/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"},{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"(每日LeetCode)871. 最低加油次数","slug":"每日LeetCode/2022-7/871 最低加油次数","date":"2022-07-02T07:36:00.000Z","updated":"2022-07-08T00:35:45.486Z","comments":true,"path":"2022/07/02/每日LeetCode/2022-7/871 最低加油次数/","link":"","permalink":"http://example.com/2022/07/02/%E6%AF%8F%E6%97%A5LeetCode/2022-7/871%20%E6%9C%80%E4%BD%8E%E5%8A%A0%E6%B2%B9%E6%AC%A1%E6%95%B0/","excerpt":"","text":"题目：汽车从起点出发驶向目的地，该目的地位于出发位置东面 target 英里处。 沿途有加油站，每个 station[i] 代表一个加油站，它位于出发位置东面 station[i][0] 英里处，并且有 station[i][1]升汽油。 假设汽车油箱的容量是无限的，其中最初有startFuel升燃料。它每行驶 1 英里就会用掉 1 升汽油。 当汽车到达加油站时，它可能停下来加油，将所有汽油从加油站转移到汽车中。 为了到达目的地，汽车所必要的最低加油次数是多少？如果无法到达目的地，则返回 -1 。 注意：如果汽车到达加油站时剩余燃料为 0，它仍然可以在那里加油。如果汽车到达目的地时剩余燃料为 0，仍然认为它已经到达目的地。 示例：示例1： 输入：target &#x3D; 100, startFuel &#x3D; 1, stations &#x3D; [[10,100]]输出：-1解释：我们无法抵达目的地，甚至无法到达第一个加油站。 示例2： 输入：target &#x3D; 100, startFuel &#x3D; 10, stations &#x3D; [[10,60],[20,30],[30,30],[60,40]]输出：2解释：我们出发时有 10 升燃料。我们开车来到距起点 10 英里处的加油站，消耗 10 升燃料。将汽油从 0 升加到 60 升。然后，我们从 10 英里处的加油站开到 60 英里处的加油站（消耗 50 升燃料），并将汽油从 10 升加到 50 升。然后我们开车抵达目的地。我们沿途在1两个加油站停靠，所以返回 2 。 思路： 一、回溯法代码(cpp)：123456789101112131415161718192021222324252627282930class Solution &#123;public: int def(vector&lt;vector&lt;int&gt;&gt;&amp; stations,int cur_station, int begin, int&amp; end, int oil)&#123; //到达目的地 if(oil+begin &gt;= end) return 0; //油量不够到达目的地 if(cur_station+1 == stations.size() &amp;&amp; oil+begin &lt; end)&#123; return -1; &#125; //油量不够到达下一个加油站 if(cur_station+1 &lt; stations.size() &amp;&amp; oil+begin &lt; stations[cur_station+1][0])&#123; return -1; &#125; int ans = INT_MAX; for(int i = cur_station+1; i &lt; stations.size(); i++)&#123; if(stations[i][0] &lt;= begin+oil)&#123; int temp = def(stations, i, stations[i][0] ,end ,oil+begin-stations[i][0]+stations[i][1]); if(temp != -1 &amp;&amp; ans &gt; temp+1) ans = temp+1; &#125; &#125; if(ans == INT_MAX) ans = -1; return ans; &#125; int minRefuelStops(int target, int startFuel, vector&lt;vector&lt;int&gt;&gt;&amp; stations) &#123; //出发地没有加油站，第一个加油站编号为0，所以初始化为-1 return def(stations, -1, 0, target, startFuel); &#125;&#125;; 运行超时 二、贪心思路：如果不需要加油就往前走，当不够到达下一个加油站或目的地，就从之前走到过的加油站之中选择汽油量最多的加油站进行补充汽油。 以此往复，到达目的地。 如果所有加油站的汽油都被加完，并且没到达目的地，则不可能到达。 代码(cpp)：1234567891011121314151617181920212223242526272829303132class Solution &#123;public: int minRefuelStops(int target, int startFuel, vector&lt;vector&lt;int&gt;&gt;&amp; stations) &#123; priority_queue&lt;int&gt; pq; int count = 0; //初始化加油次数 int begin = 0; //初始化路程 int cur_fuel = startFuel;//初始化车的汽油量 int cur_distance; //表示当前的路程 for (int i = 0; i &lt;= stations.size(); i++) &#123; if(i &lt; stations.size()) cur_distance = stations[i][0]; else cur_distance = target; //(cur_distance - begin)：表示第i-1个加油站到第i个加油站之间的路程，cur_fuel为到第i个加油站时剩余的油量 cur_fuel -= cur_distance - begin; //如果油量为负数，说明需要从第i个加油站，之前的加油站之中选择加油量最多的加油站，进行补充汽油 while (cur_fuel &lt; 0 &amp;&amp; !pq.empty()) &#123; cur_fuel += pq.top();//选择汽油量最多的加油站补充 pq.pop(); count++;//加油次数加1 &#125; //都已经把之前的加油站的汽油都补充了，还是负数说明无法到达下一个加油站或目的地 if (cur_fuel &lt; 0) &#123; return -1; &#125; if (i &lt; stations.size()) &#123; //将第i个加油站的汽油量记录，现在不需要加油，等以后缺油再加 pq.emplace(stations[i][1]); begin = cur_distance;//更新路程 &#125; &#125; return count; &#125;&#125;; 复杂度分析： 时间复杂度：O(nlogn)，其中 n 是数组 stations 的长度。需要遍历数组 stations 一次，每个加油站的汽油量最多添加到优先队列和从优先队列中移除各一次，每次优先队列的操作需要 O(logn) 的时间，因此时间复杂度是 O(nlogn)。 空间复杂度：O(n)，其中 n 是数组 stations 的长度。优先队列需要 O(n) 的空间。","categories":[{"name":"每日LeetCode","slug":"每日LeetCode","permalink":"http://example.com/categories/%E6%AF%8F%E6%97%A5LeetCode/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"},{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"vector容器用法","slug":"C++/vecter容器","date":"2022-06-30T09:00:00.000Z","updated":"2022-07-05T03:52:02.168Z","comments":true,"path":"2022/06/30/C++/vecter容器/","link":"","permalink":"http://example.com/2022/06/30/C++/vecter%E5%AE%B9%E5%99%A8/","excerpt":"","text":"vector是什么？vector是一个能够存放任意类型的动态数组。 vector实现动态增长的原理：vector的原理就是动态数组。当插入新元素的时候，如果空间不足，那么vector会重新申请更大的一块空间，将原空间数据拷贝到新空间，释放旧空间数据，再把新元素插入新申请空间。 需要导入头文件： 12#include&lt;vector&gt;using namespace std; 构造函数： 构造函数 解释 vector() 创建一个空的vector vector(int size) 创建一个vector,元素个数为size，且值均为0(默认为0) vector(int size, T value) 创建一个vector，元素个数为size,且值均为value vector(const vector&amp; v) 另一个vector容器拷贝到这个vector中 vector(iterator begin(), iterator end()) 另一个[begin,end)区间内的数组元素的复制这个vector中 成员函数： 插入函数 解释 void push_back(const T&amp; x) 容器尾部插入一个元素X void emplace_back(const T&amp; x) 容器尾部插入一个元素X，比push_back()效率高 iterator insert(iterator it,const T&amp; x) 容器中迭代器指向元素的前面插入一个元素x iterator insert(iterator it,int n,const T&amp; x) 容器中迭代器指向元素的前面插入n个相同的元素x iterator insert(iterator it,const_iterator first,const_iterator last) 向量中迭代器指向元素的前面插入另一个相同类型的vector容器的[first,last)间的数据 删除函数 解释 iterator erase(iterator it) 删除容器中迭代器指向的元素 iterator erase(iterator first,iterator last) 删除容器中[first,last)中的元素 void pop_back() 删除容器中最后一个元素 void clear() 清空容器中所有元素 遍历函数 解释 T at(int pos) 返回pos位置的元素(第一个位置为0) T front() 返回首元素 T back() 返回尾元素 iterator begin() 返回vector容器中指向的第一个元素的迭代器 iterator end() 返回vector容器中指向最后一个元素的下一个位置的迭代器 reverse_iterator rbegin() 反向迭代器，指向容器中最后一个元素 reverse_iterator rend() 反向迭代器，指向容器第一个元素前面的位置 大小函数 解释 int size() 返回vector容器中元素的个数 int capacity() 返回当前vector容器所能容纳的最大容量 int max_size() 返回vector容器的最大可允许的容量 void resize(int size) 更改vector容器的元素的个数为size void reserve(int capacity) 更改vector容器的容量为capacity 赋值函数 解释 vector&amp; operator&#x3D; 将右边vector容器的元素拷贝到左边vector容器中 void assign(int n,const T&amp; x) 设置容器中前n个元素的值为x void assign(const_iterator first,const_iterator last) 将另一个vector容器中[first,last)中元素设置成当前vector容器的元素 其他函数 解释 bool empty() 判断向量是否为空，若为空，则返回真 void swap(vector&amp; v) 将两个同类型vector容器的元素互换 vector的遍历：123for(int i = 0; i &lt; v.size(); i++)&#123; cout &lt;&lt; v[i] &lt;&lt; endl;&#125; 123for (int i = 0; i &lt; v.size(); i++)&#123; cout &lt;&lt; v1.at(i) &lt;&lt; endl;&#125; 123for (vector&lt;int&gt;::iterator it = v.begin(); it != v.end(); it++)&#123; cout &lt;&lt; *it &lt;&lt; endl;&#125; 123for (auto it = v.begin(); it != v.end(); it++)&#123; cout &lt;&lt; *it &lt;&lt; endl;&#125;","categories":[{"name":"C++","slug":"C","permalink":"http://example.com/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"},{"name":"容器","slug":"容器","permalink":"http://example.com/tags/%E5%AE%B9%E5%99%A8/"},{"name":"STL","slug":"STL","permalink":"http://example.com/tags/STL/"}]},{"title":"(每日LeetCode)1175. 质数排列","slug":"每日LeetCode/2022-6/1175 质数排列","date":"2022-06-30T03:09:00.000Z","updated":"2022-07-08T00:35:49.057Z","comments":true,"path":"2022/06/30/每日LeetCode/2022-6/1175 质数排列/","link":"","permalink":"http://example.com/2022/06/30/%E6%AF%8F%E6%97%A5LeetCode/2022-6/1175%20%E8%B4%A8%E6%95%B0%E6%8E%92%E5%88%97/","excerpt":"","text":"题目：请你帮忙给从 1 到 n 的数设计排列方案，使得所有的「质数」都应该被放在「质数索引」（索引从 1 开始）上；你需要返回可能的方案总数。由于答案可能会很大，所以请你返回答案 模 mod $10^9$ + 7 之后的结果即可。 示例： 输入：n &#x3D; 5输出：12 解释： 先看质数定义：一个大于1的自然数，除了1和它自身外，不能被其他自然数整除的数叫做质数。(1不是质数) 用红色标记质数： 1 2 3 4 5 题目的意思是将质数和非质数各分一组，进行排序一共有多少种可能： m个数排列m个位置，全排列公式：$A^m_m&#x3D;m!$ $A^3_3$为质数的所有排列次数 $A^2_2$为非质数的所有排列次数 并且每有一个质数的排列组合就有$A^2_2$次非质数的排列： 总数：$A^3_3 \\times A^2_2&#x3D;3! \\times 2!&#x3D;12$ 思路：遍历数组判断是否为质数，记录质数的个数p，非质数个数为n-p 运用公式求出总数：$A^p_p \\times A^{n-p}_{n-p}&#x3D;p! \\times (n-p)!$ 代码(cpp)：123456789101112131415161718192021222324252627282930313233343536373839class Solution &#123;public: int mod = pow(10,9)+7; //判断是否为质数 bool is_prime(int n)&#123; //从2开始 for(int i = 2; i*i &lt;= n;i++)&#123; //模运算为0，不是质数 if(n%i == 0)&#123; return false; &#125; &#125; return true; &#125; //n!运算 Long类型防止溢出 long factorial(int n)&#123; long sum = 1; for(int i = 2; i &lt;= n; i++)&#123; sum *=i; sum = sum%mod; &#125; return sum; &#125; int numPrimeArrangements(int n) &#123; int prime_num = 0; //从2开始，1不是质数 for(int i = 2; i &lt;= n; i++)&#123; if(is_prime(i))&#123; prime_num++; &#125; &#125; //n!*(n-p)! long result = (factorial(prime_num)*factorial(n-prime_num))%mod; return (int)result; &#125;&#125;; 复杂度分析： 时间复杂度：O($n^{3&#x2F;2}$)。求 n 个数中质数个数的时间复杂度为 O($n^{3&#x2F;2}$)，阶乘的时间复杂度为 O(n)，总的时间复杂度为 O($n^{3&#x2F;2}$)。 空间复杂度：O(1)O(1)，只使用了常数空间。","categories":[{"name":"每日LeetCode","slug":"每日LeetCode","permalink":"http://example.com/categories/%E6%AF%8F%E6%97%A5LeetCode/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"},{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"(每日LeetCode)535. TinyURL的加密与解密","slug":"每日LeetCode/2022-6/535 TinyURL的加密与解密","date":"2022-06-28T23:41:00.000Z","updated":"2022-07-02T07:51:52.081Z","comments":true,"path":"2022/06/29/每日LeetCode/2022-6/535 TinyURL的加密与解密/","link":"","permalink":"http://example.com/2022/06/29/%E6%AF%8F%E6%97%A5LeetCode/2022-6/535%20TinyURL%E7%9A%84%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%A7%A3%E5%AF%86/","excerpt":"","text":"题目：TinyURL 是一种 URL 简化服务， 比如：当你输入一个 URL https://leetcode.com/problems/design-tinyurl 时，它将返回一个简化的URL http://tinyurl.com/4e9iAk 。请你设计一个类来加密与解密 TinyURL 。 加密和解密算法如何设计和运作是没有限制的，你只需要保证一个 URL 可以被加密成一个 TinyURL ，并且这个 TinyURL 可以用解密方法恢复成原本的 URL 。 实现 Solution 类： Solution() 初始化 TinyURL 系统对象。String encode(String longUrl) 返回 longUrl 对应的 TinyURL 。String decode(String shortUrl) 返回 shortUrl 原本的 URL 。题目数据保证给定的 shortUrl 是由同一个系统对象加密的。 示例： 输入：url &#x3D; “https://leetcode.com/problems/design-tinyurl“输出：”https://leetcode.com/problems/design-tinyurl“ 解释：Solution obj &#x3D; new Solution();string tiny &#x3D; obj.encode(url); &#x2F;&#x2F; 返回加密后得到的 TinyURL 。string ans &#x3D; obj.decode(tiny); &#x2F;&#x2F; 返回解密后得到的原本的 URL 。 思路：使用自增id作为longUrl的键，存入unordered_map容器中 根据id来获取对应的longUrl 代码(cpp)：1234567891011121314151617181920212223class Solution &#123;private: unordered_map&lt;int, string&gt; map; int id;public: Solution()&#123; id = 0; //初始化id &#125; string encode(string longUrl) &#123; id++; map[id] = longUrl; //http://tinyurl.com/1 return &quot;http://tinyurl.com/&quot;+to_string(id); &#125; string decode(string shortUrl) &#123; //substr(int pos)：获取pos位置起的所有字符串 //stoi(string str)：将string类型的字符串转换成int类型的整数 int t_id = stoi(shortUrl.substr(19)); return map[t_id]; &#125;&#125;; 复杂度分析： 时间复杂度： Encode 函数：O(n)O(n)，其中 n 是字符串 longUrl 的长度。 Decode 函数：O(1)O(1)。我们把 shortUrl 当成有限长度的字符串看待。 空间复杂度： Encode 函数：O(n)O(n)。保存字符串 longUrl 需要 O(n)O(n) 的空间。 Decode 函数：O(1)O(1)。","categories":[{"name":"每日LeetCode","slug":"每日LeetCode","permalink":"http://example.com/categories/%E6%AF%8F%E6%97%A5LeetCode/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"},{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"(每日LeetCode)324. 摆动排序 II","slug":"每日LeetCode/2022-6/324 摆动排序 II","date":"2022-06-28T02:30:00.000Z","updated":"2022-07-08T00:35:05.704Z","comments":true,"path":"2022/06/28/每日LeetCode/2022-6/324 摆动排序 II/","link":"","permalink":"http://example.com/2022/06/28/%E6%AF%8F%E6%97%A5LeetCode/2022-6/324%20%E6%91%86%E5%8A%A8%E6%8E%92%E5%BA%8F%20II/","excerpt":"","text":"题目：给你一个整数数组 nums，将它重新排列成 nums[0] &lt; nums[1] &gt; nums[2] &lt; nums[3]... 的顺序。 你可以假设所有输入数组都可以得到满足题目要求的结果。 示例： 输入：nums &#x3D; [1,5,2,4,3,6]输出：[3,6,2,5,1,4] 思路：双指针法将数组nums按从小到大排列： 1 2 3 4 5 6 $\\leftarrow\\Uparrow$left $\\leftarrow\\Uparrow$right 把排序好的数组分成两部分，left指针位于数组中间，right指针位于数组末尾， 将left和right当前位置的元素依次打印后，left和right指针左移，直至结束 输出：[3, 6, 2, 5, 1, 4] 代码(cpp)：123456789101112131415161718192021class Solution &#123;public: void wiggleSort(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); //获取数组的元素个数 int left = n/2-1; //定义左指针 int right = n-1; //定义右指针 vector&lt;int&gt; new_nums(nums); sort(new_nums.begin(),new_nums.end()); //将新数组排序 for(int i=0;i&lt;n;i++)&#123; if(i%2 == 0)&#123; //偶数位置插入left指针的元素，奇数位置插入right指针的元素 nums[i] = a[left]; left--; &#125; else&#123; nums[i] = a[right]; rigth--; &#125; &#125; &#125;&#125;; 复杂度分析： 时间复杂度：O(nlogn)，排序所需的时间复杂度是O(nlogn)，插入O(n)，整体O(nlogn) 空间复杂度：O(n)，需要额外的空间存放排序的元素。","categories":[{"name":"每日LeetCode","slug":"每日LeetCode","permalink":"http://example.com/categories/%E6%AF%8F%E6%97%A5LeetCode/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"},{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"(每日LeetCode)剑指 Offer II 091. 粉刷房子","slug":"每日LeetCode/2022-6/剑指 Offer II 091 粉刷房子","date":"2022-06-25T02:00:00.000Z","updated":"2022-07-08T00:34:56.580Z","comments":true,"path":"2022/06/25/每日LeetCode/2022-6/剑指 Offer II 091 粉刷房子/","link":"","permalink":"http://example.com/2022/06/25/%E6%AF%8F%E6%97%A5LeetCode/2022-6/%E5%89%91%E6%8C%87%20Offer%20II%20091%20%E7%B2%89%E5%88%B7%E6%88%BF%E5%AD%90/","excerpt":"","text":"题目：假如有一排房子，共 n 个，每个房子可以被粉刷成红色、蓝色或者绿色这三种颜色中的一种，你需要粉刷所有的房子并且使其相邻的两个房子颜色不能相同。 当然，因为市场上不同颜色油漆的价格不同，所以房子粉刷成不同颜色的花费成本也是不同的。每个房子粉刷成不同颜色的花费是以一个 n x 3 的正整数矩阵 costs来表示的。 例如，costs[0][0] 表示第 0 号房子粉刷成红色的成本花费；costs[1][2] 表示第 1 号房子粉刷成绿色的花费，以此类推。请计算出粉刷完所有房子最少的花费成本。 示例： 输入: costs &#x3D; [[17,2,17],[16,16,5],[14,3,19]]输出: 10解释: 将 0 号房子粉刷成蓝色，1 号房子粉刷成绿色，2 号房子粉刷成蓝色。 最少花费: 2 + 5 + 3 &#x3D; 10。 1.递归代码(cpp)：12345678910111213141516171819202122232425262728293031class Solution &#123;public: int def(vector&lt;vector&lt;int&gt;&gt;&amp; costs, int pos, int n, vector&lt;vector&lt;int&gt;&gt; flag) &#123; //到达最后，没有房子了，退出 if (pos == n) return 0; int ans = INT_MAX; //依次选择三种颜色 for (int i = 0; i &lt; 3; i++) &#123; int temp = INT_MAX; vector&lt;vector&lt;int&gt;&gt; temp_flag(flag); //粉刷第一个房子，无需看前面房子的颜色，因为前面没有房子。 if (pos == 0) &#123; temp_flag[pos][i] = -1; temp = def(costs, pos + 1, n, temp_flag) + costs[pos][i]; &#125; //粉刷墙，要看前面用了什么颜色 else if (flag[pos - 1][i] != -1) &#123; //将这个房子的颜色标记 temp_flag[pos][i] = -1; temp = def(costs, pos + 1, n, temp_flag) + costs[pos][i]; &#125; //选择花费最少的金额 ans = min(ans, temp); &#125; return ans; &#125; int minCost(vector&lt;vector&lt;int&gt;&gt;&amp; costs) &#123; return def(costs, 0, costs.size(), costs); &#125;&#125;; 采用递归的方法，提交后，结果执行超时。 2.动态规划$$Red[pos][0]&#x3D;\\begin{cases}cost[0][0] &amp; pos &#x3D; 0; \\min(Green[pos+1][1],Blue[pos+1][2]) + costs[pos][0] &amp; pos&gt;0\\end{cases} \\$$ $$Green[pos][1]&#x3D;\\begin{cases}cost[0][1] &amp; pos &#x3D; 0; \\min(Red[pos+1][0],Blue[pos+1][2]) + costs[pos][1] &amp; pos&gt;0\\end{cases} \\$$ $$Blue[pos][2]&#x3D;\\begin{cases}cost[0][2] &amp; pos &#x3D; 0; \\min(Red[pos+1][0],Green[pos+1][1]) + costs[pos][2] &amp; pos&gt;0\\end{cases}$$ 画出动态规划图，以示例为例： costs = [[17,2,17],[16,16,5],[14,3,19]] 颜色\\pos 0 1 2 Red(0) 17 18 21 Green(1) 2 33 10 Blue(2) 17 7 37 $$mincost &#x3D; min(dp[2][0],dp[2][1],dp[2][2])$$ 代码(cpp)：123456789101112131415161718192021class Solution &#123;public: int minCost(vector&lt;vector&lt;int&gt;&gt;&amp; costs) &#123; int n = costs.size(); vector&lt;int&gt; red(n, 0); vector&lt;int&gt; blue(n, 0); vector&lt;int&gt; green(n, 0); // 初始化 red[0] = costs[0][0]; blue[0] = costs[0][1]; green[0] = costs[0][2]; for (int i = 1; i &lt; n; ++i) &#123; red[i] = min(blue[i - 1], green[i - 1]) + costs[i][0]; blue[i] = min(red[i - 1], green[i - 1]) + costs[i][1]; green[i] = min(red[i - 1], blue[i - 1]) + costs[i][2]; &#125; return min(red[n - 1], min(blue[n - 1], green[n - 1])); &#125;&#125;; 复杂度分析 时间复杂度：O(n)，其中 n 是房子个数。需要遍历全部房子一次，由于颜色数量固定是三种，因此对于每个房子计算粉刷房子的最小花费成本的时间是 O(1)，总时间复杂度是 O(n)。 空间复杂度：O(1)。使用空间优化的方法，只需要维护一个长度为 3 的数组，空间复杂度是 O(1)。","categories":[{"name":"每日LeetCode","slug":"每日LeetCode","permalink":"http://example.com/categories/%E6%AF%8F%E6%97%A5LeetCode/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"},{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"(每日LeetCode)515. 在每个树行中找最大值(中等)","slug":"每日LeetCode/2022-6/515 在每个树行中找最大值","date":"2022-06-24T01:04:00.000Z","updated":"2022-07-08T00:35:14.972Z","comments":true,"path":"2022/06/24/每日LeetCode/2022-6/515 在每个树行中找最大值/","link":"","permalink":"http://example.com/2022/06/24/%E6%AF%8F%E6%97%A5LeetCode/2022-6/515%20%E5%9C%A8%E6%AF%8F%E4%B8%AA%E6%A0%91%E8%A1%8C%E4%B8%AD%E6%89%BE%E6%9C%80%E5%A4%A7%E5%80%BC/","excerpt":"","text":"题目：给定一棵二叉树的根节点 root ，请找出该二叉树中每一层的最大值。 示例： 输入: root &#x3D; [1,3,2,5,3,null,9]输出: [1,3,9] 思路：深度优先搜索我们采用树的先序遍历，来进行深度优先搜索，并用pos来记录当前树的高度，就可以通过pos高度来判断是否在同一层，并且是否更新此高度的最大值。 代码(cpp)：123456789101112131415161718192021222324252627class Solution &#123;public: void dfs(TreeNode* root, vector&lt;int&gt;&amp; result, int pos)&#123; //如果该结点为空，则退出 if(root == nullptr) return; if(result.size() == pos)&#123; //数组的大小小于高度，大小需要加1 result.push_back(root-&gt;val); &#125; else&#123; //判断该层的某个结点，与之前记录的比较大小 result[pos] = max(result[pos], root-&gt;val); &#125; //遍历左子树，高度+1 dfs(root-&gt;left, result, pos+1); //遍历右子树，高度+1 dfs(root-&gt;right, result, pos+1); &#125; vector&lt;int&gt; largestValues(TreeNode* root) &#123; vector&lt;int&gt; result; dfs(root, result, 0); return result; &#125;&#125;; 复杂度分析 时间复杂度：O(n)，其中 n 为二叉树节点个数。二叉树的遍历中每个节点会被访问一次且只会被访问一次。 空间复杂度：O(pos)。其中 pos 表示二叉树的高度。递归函数需要栈空间，而栈空间取决于递归的深度，因此空间复杂度等价于二叉树的高度。","categories":[{"name":"每日LeetCode","slug":"每日LeetCode","permalink":"http://example.com/categories/%E6%AF%8F%E6%97%A5LeetCode/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"},{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"(每日LeetCode)30. 串联所有单词的子串","slug":"每日LeetCode/2022-6/30 串联所有单词的子串","date":"2022-06-23T03:53:00.000Z","updated":"2022-07-08T00:35:01.595Z","comments":true,"path":"2022/06/23/每日LeetCode/2022-6/30 串联所有单词的子串/","link":"","permalink":"http://example.com/2022/06/23/%E6%AF%8F%E6%97%A5LeetCode/2022-6/30%20%E4%B8%B2%E8%81%94%E6%89%80%E6%9C%89%E5%8D%95%E8%AF%8D%E7%9A%84%E5%AD%90%E4%B8%B2/","excerpt":"","text":"题目：给定一个字符串s和一些长度相同的单词words。找出s中恰好可以由words中所有单词串联形成的子串的起始位置。 注意子串要与words中的单词完全匹配，中间不能有其他字符，但不需要考虑words中单词串联的顺序。 示例： 输入：s &#x3D; “barfoofoobarthefoobarman”, words &#x3D; [“bar”,”foo”,”the”]输出：[6,9,12] 输出返回字串的第一个字符在s中的位置 第一个字串：barfoofoobarthefoobarman 6 第二个字串：barfoofoobarthefoobarman 9 第三个字符：barfoofoobarthefoobarman 12 思路：滑动窗口 word_len为每个单词的长度，因为每个单词的长度都相同； word_num为words数组中单词的个数； total_len为words数组中所有的单词的总长度； map来记录words数组中每个单词的个数； t_map遍历s时用来记录； 左指针left和右指针right用来当作左右边界； count用来统计已经匹配单词的个数，如果count == word_num，就证明匹配成功； 遍历s时无需一个一个字符的遍历，可以一个一个单词的遍历，right += word_len； 如果截取的单词map中不存在，则之前记录的全部无效，清空t_map和count； 如果某个单词在t_map中的个数大于map中的个数，就需要删除匹配的多余的单词，就需要删除窗口中第一个单词，直到某个单词出现的次数小于map中的个数 代码(cpp)：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364class Solution &#123;public: vector&lt;int&gt; findSubstring(string s, vector&lt;string&gt;&amp; words) &#123; //用来存放结果 vector&lt;int&gt; result; //判断s和words是否为空，如果其中有一个为空，则返回空数组 if(s.empty()||words.empty())&#123; return result; &#125; int word_len = words[0].size(); //一个单词的长度（每个单词长度都相同） int word_num = words.size(); // 单词的总个数 int total_len = word_len*word_num; // 全部单词的长度 //建立单词-&gt;单词个数的映射 unordered_map&lt;string, int&gt; map; //统计每个单词的个数 for(auto &amp;word : words)&#123; //map[key]:返回key值所对应的value值，如果不存在key值，则会使用该key值向当前容器中插入一个新value值为 0 map[word]++; //等价于 map[word] += 1 &#125; for(int i = 0; i&lt; word_len; i++)&#123; //left和right用来表示窗口的左右边界 int left = i; int right = i; //count用来统计已经匹配的单词个数 int count = 0; unordered_map&lt;string, int&gt; t_map; //开始滑动窗口 //right右边界依次累加单词的长度，直到超过s的长度停止循环 while(right + word_len &lt;= s.size())&#123; //substr(pos, n):从第pos的位置开始截取n个字符获取单词 string word = s.substr(right, word_len); right += word_len; //right跳到下一个单词 //count(key):在容器中查找以key键的键值对的个数。如果为0，说明此单词word在words数组中不存在。 if(map.count(word) == 0)&#123; count = 0; //清空之前统计的个数 left = right; //将左指针left移动到右指针right位置上重新开始 t_map.clear(); //之前匹配的单词没用了，清空t_map中的元素 &#125; //如果不为0，说明此单词word在words数组中存在。 else&#123; count++; //统计个数加1 t_map[word]++;// word所对应的个数加1 //t_map中的word对应的个数大于map的word对应的个数，说明匹配到多余的单词了 while(t_map[word]&gt; map[word])&#123; //获取窗口的第一个单词 string t_word = s.substr(left, word_len); //将t_word这个单词对应的个数减1 //并非是那个大于map中个数的单词 t_map[t_word]--; count--; //统计个数减1 left += word_len;//将左指针跳到下一个 &#125; //如果count等于单词的个数说明匹配成功，将左指针位置记录 if(count == word_num)&#123; result.push_back(left); &#125; &#125; &#125; &#125; return result; &#125;&#125;; 复杂度分析 时间复杂度：O(ls×n)，其中 ls 是输入 s 的长度，n 是 words 中每个单词的长度。需要做 n 次滑动窗口，每次需要遍历一次 s。","categories":[{"name":"每日LeetCode","slug":"每日LeetCode","permalink":"http://example.com/categories/%E6%AF%8F%E6%97%A5LeetCode/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"},{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"(每日LeetCode)513. 找树左下角的值","slug":"每日LeetCode/2022-6/513 找树左下角的值","date":"2022-06-22T03:11:00.000Z","updated":"2022-07-08T00:35:09.778Z","comments":true,"path":"2022/06/22/每日LeetCode/2022-6/513 找树左下角的值/","link":"","permalink":"http://example.com/2022/06/22/%E6%AF%8F%E6%97%A5LeetCode/2022-6/513%20%E6%89%BE%E6%A0%91%E5%B7%A6%E4%B8%8B%E8%A7%92%E7%9A%84%E5%80%BC/","excerpt":"","text":"题目：给定一个二叉树的 根节点 root，请找出该二叉树的 最底层 最左边 节点的值。 假设二叉树中至少有一个节点。 示例: 输入: [1,2,3,4,null,5,6,null,null,7]输出: 7 思路：深度优先搜索(DFS)我采用了优先遍历左节点，再遍历右节点，因为只有优先遍历左节点，才会优先记录当前深度左节点的值，所以就没有必要记录当前深度右边的值了。 使用depth记录当前树的深度，current_val为记录的深度current_depth的最左边的值。 进行判断如果depth的深度大于current_depth的深度，将current_val的值设置为当前结点的值，并将current_depth的值设置当前结点深度depth 代码(cpp)：1234567891011121314151617181920212223242526272829class Solution &#123;public: void dfs(TreeNode* root, int depth, int&amp; current_depth, int&amp; current_val) &#123; if (root == nullptr) //如果当前结点为空，则退出 &#123; return; &#125; //优先遍历左节点，深度加1 dfs(root-&gt;left, depth+1, current_depth, current_val); //其次遍历右节点，深度加1 dfs(root-&gt;right, depth+1, current_depth, current_val); //如果当前深度大于记录的深度 if (depth &gt; current_depth) &#123; current_depth = depth; //将当前深度记录到current_depth current_val = root-&gt;val; //将当前结点值记录到current_val &#125; &#125; int findBottomLeftValue(TreeNode* root) &#123; int current_depth = 0; //初始化current_depth int current_val = 0; //初始化current_val //因为有根结点存在，将depth设置为1，而非0 dfs(root, 1, current_depth, current_val); return current_val; &#125;&#125;; 复杂度分析 ​ 时间复杂度：O(n)，其中 n 是二叉树的节点数目。需要遍历 n 个节点。 ​ 空间复杂度：O(n)。递归栈需要占用 O(n) 的空间。","categories":[{"name":"每日LeetCode","slug":"每日LeetCode","permalink":"http://example.com/categories/%E6%AF%8F%E6%97%A5LeetCode/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"},{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]}],"categories":[{"name":"每日LeetCode","slug":"每日LeetCode","permalink":"http://example.com/categories/%E6%AF%8F%E6%97%A5LeetCode/"},{"name":"Java","slug":"Java","permalink":"http://example.com/categories/Java/"},{"name":"C++","slug":"C","permalink":"http://example.com/categories/C/"},{"name":"软件安装","slug":"软件安装","permalink":"http://example.com/categories/%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85/"},{"name":"计算机4件套","slug":"计算机4件套","permalink":"http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA4%E4%BB%B6%E5%A5%97/"},{"name":"Python","slug":"Python","permalink":"http://example.com/categories/Python/"},{"name":"爬虫","slug":"Python/爬虫","permalink":"http://example.com/categories/Python/%E7%88%AC%E8%99%AB/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"},{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"Git","slug":"Git","permalink":"http://example.com/tags/Git/"},{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"},{"name":"容器","slug":"容器","permalink":"http://example.com/tags/%E5%AE%B9%E5%99%A8/"},{"name":"es","slug":"es","permalink":"http://example.com/tags/es/"},{"name":"kibana","slug":"kibana","permalink":"http://example.com/tags/kibana/"},{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"},{"name":"c++","slug":"c","permalink":"http://example.com/tags/c/"},{"name":"框架","slug":"框架","permalink":"http://example.com/tags/%E6%A1%86%E6%9E%B6/"},{"name":"数据库","slug":"数据库","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"爬虫","slug":"爬虫","permalink":"http://example.com/tags/%E7%88%AC%E8%99%AB/"},{"name":"Python","slug":"Python","permalink":"http://example.com/tags/Python/"},{"name":"STL","slug":"STL","permalink":"http://example.com/tags/STL/"}]}