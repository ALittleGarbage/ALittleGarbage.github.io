{"meta":{"title":"活着就是为了摸鱼🐟！！！","subtitle":"","description":"一个不起眼的小博客","author":"一个小垃圾","url":"http://example.com","root":"/"},"pages":[{"title":"archives","date":"2022-06-25T09:46:11.000Z","updated":"2022-06-25T10:00:28.430Z","comments":true,"path":"archives/index.html","permalink":"http://example.com/archives/index.html","excerpt":"","text":""},{"title":"关于我是谁","date":"2022-06-25T09:46:19.000Z","updated":"2022-06-26T00:50:58.784Z","comments":true,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":""},{"title":"所有分类","date":"2022-06-25T09:45:03.000Z","updated":"2022-06-25T10:09:55.599Z","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"所有标签","date":"2022-06-25T09:44:36.000Z","updated":"2022-06-25T10:10:32.117Z","comments":true,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"","slug":"小技巧/@Autowired与@Resource","date":"2022-07-21T02:04:47.393Z","updated":"2022-07-21T14:43:05.503Z","comments":true,"path":"2022/07/21/小技巧/@Autowired与@Resource/","link":"","permalink":"http://example.com/2022/07/21/%E5%B0%8F%E6%8A%80%E5%B7%A7/@Autowired%E4%B8%8E@Resource/","excerpt":"","text":"@Autowired和@Resource区别提供方不同： @Autowired是由Spring提供，属于第三方 @Resource是由J2EE提供，属于Java的 装配时默认类型不同： @Autowired默认按type装配 默认情况下必须要求依赖对象存在，如果要允许null值，可以设置它的required属性为false。 如果想使用名称装配可以结合@Qualifier注解进行使用。 @Resource默认按name装配 名称可以通过name属性进行指定，如果没有指定name属性，当注解写在字段上时，默认取字段名进行名称查找。 如果注解写在setter方法上默认取属性名进行装配。 当找不到与名称匹配的bean时才按照类型进行装配。 但是需要注意的是，如果name属性一旦指定，就只会按照名称进行装配。 使用注意： @Autowired @Qualifier(“userService”) 是直接按照名字进行搜索，也就是说，对于UserServiceImpl 上面@Service注解必须写名字，不写就会报错，而且名字必须是@Autowired @Qualifier(“userService”) 保持一致。如果@Service上面写了名字，而@Autowired @Qualifier() ，一样会报错。 @Resource 根据这个注解的匹配效果可以看出，它进行了两次匹配，也就是说，如果你在UserService这个类上面这样写注解@Service。首先是找相同名字的，如果没有找到，再找相同类型的，而这里的@Service没有写名字，这个时候就进行了两次搜索，显然，速度就下降了许多。 @Resource根据名字搜索是这样写@Resource(“userService”)，如果你写了这个名字叫userService，那么UserServiceImpl的@Service注解也必须也是这个名字，不然还是会报错。","categories":[],"tags":[]},{"title":"(每日LeetCode)814. 二叉树剪枝","slug":"每日LeetCode/2022-7/814 二叉树剪枝","date":"2022-07-21T00:36:00.000Z","updated":"2022-07-21T02:13:56.542Z","comments":true,"path":"2022/07/21/每日LeetCode/2022-7/814 二叉树剪枝/","link":"","permalink":"http://example.com/2022/07/21/%E6%AF%8F%E6%97%A5LeetCode/2022-7/814%20%E4%BA%8C%E5%8F%89%E6%A0%91%E5%89%AA%E6%9E%9D/","excerpt":"","text":"题目：给你二叉树的根结点 root ，此外树的每个结点的值要么是 0 ，要么是 1 。 返回移除了所有不包含 1 的子树的原二叉树。 节点 node 的子树为 node 本身加上所有 node 的后代。 示例： 输入：root &#x3D; [1,null,0,0,1]输出：[1,null,0,null,1]解释：只有红色节点满足条件“所有不包含 1 的子树”。 右图为返回的答案。 自底向上进行剪枝，如果某个节点不存在左右节点，并且该节点值为0的话就需要剪枝 代码(cpp)：123456789101112131415class Solution &#123;public: TreeNode* pruneTree(TreeNode* root) &#123; if(root == nullptr) return nullptr; root-&gt;left = pruneTree(root-&gt;left); root-&gt;right = pruneTree(root-&gt;right); if(root-&gt;left == nullptr &amp;&amp; root-&gt;right ==nullptr &amp;&amp; root-&gt;val == 0)&#123; return nullptr; &#125; return root; &#125;&#125;; 复杂度分析： 时间复杂度：O(n)，其中 n 是二叉树节点的个数。每个节点都需要遍历一次。 空间复杂度：O(n)，其中 n 是二叉树节点的个数。递归的深度最多为 O(n)。","categories":[{"name":"每日LeetCode","slug":"每日LeetCode","permalink":"http://example.com/categories/%E6%AF%8F%E6%97%A5LeetCode/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"},{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"(每日LeetCode)1252. 奇数值单元格的数目","slug":"每日LeetCode/2022-7/1252 奇数值单元格的数目","date":"2022-07-12T01:24:00.000Z","updated":"2022-07-12T01:26:30.157Z","comments":true,"path":"2022/07/12/每日LeetCode/2022-7/1252 奇数值单元格的数目/","link":"","permalink":"http://example.com/2022/07/12/%E6%AF%8F%E6%97%A5LeetCode/2022-7/1252%20%E5%A5%87%E6%95%B0%E5%80%BC%E5%8D%95%E5%85%83%E6%A0%BC%E7%9A%84%E6%95%B0%E7%9B%AE/","excerpt":"","text":"题目：给你一个 m x n 的矩阵，最开始的时候，每个单元格中的值都是 0。 另有一个二维索引数组 indices，indices[i] = [ri, ci] 指向矩阵中的某个位置，其中 ri 和 ci 分别表示指定的行和列（从 0 开始编号）。 对 indices[i] 所指向的每个位置，应同时执行下述增量操作： ri 行上的所有单元格，加 1 。ci 列上的所有单元格，加 1 。给你 m、n 和 indices 。请你在执行完所有 indices 指定的增量操作后，返回矩阵中 奇数值单元格 的数目。 示例： 输入：m &#x3D; 2, n &#x3D; 3, indices &#x3D; [[0,1],[1,1]]输出：6解释： [[0,0,0], &#x3D;&#x3D;&gt; [[1,2,1], &#x3D;&#x3D;&gt; [[1,3,1], [0,0,0]] [0,1,0]] [1,3,1]] 返回奇数的个数 代码(cpp)：1234567891011121314151617181920212223242526class Solution &#123;public: int oddCells(int m, int n, vector&lt;vector&lt;int&gt;&gt;&amp; indices) &#123; vector&lt;int&gt; dp(n); vector&lt;vector&lt;int&gt;&gt; dps(m, dp); for (int i = 0; i &lt; indices.size(); i++) &#123; for (int j = 0; j &lt; n; j++) &#123; dps[indices[i][0]][j] += 1; &#125; for (int k = 0; k &lt; m; k++) &#123; dps[k][indices[i][1]] += 1; &#125; &#125; int count = 0; for (int i = 0; i &lt; m; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; if (dps[i][j] % 2 != 0) &#123; count++; &#125; &#125; &#125; return count; &#125;&#125;; 复杂度分析： 时间复杂度：O(q×(m+n)+m×n), 其中 q 表示数组 indices 的长度，m,n 为矩阵的行数与列数。遍历数组时，每次都需要更新矩阵中一行加一列，需要的时间为 O(q×(m+n))，最后还需要遍历矩阵，需要的时间为 O(m×n)，总的时间复杂度为 O(q×(m+n)+m×n)。 空间复杂度：O(m×n)，其中 m,n 为矩阵的行数与列数。需要存储矩阵的所有元素。","categories":[{"name":"每日LeetCode","slug":"每日LeetCode","permalink":"http://example.com/categories/%E6%AF%8F%E6%97%A5LeetCode/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"},{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"(每日LeetCode)676. 实现一个魔法字典","slug":"每日LeetCode/2022-7/676 实现一个魔法字典","date":"2022-07-11T00:35:00.000Z","updated":"2022-07-11T04:04:29.012Z","comments":true,"path":"2022/07/11/每日LeetCode/2022-7/676 实现一个魔法字典/","link":"","permalink":"http://example.com/2022/07/11/%E6%AF%8F%E6%97%A5LeetCode/2022-7/676%20%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E9%AD%94%E6%B3%95%E5%AD%97%E5%85%B8/","excerpt":"","text":"题目：设计一个使用单词列表进行初始化的数据结构，单词列表中的单词 互不相同 。 如果给出一个单词，请判定能否只将这个单词中一个字母换成另一个字母，使得所形成的新单词存在于你构建的字典中。 实现 MagicDictionary 类： MagicDictionary() 初始化对象void buildDict(String[] dictionary) 使用字符串数组 dictionary 设定该数据结构，dictionary 中的字符串互不相同bool search(String searchWord) 给定一个字符串 searchWord ，判定能否只将字符串中 一个 字母换成另一个字母，使得所形成的新字符串能够与字典中的任一字符串匹配。如果可以，返回 true；否则，返回 false。 示例： 输入[“MagicDictionary”, “buildDict”, “search”, “search”, “search”, “search”][[], [[“hello”, “leetcode”]], [“hello”], [“hhllo”], [“hell”], [“leetcoded”]]输出[null, null, false, true, false, false] 解释MagicDictionary magicDictionary &#x3D; new MagicDictionary();magicDictionary.buildDict([“hello”, “leetcode”]);magicDictionary.search(“hello”); &#x2F;&#x2F; 返回 FalsemagicDictionary.search(“hhllo”); &#x2F;&#x2F; 将第二个 ‘h’ 替换为 ‘e’ 可以匹配 “hello” ，所以返回 TruemagicDictionary.search(“hell”); &#x2F;&#x2F; 返回 FalsemagicDictionary.search(“leetcoded”); &#x2F;&#x2F; 返回 False 思路：遍历词典，找到与searchWord单词长度一样的单词，再与之对比相同的位置的字母是否相同，记录不相同字母的次数，只有不相同的字母的次数为1时，才可以返回true 代码(cpp)：1234567891011121314151617181920212223242526class MagicDictionary &#123;public: vector&lt;string&gt; dic; MagicDictionary() &#123;&#125; void buildDict(vector&lt;string&gt; dictionary) &#123; this-&gt;dic= dictionary; &#125; bool search(string searchWord) &#123; int n = searchWord.size(); for(int i = 0; i &lt; dic.size(); i++)&#123; if(dic[i].size() == n)&#123; int count = 0; for(int j = 0; j &lt; n; j++)&#123; if(dic[i][j] != searchWord[j])&#123; count++; &#125; &#125; if(count == 1) return 1; &#125; &#125; return 0; &#125;&#125;; 复杂度分析： 时间复杂度：O(qnl)，其中 n 是数组 dictionary 的长度，l 是数组 dictionary 中字符串的平均长度，q 是函数 search(searchWord) 的调用次数。 空间复杂度：O(nl)，即为数组需要使用的空间。","categories":[{"name":"每日LeetCode","slug":"每日LeetCode","permalink":"http://example.com/categories/%E6%AF%8F%E6%97%A5LeetCode/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"},{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"(每日LeetCode)873. 最长的斐波那契子序列的长度","slug":"每日LeetCode/2022-7/873 最长的斐波那契子序列的长度","date":"2022-07-09T00:34:00.000Z","updated":"2022-07-09T03:38:53.250Z","comments":true,"path":"2022/07/09/每日LeetCode/2022-7/873 最长的斐波那契子序列的长度/","link":"","permalink":"http://example.com/2022/07/09/%E6%AF%8F%E6%97%A5LeetCode/2022-7/873%20%E6%9C%80%E9%95%BF%E7%9A%84%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E5%AD%90%E5%BA%8F%E5%88%97%E7%9A%84%E9%95%BF%E5%BA%A6/","excerpt":"","text":"题目：如果序列 $X_1, X_2, …, X_n$ 满足下列条件，就说它是 斐波那契式 的： n &gt;&#x3D; 3对于所有 i + 2 &lt;&#x3D; n，都有 $X_i + X_{i+1} &#x3D; X_{i+2}$给定一个严格递增的正整数数组形成序列 arr ，找到 arr 中最长的斐波那契式的子序列的长度。如果一个不存在，返回 0 。 （回想一下，子序列是从原序列 arr 中派生出来的，它从 arr 中删掉任意数量的元素（也可以不删），而不改变其余元素的顺序。例如， [3, 5, 8] 是 [3, 4, 5, 6, 7, 8] 的一个子序列） 示例： 输入: arr &#x3D; [1,3,7,11,12,14,18]输出: 3解释: 最长的斐波那契式子序列有 [1,11,12]、[3,11,14] 以及 [7,11,18] 。 思路：递归费劲尽心，最后运行超时！！ 代码(cpp)：12345678910111213141516171819202122232425262728class Solution &#123;public: int def(vector&lt;int&gt;&amp; arr, vector&lt;int&gt; dp, int pos)&#123; int ans = 0; int n = dp.size(); for(int i=pos; i &lt; arr.size(); i++)&#123; if(n &lt; 2)&#123; vector&lt;int&gt; n_dp(dp); n_dp.emplace_back(arr[i]); ans = max(def(arr, n_dp, i+1)+1, ans); &#125; else if(n &gt;= 2 &amp;&amp; dp[n-1] + dp[n-2] == arr[i])&#123; vector&lt;int&gt; n_dp(dp); n_dp.emplace_back(arr[i]); ans = max(def(arr, n_dp, i+1)+1, ans); &#125; &#125; if(ans &lt;= 2 &amp;&amp; pos &lt; 2) return 0; return ans; &#125; int lenLongestFibSubseq(vector&lt;int&gt;&amp; arr) &#123; vector&lt;int&gt; dp; return def(arr, dp, 0); &#125;&#125;; 思路：动态规划摆烂了！ arr[k]+arr[j]=arr[i] 大小：k&lt;j&lt;i 代码(cpp)：123456789101112131415161718192021222324252627282930class Solution &#123;public: int lenLongestFibSubseq(vector&lt;int&gt;&amp; arr) &#123; unordered_map&lt;int, int&gt; indices; int n = arr.size(); for (int i = 0; i &lt; n; i++) &#123; indices[arr[i]] = i; &#125; //创建全是0的n*n二维数组 vector&lt;vector&lt;int&gt;&gt; dp(n, vector&lt;int&gt;(n)); int ans = 0; for (int i = 0; i &lt; n; i++) &#123; for (int j = i - 1; j &gt;= 0 &amp;&amp; arr[j] * 2 &gt; arr[i]; j--) &#123; int k = -1; //如果indices中存在arr[i]-arr[j]这个数 if (indices.count(arr[i] - arr[j])) &#123; //获得获得此数 k = indices[arr[i] - arr[j]]; &#125; //如果k不等于-1 if (k &gt;= 0) &#123; dp[j][i] = max(dp[k][j] + 1, 3); &#125; //获得到最大的序列长度 ans = max(ans, dp[j][i]); &#125; &#125; return ans; &#125;&#125;; 复杂度分析： 时间复杂度：O(n^2)，其中 n 是数组 arr 的长度。动态规划的状态数是 O(n^2)，每个状态的计算时间都是 O(1) 空间复杂度：O(n^2)，其中 n 是数组 arr 的长度。需要创建二维数组 dp，空间是 O(n^2)","categories":[{"name":"每日LeetCode","slug":"每日LeetCode","permalink":"http://example.com/categories/%E6%AF%8F%E6%97%A5LeetCode/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"},{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"(每日LeetCode)1846. 减小和重新排列数组后的最大元素","slug":"每日LeetCode/2022-7/1846 减小和重新排列数组后的最大元素","date":"2022-07-08T00:34:00.000Z","updated":"2022-07-08T00:34:32.816Z","comments":true,"path":"2022/07/08/每日LeetCode/2022-7/1846 减小和重新排列数组后的最大元素/","link":"","permalink":"http://example.com/2022/07/08/%E6%AF%8F%E6%97%A5LeetCode/2022-7/1846%20%E5%87%8F%E5%B0%8F%E5%92%8C%E9%87%8D%E6%96%B0%E6%8E%92%E5%88%97%E6%95%B0%E7%BB%84%E5%90%8E%E7%9A%84%E6%9C%80%E5%A4%A7%E5%85%83%E7%B4%A0/","excerpt":"","text":"题目：给你一个正整数数组 arr 。请你对 arr 执行一些操作（也可以不进行任何操作），使得数组满足以下条件： arr 中 第一个 元素必须为 1 。任意相邻两个元素的差的绝对值 小于等于 1 ，也就是说，对于任意的 1 &lt;= i &lt; arr.length （数组下标从 0 开始），都满足 abs(arr[i] - arr[i - 1]) &lt;= 1 。abs(x) 为 x 的绝对值。你可以执行以下 2 种操作任意次： 减小 arr 中任意元素的值，使其变为一个 更小的正整数 。重新排列 arr 中的元素，你可以以任意顺序重新排列。请你返回执行以上操作后，在满足前文所述的条件下，arr 中可能的 最大值 。 示例： 输入：arr &#x3D; [100,1,1000]输出：3解释：一个可行的方案如下： 重新排列 arr 得到 [1,100,1000] 。 将第二个元素减小为 2 。 将第三个元素减小为 3 。现在 arr &#x3D; [1,2,3] ，满足所有条件。arr 中最大元素为 3 。 代码(cpp)：1234567891011121314151617181920212223class Solution &#123;public: int maximumElementAfterDecrementingAndRearranging(vector&lt;int&gt;&amp; arr) &#123; //将arr数组排序 sort(arr.begin(), arr.end()); //如果第一个元素不为1，则设置为1 if(arr[0] != 1) arr[0] = 1; 将最大数设置为数组第一个元素 int max = arr[0]; for(int i = 1; i &lt; arr.size(); i++)&#123; //当前的元素减去前面的元素，它们的绝对值肯定是大于0的 int temp = arr[i] - arr[i-1]; //如果绝对值大于1，则设置当前的元素为前面的元素+1 if(temp &gt; 1) arr[i] = arr[i-1]+1; //如果当前元素大于max的元素，将当前元素设置为最大数 if(arr[i] &gt; max) max = arr[i]; &#125; //返回最大数 return max; &#125; &#125;; 复杂度分析： 时间复杂度：O(nlogn)，其中 n 是数组 arr 的长度。时间复杂度即排序的复杂度。 空间复杂度：O(logn)。空间复杂度不考虑输入，因此空间复杂度主要取决于排序时产生的 O(logn) 的栈空间。","categories":[{"name":"每日LeetCode","slug":"每日LeetCode","permalink":"http://example.com/categories/%E6%AF%8F%E6%97%A5LeetCode/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"},{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"","slug":"Java/MyBatis-Plus框架","date":"2022-07-07T06:04:11.246Z","updated":"2022-07-15T01:04:44.519Z","comments":true,"path":"2022/07/07/Java/MyBatis-Plus框架/","link":"","permalink":"http://example.com/2022/07/07/Java/MyBatis-Plus%E6%A1%86%E6%9E%B6/","excerpt":"","text":"1.初识MyBatis-PlusMyBatis-Plus是MyBatis的增强工具，在MyBatis的基础上只做增强不做改变，为了简化开发，提高效率而生 官网：MyBatis-Plus 特性： 无入侵：只做增强不做改变，导入它不会对现有工程产生影响。 损耗小：启动即会自动注入基本CRUD，性能基本不损耗，直接面向对象操作 强大的CRUD操作：内置通用Mapper、通用Service ,仅仅通过少量配置即可实现单表大部分CRUD操作，更有强大的条件构造器，满足各类使用需求 支持Lambda形式调用：通过Lambda表达式，方便的编写各类查询条件，无需再担心字段写错 支持多种数据库：支持MySQL、MariaDB、 Oracle、 DB2、 H2、 HSQL、 SQLite、 Postgre、SQL Server等多种数据库 支持主键自动生成：支持多达4种主键策略(内含分布式唯一ID生成器- Sequence)，可自由配置，完美解决主键问题 支持XML热加载：Mapper对应的XML支持热加载，对于简单的CRUD操作，甚至可以无XML启动 支持ActiveRecord模式：支持ActiveRecord形式调用，实体类只需继承Model类即可进行强大的CRUD操作 支持自定义全局通用操作：支持全局通用方法注入(Write once，use anywhere) 支持关键词自动转义：支持数据库关键词( order、 key…. )自动转义，还可自定义关键词 内置代码生成器：采用代码或者Maven插件可快速生成Mapper、 Model、Service、Controller层代码，支持模板引擎，更有超多自定义配置等您来使用 内置分页插件：基于MyBatis物理分页，开发者无需关心具体操作，配置好插件之后，写分页等同于普通List查询 内置性能分析插件：可输出Sql语句以及其执行时间，建议开发测试时启用该功能，能快速揪出慢查询 内置全局拦截插件：提供全表delete、update 操作智能分析阻断，也可自定义拦截规则，预防误操作 内置Sql注入剥离器：支持Sql注入剥离，有效预防Sql注入攻击 2.创建数据库创建数据库： 数据名：mp 字符集：utf-8 创建表： 123456789101112131415161718192021-- 创建测试表CREATE TABLE `tb_user` (`id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT &#x27;主键ID&#x27;,`user_name` varchar(20) NOT NULL COMMENT &#x27;用户名&#x27;,`password` varchar(20) NOT NULL COMMENT &#x27;密码&#x27;,`name` varchar(30) DEFAULT NULL COMMENT &#x27;姓名&#x27;,`age` int(11) DEFAULT NULL COMMENT &#x27;年龄&#x27;,`email` varchar(50) DEFAULT NULL COMMENT &#x27;邮箱&#x27;,PRIMARY KEY (`id`)) ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8;-- 插入测试数据INSERT INTO `tb_user` (`id`, `user_name`, `password`, `name`, `age`, `email`) VALUES(&#x27;1&#x27;, &#x27;zhangsan&#x27;, &#x27;123456&#x27;, &#x27;张三&#x27;, &#x27;18&#x27;, &#x27;test1@itcast.cn&#x27;);INSERT INTO `tb_user` (`id`, `user_name`, `password`, `name`, `age`, `email`) VALUES(&#x27;2&#x27;, &#x27;lisi&#x27;, &#x27;123456&#x27;, &#x27;李四&#x27;, &#x27;20&#x27;, &#x27;test2@itcast.cn&#x27;);INSERT INTO `tb_user` (`id`, `user_name`, `password`, `name`, `age`, `email`) VALUES(&#x27;3&#x27;, &#x27;wangwu&#x27;, &#x27;123456&#x27;, &#x27;王五&#x27;, &#x27;28&#x27;, &#x27;test3@itcast.cn&#x27;);INSERT INTO `tb_user` (`id`, `user_name`, `password`, `name`, `age`, `email`) VALUES(&#x27;4&#x27;, &#x27;zhaoliu&#x27;, &#x27;123456&#x27;, &#x27;赵六&#x27;, &#x27;21&#x27;, &#x27;test4@itcast.cn&#x27;);INSERT INTO `tb_user` (`id`, `user_name`, `password`, `name`, `age`, `email`) VALUES(&#x27;5&#x27;, &#x27;sunqi&#x27;, &#x27;123456&#x27;, &#x27;孙七&#x27;, &#x27;24&#x27;, &#x27;test5@itcast.cn&#x27;); 3.Mybatis-Plus快速入门导入所有依赖： 12345678910111213141516171819202122232425262728293031323334353637383940&lt;dependencies&gt; &lt;!-- mybatis-plus插件依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus&lt;/artifactId&gt; &lt;version&gt;3.1.1&lt;/version&gt; &lt;/dependency&gt; &lt;!-- mysql --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.47&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 数据库连接池 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.1.16&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 简化bean代码工具 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;version&gt;1.18.24&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 单元测试插件依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- 日志插件依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt; &lt;version&gt;1.7.36&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; resourses资源包中，新建log4j.properties文件： 1234log4j.rootLogger=DEBUG,A1log4j.appender.A1=org.apache.log4j.ConsoleAppenderlog4j.appender.A1.layout=org.apache.log4j.PatternLayoutlog4j.appender.A1.layout.ConversionPattern=[%t] [%c]-[%p] %m%n 创建User实体类： 1234567891011@Data //生成getter和setterd方法@NoArgsConstructor // 生成无参构造函数@AllArgsConstructor // 生成有参构造函数public class User &#123; private Long id; private String userName; private String password; private String name; private String age; private String email;&#125; 项目结构： 3.1 Mybatis实现查询在resources资源包中，创建mybatis-config.xml文件： 12345678910111213141516171819202122&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt; &lt;environments default=&quot;development&quot;&gt; &lt;environment id=&quot;development&quot;&gt; &lt;transactionManager type=&quot;JDBC&quot;/&gt; &lt;dataSource type=&quot;POOLED&quot;&gt; &lt;property name=&quot;driver&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/mp?useUnicode=true&amp;amp;characterEncoding=utf8&amp;amp;autoReconnect=true&amp;amp;allowMultiQueries=true&amp;amp;useSSL=false&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;123456&quot;/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;mappers&gt; &lt;mapper resource=&quot;UserMapper.xml&quot;/&gt; &lt;/mappers&gt;&lt;/configuration&gt; 创建UserMapper接口： 1234public interface UserMapper &#123; List&lt;User&gt; findAll(); &#125; 在resources资源包创建UserMapper.xml文件:： namespace为UserMapper接口的位置 id为UserMapper中的方法名 resultType为实体类的位置 123456789&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.mybatisp.mapper.UserMapper&quot;&gt; &lt;select id=&quot;findAll&quot; resultType=&quot;com.mybatisp.pojo.User&quot;&gt; select * from tb_user &lt;/select&gt;&lt;/mapper&gt; 单元测试： 1234567891011@Testpublic void testFindAll() throws IOException &#123; InputStream is = Resources.getResourceAsStream(&quot;mybatis-config.xml&quot;); SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(is); SqlSession sqlSession = sqlSessionFactory.openSession(); UserMapper userMapper = sqlSession.getMapper(UserMapper.class); System.out.println(userMapper.findAll());&#125; 控制台打印： 1[User(id=1, userName=null, password=123456, name=张三, age=18, email=test1@itcast.cn), User(id=2, userName=null, password=123456, name=李四, age=20, email=test2@itcast.cn), User(id=3, userName=null, password=123456, name=王五, age=28, email=test3@itcast.cn), User(id=4, userName=null, password=123456, name=赵六, age=21, email=test4@itcast.cn), User(id=5, userName=null, password=123456, name=孙七, age=24, email=test5@itcast.cn)] 3.2 Mybatis+MP实现查询将UserMapper继承BaseMapper，将拥有了BaseMapper中的所有方法： 1234public interface UserMapper extends BaseMapper&lt;User&gt; &#123; List&lt;User&gt; findAll();&#125; 单元测试： 123456789101112@Testpublic void testFindAll2() throws IOException &#123; InputStream is = Resources.getResourceAsStream(&quot;mybatis-config.xml&quot;); //这里使用的是MP中的MybatisSqlSessionFactoryBuilder SqlSessionFactory sqlSessionFactory = new MybatisSqlSessionFactoryBuilder().build(is); SqlSession sqlSession = sqlSessionFactory.openSession(); UserMapper userMapper = sqlSession.getMapper(UserMapper.class); System.out.println(userMapper.findAll()); &#125; 运行成功！ 改用BaseMapper中定义的方法查询所有： 1234567891011@Testpublic void testFindAll2() throws IOException &#123; InputStream is = Resources.getResourceAsStream(&quot;mybatis-config.xml&quot;); SqlSessionFactory sqlSessionFactory = new MybatisSqlSessionFactoryBuilder().build(is); SqlSession sqlSession = sqlSessionFactory.openSession(); UserMapper userMapper = sqlSession.getMapper(UserMapper.class); //System.out.println(userMapper.findAll()); System.out.println(userMapper.selectList(null));&#125; 报错： 1Cause: com.mysql.jdbc.exceptions.jdbc4.MySQLSyntaxErrorException: Table &#x27;mp.user&#x27; doesn&#x27;t exist 报错原因是没有找到user表，因为数据库中的表名为tb_user所以导致没有找到该表。需要指定表： 在User实体类中与数据库中的表进行映射： 123456789101112@Data //生成getter和setter方法@NoArgsConstructor // 生成无参构造函数@AllArgsConstructor // 生成有参构造函数@TableName(&quot;tb_user&quot;) //指定为tb_user表public class User &#123; private Long id; private String userName; private String password; private String name; private String age; private String email;&#125; 再次运行，成功！ 3.3 Spring+Mybatis+MP新建项目： 导入依赖： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;5.2.10.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;5.2.10.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;5.2.10.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus&lt;/artifactId&gt; &lt;version&gt;3.1.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.47&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.1.16&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;version&gt;1.18.24&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt; &lt;version&gt;1.7.36&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 在resources资源包中创建log4j.properties文件： 1234log4j.rootLogger=DEBUG,A1log4j.appender.A1=org.apache.log4j.ConsoleAppenderlog4j.appender.A1.layout=org.apache.log4j.PatternLayoutlog4j.appender.A1.layout.ConversionPattern=[%t] [%c]-[%p] %m%n 在resources资源包中创建jdbc.properties文件： 1234jdbc.driver=com.mysql.jdbc.driverjdbc.url=jdbc:mysql://localhost:3306/mp?useUnicode=true&amp;characterEncoding=utf8&amp;autoReconnect=true&amp;allowMultiQueries=true&amp;useSSL=falsejdbc.username=rootjdbc.password=123456 在resources资源包中创建applicationContext.xml文件 1234567891011121314151617181920212223242526272829&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beanshttp://www.springframework.org/schema/beans/spring-beans.xsdhttp://www.springframework.org/schema/contexthttp://www.springframework.org/schema/context/spring-context.xsd&quot;&gt; &lt;context:property-placeholder location=&quot;classpath*:*.properties&quot;/&gt; &lt;!-- 定义数据源 --&gt; &lt;bean id=&quot;dataSource&quot; class=&quot;com.alibaba.druid.pool.DruidDataSource&quot; destroy-method=&quot;close&quot;&gt; &lt;property name=&quot;url&quot; value=&quot;$&#123;jdbc.url&#125;&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;$&#123;jdbc.username&#125;&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot;/&gt; &lt;property name=&quot;driverClassName&quot; value=&quot;$&#123;jdbc.driver&#125;&quot;/&gt; &lt;property name=&quot;maxActive&quot; value=&quot;10&quot;/&gt; &lt;property name=&quot;minIdle&quot; value=&quot;5&quot;/&gt; &lt;/bean&gt; &lt;!--这里使用MP提供的sqlSessionFactory，完成了Spring与MP的整合--&gt; &lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;com.baomidou.mybatisplus.extension.spring.MybatisSqlSessionFactoryBean&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt; &lt;/bean&gt; &lt;!--扫描mapper接口，使用的依然是Mybatis原生的扫描器--&gt; &lt;bean class=&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt; &lt;property name=&quot;basePackage&quot; value=&quot;com.mybatisp.mapper&quot;/&gt; &lt;/bean&gt;&lt;/beans&gt; 创建User实体类： 123456789101112@Data //生成getter和setter方法@NoArgsConstructor // 生成无参构造函数@AllArgsConstructor // 生成有参构造函数@TableName(&quot;tb_user&quot;)public class User &#123; private Long id; private String userName; private String password; private String name; private String age; private String email;&#125; 创建UerMapper接口： 12public interface UserMapper extends BaseMapper&lt;User&gt; &#123;&#125; 单元测试： 1234567891011@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(locations = &quot;classpath:applicationContext.xml&quot;)public class MybatisTest &#123; @Autowired private UserMapper userMapper; @Test public void testSelectList()&#123; System.out.println(userMapper.selectList(null)); &#125;&#125; 运行成功！ 3.4 SpringBoot+Mybaits+MPxml版 项目结构： 创建springboot项目自动导入依赖： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt; &lt;version&gt;3.4.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.2.11&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.junit.vintage&lt;/groupId&gt; &lt;artifactId&gt;junit-vintage-engine&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt;&lt;/dependencies&gt;&lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-dependencies&lt;/artifactId&gt; &lt;version&gt;$&#123;spring-boot.version&#125;&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/dependencyManagement&gt;&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;version&gt;3.8.1&lt;/version&gt; &lt;configuration&gt; &lt;source&gt;1.8&lt;/source&gt; &lt;target&gt;1.8&lt;/target&gt; &lt;encoding&gt;UTF-8&lt;/encoding&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;version&gt;2.3.7.RELEASE&lt;/version&gt; &lt;configuration&gt; &lt;mainClass&gt;com.mybatisp.SpringbootMpApplication&lt;/mainClass&gt; &lt;/configuration&gt; &lt;executions&gt; &lt;execution&gt; &lt;id&gt;repackage&lt;/id&gt; &lt;goals&gt; &lt;goal&gt;repackage&lt;/goal&gt; &lt;/goals&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; application.yml： 1234567spring: datasource: druid: driver-class-name: com.mysql.cj.jdbc.Driver url: jdbc:mysql://localhost:3306/mp?serverTimezone=UTC username: root password: 123456 User实体类： 123456789101112@Data //生成getter和setter方法@NoArgsConstructor // 生成无参构造函数@AllArgsConstructor // 生成有参构造函数@TableName(&quot;tb_user&quot;)public class User &#123; private Long id; private String userName; private String password; private String name; private String age; private String email;&#125; UserMapper接口： 123@Mapperpublic interface UserMapper extends BaseMapper&lt;User&gt; &#123;&#125; 单元测试： 12345678910@SpringBootTestpublic class UserMapperTest &#123; @Autowired private UserMapper userMapper; @Test public void findAll() &#123; System.out.println(userMapper.selectList(null)); &#125;&#125; 运行成功！ 9.代码生成器创建Springboot项目： 添加下面的依赖： 1234567891011&lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-generator&lt;/artifactId&gt; &lt;version&gt;3.5.2&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.freemarker&lt;/groupId&gt; &lt;artifactId&gt;freemarker&lt;/artifactId&gt; &lt;version&gt;2.3.31&lt;/version&gt;&lt;/dependency&gt; 创建一个测试类： 12345678910111213141516171819202122232425public class FastAutoGeneratorTest &#123; public static void main(String[] args) &#123; FastAutoGenerator.create(&quot;jdbc:mysql://localhost:3306/mp?serverTimezone=UTC&quot;, &quot;root&quot;, &quot;123456&quot;) .globalConfig(builder -&gt; &#123; builder.author(&quot;baomidou&quot;) // 设置作者 //.enableSwagger() // 开启 swagger 模式 .fileOverride() // 覆盖已生成文件 .outputDir(&quot;E:\\\\Java_Web\\\\Mybatis-p\\\\mp_04_generator\\\\src\\\\main\\\\java&quot;); // 指定输出目录 &#125;) .packageConfig(builder -&gt; &#123; builder.parent(&quot;com&quot;) // 设置父包名 .moduleName(&quot;mybatisp&quot;) // 设置父包模块名 .pathInfo(Collections.singletonMap(OutputFile.xml, &quot;E:\\\\Java_Web\\\\Mybatis-p\\\\mp_04_generator\\\\src\\\\main\\\\resources\\\\mapper&quot;)); // 设置mapperXml生成路径 &#125;) .strategyConfig(builder -&gt; &#123; builder.addInclude(&quot;tb_user&quot;) // 设置需要生成的表名 .addTablePrefix(&quot;tb_&quot;, &quot;c_&quot;); // 设置过滤表前缀 &#125;) .templateEngine(new FreemarkerTemplateEngine()) // 使用Freemarker引擎模板，默认的是Velocity引擎模板 .execute(); &#125;&#125; 控制台打印： 12345608:57:51.095 [main] DEBUG com.baomidou.mybatisplus.generator.AutoGenerator - ==========================准备生成文件...==========================08:57:51.521 [main] DEBUG com.baomidou.mybatisplus.generator.config.querys.MySqlQuery - 执行SQL:show table status WHERE 1=1 AND NAME IN (&#x27;tb_user&#x27;)08:57:51.538 [main] DEBUG com.baomidou.mybatisplus.generator.config.querys.MySqlQuery - 返回记录数:1,耗时(ms):1608:57:51.550 [main] DEBUG com.baomidou.mybatisplus.generator.config.querys.MySqlQuery - 执行SQL:show full fields from `tb_user`08:57:51.559 [main] DEBUG com.baomidou.mybatisplus.generator.config.querys.MySqlQuery - 返回记录数:6,耗时(ms):908:57:51.652 [main] DEBUG com.baomidou.mybatisplus.generator.AutoGenerator - ==========================文件生成完成！！！========================== 以下为生成的文件：","categories":[],"tags":[]},{"title":"(每日LeetCode)729. 我的日程安排表 I","slug":"每日LeetCode/2022-7/729 我的日程安排表 I","date":"2022-07-05T04:50:00.000Z","updated":"2022-07-08T00:35:39.494Z","comments":true,"path":"2022/07/05/每日LeetCode/2022-7/729 我的日程安排表 I/","link":"","permalink":"http://example.com/2022/07/05/%E6%AF%8F%E6%97%A5LeetCode/2022-7/729%20%E6%88%91%E7%9A%84%E6%97%A5%E7%A8%8B%E5%AE%89%E6%8E%92%E8%A1%A8%20I/","excerpt":"","text":"题目：实现一个 MyCalendar 类来存放你的日程安排。如果要添加的日程安排不会造成 重复预订 ，则可以存储这个新的日程安排。 当两个日程安排有一些时间上的交叉时（例如两个日程安排都在同一时间内），就会产生 重复预订 。 日程可以用一对整数 start 和 end 表示，这里的时间是半开区间，即 [start, end), 实数 x 的范围为， start &lt;= x &lt; end 。 实现 MyCalendar 类： MyCalendar() 初始化日历对象。boolean book(int start, int end) 如果可以将日程安排成功添加到日历中而不会导致重复预订，返回 true。否则，返回 false 并且不要将该日程安排添加到日历中。 示例： 输入：[“MyCalendar”, “book”, “book”, “book”][[], [10, 20], [15, 25], [20, 30]]输出：[null, true, false, true] 思路：二分查找设已经插入了一些日程： $[[start_1,end_1),[start_2,end_2),[start_3,end_3)]$ 日程之间不交叉并且一定是有这样的排序： $start_1 &lt; end_1 \\leq start_2 &lt; end_2 \\leq start_3 &lt; end_3$ 如果要插入[start, end) 一定是在$end_i \\leq start&lt;end&lt; start_{i+1}$ 利用二分查找，找到恰比end大的元素：$start_{i+1}$ 再将$start_{i+1}$前面的元素$end_i$与start比较，看是否交叉。 代码(cpp)：123456789101112131415161718class MyCalendar &#123;public: //set默认的比较规则先按照first比较，如果first相同，再按照second比较 set&lt;pair&lt;int, int&gt;&gt; calendar; bool book(int start, int end) &#123; //获取比end恰好大的元素的迭代器，没有则返回迭代器end() //如果calendar没有元素，则返回迭代器begin() auto temp = calendar.lower_bound(&#123;end, 0&#125;); //如果temp为begin()说明没有元素直接插入 //如果不为begin()则与temp前面的元素的右区间比较，如果小于等于start说明没有交叉，插入 if(temp == calendar.begin() || (--temp)-&gt;second &lt;= start)&#123; calendar.insert(&#123;start, end&#125;); return true; &#125; return false; &#125;&#125;; 复杂度分析： 时间复杂度：O(nlogn), 其中 n 表示日程安排的数量。由于每次在进行预订时，都需要进行二分查找，需要的时间为 O(logn)。 空间复杂度：O(n)，其中 n 表示日程安排的数量。需要保存所有已经预订的行程。","categories":[{"name":"每日LeetCode","slug":"每日LeetCode","permalink":"http://example.com/categories/%E6%AF%8F%E6%97%A5LeetCode/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"},{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"set容器用法","slug":"C++/set容器","date":"2022-07-04T16:00:00.000Z","updated":"2022-07-07T06:52:27.242Z","comments":true,"path":"2022/07/05/C++/set容器/","link":"","permalink":"http://example.com/2022/07/05/C++/set%E5%AE%B9%E5%99%A8/","excerpt":"","text":"set容器：所有元素都会在插入时自动排序，底层结构采用二叉树实现。 set和multiset区别： set不可以插入重复数据，而multiset可以 set插入数据的同时会返回插入结果，表示插入是否成功 multiset不会检测数据，因此可以插入重复数据 set容器的使用： 头文件： 12#include&lt;set&gt; using namespace std; 构造函数： 构造函数 解释 set() 默认构造函数 set(const set &amp;st) 拷贝构造函数 成员函数： 成员函数 解释 void insert(T key) 插入key void emplace(T key) 插入key，比insert()效率高 erase() 删除 void clear() 清空 bool find(T key) 查找 int count(T key) 统计 int size() 获取大小 bool empty() 是否为空 void swap(set &amp;st) 交换 iterator lower_bound(T key) 如果set容器中没有元素，则返回迭代器begin()；如果set容器中存在元素，则返回恰好比key大的元素的迭代器，不存在则返回迭代器end() 自定义数据类型排序 set&lt;pair&lt;int,int&gt;&gt; set默认的比较规则先按照first比较，如果first相同，再按照second 比较。","categories":[{"name":"C++","slug":"C","permalink":"http://example.com/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"},{"name":"容器","slug":"容器","permalink":"http://example.com/tags/%E5%AE%B9%E5%99%A8/"},{"name":"STL","slug":"STL","permalink":"http://example.com/tags/STL/"}]},{"title":"(每日LeetCode)1200. 最小绝对差","slug":"每日LeetCode/2022-7/1200 最小绝对差","date":"2022-07-03T23:54:00.000Z","updated":"2022-07-08T00:36:23.299Z","comments":true,"path":"2022/07/04/每日LeetCode/2022-7/1200 最小绝对差/","link":"","permalink":"http://example.com/2022/07/04/%E6%AF%8F%E6%97%A5LeetCode/2022-7/1200%20%E6%9C%80%E5%B0%8F%E7%BB%9D%E5%AF%B9%E5%B7%AE/","excerpt":"","text":"题目：给你个整数数组 arr，其中每个元素都 不相同。 请你找到所有具有最小绝对差的元素对，并且按升序的顺序返回。 示例：示例1： 输入：arr &#x3D; [4,2,1,3]输出：[[1,2],[2,3],[3,4]] 示例2： 输入：arr &#x3D; [1,3,6,10,15]输出：[[1,3]] 思路：先将arr数组排序 再遍历arr数组，如果找到有比min更小的差值，将min改为该差值，将dp数组之前记录的数据清空(因为之前记录的都是差值大的)，重新插入差值更小的数据。 代码(cpp)：123456789101112131415161718192021222324class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; minimumAbsDifference(vector&lt;int&gt;&amp; arr) &#123; //将arr数组排序 sort(arr.begin(),arr.end()); int min = INT_MAX; vector&lt;vector&lt;int&gt;&gt; dp; for(int i = 1; i &lt; arr.size(); i++)&#123; //当前的差值 int temp = arr[i]-arr[i-1]; if(temp &lt; min)&#123; min = temp; //将dp数组清空 dp.clear(); //重新插入新的差值小的数据 dp.push_back(&#123;arr[i-1],arr[i]&#125;); &#125; else if(temp == min)&#123; dp.push_back(&#123;arr[i-1],arr[i]&#125;); &#125; &#125; return dp; &#125;&#125;; 复杂度分析： 时间复杂度：O(nlogn)，其中 n 是数组 arr 的长度。排序需要的时间为 O(nlogn)，遍历需要的是时间为 O(n)，因此总时间复杂度为 O(nlogn)。 空间复杂度：O(logn)，即为排序需要使用的栈空间。这里不计入返回值需要使用的空间。","categories":[{"name":"每日LeetCode","slug":"每日LeetCode","permalink":"http://example.com/categories/%E6%AF%8F%E6%97%A5LeetCode/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"},{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"操作系统","slug":"计算机4件套/操作系统","date":"2022-07-03T15:07:28.465Z","updated":"2022-07-13T07:19:59.048Z","comments":true,"path":"2022/07/03/计算机4件套/操作系统/","link":"","permalink":"http://example.com/2022/07/03/%E8%AE%A1%E7%AE%97%E6%9C%BA4%E4%BB%B6%E5%A5%97/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/","excerpt":"","text":"一、操作系统概述二、进程三、内存四、文件五、I-O设备","categories":[],"tags":[]},{"title":"Redis框架的学习笔记","slug":"Java/Redis框架","date":"2022-07-03T14:50:31.983Z","updated":"2022-07-21T16:34:06.674Z","comments":true,"path":"2022/07/03/Java/Redis框架/","link":"","permalink":"http://example.com/2022/07/03/Java/Redis%E6%A1%86%E6%9E%B6/","excerpt":"","text":"基础篇1.初识Redis1.1 认识NoSql键值数据库是一种NoSql数据库 key value 1001 { “id”:1001, “name”:”张三”, “age”:20,} SQL：关系型数据库 NoSQL：非关系型数据库 SQL与NoSQl的比较： SQL NoSQL 数据结构 结构化 非结构化：1.键值类型(Redis)2.文档类型(MongoDB)3.列类型(HBase)4.Graph类型(Neo4j) 数据关联 关联的(数据有关联) 无关联的 查询方式 SQL查询(SQL语法通用) 非SQL(语法不统一) 事务特性 ACID BASE 存储方式 磁盘 内存 扩展性 垂直 水平 使用场景 1.数据结构固定2.相关业务数据安全性、一致性要求较高 1.数据结构不固定2.相关业务数据安全性、一致性要求不高3.对性能要求 1.2 认识RedisRedis诞生于2009年全称时Remote Dictionary Server，远程词典服务器，是一个基于内存的键值型NoSQL数据库。 特征： 键值(key-value)型：value支持多种不同数据结构，功能丰富 单线程：每个命令具备原子性 低延迟、速度快：基于内存、IO多路复用、良好的编码(C语言开发) 支持数据持久化 支持主从集群、分片集群 支持多语言客户端 1.3 Redis的安装及其配置(不要看这个教程安装，有问题我还要改)​ 大多企业都是基于Linux服务器来部署项目，而且Redis官方也没有提供Windows版本的安装包。因此会使用基于Linux系统来安装Redis。 Redis官网：Redis Linux版本为：CentOS7 注意：下面的安装Redis方法不适用于Ubuntu 打开命令行，依次输入一下内容： 123456789101112131415#转换成root权限su - #输入密码#安装gcc依赖yum install -y gcc tcl#进入到src目录cd /usr/local/src#下载redis-6.2.6.tar.gzwget https://download.redis.io/releases/redis-6.2.6.tar.gz#解压redis-6.2.6.tar.gztar -zxvf redis-6.2.6.tar.gz#进入redis-6.2.6cd redis-6.2.6#运行编译命令make &amp;&amp; make install 默认安装路径为/usr/local/bin目录下： 1ll /usr/local/bin 看到这个样子安装基本成功了 Redis的配置文件： 重新打开命令行： 12345678su -#输入密码#进入到redis-6.2.6目录cd /usr/local/src/redis-6.2.6#备份redis.confcp redis.conf redis.conf.bck#打开redis.conf配置文件vi redis.conf 修改redis.conf文件的一些配置： 123456#bind 127.0.0.1 -::会导致只能在本地访问，修改为0.0.0.0就可以在任意ip访问，生产环境不要设置为0.0.0.0bind 0.0.0.0#守护进程，修改为yes即可后台运行daemonize yes#设置密码为123456requirepass 123456 查找：/+所要查找的字符串；按n向下查找，按N向上查找 输入i即可修改数据，修改完成后按ESC退出编辑 :wq为保存并退出 退出后： 12345redis-server redis.conf#查看redis进程ps -ef|grep redis #杀死进程kill -9 端口号 接着设置开机自启： 12#新建一个系统服务文件vi /etc/systemd/system/redis.service 将下面内容全部复制到redis.service文件中： 1234567891011[Unit]Description=redis-serverAfter=network.target[Service]Type=forkingExecStart=/usr/local/bin/redis-server /usr/local/src/redis-6.2.6/redis.confPrivateTmp=true[Install]WantedBy=multi-user.target 保存退出后， 接着: 12345678910#重载系统服务systemctl daemon-reload#启动redissystemctl start redis#查看redis状态systemctl status redis#停止redissystemctl stop redis#redis开机自启systemctl enable redis 2.Redis命令2.1 Redis数据结构介绍Redis是一个key-value的数据库，key一般是String类型，不过value的类型多种多样： 数据类型 格式 String hello Redis Hash {name: “jack”, age: 21} List [A -&gt; B -&gt; C -&gt; D] Set {A, B, C} SortSet {A: 1, B: 2, C: 3} GEO(地理坐标) {A: (120.3, 30.5)} BitMap 0101001001100101011001000110100101110011 HyperLog 0101001001100101011001000110100101110011 基本类型：String、Hash、List、Set、SortSet 特殊类型：GEO、BitMap、HyperLog 2.2 Redis通用命令 命令 解释 举例 KEYS 查看符合模板的所有key，不建议在生产环境设备上使用(效率低) KEYS *：查看所有keyKEYS n*：查看所有n开头的key DEL 删除一个指定key DEL name：删除name EXISTS 判断key是否存在 EXISTS name：存在返回1，否则返回0 EXPIRE 给一个key设置有效期，有效期到期key会被自动删除 EXPIRE name 20：设置name的有效期为20秒 TTL 查看一个key的剩余有效期 TTL name：查看name的有效期，如果返回-2，则说明到期了如果返回-1，则说明永久有效 2.3 String类型String类型、也就是字符串类型，是Redis中最简单的存储类型 其value是字符串，不过根据字符串的格式不同，又可以分类为3类： string：普通字符串 int：整数类型，可以做自增、自减操作 float：浮点类型，可以做自增、自减操作 不管是哪种格式，底层都是字节数组形式存储，字符串类型的最大空间不能超过512m Key Value msg hello Redis num 10 score 98.5 String类型常见命令： 命令 SET key value 添加或修改已经存在的一个String类型的键值对 SET name Jerry：把name的value设置为Jerry GET key 根据key获取String类型的value GET name：获取到value为”Jerry” MSET 批量添加多个String类型的键值对 MSET score 12.5 age 18：添加多个键值对 MGET 根据多个key获取多个String类型的value MGET name score age：得到多个value为”Jreey” “12.5” “18” INCR 让一个整型的key自增1 INCR age：age的value加1，由18变为19 INCRBY 让一个整型的key自增并指定步长 INCRBY age 2：age的value加2，由19变为21 INCRBYFLOAT 让一个浮点类型的数字自增并指定步长 INCRBYFLOAT score 0.5：score的value加0.5，由12.5变为13.0 SETNX 添加一个String类型的键值对，前提是这个key不存在，否则不执行(新增效果) SETNX name Tom：不执行，返回0SETNX k1 v1：执行，返回1 SETEX 添加一个String类型的键值对，并且指定有效期 SETEX name 10 jerry ：添加键值对，并将有效期设置为10秒 2.4 Key的层级格式Redis没有类似于MySQL中的Table表的概念 Redis的Key允许有多个单词形成层级结构，多个单词之间用:隔开，格式(不固定)如下： 项目名:业务名:类型:id 例如项目名叫demo，有user和book两种不同类型的数据，我们可以这样定义Key： user相关的Key：demo:user:1 book相关的Key：demo:book:1 如果Value是一个java对象，例如一个User对象，则可以将对象序列化为json字符串后存储： Key Value demo:user:1 {“id”: 1, “name”: “Jerry”, “age”: 18} demo:book:1 {“id”: 1, “name”: “BOOK”, “price”: 15} 插入操作(注意：Value值要加&#39;&#39;)： set demo:user:1 &#39;&#123;&quot;id&quot;: 1, &quot;name&quot;: &quot;Jerry&quot;, &quot;age&quot;: 18&#125;&#39; set demo:book:1 &#39;&#123;&quot;id&quot;: 1, &quot;name&quot;: &quot;BOOK&quot;, &quot;price&quot;: 15&#125;&#39; 打开图形界面客户端查看： 2.5 Hash类型Hash类型，也叫散列，其value是一个无序字典，类似于java中的HashMap结构 String结构是将对象序列化为json字符串后存储，当需要修改对象某个字段时很不方便(需要修改整个字符串)： Key Value demo:user:1 {“id”: 1, “name”: “Jerry”, “age”: 18} demo:user:2 {“id”: 2, “name”: “Tom”, “price”: 20} 而Hash结构可以将对象中每个字段独立存储，可以针对单个字段做CRUD： Key Value field value demo:user:1 name Jerry age 18 demo:user:2 name Tom age 20 Hash类型常见命令： 命令 HSET key field value 添加或修改hash类型key的field的值 HSET demo:user:2 name LiHua：把name的value设置为Lihua HGET key field 获取一个hash类型key的field的值 HGET demo:user:2 name：获取到value为”LiHua” HMSET 批量添加多个hash类型key的field的值 HMSET demo:user:3 name LiLei age 22：添加多个field的值 HMGET 批量获取根据多个hash类型key的field的值 HMGET demo:user:3 name age：得到多个field的值为”LiLei” “22” HGETALL 获取一个hash类型的key中的所有的field和value HGETALL demo:user:3：获取到key中所有的field和value HKEYS 获取一个hash类型的key中的所有的field HKEYS demo:user:3：获取key中所有的field HVALS 获取一个hash类型的key中的所有的value HVALS demo:user:3：获取key中所有的value HINCRBY 让一个hash类型的key的字段自增并指定步长 HINCRBY demo:user:3 age 2：age的value加2，由22变为24 HSETNX 添加一个hash类型的key的field值，前提是这个field不存在，否则不执行(新增效果) HSETNX demo:user:3 name XXX：存在field值不执行，返回0HSETNX demo:user:3 sex man：不存在field值执行，返回1 2.6 List类型Redis中的List类型与java中的LinkList类似，可以看作是一个双向链表结构，既可以支持正向检索也可以支持反向检索。 特征与LinkList也类似： 有序 元素可以重复 插入和删除快 查询速度一般 常用来存储一个有序数据，如：评论列表、点赞列表等 List类型的常见命令： LPUSH key element 向列表左侧插入一个或多个元素 LPUSH user 1 2 3：表中从第一位依次为 “3” “2” “1” LPOP key 移除并返回列表左侧的第一个元素，没有则返回nil LPOP user 1 RPUSH key element 向列表右侧插入一个或多个元素 RPUSH user 4 5 6：表中从第一位依次为 “4” “5” “6” RPOP key 移除并返回列表右侧的第一个元素 LRANGE key star end 返回一段角标范围内的所有元素 LRANGE 1 star 2：从0开始，获取到1~2之间的元素 BLPOP 与LPOP类似，只不过在没有元素时等待指定时间，而不是直接返回nil BLPOP user2 1 100：移除并返回到左侧的第一个元素，没有则等待100秒，超时返回nil BRPOP 与RPOP类似，只不过在没有元素时等待指定时间，而不是直接返回nil List结构模拟一个栈 入口和出口在同一边 如：LPUSH和LPOP或者 RPUSH和RPOP List结构模拟一个队列 入口和出口不在同一边 如：LPUSH和RPOP 或者 RPUSH和LPOP List结构模拟一个阻塞队列 入口和出口不在同一边 出队采用BLPOP或者BRPOP 如：LPUSH和BRPOP 或者 RPUSH和BLPOP 2.7 Set类型Redis的Set结构与Java中的Hashset类似，可以看做是一个value为null的HashMap。因为也是一个hash表，因此具备与Hashset类似的特征： 无序 元素不可重复 查找快 支持交集、并集、差集等功能 Set类型的常见命令： SADD key member 向set中添加一个或多个元素 SADD s1 a b c SREM key member 移除set中的指定元素 SREM s1 a SCARD key 返回set中元素的个数 SCARD s1 SISMEMBER key member 判断一个元素是否存在于set中 SISMEMBER s1 a SMEMBERS 获取set中的所有元素 SMEMBERS SINTER key1 key2 求key1与key2的交集 SDIFF key1 key2 求key1与key2的差集 SUNION key1 key2 求key1与key2的并集 2.8 SortedSet类型Redis的SortedSet是一个可排序的set集合，与java中的TreeSet有些类似，但底层数据结构却差别很大Sortedset中的每一个元素都带有一个score属性，可以基于score属性对元素排序，底层的实现是一个跳表(SkipList)加hash表。SortedSet具备下列特性： 可排序 元素不重复 查询速度快 因为Sortedset的可排序特性，经常被用来实现排行榜这样的功能。 SortedSet类型的常见命令： ZADD key score member 添加一个或多个元素到sorted set，如果已经存在则更新其score值 ZADD SSet 85 Tom 98 Jerry 77 Rose 78 Jack：向SSet中添加元素，并按照升序排列 ZREM key member 删除sorted set中的一个指定元素 ZREM SSet Tom：删除Tom ZSCORE key member 获取sorted set中的指定元素的score值 ZRANK key member 获取sorted set 中的指定元素升序的排名 ZRANK SSet Rose：按照升序的序列，从0开始，返回Rose的排名 ZREVRANK key member 获取sorted set 中的指定元素降序的排名 ZRANK SSet Rose：按照降序的序列，从0开始，返回Rose的排名 ZCARD key 获取sorted set中的元素个数 ZCOUNT key min max 统计score值在给定范国内的所有元素的个数 ZINCRBY key increment member 让sorted set中的指定元素自增，步长为指定的increment值 ZRANGE key min max 按照score升序排序后，获取指定排名范围内的元素 ZCOUNT SSet 0 2：按照升序的情况，获取0~2范围的元素 ZREVRANGE key min max 按照score的降序排序后，获取指定排名范围内的元素 ZCOUNT SSet 0 2：按照降序的情况，获取0~2范围的元素 ZRANGEBYSCORE key min max 按照score排序后，获取指定score范国内的元素 ZRANGEBYSCORE SSet 0 80：返回0~80分数的元素 ZDIFF、ZINTER、ZUNION 求差集、交集、并集 注意：所有排名默认都是升序，如果降序则在命令的Z后面添加REV即可 例如：ZREVRANK 3.Redis的java客户端Redis官网中提供了各种语言的客户端 Java： Jedis：以Redis命令作为方法名称，学习成本低，简单实用但是Jedis实例是线程不安全的，多线程环境下需要基于连接池来使用 Lettuce：基于Netty实现的，支持同步、异步和响应式编程方式，并且是线程安全的。支持Redis的哨兵模式、集群模式和管道模式 Redisson：是一个基于Redis实现的分布式、可伸缩的Java数据结构集合。包含了诸如Map、Queue、LockSemaphore、Atomiclong等强大功能 其中Spring整合了Jedis和Lettuce，只需导入坐标Spring Data Redis 3.1 Jedis快速入门Jedis：Jedis官网 引入jedis依赖： 12345&lt;dependency&gt; &lt;groupId&gt;redis.clients&lt;/groupId&gt; &lt;artifactId&gt;jedis&lt;/artifactId&gt; &lt;version&gt;3.7.0&lt;/version&gt;&lt;/dependency&gt; 完整依赖： 123456789101112131415&lt;dependencies&gt; &lt;!-- jedis依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;redis.clients&lt;/groupId&gt; &lt;artifactId&gt;jedis&lt;/artifactId&gt; &lt;version&gt;3.7.0&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 测试依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.junit.jupiter&lt;/groupId&gt; &lt;artifactId&gt;junit-jupiter&lt;/artifactId&gt; &lt;version&gt;5.7.0&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 以下在Test中进行： 建立连接 123456789@BeforeEach //在测试方法执行之前执行的方法 void setUp() &#123; //建立连接 jedis = new Jedis(&quot;127.0.0.1&quot;,6379); //设置密码 jedis.auth(&quot;123456&quot;); //选择库 jedis.select(0); &#125; 测试String类型 12345@Testvoid testString() &#123; jedis.set(&quot;name&quot;,&quot;Tom&quot;); System.out.println(jedis.get(&quot;name&quot;));&#125; 释放资源 123456@AfterEach //在测试方法执行之后执行的方法void tearDown() &#123; if (jedis != null)&#123; jedis.close(); &#125;&#125; 完整测试： 12345678910111213141516171819202122232425262728293031323334public class JedisTest &#123; private Jedis jedis; @BeforeEach //在测试方法执行之前执行的方法 void setUp() &#123; //建立连接 jedis = new Jedis(&quot;127.0.0.1&quot;,6379); //设置密码 jedis.auth(&quot;123456&quot;); //选择库 jedis.select(0); &#125; @Test void testString() &#123; jedis.set(&quot;name&quot;,&quot;Tom&quot;); System.out.println(jedis.get(&quot;name&quot;)); &#125; @Test void testHash() &#123; jedis.hset(&quot;demo:user:2&quot;,&quot;name&quot;,&quot;Jerry&quot;); jedis.hset(&quot;demo:user:2&quot;,&quot;age&quot;,&quot;18&quot;); Map&lt;String, String&gt; map = jedis.hgetAll(&quot;demo:user:2&quot;); System.out.println(map); &#125; @AfterEach //在测试方法执行之后执行的方法 void tearDown() &#123; if (jedis != null)&#123; jedis.close(); &#125; &#125;&#125; jedis使用的基本步骤： 引入依赖 创建jedis对象，建立连接 使用jedis的方法名与Redis命令一致 释放资源 3.2 Jedis的连接池Jedis本身线程是不安全的，并且频繁的创建和销毁连接会有性能损耗，因此推荐使用Jedis连接池替代Jedis的直连方法 创建JedisConnectionFactory工具类： 12345678910111213141516171819202122232425262728public class JedisConnectionFactory &#123; private static final JedisPool jedisPool; static &#123; //配置连接池 JedisPoolConfig jedisPoolConfig = new JedisPoolConfig(); //最大连接数 jedisPoolConfig.setMaxTotal(8); //最大空闲连接 jedisPoolConfig.setMaxIdle(8); //最小空闲连接 jedisPoolConfig.setMinIdle(0); //等待时长 jedisPoolConfig.setMaxWaitMillis(1000); //创建连接池对象 jedisPool = new JedisPool(jedisPoolConfig, &quot;127.0.0.1&quot;, 6379, 1000, &quot;123456&quot;); &#125; public static Jedis getJedis()&#123; return jedisPool.getResource(); &#125;&#125; 测试类中： 123456789101112131415161718192021222324252627public class JedisTest &#123; private Jedis jedis; @BeforeEach //在测试方法执行之前执行的方法 void setUp() &#123; //建立连接 jedis = JedisConnectionFactory.getJedis(); //选择库 jedis.select(0); &#125; @Test void testHash() &#123; jedis.hset(&quot;demo:user:2&quot;,&quot;name&quot;,&quot;Jerry&quot;); jedis.hset(&quot;demo:user:2&quot;,&quot;age&quot;,&quot;18&quot;); Map&lt;String, String&gt; map = jedis.hgetAll(&quot;demo:user:2&quot;); System.out.println(map); &#125; @AfterEach //在测试方法执行之后执行的方法 void tearDown() &#123; if (jedis != null)&#123; //close方法当检测到是连接池时，并不是真正的关闭连接，而是将对象归还给连接池 jedis.close(); &#125; &#125;&#125; 3.3 初识SpringDataRedisSpringData是Spring中数据操作的模块，包含对各种数据库的集成，其中对Redis的集成模块就叫做SpringDataRedis 提供了对不同Redis客户端的整合 （Lettuce和Jedis） 提供了RedisTemplate统一API来操作Redis 支持Redis的发布订阅模型 支持Redis哨兵和Redis集群 支持基于Lettuce的响应式编程 支持基于JDK、JSON、字符串、Spring对象的数据序列化及反序列化 支持基于Redis的JDKCollection实现 SpringDataRedis中提供了RedisTemplate工具类，其中封装了各种对Redis的操作。并且将不同数据类型的操作API封装到了不同的类型中： API 返回值类型 解释 redisTemplate.opsForValue() ValueOperations 操作String类型数据 redisTemplate.opsForHash() HashOperations 操作Hash类型数据 redisTemplate.opsForList() ListOperations 操作List类型数据 redisTemplate.opsForSet() SetOperations 操作Set类型数据 redisTemplate.opsForZSet() ZSetOperations 操作SortedSet类型数据 redisTemplate 通用命令 3.4 SpringDataRedis快速入门SpringBoot已经提供了对SpringDataRedis的支持，其中Spring默认支持Lettuce，如需使用Jedis需要额外导入依赖 导入依赖 12345678910&lt;!-- Redis依赖 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!-- 连接池依赖 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.commons&lt;/groupId&gt; &lt;artifactId&gt;commons-pool2&lt;/artifactId&gt;&lt;/dependency&gt; 配置文件 1234567891011spring: redis: host: 127.0.0.1 port: 6379 password: 123456 lettuce: pool: max-active: 8 # 最大连接数 max-idle: 8 #最大空闲连接数 min-idle: 0 #最小空闲连接数 max-wait: 100ms # 连接等待时间 注入RedisTemplate，进行测试： 12345678910111213@SpringBootTestpublic class RedisTemplateTest &#123; @Autowired private RedisTemplate redisTemplate; @Test void testString() &#123; //插入一条String类型的数据 redisTemplate.opsForValue().set(&quot;name&quot;,&quot;dahuang&quot;); //获取String类型的数据 System.out.println(redisTemplate.opsForValue().get(&quot;name&quot;)); &#125;&#125; SpringDataRedis的使用步骤： 引入spring-boot-starter-data-redis依赖 在application.yml配置Redis以及连接池信息 注入RedisTemplate 3.5 SpringDataRedis的序列化方式RedisTemplate可以接收任意Object作为值写入Redis，只不过写入前会把Object序列化为字节形式，默认采用JDK序列化，刚才存入的数据的结果是这样： 缺点： 可读性差 内存占用较大 需要导入jackson依赖： 1234&lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;&lt;/dependency&gt; 可以自定义RedisTemplate的序列化方式： 123456789101112131415161718192021@Configurationpublic class RedisConfig &#123; @Bean public RedisTemplate&lt;String, Object&gt; redisTemplate(RedisConnectionFactory redisConnectionFactory)&#123; //创建RedisTemplate RedisTemplate&lt;String,Object&gt; redisTemplate = new RedisTemplate&lt;&gt;(); //设置连接工厂 redisTemplate.setConnectionFactory(redisConnectionFactory); //设置json序列化 GenericJackson2JsonRedisSerializer gjjrs = new GenericJackson2JsonRedisSerializer(); //设置key的序列化 redisTemplate.setKeySerializer(RedisSerializer.string()); redisTemplate.setHashKeySerializer(RedisSerializer.string()); //设置value的序列化 redisTemplate.setValueSerializer(gjjrs); redisTemplate.setHashValueSerializer(gjjrs); return redisTemplate; &#125;&#125; 创建一个实体类： 123456789101112@Datapublic class User &#123; private String name; public Integer age; public User()&#123;&#125; public User(String name, Integer age) &#123; this.name = name; this.age = age; &#125;&#125; 进行测试： 123456@Testvoid testString() &#123; redisTemplate.opsForValue().set(&quot;demo:user:3&quot;,new User(&quot;dahuang&quot;,18)); User u = (User) redisTemplate.opsForValue().get(&quot;demo:user:3&quot;); System.out.println(&quot;u = &quot; + u);&#125; 控制台打印： 1u = User(name=dahuang, age=18) Redis中的数据： 12345&#123; &quot;@class&quot;: &quot;com.redis.pojo.User&quot;, &quot;name&quot;: &quot;dahuang&quot;, &quot;age&quot;: 18&#125; 3.6 StringRedisTemplate 尽管json的序列化方式可以满足需求，但仍然存在一些问题 为了在反序列化时知道对象的类型，json序列化器会将类的class类型写入json结果中，存入Redis，会带来额外的内存开销 为了节省空间，并不会使用json序列化器来处理value，而是统一使用String序列化器，要求只能存储String类型的key和value 当存储java对象时，手动完成对象的序列化和反序列化 graph LR; 实体类 --> |手动序列化|json字符串 --> |插入|Redis Redis -->|获取| json字符串 --> |手动反序列化|实体类 Spring默认提供了一个SpringRedisTemplate类，它的key和value的序列化方式默认就是String方式。省去了自定义RedisTemplate的过程： 12345678910111213141516171819202122@SpringBootTestpublic class StringRedisTemplateTest &#123; @Autowired private StringRedisTemplate stringRedisTemplate; //json工具 private static final ObjectMapper mapper = new ObjectMapper(); @Test void testStringTemplate() throws JsonProcessingException &#123; User user = new User(&quot;dahei&quot;, 22); //手动序列化 String json = mapper.writeValueAsString(user); //插入数据 stringRedisTemplate.opsForValue().set(&quot;demo:user:5&quot;,json); //获取数据 String val = stringRedisTemplate.opsForValue().get(&quot;demo:user:5&quot;); //手动反序列化 User u = mapper.readValue(val, User.class); //打印user System.out.println(&quot;u = &quot; + u); &#125;&#125; RedisTemplate的两种序列化实践方案： 方案一： 自定义RedisTemplate 修改RedisTemplate的序列化器为GenericJackson2JsonRedisSerializer 方案二： 使用StringRedisTemplate 写入Redis时，需手动把对象序列化为json 读取Redis时，手动把读取到的json反序列化为对象 3.7 RedisTemplate操作Hash类型12345678@Testvoid testHash() &#123; stringRedisTemplate.opsForHash().put(&quot;user:6&quot;,&quot;name&quot;,&quot;dahei&quot;); stringRedisTemplate.opsForHash().put(&quot;user:6&quot;,&quot;age&quot;,&quot;22&quot;); Map&lt;Object, Object&gt; entries = stringRedisTemplate.opsForHash().entries(&quot;user:6&quot;); System.out.println(&quot;entries = &quot; + entries);&#125; 实战篇 此项目为黑马点评，如需请到vx搜索黑马程序员获取资源 项目结构： application.yaml的配置： 123456789101112131415161718192021222324252627server: port: 8081spring: application: name: hmdp datasource: driver-class-name: com.mysql.jdbc.Driver url: jdbc:mysql://localhost:3306/hmdp?useSSL=false&amp;serverTimezone=UTC username: root password: 123456 redis: host: 127.0.0.1 port: 6379 password: 123456 lettuce: pool: max-active: 10 max-idle: 10 min-idle: 1 time-between-eviction-runs: 10s jackson: default-property-inclusion: non_null # JSON处理时忽略非空字段mybatis-plus: type-aliases-package: com.hmdp.entity # 别名扫描包logging: level: com.hmdp: debug 1.短信登录1.1 基于Session实现短信登录流程发送短信验证码： 短信验证码登录、注册： 校验登录状态： 1.2 实现发送短信验证码IUserService： 1234public interface IUserService extends IService&lt;User&gt; &#123; Result sendCode(String phone, HttpSession session);&#125; UserServiceImpl中实现sendCode方法： 12345678910111213141516@Overridepublic Result sendCode(String phone, HttpSession session) &#123; //校验手机号 if (RegexUtils.isPhoneInvalid(phone)) &#123; //不符合，返回错误信息 return Result.fail(&quot;手机号格式错误&quot;); &#125; //符合，生成验证码 String code = RandomUtil.randomNumbers(6); //保存验证码到Session session.setAttribute(&quot;code&quot;,code); //发送验证码，模拟一下 log.debug(&quot;发送验证码成功，验证码为：&quot;+code); //返回OK return Result.ok();&#125; UserController： 12345@PostMapping(&quot;code&quot;)public Result sendCode(@RequestParam(&quot;phone&quot;) String phone, HttpSession session) &#123; //发送短信验证码并保存验证码 return userService.sendCode(phone, session);&#125; 日志打印： 1发送验证码成功，验证码为：608824 1.3 实现短信验证登录与注册1234public interface IUserService extends IService&lt;User&gt; &#123; Result sendCode(String phone, HttpSession session); Result login(LoginFormDTO loginForm, HttpSession session);&#125; 1234567891011121314151617181920212223242526272829303132@Overridepublic Result login(LoginFormDTO loginForm, HttpSession session) &#123; //校验手机号 if (RegexUtils.isPhoneInvalid(loginForm.getPhone())) &#123; //不符合，返回错误信息 return Result.fail(&quot;手机号格式错误&quot;); &#125; //校验验证码 String code = (String) session.getAttribute(&quot;code&quot;); if (code == null || !code.equals(loginForm.getCode())) &#123; //不一致，返回错误信息 return Result.fail(&quot;验证码错误&quot;); &#125; //一致，查询手机号是否存在 User user = query().eq(&quot;phone&quot;, loginForm.getPhone()).one(); if (user == null) &#123; //不存在，插入到数据库，完成注册 user = createUserByPhone(loginForm.getPhone()); &#125; //保存用户到Session session.setAttribute(&quot;user&quot;,user); //每个session都有唯一的id，不需要登陆凭证 return Result.ok();&#125;private User createUserByPhone(String phone) &#123; User user = new User(); user.setPhone(phone); user.setNickName(USER_NICK_NAME_PREFIX + RandomUtil.randomNumbers(10)); save(user); return user;&#125; 12345@PostMapping(&quot;/login&quot;)public Result login(@RequestBody LoginFormDTO loginForm, HttpSession session)&#123; //实现登录功能 return userService.login(loginForm,session);&#125; 1.4 实现登录校验拦截器调用/user/me接口获取用户信息时，响应中包含了手机号、密码等敏感信息，并且发送的多余信息增加了服务器的压力。所以我们只需要用户昵称、头像和id等的部分信息。 定义一个UserDto： 123456@Datapublic class UserDTO &#123; private Long id; //id private String nickName;//昵称 private String icon;//头像&#125; 将UserServiceImpl的login方法中存入session的User转换成UserDto类型： 1session.setAttribute(&quot;user&quot;, BeanUtil.copyProperties(user, UserDTO.class)); 新建LoginInterceptor拦截器： 12345678910111213141516171819202122232425public class LoginInterceptor implements HandlerInterceptor &#123; @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; //获取session HttpSession session = request.getSession(); //获取用户信息 UserDTO user = (UserDTO) session.getAttribute(&quot;user&quot;); //不存在，拦截 if (user == null)&#123; //返回状态码401，未授权 response.setStatus(401); return false; &#125; //存在，保存到TheadLocal UserHolder.saveUser(user); //放行 return true; &#125; @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123; //移除用户 UserHolder.removeUser(); &#125;&#125; 新建MvcConfig配置类，添加拦截器并添加排序路径： 12345678910111213141516@Configurationpublic class MvcConfig implements WebMvcConfigurer &#123; @Override public void addInterceptors(InterceptorRegistry registry) &#123; registry.addInterceptor(new LoginInterceptor()) .excludePathPatterns( //排除路径 &quot;/user/login&quot;, &quot;/user/code&quot;, &quot;/shop/**&quot;, &quot;/shop-type/**&quot;, &quot;/blog/hot&quot;, &quot;/upload/**&quot;, &quot;/voucher/**&quot; ); &#125;&#125; UserController中实现获取用户信息： 123456@GetMapping(&quot;/me&quot;)public Result me()&#123; //获取当前登录的用户并返回 UserDTO user = UserHolder.getUser(); return Result.ok(user);&#125; 1.5 Session共享问题分析session共享问题：多台Tomcat不能共享session存储空间，当请求切换到不同的Tomcat服务器时导致数据对是问题 session的替代方案应该满足： 数据共享 内存存储 key、value结构 Redis都能解决以上问题，并且延时低 1.6 基于Redis实现共享Session登录流程发送短信验证码： 可以采用String数据类型存储： key value 手机号 验证码 短信验证登录、注册： 保存登录用户信息，可以使用String结构，以json字符串来保存，比较直观 Hash结构可以将对象中的每一个字段独立存储，可以针对单个字段做CRUD，并且内存占用少(推荐) 保存用户到Redis： key value 随机token为key存储用户数据 {name:Tom} 校验登录状态： 1.7 基于Redis实现短信登录*修改UserServiceImpl中的sendCode方法： 12345678910111213141516171819202122@Resourceprivate StringRedisTemplate stringRedisTemplate;@Overridepublic Result sendCode(String phone, HttpSession session) &#123; //校验手机号 if (RegexUtils.isPhoneInvalid(phone)) &#123; //不符合，返回错误信息 return Result.fail(&quot;手机号格式错误&quot;); &#125; //符合，生成验证码 String code = RandomUtil.randomNumbers(6); //保存验证码到Redis，设置有效期 stringRedisTemplate.opsForValue().set(RedisConstants.LOGIN_CODE_KEY +phone, //key code, //value RedisConstants.LOGIN_CODE_TTL, // 2 TimeUnit.MINUTES);//指定单位为分钟 //发送验证码，模拟一下 log.debug(&quot;发送验证码成功，验证码为：&quot;+code); //返回OK return Result.ok();&#125; 修改UserServiceImpl中的login方法： 1234567891011121314151617181920212223242526272829303132333435363738394041@Resourceprivate StringRedisTemplate stringRedisTemplate;@Overridepublic Result login(LoginFormDTO loginForm, HttpSession session) &#123; //校验手机号 if (RegexUtils.isPhoneInvalid(loginForm.getPhone())) &#123; //不符合，返回错误信息 return Result.fail(&quot;手机号格式错误&quot;); &#125; //校验验证码 String code = stringRedisTemplate.opsForValue().get(RedisConstants.LOGIN_CODE_KEY + loginForm.getPhone()); if (code == null || !code.equals(loginForm.getCode())) &#123; //不一致，返回错误信息 return Result.fail(&quot;验证码错误&quot;); &#125; //一致，查询手机号是否存在 User user = query().eq(&quot;phone&quot;, loginForm.getPhone()).one(); if (user == null) &#123; //不存在，插入到数据库，完成注册 user = createUserByPhone(loginForm.getPhone()); &#125; //随机生成登录令牌token， String token = UUID.randomUUID().toString(true); //将User对象转成UserDto在转换成Map数据类型 UserDTO userDTO = BeanUtil.copyProperties(user, UserDTO.class); //map数据类型的键值对都需要是String类型的 Map&lt;String, Object&gt; userMap = BeanUtil.beanToMap(userDTO, new HashMap&lt;&gt;(), CopyOptions.create().setIgnoreNullValue(true) //忽略空的值 .setFieldValueEditor((fieldName, fieldValue) -&gt; fieldValue.toString()));//所有value值转换为String //保存用户到Redis String key = RedisConstants.LOGIN_USER_KEY + token; stringRedisTemplate.opsForHash().putAll(key, userMap); //设置有效期30分钟 stringRedisTemplate.expire(key, //key RedisConstants.LOGIN_USER_TTL, // 30 TimeUnit.MINUTES); //分钟 //返回token return Result.ok(token); &#125; MVcConfig配置类中注入StringRedisTemplate： 12345678910111213141516171819@Configurationpublic class MvcConfig implements WebMvcConfigurer &#123; @Resource private StringRedisTemplate stringRedisTemplate; @Override public void addInterceptors(InterceptorRegistry registry) &#123; registry.addInterceptor(new LoginInterceptor(stringRedisTemplate)) .excludePathPatterns( //排除路径 &quot;/user/login&quot;, &quot;/user/code&quot;, &quot;/shop/**&quot;, &quot;/shop-type/**&quot;, &quot;/blog/hot&quot;, &quot;/upload/**&quot;, &quot;/voucher/**&quot; ); &#125;&#125; LoginInterceptor中获取Redis中的数据： 12345678910111213141516171819202122232425262728293031323334353637383940414243public class LoginInterceptor implements HandlerInterceptor &#123; private StringRedisTemplate stringRedisTemplate; public LoginInterceptor(StringRedisTemplate stringRedisTemplate) &#123; this.stringRedisTemplate = stringRedisTemplate; &#125; @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; //获取token，前端会将token放入到请求头中 String token = request.getHeader(&quot;authorization&quot;); if (StrUtil.isBlank(token)) &#123; //返回状态码401，未授权 response.setStatus(401); return false; &#125; //获取用户信息 Map&lt;Object, Object&gt; userMap = stringRedisTemplate.opsForHash().entries(RedisConstants.LOGIN_USER_KEY + token); //不存在，拦截 if (userMap.isEmpty())&#123; //返回状态码401，未授权 response.setStatus(401); return false; &#125; //将map转换成UserDto UserDTO user = BeanUtil.fillBeanWithMap(userMap,new UserDTO(),false); //存在，保存到TheadLocal UserHolder.saveUser(user); //刷新有效期 stringRedisTemplate.expire(RedisConstants.LOGIN_USER_KEY + token, //key RedisConstants.LOGIN_USER_TTL, // 30 TimeUnit.MINUTES); //分钟 //放行 return true; &#125; @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123; //移除用户 UserHolder.removeUser(); &#125;&#125; 1.8 解决状态登录刷新问题拦截器 获取token 查询Redis的用户信息 不存在，则拦截 存在，则继续 保存到ThreadLocal 刷新token的有效期 放行 拦截器只会拦截登录的路径，从而刷新token有效期。 但是其他的一些不需要登录也可以查看的页面，比如首页，则不会刷新token有效期。 有可能长时间查看其他页面，导致在查看需要登录的路径，token过了有效期，需要重新登录的问题 sequenceDiagram 用户-->>拦截器1:发送请求 note over 拦截器1:拦截一切路径1. 获取token2. 查询Redis的用户3. 保存到ThreadLocal4. 刷新token的有效期5. 放行 拦截器1->>拦截器2:进入 note over 拦截器2:拦截需要登录的路径查看token存在，则拦截不存在，则继续 拦截器2->>UserController:进入 RefreshTokenInterceptor中： 12345678910111213141516171819202122232425262728293031323334353637383940public class RefreshTokenInterceptor implements HandlerInterceptor &#123; private StringRedisTemplate stringRedisTemplate; public RefreshTokenInterceptor(StringRedisTemplate stringRedisTemplate) &#123; this.stringRedisTemplate = stringRedisTemplate; &#125; @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; //获取token String token = request.getHeader(&quot;authorization&quot;); //token不存在，直接放行，不添加到ThreadLocal if (StrUtil.isBlank(token)) &#123; return true; &#125; //获取用户信息 Map&lt;Object, Object&gt; userMap = stringRedisTemplate.opsForHash().entries(RedisConstants.LOGIN_USER_KEY + token); //用户信息不存在，直接放行，不添加到ThreadLocal if (userMap.isEmpty())&#123; return true; &#125; //将map转换成UserDto UserDTO user = BeanUtil.fillBeanWithMap(userMap,new UserDTO(),false); //保存到TheadLocal UserHolder.saveUser(user); //刷新有效期 stringRedisTemplate.expire(RedisConstants.LOGIN_USER_KEY + token, //key RedisConstants.LOGIN_USER_TTL, // 30 TimeUnit.MINUTES); //分钟 //放行 return true; &#125; @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123; //移除用户 UserHolder.removeUser(); &#125;&#125; LoginInterceptor中： 1234567891011121314public class LoginInterceptor implements HandlerInterceptor &#123; @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; //判断ThreadLocal是否存在用户 if (UserHolder.getUser() == null)&#123; //没有，拦截，设置状态码 response.setStatus(401); return false; &#125; //有用户放行 return true; &#125;&#125; MvcConfig配置类中： 123456789101112131415161718192021222324@Configurationpublic class MvcConfig implements WebMvcConfigurer &#123; @Resource private StringRedisTemplate stringRedisTemplate; @Override public void addInterceptors(InterceptorRegistry registry) &#123; //token刷新拦截器 registry.addInterceptor(new RefreshTokenInterceptor(stringRedisTemplate)) .addPathPatterns(&quot;/**&quot;) //拦截所有路径 .order(0); // 注册顺序为0 //登录拦截器 registry.addInterceptor(new LoginInterceptor()) .excludePathPatterns( //排除路径 &quot;/user/login&quot;, &quot;/user/code&quot;, &quot;/shop/**&quot;, &quot;/shop-type/**&quot;, &quot;/blog/hot&quot;, &quot;/upload/**&quot;, &quot;/voucher/**&quot; ).order(1); //注册顺序为1 &#125;&#125; 2.商户查询缓存3.达人探店4.优惠券秒杀5.好友关注6.附近的商户7.用户签到8.UV统计高级篇原理篇st=>start: 开始 op=>operation: 提交手机号 cond=>condition: 校验手机号 code=>operation: 生成验证码 save=>operation: 验证码保存到Session send=>operation: 发送验证码 e=>end: 结束 st->op->cond(yes)->code->save->send->e cond(no)->op{\"scale\":1,\"line-width\":2,\"line-length\":50,\"text-margin\":10,\"font-size\":12} var code = document.getElementById(\"flowchart-0-code\").value; var options = JSON.parse(decodeURIComponent(document.getElementById(\"flowchart-0-options\").value)); var diagram = flowchart.parse(code); diagram.drawSVG(\"flowchart-0\", options);st=>start: 开始 op=>operation: 提交手机号和验证码 cond1=>condition: 校验验证码 code=>operation: 根据手机号查询用户 cond2=>condition: 用户是否存在 login=>operation: 登录 register=>operation: 创建新用户 save1=>operation: 保存用户到Session save2=>operation: 保存用户到数据库 e=>end: 结束 st->op->cond1(yes)->code->cond2(yes)->login->save1->e cond1(no)->op cond2(no)->register->save2->save1{\"scale\":1,\"line-width\":2,\"line-length\":50,\"text-margin\":10,\"font-size\":12} var code = document.getElementById(\"flowchart-1-code\").value; var options = JSON.parse(decodeURIComponent(document.getElementById(\"flowchart-1-options\").value)); var diagram = flowchart.parse(code); diagram.drawSVG(\"flowchart-1\", options);st=>start: 开始 op=>operation: 请求并携带cookie get=>operation: 从Session获取用户 cond=>condition: 判断用户是否存在 save=>operation: 保存用户到TreadLocal pass=>operation: 放行 intercept=>operation: 拦截 e=>end: 结束 st->op->get->cond(yes)->save->pass->e cond(no)->intercept->e{\"scale\":1,\"line-width\":2,\"line-length\":50,\"text-margin\":10,\"font-size\":12} var code = document.getElementById(\"flowchart-2-code\").value; var options = JSON.parse(decodeURIComponent(document.getElementById(\"flowchart-2-options\").value)); var diagram = flowchart.parse(code); diagram.drawSVG(\"flowchart-2\", options);st=>start: 开始 op=>operation: 提交手机号 cond=>condition: 校验手机号 code=>operation: 生成验证码 save=>operation: 验证码保存到Redis send=>operation: 发送验证码 e=>end: 结束 st->op->cond(yes)->code->save->send->e cond(no)->op{\"scale\":1,\"line-width\":2,\"line-length\":50,\"text-margin\":10,\"font-size\":12} var code = document.getElementById(\"flowchart-3-code\").value; var options = JSON.parse(decodeURIComponent(document.getElementById(\"flowchart-3-options\").value)); var diagram = flowchart.parse(code); diagram.drawSVG(\"flowchart-3\", options);st=>start: 开始 op=>operation: 提交手机号和验证码 cond1=>condition: 校验验证码 code=>operation: 根据手机号查询用户 cond2=>condition: 用户是否存在 login=>operation: 登录 register=>operation: 创建新用户 save1=>operation: 保存用户到Redis save2=>operation: 保存用户到数据库 back=>operation: 返回token给客户端 e=>end: 结束 st->op->cond1(yes)->code->cond2(yes)->login->save1->back->e cond1(no)->op cond2(no)->register->save2->save1{\"scale\":1,\"line-width\":2,\"line-length\":50,\"text-margin\":10,\"font-size\":12} var code = document.getElementById(\"flowchart-4-code\").value; var options = JSON.parse(decodeURIComponent(document.getElementById(\"flowchart-4-options\").value)); var diagram = flowchart.parse(code); diagram.drawSVG(\"flowchart-4\", options);st=>start: 开始 op=>operation: 请求并携带token get=>operation: 从Redis获取用户 cond=>condition: 判断用户是否存在 save=>operation: 保存用户到TreadLocal pass=>operation: 放行 intercept=>operation: 拦截 e=>end: 结束 st->op->get->cond(yes)->save->pass->e cond(no)->intercept->e{\"scale\":1,\"line-width\":2,\"line-length\":50,\"text-margin\":10,\"font-size\":12} var code = document.getElementById(\"flowchart-5-code\").value; var options = JSON.parse(decodeURIComponent(document.getElementById(\"flowchart-5-options\").value)); var diagram = flowchart.parse(code); diagram.drawSVG(\"flowchart-5\", options);","categories":[{"name":"Java","slug":"Java","permalink":"http://example.com/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"},{"name":"框架","slug":"框架","permalink":"http://example.com/tags/%E6%A1%86%E6%9E%B6/"}]},{"title":"(每日LeetCode)556. 下一个更大元素 III","slug":"每日LeetCode/2022-7/556 下一个更大元素 III","date":"2022-07-03T04:00:00.000Z","updated":"2022-07-08T00:35:35.528Z","comments":true,"path":"2022/07/03/每日LeetCode/2022-7/556 下一个更大元素 III/","link":"","permalink":"http://example.com/2022/07/03/%E6%AF%8F%E6%97%A5LeetCode/2022-7/556%20%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%9B%B4%E5%A4%A7%E5%85%83%E7%B4%A0%20III/","excerpt":"","text":"题目：给你一个正整数 n ，请你找出符合条件的最小整数，其由重新排列 n 中存在的每位数字组成，并且其值大于 n 。如果不存在这样的正整数，则返回 -1 。 注意 ，返回的整数应当是一个 32 位整数 ，如果存在满足题意的答案，但不是 32 位整数 ，同样返回 -1。 示例：示例 1： 输入：n &#x3D; 12324321输出：12331224 示例 2： 输入：n &#x3D; 21输出：-1 思路：以n = 12324321为例 ①.pos1指针从后往前遍历，找到第pos1位置的数比后面的数小的位置，pos1记录位置 1 2 3 2 4 3 2 1 $\\leftarrow\\Uparrow$pos1 2与1比较，2大，pos1向左移 循环直到： 1 2 3 2 4 3 2 1 $\\leftarrow\\Uparrow$pos1 2与4比较，2小，记录pos1的位置 ②.再定义pos2指针，从后往前遍历，找到比pos1位置后面的数中，有比pos1位置的数大的数，用pos2记录位置 1 2 3 2 4 3 2 1 $\\Uparrow$pos1 $\\leftarrow\\Uparrow$pos2 pos1大于pos2，pos2指针左移 循环直到： 1 2 3 2 4 3 2 1 $\\Uparrow$pos1 $\\leftarrow\\Uparrow$pos2 pos1小于pos2，记录指针pos2位置 ③.交换pos1和pos2的位置 1 2 3 3 4 2 2 1 ④.将pos1位置后面的数进行反转 1 2 3 3 1 2 2 4 结果：12331224 代码(cpp)：12345678910111213141516171819202122232425262728class Solution &#123;public: int nextGreaterElement(int n) &#123; //将n转换成字符串 string num = to_string(n); int pos1 = num.size()-2; //从后往前遍历，找到前面的数小于后面的数，前面数的位置 while(pos1 &gt;= 0 &amp;&amp; num[pos1] &gt;= num[pos1+1])&#123; pos1--; &#125; //遍历到字符串第0个位置，还没有小于的数，则不存在 if(pos1 &lt; 0) return -1; int pos2 = num.size()-1; //从后往前遍历，找到有比pos1位置的数小的数，返回pos2位置 while(pos2 &gt; pos1 &amp;&amp; num[pos1] &gt;= num[pos2])&#123; pos2--; &#125; //交换两个位置的数 swap(num[pos1],num[pos2]); //将pos1后面的字符串反转 reverse(num.begin() + pos1 + 1, num.end()); //防止溢出，先将temp转换成long型 long temp = stol(num); //如果超出int的范围，返回-1 if(temp &gt; INT_MAX) return -1; return temp; &#125;&#125;; 复杂度分析： 时间复杂度：O(logn)。 空间复杂度：O(logn)。","categories":[{"name":"每日LeetCode","slug":"每日LeetCode","permalink":"http://example.com/categories/%E6%AF%8F%E6%97%A5LeetCode/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"},{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"(每日LeetCode)871. 最低加油次数","slug":"每日LeetCode/2022-7/871 最低加油次数","date":"2022-07-02T07:36:00.000Z","updated":"2022-07-08T00:35:45.486Z","comments":true,"path":"2022/07/02/每日LeetCode/2022-7/871 最低加油次数/","link":"","permalink":"http://example.com/2022/07/02/%E6%AF%8F%E6%97%A5LeetCode/2022-7/871%20%E6%9C%80%E4%BD%8E%E5%8A%A0%E6%B2%B9%E6%AC%A1%E6%95%B0/","excerpt":"","text":"题目：汽车从起点出发驶向目的地，该目的地位于出发位置东面 target 英里处。 沿途有加油站，每个 station[i] 代表一个加油站，它位于出发位置东面 station[i][0] 英里处，并且有 station[i][1]升汽油。 假设汽车油箱的容量是无限的，其中最初有startFuel升燃料。它每行驶 1 英里就会用掉 1 升汽油。 当汽车到达加油站时，它可能停下来加油，将所有汽油从加油站转移到汽车中。 为了到达目的地，汽车所必要的最低加油次数是多少？如果无法到达目的地，则返回 -1 。 注意：如果汽车到达加油站时剩余燃料为 0，它仍然可以在那里加油。如果汽车到达目的地时剩余燃料为 0，仍然认为它已经到达目的地。 示例：示例1： 输入：target &#x3D; 100, startFuel &#x3D; 1, stations &#x3D; [[10,100]]输出：-1解释：我们无法抵达目的地，甚至无法到达第一个加油站。 示例2： 输入：target &#x3D; 100, startFuel &#x3D; 10, stations &#x3D; [[10,60],[20,30],[30,30],[60,40]]输出：2解释：我们出发时有 10 升燃料。我们开车来到距起点 10 英里处的加油站，消耗 10 升燃料。将汽油从 0 升加到 60 升。然后，我们从 10 英里处的加油站开到 60 英里处的加油站（消耗 50 升燃料），并将汽油从 10 升加到 50 升。然后我们开车抵达目的地。我们沿途在1两个加油站停靠，所以返回 2 。 思路： 一、回溯法代码(cpp)：123456789101112131415161718192021222324252627282930class Solution &#123;public: int def(vector&lt;vector&lt;int&gt;&gt;&amp; stations,int cur_station, int begin, int&amp; end, int oil)&#123; //到达目的地 if(oil+begin &gt;= end) return 0; //油量不够到达目的地 if(cur_station+1 == stations.size() &amp;&amp; oil+begin &lt; end)&#123; return -1; &#125; //油量不够到达下一个加油站 if(cur_station+1 &lt; stations.size() &amp;&amp; oil+begin &lt; stations[cur_station+1][0])&#123; return -1; &#125; int ans = INT_MAX; for(int i = cur_station+1; i &lt; stations.size(); i++)&#123; if(stations[i][0] &lt;= begin+oil)&#123; int temp = def(stations, i, stations[i][0] ,end ,oil+begin-stations[i][0]+stations[i][1]); if(temp != -1 &amp;&amp; ans &gt; temp+1) ans = temp+1; &#125; &#125; if(ans == INT_MAX) ans = -1; return ans; &#125; int minRefuelStops(int target, int startFuel, vector&lt;vector&lt;int&gt;&gt;&amp; stations) &#123; //出发地没有加油站，第一个加油站编号为0，所以初始化为-1 return def(stations, -1, 0, target, startFuel); &#125;&#125;; 运行超时 二、贪心思路：如果不需要加油就往前走，当不够到达下一个加油站或目的地，就从之前走到过的加油站之中选择汽油量最多的加油站进行补充汽油。 以此往复，到达目的地。 如果所有加油站的汽油都被加完，并且没到达目的地，则不可能到达。 代码(cpp)：1234567891011121314151617181920212223242526272829303132class Solution &#123;public: int minRefuelStops(int target, int startFuel, vector&lt;vector&lt;int&gt;&gt;&amp; stations) &#123; priority_queue&lt;int&gt; pq; int count = 0; //初始化加油次数 int begin = 0; //初始化路程 int cur_fuel = startFuel;//初始化车的汽油量 int cur_distance; //表示当前的路程 for (int i = 0; i &lt;= stations.size(); i++) &#123; if(i &lt; stations.size()) cur_distance = stations[i][0]; else cur_distance = target; //(cur_distance - begin)：表示第i-1个加油站到第i个加油站之间的路程，cur_fuel为到第i个加油站时剩余的油量 cur_fuel -= cur_distance - begin; //如果油量为负数，说明需要从第i个加油站，之前的加油站之中选择加油量最多的加油站，进行补充汽油 while (cur_fuel &lt; 0 &amp;&amp; !pq.empty()) &#123; cur_fuel += pq.top();//选择汽油量最多的加油站补充 pq.pop(); count++;//加油次数加1 &#125; //都已经把之前的加油站的汽油都补充了，还是负数说明无法到达下一个加油站或目的地 if (cur_fuel &lt; 0) &#123; return -1; &#125; if (i &lt; stations.size()) &#123; //将第i个加油站的汽油量记录，现在不需要加油，等以后缺油再加 pq.emplace(stations[i][1]); begin = cur_distance;//更新路程 &#125; &#125; return count; &#125;&#125;; 复杂度分析： 时间复杂度：O(nlogn)，其中 n 是数组 stations 的长度。需要遍历数组 stations 一次，每个加油站的汽油量最多添加到优先队列和从优先队列中移除各一次，每次优先队列的操作需要 O(logn) 的时间，因此时间复杂度是 O(nlogn)。 空间复杂度：O(n)，其中 n 是数组 stations 的长度。优先队列需要 O(n) 的空间。","categories":[{"name":"每日LeetCode","slug":"每日LeetCode","permalink":"http://example.com/categories/%E6%AF%8F%E6%97%A5LeetCode/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"},{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"vector容器用法","slug":"C++/vecter容器","date":"2022-06-30T09:00:00.000Z","updated":"2022-07-05T03:52:02.168Z","comments":true,"path":"2022/06/30/C++/vecter容器/","link":"","permalink":"http://example.com/2022/06/30/C++/vecter%E5%AE%B9%E5%99%A8/","excerpt":"","text":"vector是什么？vector是一个能够存放任意类型的动态数组。 vector实现动态增长的原理：vector的原理就是动态数组。当插入新元素的时候，如果空间不足，那么vector会重新申请更大的一块空间，将原空间数据拷贝到新空间，释放旧空间数据，再把新元素插入新申请空间。 需要导入头文件： 12#include&lt;vector&gt;using namespace std; 构造函数： 构造函数 解释 vector() 创建一个空的vector vector(int size) 创建一个vector,元素个数为size，且值均为0(默认为0) vector(int size, T value) 创建一个vector，元素个数为size,且值均为value vector(const vector&amp; v) 另一个vector容器拷贝到这个vector中 vector(iterator begin(), iterator end()) 另一个[begin,end)区间内的数组元素的复制这个vector中 成员函数： 插入函数 解释 void push_back(const T&amp; x) 容器尾部插入一个元素X void emplace_back(const T&amp; x) 容器尾部插入一个元素X，比push_back()效率高 iterator insert(iterator it,const T&amp; x) 容器中迭代器指向元素的前面插入一个元素x iterator insert(iterator it,int n,const T&amp; x) 容器中迭代器指向元素的前面插入n个相同的元素x iterator insert(iterator it,const_iterator first,const_iterator last) 向量中迭代器指向元素的前面插入另一个相同类型的vector容器的[first,last)间的数据 删除函数 解释 iterator erase(iterator it) 删除容器中迭代器指向的元素 iterator erase(iterator first,iterator last) 删除容器中[first,last)中的元素 void pop_back() 删除容器中最后一个元素 void clear() 清空容器中所有元素 遍历函数 解释 T at(int pos) 返回pos位置的元素(第一个位置为0) T front() 返回首元素 T back() 返回尾元素 iterator begin() 返回vector容器中指向的第一个元素的迭代器 iterator end() 返回vector容器中指向最后一个元素的下一个位置的迭代器 reverse_iterator rbegin() 反向迭代器，指向容器中最后一个元素 reverse_iterator rend() 反向迭代器，指向容器第一个元素前面的位置 大小函数 解释 int size() 返回vector容器中元素的个数 int capacity() 返回当前vector容器所能容纳的最大容量 int max_size() 返回vector容器的最大可允许的容量 void resize(int size) 更改vector容器的元素的个数为size void reserve(int capacity) 更改vector容器的容量为capacity 赋值函数 解释 vector&amp; operator&#x3D; 将右边vector容器的元素拷贝到左边vector容器中 void assign(int n,const T&amp; x) 设置容器中前n个元素的值为x void assign(const_iterator first,const_iterator last) 将另一个vector容器中[first,last)中元素设置成当前vector容器的元素 其他函数 解释 bool empty() 判断向量是否为空，若为空，则返回真 void swap(vector&amp; v) 将两个同类型vector容器的元素互换 vector的遍历：123for(int i = 0; i &lt; v.size(); i++)&#123; cout &lt;&lt; v[i] &lt;&lt; endl;&#125; 123for (int i = 0; i &lt; v.size(); i++)&#123; cout &lt;&lt; v1.at(i) &lt;&lt; endl;&#125; 123for (vector&lt;int&gt;::iterator it = v.begin(); it != v.end(); it++)&#123; cout &lt;&lt; *it &lt;&lt; endl;&#125; 123for (auto it = v.begin(); it != v.end(); it++)&#123; cout &lt;&lt; *it &lt;&lt; endl;&#125;","categories":[{"name":"C++","slug":"C","permalink":"http://example.com/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"},{"name":"容器","slug":"容器","permalink":"http://example.com/tags/%E5%AE%B9%E5%99%A8/"},{"name":"STL","slug":"STL","permalink":"http://example.com/tags/STL/"}]},{"title":"(每日LeetCode)1175. 质数排列","slug":"每日LeetCode/2022-6/1175 质数排列","date":"2022-06-30T03:09:00.000Z","updated":"2022-07-08T00:35:49.057Z","comments":true,"path":"2022/06/30/每日LeetCode/2022-6/1175 质数排列/","link":"","permalink":"http://example.com/2022/06/30/%E6%AF%8F%E6%97%A5LeetCode/2022-6/1175%20%E8%B4%A8%E6%95%B0%E6%8E%92%E5%88%97/","excerpt":"","text":"题目：请你帮忙给从 1 到 n 的数设计排列方案，使得所有的「质数」都应该被放在「质数索引」（索引从 1 开始）上；你需要返回可能的方案总数。由于答案可能会很大，所以请你返回答案 模 mod $10^9$ + 7 之后的结果即可。 示例： 输入：n &#x3D; 5输出：12 解释： 先看质数定义：一个大于1的自然数，除了1和它自身外，不能被其他自然数整除的数叫做质数。(1不是质数) 用红色标记质数： 1 2 3 4 5 题目的意思是将质数和非质数各分一组，进行排序一共有多少种可能： m个数排列m个位置，全排列公式：$A^m_m&#x3D;m!$ $A^3_3$为质数的所有排列次数 $A^2_2$为非质数的所有排列次数 并且每有一个质数的排列组合就有$A^2_2$次非质数的排列： 总数：$A^3_3 \\times A^2_2&#x3D;3! \\times 2!&#x3D;12$ 思路：遍历数组判断是否为质数，记录质数的个数p，非质数个数为n-p 运用公式求出总数：$A^p_p \\times A^{n-p}_{n-p}&#x3D;p! \\times (n-p)!$ 代码(cpp)：123456789101112131415161718192021222324252627282930313233343536373839class Solution &#123;public: int mod = pow(10,9)+7; //判断是否为质数 bool is_prime(int n)&#123; //从2开始 for(int i = 2; i*i &lt;= n;i++)&#123; //模运算为0，不是质数 if(n%i == 0)&#123; return false; &#125; &#125; return true; &#125; //n!运算 Long类型防止溢出 long factorial(int n)&#123; long sum = 1; for(int i = 2; i &lt;= n; i++)&#123; sum *=i; sum = sum%mod; &#125; return sum; &#125; int numPrimeArrangements(int n) &#123; int prime_num = 0; //从2开始，1不是质数 for(int i = 2; i &lt;= n; i++)&#123; if(is_prime(i))&#123; prime_num++; &#125; &#125; //n!*(n-p)! long result = (factorial(prime_num)*factorial(n-prime_num))%mod; return (int)result; &#125;&#125;; 复杂度分析： 时间复杂度：O($n^{3&#x2F;2}$)。求 n 个数中质数个数的时间复杂度为 O($n^{3&#x2F;2}$)，阶乘的时间复杂度为 O(n)，总的时间复杂度为 O($n^{3&#x2F;2}$)。 空间复杂度：O(1)O(1)，只使用了常数空间。","categories":[{"name":"每日LeetCode","slug":"每日LeetCode","permalink":"http://example.com/categories/%E6%AF%8F%E6%97%A5LeetCode/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"},{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"(每日LeetCode)535. TinyURL的加密与解密","slug":"每日LeetCode/2022-6/535 TinyURL的加密与解密","date":"2022-06-28T23:41:00.000Z","updated":"2022-07-02T07:51:52.081Z","comments":true,"path":"2022/06/29/每日LeetCode/2022-6/535 TinyURL的加密与解密/","link":"","permalink":"http://example.com/2022/06/29/%E6%AF%8F%E6%97%A5LeetCode/2022-6/535%20TinyURL%E7%9A%84%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%A7%A3%E5%AF%86/","excerpt":"","text":"题目：TinyURL 是一种 URL 简化服务， 比如：当你输入一个 URL https://leetcode.com/problems/design-tinyurl 时，它将返回一个简化的URL http://tinyurl.com/4e9iAk 。请你设计一个类来加密与解密 TinyURL 。 加密和解密算法如何设计和运作是没有限制的，你只需要保证一个 URL 可以被加密成一个 TinyURL ，并且这个 TinyURL 可以用解密方法恢复成原本的 URL 。 实现 Solution 类： Solution() 初始化 TinyURL 系统对象。String encode(String longUrl) 返回 longUrl 对应的 TinyURL 。String decode(String shortUrl) 返回 shortUrl 原本的 URL 。题目数据保证给定的 shortUrl 是由同一个系统对象加密的。 示例： 输入：url &#x3D; “https://leetcode.com/problems/design-tinyurl“输出：”https://leetcode.com/problems/design-tinyurl“ 解释：Solution obj &#x3D; new Solution();string tiny &#x3D; obj.encode(url); &#x2F;&#x2F; 返回加密后得到的 TinyURL 。string ans &#x3D; obj.decode(tiny); &#x2F;&#x2F; 返回解密后得到的原本的 URL 。 思路：使用自增id作为longUrl的键，存入unordered_map容器中 根据id来获取对应的longUrl 代码(cpp)：1234567891011121314151617181920212223class Solution &#123;private: unordered_map&lt;int, string&gt; map; int id;public: Solution()&#123; id = 0; //初始化id &#125; string encode(string longUrl) &#123; id++; map[id] = longUrl; //http://tinyurl.com/1 return &quot;http://tinyurl.com/&quot;+to_string(id); &#125; string decode(string shortUrl) &#123; //substr(int pos)：获取pos位置起的所有字符串 //stoi(string str)：将string类型的字符串转换成int类型的整数 int t_id = stoi(shortUrl.substr(19)); return map[t_id]; &#125;&#125;; 复杂度分析： 时间复杂度： Encode 函数：O(n)O(n)，其中 n 是字符串 longUrl 的长度。 Decode 函数：O(1)O(1)。我们把 shortUrl 当成有限长度的字符串看待。 空间复杂度： Encode 函数：O(n)O(n)。保存字符串 longUrl 需要 O(n)O(n) 的空间。 Decode 函数：O(1)O(1)。","categories":[{"name":"每日LeetCode","slug":"每日LeetCode","permalink":"http://example.com/categories/%E6%AF%8F%E6%97%A5LeetCode/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"},{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"SpringMVC框架的学习笔记","slug":"Java/SpringMCV框架","date":"2022-06-28T14:02:54.299Z","updated":"2022-07-07T06:25:56.557Z","comments":true,"path":"2022/06/28/Java/SpringMCV框架/","link":"","permalink":"http://example.com/2022/06/28/Java/SpringMCV%E6%A1%86%E6%9E%B6/","excerpt":"","text":"1.初认SpringMVC1.1 SpringMVC简介 SpringMVC技术与Servlet技术功能等同，均属于web层开发技术 SpringMVC是一种基于java实现MVC模型的轻量级Web框架 优点： 使用简单，开发便捷(相比与Servlet) 灵活性强 项目结构： 1.2 SpringMVC入门1.使用SpringMVC技术需要先导入SpringMVC坐标与Servlet 不需要导入spring-context包，spring-webmvc包中包含spring-context包 2.导入Tomcat插件 12345678910111213141516171819202122232425&lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;version&gt;3.1.0&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;!-- 和Tomcat有冲突 --&gt; &lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;5.2.10.RELEASE&lt;/version&gt; &lt;/dependency&gt;&lt;!--Tomcat插件--&gt;&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.tomcat.maven&lt;/groupId&gt; &lt;artifactId&gt;tomcat7-maven-plugin&lt;/artifactId&gt; &lt;version&gt;2.1&lt;/version&gt; &lt;configuration&gt; &lt;port&gt;8888&lt;/port&gt; &lt;!--端口可任意只要没有被占用--&gt; &lt;path&gt;/&lt;/path&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; 3.创建SpringMVC控制器类(等同于Servlet功能) 1234567891011@Controllerpublic class UserController &#123; //设置当前控制器方法的请求路径 @RequestMapping(&quot;/save&quot;) //设置当前控制器方法响应内容为当前返回值，无需解析 @ResponseBody public String save()&#123; System.out.println(&quot;user is saving~~&quot;); return &quot;&#123;&#x27;info&#x27;:&#x27;springmvc&#x27;&#125;&quot;; &#125;&#125; 4.初始化SpringMVC环境(同Spring环境)，设定SpringMVC加载对应的bean 12345//创建SpringMVC的配置文件，加载controller对应的bean@Configuration@ComponentScan(&quot;com.springmvc.controller&quot;)public class SpringMvcConfig &#123;&#125; 5.初始化Servlet容器，加载SpringMVC环境，并设置SpringMVC技术处理的请求 123456789101112131415161718192021//定义一个servlet容器启动的配置类，在里面加载Spring的配置public class ServletContainerInitConfig extends AbstractDispatcherServletInitializer &#123; //加载SpringMVC容器的配置 @Override protected WebApplicationContext createServletApplicationContext() &#123; AnnotationConfigWebApplicationContext acwac = new AnnotationConfigWebApplicationContext(); acwac.register(SpringMvcConfig.class); return acwac; &#125; //设定SpringMVC对应的请求的映射路径 @Override protected String[] getServletMappings() &#123; //设置为/表示拦截所有请求，任意请求都将转入到SpringMVC中进行处理 return new String[]&#123;&quot;/&quot;&#125;; &#125; //加载Spring容器配置，现在不需要 @Override protected WebApplicationContext createRootApplicationContext() &#123; return null; &#125;&#125; 右键找到Run Maven再找到tomcat7:run点击运行，打开浏览器打开http://localhost:8888/save 页面即可出现内容： 1&#123;&#x27;info&#x27;:&#x27;springmvc&#x27;&#125; 此时控制台打印出： 1user is saving~~ 1.3 入门总结 SpringMVC入门程序开发总结(1+N) 一次性工作 创建工程, 设置服务器，加载工程 导入坐标 创建web容器启动类, 加载SpringMVC配置， 并设置SpringMVC请求拦截路径 SpringMVC核心配置类 (设置配置类,扫描controller包, 加载Controller控制器bean) 多次工作 定义处理请求的控制器类 定义处理请求的控制器方法， 并配置映射路径@RequestMapping与返回json数据@ResponseBody 1.4 工作流程入门案例工作流程分析 启动服务器初始化过程 服务器启动, 执行ServletContainersInitConfig类,初始化web容器 执行createServletApplicationContext方法，创建了WebApplicationContext对象 加载SpringMvcConfig配置文件 执行@ComponentScan加载对应的bean 加载UserController, 每个@RequestMapping的名称对应一 个具体的方法 执行getServletMappings方法, 定义所有的请求都通过SpringMVC 单次请求过程 发送请求http:localhost:8888/save web容器发现所有请求都经过SpringMVC, 将请求交给SpringMVC处理 解析请求路径&#x2F;save 由&#x2F;save匹配执行对应的方法save() 执行save() 检测到有@ResponseBody直接将save()方法的返回值作为响应求体返回给请求方 1.5 bean加载控制 com springmvc config controller service dao Controller加载控制业务与业务bean加载控制 SpringMVC相关bean 表现层bean(Controller) Spring控制的bean 业务bean(Service) 功能bean(DataSourse等) SpringMVC相关的bean加载控制 SpringMVC加载的bean对应的包均在com.springnvc.controller包内 Spring相关bean加载控制 Spring加载的bean设定范围为com.springmvc，排除controller包内的bean Spring加载的bean设定范围为精准范围，如：com.springmvc.dao、com.springmvc.service等(常用) 不区分Spring与SpringMVC的环境，加载到同一个环境中 方式一(常用)： 1234@Configuration@ComponentScan(&#123;&quot;com.springmvc.dao&quot;,&quot;com.springmvc.service&quot;&#125;)public class SpringConfig &#123;&#125; 方式二： 123456789@Configuration@ComponentScan(value = &quot;com.springmvc&quot;, excludeFilters = @ComponentScan.Filter( type = FilterType.ANNOTATION, //按照注解排除 classes = Controller.class //需要排除的注解类型 ))public class SpringConfig &#123;&#125; 加载SpringMVC和Spring配置 123456789101112131415161718192021public class ServletContainerInitConfig extends AbstractDispatcherServletInitializer &#123; //加载SpringMVC配置 @Override protected WebApplicationContext createServletApplicationContext() &#123; AnnotationConfigWebApplicationContext acwac = new AnnotationConfigWebApplicationContext(); acwac.register(SpringMvcConfig.class); return acwac; &#125; @Override protected String[] getServletMappings() &#123; return new String[]&#123;&quot;/&quot;&#125;; &#125; //加载SpringMVC配置 @Override protected WebApplicationContext createRootApplicationContext() &#123; AnnotationConfigWebApplicationContext acwac = new AnnotationConfigWebApplicationContext(); acwac.register(SpringConfig.class); return acwac; &#125;&#125; 简化操作(常用)： 1234567891011121314151617public class ServletContainerInitConfig extends AbstractAnnotationConfigDispatcherServletInitializer &#123; @Override protected Class&lt;?&gt;[] getRootConfigClasses() &#123; return new Class[]&#123;SpringConfig.class&#125;; &#125; @Override protected Class&lt;?&gt;[] getServletConfigClasses() &#123; return new Class[]&#123;SpringMvcConfig.class&#125;; &#125; @Override protected String[] getServletMappings() &#123; return new String[]&#123;&quot;/&quot;&#125;; &#125;&#125; 2.请求与响应2.1 请求映射路径项目结构： BookController： 123456789@Controllerpublic class BookController &#123; @RequestMapping(&quot;/save&quot;) @ResponseBody public String save()&#123; System.out.println(&quot;book is saving~~&quot;); return &quot;&#123;&#x27;info&#x27;:&#x27;springmvc&#x27;&#125;&quot;; &#125;&#125; UserController： 123456789@Controllerpublic class UserController &#123; @RequestMapping(&quot;/save&quot;) @ResponseBody public String save()&#123; System.out.println(&quot;user is saving~~&quot;); return &quot;&#123;&#x27;info&#x27;:&#x27;springmvc&#x27;&#125;&quot;; &#125;&#125; 运行程序后报错，无法启动。 因为路径都为/save的话，在网页请求/save，程序会不知道调用哪个控制器方法 改进： BookController： 123456789@Controllerpublic class BookController &#123; @RequestMapping(&quot;/book/save&quot;) @ResponseBody public String save()&#123; System.out.println(&quot;book is saving~~&quot;); return &quot;&#123;&#x27;info&#x27;:&#x27;springmvc&#x27;&#125;&quot;; &#125;&#125; UserController： 123456789@Controllerpublic class UserController &#123; @RequestMapping(&quot;/user/save&quot;) @ResponseBody public String save()&#123; System.out.println(&quot;user is saving~~&quot;); return &quot;&#123;&#x27;info&#x27;:&#x27;springmvc&#x27;&#125;&quot;; &#125;&#125; 还可以更加精简，增加模块的请求路径前缀： @RequestMapping注解： 设置在控制器方法上：请求访问路径 设置在类上：统一设置当前类中控制器方法请求路径前缀 BookController： 12345678910@Controller@RequestMapping(&quot;/book&quot;)public class BookController &#123; @RequestMapping(&quot;/save&quot;) @ResponseBody public String save()&#123; System.out.println(&quot;book is saving~~&quot;); return &quot;&#123;&#x27;info&#x27;:&#x27;springmvc&#x27;&#125;&quot;; &#125;&#125; UserController： 12345678910@Controller@RequestMapping(&quot;/user&quot;)public class UserController &#123; @RequestMapping(&quot;/save&quot;) @ResponseBody public String save()&#123; System.out.println(&quot;user is saving~~&quot;); return &quot;&#123;&#x27;info&#x27;:&#x27;springmvc&#x27;&#125;&quot;; &#125;&#125; 2.2 请求方式 Get请求 Post请求 所要访问的控制器方法： 1234567891011@Controller@RequestMapping(&quot;/user&quot;)public class UserController &#123; @RequestMapping(&quot;/save&quot;) @ResponseBody public String save(String name, int age)&#123; System.out.println(&quot;user is saving~~&quot;); System.out.println(&quot;name=&quot;+name+&quot; age=&quot;+age); return &quot;&#123;&#x27;info&#x27;:&#x27;springmvc&#x27;&#125;&quot;; &#125;&#125; get请求： url地址传参，地址参数要与形参变量名相同，定义形参几个接收参数 访问链接：http://localhost:8888/user/save?name=dahuang&amp;age=18 控制台打印： 12user is saving~~name=dahuang age=18 post请求： form表单post请求传参，表单参数名要与形参变量名相同，定义形参几个接收参数 访问链接：http://localhost:8888/user/save 提交数据形式：x-www-form-urlencoded 控制台打印： 12user is saving~~name=dahei age=20 如果参数为中文呢？ 控制台打印，会乱码： 12user is saving~~name=å¤§é» age=20 Post请求中文乱码处理： 在ServletContainerInitConfig配置文件中重写getServletFilters()方法 为web容器添加过滤器并指定字符集，Spring-web包中提供了专用的字符过滤器 123456@Overrideprotected Filter[] getServletFilters() &#123; CharacterEncodingFilter aef = new CharacterEncodingFilter(); aef.setEncoding(&quot;UTF-8&quot;); return new Filter[]&#123;aef&#125;;&#125; 再次运行后，控制台打印： 12user is saving~~name=大黄 age=20 2.3 5种类型参数传递 参数种类 普通参数 POJO参数 嵌套POJO参数 数组类型参数 集合类型参数 普通参数：请求参数名与形参变量名不同，使用@RequestParam注解绑定参数关系 1234567891011@Controller@RequestMapping(&quot;/user&quot;)public class UserController &#123; @RequestMapping(&quot;/save&quot;) @ResponseBody public String save(@RequestParam(&quot;name&quot;) String userName, int age)&#123; System.out.println(&quot;user is saving~~&quot;); System.out.println(&quot;name=&quot;+userName+&quot; age=&quot;+age); return &quot;&#123;&#x27;info&#x27;:&#x27;springmvc&#x27;&#125;&quot;; &#125;&#125; POJO参数：请求参数名与形参对象名相同，定义POJO类型形参即可接收参数 创建一个实体类User 1234567891011121314151617public class User &#123; private String name; private int age; public String getName() &#123;return name;&#125; public void setName(String name) &#123;this.name = name;&#125; public int getAge() &#123;return age;&#125; public void setAge(int age) &#123;this.age = age;&#125; @Override public String toString() &#123; return &quot;User&#123;&quot; + &quot;name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &quot;, age=&quot; + age + &#x27;&#125;&#x27;; &#125;&#125; UserController中： 1234567891011@Controller@RequestMapping(&quot;/user&quot;)public class UserController &#123; @RequestMapping(&quot;/save&quot;) @ResponseBody public String save(User user)&#123; System.out.println(&quot;user is saving~~&quot;); System.out.println(user.toString()); return &quot;&#123;&#x27;info&#x27;:&#x27;springmvc&#x27;&#125;&quot;; &#125;&#125; get请求： url地址：http://localhost:8888/user/save?name=dahei&amp;age=16 控制台打印： 12user is saving~~User&#123;name=&#x27;dahei&#x27;, age=16&#125; 嵌套POJO参数：POJO对象中包含POJO对象 创建一个新实体类Address： 1234567891011121314151617public class Address &#123; private String province; private String city; public String getProvince() &#123;return province;&#125; public void setProvince(String province) &#123;this.province = province;&#125; public String getCity() &#123;return city;&#125; public void setCity(String city) &#123;this.city = city;&#125; @Override public String toString() &#123; return &quot;Address&#123;&quot; + &quot;province=&#x27;&quot; + province + &#x27;\\&#x27;&#x27; + &quot;, city=&#x27;&quot; + city + &#x27;\\&#x27;&#x27; + &#x27;&#125;&#x27;; &#125;&#125; 将Address对象加入到User对象中： 123456789101112131415161718192021public class User &#123; private String name; private int age; private Address address; public Address getAddress() &#123;return address;&#125; public void setAddress(Address address) &#123;this.address = address;&#125; public String getName() &#123;return name;&#125; public void setName(String name) &#123;this.name = name;&#125; public int getAge() &#123;return age;&#125; public void setAge(int age) &#123;this.age = age;&#125; @Override public String toString() &#123; return &quot;User&#123;&quot; + &quot;name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &quot;, age=&quot; + age + &quot;, address=&quot; + address + &#x27;&#125;&#x27;; &#125;&#125; get请求： url地址：http://localhost:8888/user/save?name=dahuang&amp;age=20&amp;address.province=tianjin&amp;address.city=baodi 控制台打印： 12user is saving~~User&#123;name=&#x27;dahuang&#x27;, age=20, address=Address&#123;province=&#x27;tianjin&#x27;, city=&#x27;baodi&#x27;&#125;&#125; 数组参数： 1234567891011@Controller@RequestMapping(&quot;/user&quot;)public class UserController &#123; @RequestMapping(&quot;/save&quot;) @ResponseBody public String save(String[] hobbies)&#123; System.out.println(&quot;user is saving~~&quot;); System.out.println(Arrays.toString(hobbies)); return &quot;&#123;&#x27;info&#x27;:&#x27;springmvc&#x27;&#125;&quot;; &#125;&#125; get请求： url地址：http://localhost:8888/user/save?hobbies=TV&amp;hobbies=game&amp;hobbies=food 控制台打印： 12user is saving~~[TV, game, food] 集合参数： 1234567891011@Controller@RequestMapping(&quot;/user&quot;)public class UserController &#123; @RequestMapping(&quot;/save&quot;) @ResponseBody public String save(@RequestParam List&lt;String&gt; hobbies)&#123; System.out.println(&quot;user is saving~~&quot;); System.out.println(hobbies.toString()); return &quot;&#123;&#x27;info&#x27;:&#x27;springmvc&#x27;&#125;&quot;; &#125;&#125; get请求： url地址：http://localhost:8888/user/save?hobbies=TV&amp;hobbies=game&amp;hobbies=food 控制台打印： 12user is saving~~[TV, game, food] 2.4 传递json数据*导入jackson坐标： 12345&lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;2.9.0&lt;/version&gt;&lt;/dependency&gt; json有两种格式： 对象格式：&#123;&quot;key1&quot;:obj,&quot;key2&quot;:obj,&quot;key3&quot;:obj...&#125; 数组&#x2F;集合格式：[obj,obj,obj...] 在SpringMvcConfig配置文件中，添加注解@EnableWebMvc： @EnableWebMvc注解：开启json数据转换成对象的功能 12345@Configuration@ComponentScan(&quot;com.springmvc.controller&quot;)@EnableWebMvcpublic class SpringMvcConfig &#123;&#125; 集合参数：json格式 @RequestBody注解：将请求中请求体所包含的数据传递给请求参数，此注解一个处理器方法只能使用一次 1234567891011@Controller@RequestMapping(&quot;/user&quot;)public class UserController &#123; @RequestMapping(&quot;/save&quot;) @ResponseBody public String save(@RequestBody List&lt;String&gt; hobbies)&#123; System.out.println(&quot;user is saving~~&quot;); System.out.println(hobbies.toString()); return &quot;&#123;&#x27;info&#x27;:&#x27;springmvc&#x27;&#125;&quot;; &#125;&#125; 控制台打印： 12user is saving~~[TV, game, food] POJO参数：json格式 1234567891011@Controller@RequestMapping(&quot;/user&quot;)public class UserController &#123; @RequestMapping(&quot;/save&quot;) @ResponseBody public String save(@RequestBody User user)&#123; System.out.println(&quot;user is saving~~&quot;); System.out.println(user.toString()); return &quot;&#123;&#x27;info&#x27;:&#x27;springmvc&#x27;&#125;&quot;; &#125;&#125; 控制台打印： 12user is saving~~User&#123;name=&#x27;dahuang&#x27;, age=20, address=Address&#123;province=&#x27;tianjin&#x27;, city=&#x27;baodi&#x27;&#125;&#125; 集合对象参数：json格式 1234567891011@Controller@RequestMapping(&quot;/user&quot;)public class UserController &#123; @RequestMapping(&quot;/save&quot;) @ResponseBody public String save(@RequestBody List&lt;User&gt; list)&#123; System.out.println(&quot;user is saving~~&quot;); System.out.println(list.toString()); return &quot;&#123;&#x27;info&#x27;:&#x27;springmvc&#x27;&#125;&quot;; &#125;&#125; 控制台打印： 12user is saving~~[User&#123;name=&#x27;dahei&#x27;, age=20, address=Address&#123;province=&#x27;tianjin&#x27;, city=&#x27;baodi&#x27;&#125;&#125;, User&#123;name=&#x27;dahuang&#x27;, age=20, address=Address&#123;province=&#x27;guizhou&#x27;, city=&#x27;zunyi&#x27;&#125;&#125;] @RequestBody与@RequestParam的区别： 区别 @RequestParam用于url地址传参，表单传参 application/x-www-form-urlencoded @RequestBody用于接收json数据 application/json 应用 后期开发，发送json格式数据为主，@RequestBody拥有较广 如果发送非json格式数据，选用@RequestParam接收请求参数 2.5 日期类型参数传递日期类型数据基于系统不同格式也不尽相同 2022-07-04 2022&#x2F;07&#x2F;04 07&#x2F;04&#x2F;2022 接收形参时，根据不同的日期格式设置不同的接收方式 @DataTimeFormat注解中的pattern属性来自定义日期时间型数据格式 1234567891011121314@Controller@RequestMapping(&quot;/user&quot;)public class UserController &#123; @RequestMapping(&quot;/date&quot;) @ResponseBody public String save(Date date1, @DateTimeFormat(pattern = &quot;yyyy-mm-dd&quot;) Date date2, @DateTimeFormat(pattern = &quot;yyyy/mm/dd HH:mm:ss&quot;) Date date3)&#123; System.out.println(&quot;date1==&gt;&quot;+date1); System.out.println(&quot;date2==&gt;&quot;+date2); System.out.println(&quot;date3==&gt;&quot;+date3); return &quot;&#123;&#x27;info&#x27;:&#x27;springmvc&#x27;&#125;&quot;; &#125;&#125; 控制台打印： 123date1==&gt;Mon Jul 04 00:00:00 CST 2022date2==&gt;Tue Jan 04 00:07:00 CST 2022date3==&gt;Tue Jan 04 23:10:00 CST 2022 类型转换器： Converter接口 1234public interface Converter&lt;S, T&gt; &#123; @Nullable T convert(S val);&#125; 请求参数年龄数据(String&#x3D;&#x3D;&gt;Integer) 日期格式转换(String&#x3D;&#x3D;&gt;Date) @EnableWebMvc注解作用之一：根据类型匹配对应的类型转换器 2.6 响应数据 响应页面 响应数据 文本数据 json数据 响应页面： 在webapp资源包中新建文件：page.jsp 12345&lt;html&gt;&lt;body&gt;&lt;h2&gt;Hello SpringMVC!&lt;/h2&gt;&lt;/body&gt;&lt;/html&gt; 页面跳转： 123456789@Controllerpublic class UserController &#123; @RequestMapping(&quot;/jumpPage&quot;) public String jumpPage()&#123; System.out.println(&quot;页面跳转&quot;); return &quot;page.jsp&quot;; &#125;&#125; url地址：http://localhost:8888/jumpPage 会自动跳转到page.jsp页面 响应文本数据： 123456789@Controllerpublic class UserController &#123; @RequestMapping(&quot;/toText&quot;) @ResponseBody public String toText()&#123; System.out.println(&quot;返回纯文本数据&quot;); return &quot;hello SpringMVC&quot;; &#125;&#125; url地址：http://localhost:8888/toText 页面数据： 1hello SpringMVC 响应POJO对象： 123456789101112@Controllerpublic class UserController &#123; @RequestMapping(&quot;/toPojo&quot;) @ResponseBody public User toPojo()&#123; System.out.println(&quot;返回POJO数据&quot;); User user = new User(); user.setName(&quot;大黄&quot;); user.setAge(18); return user; &#125;&#125; url地址：http://localhost:8888/toPojo 页面数据： 12345&#123; &quot;name&quot;: &quot;大黄&quot;, &quot;age&quot;: 18, &quot;address&quot;: null&#125; 其中是jackson自动将对象转换成json数据 所以一定要导入jackson坐标 响应POJO集合对象： 123456789101112131415161718@Controllerpublic class UserController &#123; @RequestMapping(&quot;/toPojoList&quot;) @ResponseBody public List&lt;User&gt; toPojoList()&#123; System.out.println(&quot;返回POJO集合对象数据&quot;); User user1 = new User(); user1.setName(&quot;大黄&quot;); user1.setAge(18); User user2 = new User(); user2.setName(&quot;大黑&quot;); user2.setAge(20); List&lt;User&gt; list = new ArrayList&lt;&gt;(); list.add(user1); list.add(user2); return list; &#125;&#125; url地址：http://localhost:8888/toPojoList 页面数据： 123456789101112[ &#123; &quot;name&quot;: &quot;大黄&quot;, &quot;age&quot;: 18, &quot;address&quot;: null &#125;, &#123; &quot;name&quot;: &quot;大黑&quot;, &quot;age&quot;: 20, &quot;address&quot;: null &#125;] @ResponseBody注解： 设置当前控制器返回值作为响应体 控制器方法返回值数据类型为String，则返回文本数据 控制器方法返回值数据类型为对象，则自动将对象转换成json数据 类型转换器： web请求专用类型转换器：HttpMessageConverter接口 3.REST风格3.1 REST简介 REST(Representational State Transfer)：表现形式状态转换 传统风格资源描述形式 http://localhost:8888/user/getById?id=1 http://localhost:8888/user/saveUser REST风格描述形式 http://localhost:8888/user/1 http://localhost:8888/user 优点： 隐藏资源的访问行为，无法通过地址得知对资源是如何操作 书写简化 按照REST风格访问资源时使用行为动作区分对资源进行了何种操作 http://localhost:8888/users 查询全部用户信息(get) http://localhost:8888/users/1 查询指定用户信息(post) http://localhost:8888/users 添加用户信息(post) http://localhost:8888/users 修改用户信息(put) http://localhost:8888/users/1 删除用户信息(delete) 描述模块的名称通常使用复数，也就是加s的格式描述，表示此类资源，而非单个资源。 例如：users、books…. 根据REST风格对资源进行访问称为RESTFul 3.2 REST入门@RequestMapping注解中method属性可以设定http请求地址，例如：GET、POST、PUT、DELETE… @PathVariable注解：绑定路径参数与处理器方法形参间的关系，要求路径参数名与形参名一一对应 12345678910111213141516171819202122232425262728293031323334353637@Controllerpublic class UserController &#123; @RequestMapping(value = &quot;/users&quot;, method = RequestMethod.POST) @ResponseBody public String save()&#123; System.out.println(&quot;save~~&quot;); return &quot;save success&quot;; &#125; @RequestMapping(value = &quot;/users&quot;, method = RequestMethod.PUT) @ResponseBody public String update()&#123; System.out.println(&quot;update~~&quot;); return &quot;update success&quot;; &#125; @RequestMapping(value = &quot;/users/&#123;id&#125;&quot;, method = RequestMethod.DELETE) @ResponseBody public String delete(@PathVariable Integer id)&#123; //路径变量 System.out.println(&quot;delete~~&quot;); return &quot;delete success&quot;; &#125; @RequestMapping(value = &quot;/users&quot;, method = RequestMethod.GET) @ResponseBody public String getAll()&#123; System.out.println(&quot;getAll~~&quot;); return &quot;getAll success&quot;; &#125; @RequestMapping(value = &quot;/users/&#123;id&#125;&quot;, method = RequestMethod.POST) @ResponseBody public String getById(@PathVariable Integer id)&#123; System.out.println(&quot;getById~~&quot;); return &quot;getById success&quot;; &#125;&#125; @RequestBody @RequestParam @PathVariable 区别 @RequestParam用于接收url地址传参或表单传参 @RequestBody用于接收json数据 @PathVariab1e用于接收路径参数, 使用{参数名称}描述路径参数 应用 后期开发中，发送请求参数超过1个时，以json格式为主, @RequestBody应用较广 如果发送非json格式数据 ,选用@RequestParam接收请求参数 采用RESTful进行开发，当参数数量较少时，例如1个， 可以采用@PathVariable接收请求路径变量，通常用于传递id值 3.3 REST快速开发@ResponseBody： 设置当前控制器类为RESTful风格，等同于@Controller与@ResponseBody两个注解组合功能 标准请求动作映射： @GetMapping：对应GET请求 @PostMapping：对应POST请求 @PutMapping：对应PUT请求 @DeleteMapping：对应DELETE请求 12345678910111213141516171819202122232425262728293031323334//@ResponseBody + @Controller ==&gt; @RestController@RestController@RequestMapping(&quot;/users&quot;)public class UserController &#123; @PostMapping public String save()&#123; System.out.println(&quot;save~~&quot;); return &quot;save success&quot;; &#125; @PutMapping public String update()&#123; System.out.println(&quot;update~~&quot;); return &quot;update success&quot;; &#125; @DeleteMapping(&quot;/&#123;id&#125;&quot;) public String delete(@PathVariable Integer id)&#123; //路径变量 System.out.println(&quot;delete~~&quot;); return &quot;delete success&quot;; &#125; @GetMapping public String getAll()&#123; System.out.println(&quot;getAll~~&quot;); return &quot;getAll success&quot;; &#125; @PostMapping(&quot;/&#123;id&#125;&quot;) public String getById(@PathVariable Integer id)&#123; System.out.println(&quot;getById~~&quot;); return &quot;getById success&quot;; &#125;&#125; 4.SSM整合5.拦截器5.1 拦截器的概念 拦截器(Interceptor)是一种动态拦截方法调用的机制，再SpringMVC中动态拦截控制器方法的执行 作用： 在指定的方法调用前后执行预先设定的代码 阻止原始方法的执行 拦截器与过滤器的区别： 归属不同：Filter属于Servlet技术，Interceptor属于SpringMVC技术 拦截内容不同：Filter对所有访问进行数据增强，Interceptor仅针对SpringMVC的访问进行增强 5.2 拦截器入门 制作拦截器功能类 配置拦截器的执行位置 项目结构： ProjectInterceptor： 此时preHandle方法的返回值为true：执行请求的方法 123456789101112131415161718@Componentpublic class ProjectInterceptor implements HandlerInterceptor &#123; @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; System.out.println(&quot;preHandle~~~&quot;); return true; &#125; @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123; System.out.println(&quot;postHandle~~~&quot;); &#125; @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123; System.out.println(&quot;afterCompletion~~~&quot;); &#125;&#125; SpringMvcSupport： 12345678910@Configurationpublic class SpringMvcSupport extends WebMvcConfigurationSupport &#123; @Autowired private ProjectInterceptor projectInterceptor; @Override protected void addInterceptors(InterceptorRegistry registry) &#123; registry.addInterceptor(projectInterceptor).addPathPatterns(&quot;/users&quot;); &#125;&#125; SpringMvcConfig中添加扫描路径”com.springmvc.config” 12345@Configuration@ComponentScan(&#123;&quot;com.springmvc.controller&quot;,&quot;com.springmvc.config&quot;&#125;)@EnableWebMvcpublic class SpringMvcConfig &#123;&#125; UserController： 123456789101112131415161718192021222324252627282930313233@RestController@RequestMapping(&quot;/users&quot;)public class UserController &#123; @PostMapping public String save()&#123; System.out.println(&quot;save~~&quot;); return &quot;save success&quot;; &#125; @PutMapping public String update()&#123; System.out.println(&quot;update~~&quot;); return &quot;update success&quot;; &#125; @DeleteMapping(&quot;/&#123;id&#125;&quot;) public String delete(@PathVariable Integer id)&#123; //路径变量 System.out.println(&quot;delete~~&quot;); return &quot;delete success&quot;; &#125; @GetMapping public String getAll()&#123; System.out.println(&quot;getAll~~&quot;); return &quot;getAll success&quot;; &#125; @PostMapping(&quot;/&#123;id&#125;&quot;) public String getById(@PathVariable Integer id)&#123; System.out.println(&quot;getById~~&quot;); return &quot;getById success&quot;; &#125;&#125; 页面展示： 1getAll success 控制台打印： 1234preHandle~~~getAll~~postHandle~~~afterCompletion~~~ 如果preHandle方法的返回值为false：不会执行请求的方法 123456789101112131415161718@Componentpublic class ProjectInterceptor implements HandlerInterceptor &#123; @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; System.out.println(&quot;preHandle~~~&quot;); return false; &#125; @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123; System.out.println(&quot;postHandle~~~&quot;); &#125; @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123; System.out.println(&quot;afterCompletion~~~&quot;); &#125;&#125; 页面无内容，被拦截 控制台打印： 1preHandle~~~ 所以可以通过if语句进行某种判断，返回true或false，来是否执行请求的方法 5.3 拦截器参数前置处理： 1234567@Overridepublic boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; System.out.println(&quot;preHandle~~~&quot;); return true;&#125; 参数： request：请求对象 response：响应对象 handle：被调用的处理器对象，本质为一个方法对象，对反射技术中的Method对象进行了再包装 返回值： 返回值为false，被拦截的处理将不执行 返回值为true，被拦截的处理将会执行 后置处理： 1234567@Overridepublic void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123; System.out.println(&quot;postHandle~~~&quot;);&#125; 参数： modelAndView：如果处理器执行完成具有返回结果，可以读取到对应数据与页面信息，并进行调整(了解即可) 完成后处理： 1234567@Overridepublic void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123; System.out.println(&quot;afterCompletion~~~&quot;);&#125; 参数： ex：如果处理执行过程中出现异常对象，可以针对异常情况进行单独处理(了解即可) 5.4 拦截器链配置(了解) 当配置多个拦截器时，形成拦截链 拦截器链的运行顺序： preHandle：与配置顺序相同，必定运行 postHandle：与配置顺序相反，可能不运行 afterCompletion：与配置顺序相反，可能不运行 但拦截器出现对原始处理器的拦截，后面的拦截器均终止运行 当拦截器运行中断，仅运行配置再前面的拦截器的afterCompletion操作 通常开发项目时，很少会用到拦截器链，一般一个拦截器就可以解决问题 按照1、2、3的顺序配置 12345678910111213141516@Configurationpublic class SpringMvcSupport extends WebMvcConfigurationSupport &#123; @Autowired private ProjectInterceptor1 projectInterceptor1; @Autowired private ProjectInterceptor2 projectInterceptor2; @Autowired private ProjectInterceptor3 projectInterceptor3; @Override protected void addInterceptors(InterceptorRegistry registry) &#123; registry.addInterceptor(projectInterceptor1).addPathPatterns(&quot;/users&quot;); registry.addInterceptor(projectInterceptor2).addPathPatterns(&quot;/users&quot;); registry.addInterceptor(projectInterceptor3).addPathPatterns(&quot;/users&quot;); &#125;&#125; 全部的preHandle方法返回值都为true： graph LR; pre1-->pre2-->pre3-->c(controller)-->post3-->post2-->post1-->after3-->after2-->after1; 3的preHandle方法返回值为false： graph LR; pre1-->pre2-->pre3-->after2-->after1; 2的preHandle方法返回值为false： graph LR; pre1-->pre2-->after1; 1的preHandle方法返回值为false： graph LR; pre1;","categories":[{"name":"Java","slug":"Java","permalink":"http://example.com/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"},{"name":"框架","slug":"框架","permalink":"http://example.com/tags/%E6%A1%86%E6%9E%B6/"}]},{"title":"(每日LeetCode)324. 摆动排序 II","slug":"每日LeetCode/2022-6/324 摆动排序 II","date":"2022-06-28T02:30:00.000Z","updated":"2022-07-08T00:35:05.704Z","comments":true,"path":"2022/06/28/每日LeetCode/2022-6/324 摆动排序 II/","link":"","permalink":"http://example.com/2022/06/28/%E6%AF%8F%E6%97%A5LeetCode/2022-6/324%20%E6%91%86%E5%8A%A8%E6%8E%92%E5%BA%8F%20II/","excerpt":"","text":"题目：给你一个整数数组 nums，将它重新排列成 nums[0] &lt; nums[1] &gt; nums[2] &lt; nums[3]... 的顺序。 你可以假设所有输入数组都可以得到满足题目要求的结果。 示例： 输入：nums &#x3D; [1,5,2,4,3,6]输出：[3,6,2,5,1,4] 思路：双指针法将数组nums按从小到大排列： 1 2 3 4 5 6 $\\leftarrow\\Uparrow$left $\\leftarrow\\Uparrow$right 把排序好的数组分成两部分，left指针位于数组中间，right指针位于数组末尾， 将left和right当前位置的元素依次打印后，left和right指针左移，直至结束 输出：[3, 6, 2, 5, 1, 4] 代码(cpp)：123456789101112131415161718192021class Solution &#123;public: void wiggleSort(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); //获取数组的元素个数 int left = n/2-1; //定义左指针 int right = n-1; //定义右指针 vector&lt;int&gt; new_nums(nums); sort(new_nums.begin(),new_nums.end()); //将新数组排序 for(int i=0;i&lt;n;i++)&#123; if(i%2 == 0)&#123; //偶数位置插入left指针的元素，奇数位置插入right指针的元素 nums[i] = a[left]; left--; &#125; else&#123; nums[i] = a[right]; rigth--; &#125; &#125; &#125;&#125;; 复杂度分析： 时间复杂度：O(nlogn)，排序所需的时间复杂度是O(nlogn)，插入O(n)，整体O(nlogn) 空间复杂度：O(n)，需要额外的空间存放排序的元素。","categories":[{"name":"每日LeetCode","slug":"每日LeetCode","permalink":"http://example.com/categories/%E6%AF%8F%E6%97%A5LeetCode/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"},{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"Spring框架的学习笔记","slug":"Java/Spring框架","date":"2022-06-25T09:55:58.239Z","updated":"2022-07-21T02:45:13.465Z","comments":true,"path":"2022/06/25/Java/Spring框架/","link":"","permalink":"http://example.com/2022/06/25/Java/Spring%E6%A1%86%E6%9E%B6/","excerpt":"","text":"1.初识Spring 官网：spring官网 Spring已经发展成了一种开发的生态圈，Spring提供了若干个项目，每个项目用于完成特定的功能 Spring Framework Spring Boot Spring Cloud …. 目前已经发展到Spring 5.0，需要JDK8以上支持 2.Spring Framework架构 Spring Framework是Spring生态圈中最基础的项目，是其他项目的根基 Data Access：数据访问 Data Integeration：数据集成 Web：web开发 AOP：面向切面编程 Aspects：AOP思想实现 Core Container：核心容器 Test：单元测试与集成测试 3.核心概念3.1 项目结构 java包 com包 spring包 dao包 BookDao.java impl包 BookDaoImpl.java service包 BookSerive.java impl包 BookServiceImpl.java App.java主函数 resources包 applicationContext.xml jdbc.properties 3.2 初识IOC和DI12345public class BookDaoImpl implements BookDao &#123; public void save() &#123; System.out.println(&quot;book dao save...&quot;); &#125;&#125; 123456public class BookServiceImpl implements BookService &#123; private BookDao bookDao = new BookDaoImpl; public void save() &#123; bookDao.save(); &#125;&#125; 这是一种很常见的写法。但是这样的写法耦合度太高，耦合度可以简单的理解为：两个类之间的关联程度，耦合度高就代表两个类之间关联程度很高，动其中一个类，就不得不动另外一个类。 所以就需要解耦 123456public class BookServiceImpl implements BookService &#123; private BookDao bookDao;//service:我免费啦！ public void save() &#123; bookDao.save(); &#125;&#125; IOC(Inversion of Control) 控制反转 使用对象时，由以前主动new一个对象转换为由外部提供对象，创建对象的控制权交给了外部，此思想为控制反转。 Spring技术对IOC进行实现 Spring提供一个容器，称为IOC容器，用来当作IOC思想中的**”外部”** IOC容器负责对象的创建、初始化等工作 在IOC容器中被创建或被管理的对象称之为Bean DI(Dependency Injection) 依赖注入 在容器中建立的bean与bean之间的依赖关系的整个过程，称之为依赖注入。 例：service层需要依赖dao层运行，但无需自己new一个dao层，它会自动生成dao层。 目标：充分解耦 使用IOC容器管理bean(IOC思想) 在ICO容器内将依赖关系的bean进行关系绑定(DI思想) 在使用对象时不仅可以从IOC容器中获取，并且也可以获取到bean已经绑定的所有依赖关系 4.IOC入门 pom.xml导入spring的坐标 12345&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;5.3.18&lt;/version&gt;&lt;/dependency&gt; resources目录创建Spring配置文件applicationContext.xml 配置bean bean标签：配置bean id属性：给bean起名字 class属性：给bean定义类型 123&lt;bean id=&quot;bookDao&quot; class=&quot;com.spring.dao.impl.BookDaoImpl&quot;/&gt;&lt;bean id=&quot;bookService&quot; class=&quot;com.spring.service.impl.BookServiceImpl&quot;/&gt; 创建名为启动类App 1234567891011121314151617import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;import com.spring.dao.BookDao;public class App &#123; public static void main(String[] args) &#123; //获取ICO容器 ApplicationContext ac = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); //获取bean BookDao bookDao = (BookDao) ac.getBean(&quot;bookDao&quot;); bookDao.save(); BookService bookService = (BookService) ac.getBean(&quot;bookService&quot;); bookService.save(); &#125;&#125; 5.DI入门 基于IOC管理bean 不能保留Service层中用new创建的对象 通过spring配置文件进行配置Service与Dao的关系 12345678910111213public class BookServiceImpl implements BookService &#123; //删除业务层中用new创建对象的方式 //private BookDao bookDao = new BookDaoImpl(); private BookDao bookDao; //提供相应的set的方法 public void setBookDao(BookDao bookDao) &#123; this.bookDao = bookDao; &#125; public void save() &#123; bookDao.save(); &#125;&#125; 在spring配置文件applicationContext.xml中，配置property property标签：配置当前bean的属性 name属性：配置哪个具体的属性 ref属性：参照spring配置文件中的哪个bean的id 123456&lt;bean id=&quot;bookDao&quot; class=&quot;com.spring.dao.impl.BookDaoImpl&quot;/&gt;&lt;bean id=&quot;bookService&quot; class=&quot;com.spring.service.impl.BookServiceImpl&quot;&gt; &lt;!-- 配置service与dao的关系 --&gt; &lt;property name=&quot;bookDao&quot; ref=&quot;bookDao&quot;/&gt;&lt;/bean&gt; 配置完成后，BookDao无需使用new来手动创建对象，而是通过spring来自动创建 6.bean基础配置6.1 bean别名配置 name属性：可以起多个别名用;分号 空格,逗号分隔 123&lt;bean id=&quot;bookDao&quot; name=&quot;dao Dao&quot; class=&quot;com.spring.dao.impl.BookDaoImpl&quot;/&gt;&lt;bean id=&quot;bookService&quot; name=&quot;Service service&quot; class=&quot;com.spring.service.impl.BookServiceImpl&quot;/&gt; 别名可以用于getBean()方法 1234567891011public class App &#123; public static void main(String[] args) &#123; //获取ICO容器 ApplicationContext ac = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); //获取bean //BookService bookService=(BookService)ac.getBean(&quot;bookService&quot;); //通过别名获取BookService BookService bookService=(BookService)ac.getBean(&quot;Service&quot;); bookService.save(); &#125;&#125; 别名也可以用户ref属性，不建议用别名，建议使用id 123&lt;bean id=&quot;bookService&quot; class=&quot;com.spring.service.impl.BookServiceImpl&quot;&gt; &lt;property name=&quot;bookDao&quot; ref=&quot;Dao&quot;/&gt;&lt;/bean&gt; 6.2 bean的作用范围创建的bean是否为多个对象 123456789101112public class App &#123; public static void main(String[] args) &#123; //获取ICO容器 ApplicationContext ac = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); //获取bean BookDao bookDao1 = (BookDao) ac.getBean(&quot;bookDao&quot;); BookDao bookDao2 = (BookDao) ac.getBean(&quot;bookDao&quot;); System.out.println(bookDao1); System.out.println(bookDao2); &#125;&#125; 123运行结果：com.spring.dao.impl.BookDaoImpl@7219ec67com.spring.dao.impl.BookDaoImpl@7219ec67 结论：两个对象地址相同，spring默认创建的bean是单例的 需要在配置文件的bean标签里添加一个scope属性 scope属性有singleton单例模式和prototype非单例模式 scope属性默认为singleton单例模式 1&lt;bean id=&quot;bookDao&quot; class=&quot;com.spring.dao.impl.BookDaoImpl&quot; scope=&quot;prtotype&quot;/&gt; 123再次运行后，运行结果：com.spring.dao.impl.BookDaoImpl@7219ec67com.spring.dao.impl.BookDaoImpl@45018215 结论：两个对象地址不同，为非单例模式 bean作用范围说明 单例bean的优势 减少了新生成实例的消耗，可以快速获取到bean，更大程度的复用 适合交给容器进行管理的bean 表现层对象，业务层对象，数据层对象，工具对象 不适合交给容器进行管理的bean 封装实体的域对象(存在变量的) 7.bean实例化 bean的本质就是对象，创建bean都需要使用构造方法完成 7.1 构造方法实例化bean(常用) 在BookDaoImpl类中创建构造方法： 123456789101112public class BookDaoImpl implements BookDao &#123; public BookDaoImpl()&#123; System.out.println(&quot;BookDaoImpl构造函数&quot;); &#125; /*private BookDaoImpl()&#123; System.out.println(&quot;BookDaoImpl构造函数&quot;); &#125;*/ public void save() &#123; System.out.println(&quot;BookDao~~~~~&quot;); &#125;&#125; AppForInstanceBook类进行测试： 12345678public class AppForInstanceBook &#123; public static void main(String[] args) &#123; ApplicationContext ac = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); BookDao bookDao = (BookDao) ac.getBean(&quot;bookDao&quot;); bookDao.save(); &#125;&#125; 123运行结果：BookDaoImpl构造函数BookDao~~~~~ 并且BookDaoImpl中的构造方法无论是否私有都可以被调用，这就是反射。 无参构造方法不存在，将会抛出异常 在BookDaoImpl类中构造方法改为有参构造： 123public BookDaoImpl(int i)&#123; System.out.println(&quot;BookDaoImpl构造函数&quot;);&#125; 运行后会报错，同时说明Spring创建bean的时候，调用的是无参构造。 7.2 静态工厂实例化bean(早期实例化bean 了解) 创建一个factory软件包，并在里面创建一个BookDaoFactory类： 123456public class BookDaoFactory &#123; public static BookDao getBookDao()&#123; System.out.println(&quot;factory is running&quot;); return new BookDaoImpl(); &#125;&#125; AppForInstanceBook类运行： 1234567public class AppForInstanceBook &#123; public static void main(String[] args) &#123; BookDao bookDao = BookDaoFactory.getBookDao(); bookDao.save(); &#125;&#125;//运行成功 通过配置文件使用静态工厂实例化bean： Spring配置文件中： factory-method属性：选择工厂里的bean实例方法 12&lt;bean id=&quot;bookDao&quot; class=&quot;com.spring.factory.BookDaoFactory&quot; factory-method=&quot;getBookDao&quot;/&gt; AppForInstanceBook类运行： 12345678public class AppForInstanceBook &#123; public static void main(String[] args) &#123; ApplicationContext ac = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); BookDao bookDao = (BookDao) ac.getBean(&quot;bookDao&quot;); bookDao.save(); &#125;&#125; 1234运行结果：factory is runningBookDaoImpl构造函数BookDao~~~~~ 7.3 实例工厂实例化bean(非静态工厂 了解) BookDaoFactory类中，将方法改为非静态方法 123456public class BookDaoFactory &#123; public BookDao getBookDao()&#123; System.out.println(&quot;factory is running~~~~~&quot;); return new BookDaoImpl(); &#125;&#125; AppForInstanceBook类运行： 1234567public class AppForInstanceBook &#123; public static void main(String[] args) &#123; BookDaoFactory bookDaoFactory = new BookDaoFactory(); BookDao bookDao = bookDaoFactory.getBookDao(); bookDao.save(); &#125;&#125; 1234运行结果：factory is running~~~~~BookDaoImpl构造函数BookDao~~~~~ 通过配置文件使用静态工厂实例化bean： Spring配置文件中： 12345&lt;!-- 先要造出工厂的bean --&gt;&lt;bean id=&quot;bookDaoFactory&quot; class=&quot;com.spring.factory.BookDaoFactory&quot;/&gt;&lt;bean id=&quot;bookDao&quot; factory-bean=&quot;bookDaoFactory&quot; factory-method=&quot;getBookDao&quot; /&gt; AppForInstanceBook类运行： 12345678public class AppForInstanceBook &#123; public static void main(String[] args) &#123; ApplicationContext ac = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); BookDao bookDao = (BookDao) ac.getBean(&quot;bookDao&quot;); bookDao.save(); &#125;&#125; 1234运行结果：factory is running~~~~~BookDaoImpl构造函数BookDao~~~~~ 配置文件中beanbookDaoFactory只是为了配合使用，实际没有意义。 Spring对这种实例化bean方法进行了改良： 4.通过FactoryBean实例化bean(实用) 创建BookDaoFactoryBean类实现接口FactoryBean&lt;T&gt; 123456789101112public class BookDaoFactoryBean implements FactoryBean&lt;BookDao&gt; &#123; //代替原始实例工厂中创建对象的方法 @Override public BookDao getObject() throws Exception &#123; return new BookDaoImpl(); &#125; @Override public Class&lt;?&gt; getObjectType() &#123; return BookDao.class; &#125;&#125; Spring配置文件中： 1&lt;bean id=&quot;bookDao&quot; class=&quot;com.spring.factory.BookDaoFactoryBean&quot;/&gt; AppForInstanceBook类运行： 12345678public class AppForInstanceBook &#123; public static void main(String[] args) &#123; ApplicationContext ac = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); BookDao bookDao = (BookDao) ac.getBean(&quot;bookDao&quot;); bookDao.save(); &#125;&#125; 123运行结果：BookDaoImpl构造函数BookDao~~~~~ 并且BookDaoFactoryBean类中可以重写isSinglenton方法： 1234567891011121314151617181920212223242526272829&lt;table&gt; &lt;th align=&quot;center&quot;&gt; &lt;td rowspan=&quot;2&quot;&gt;Key&lt;/td&gt; &lt;td colspan=&quot;2&quot;&gt;Value&lt;/td&gt; &lt;/th&gt; &lt;tr align=&quot;center&quot;&gt; &lt;td&gt;field&lt;/td&gt; &lt;td&gt;value&lt;/td&gt; &lt;/tr&gt; &lt;tr align=&quot;center&quot;&gt; &lt;td rowspan=&quot;2&quot;&gt;REQUIRES_NEW&lt;/td&gt; &lt;td&gt;开启T&lt;/td&gt; &lt;td&gt;新建T2&lt;/td&gt; &lt;/tr&gt; &lt;tr align=&quot;center&quot;&gt; &lt;td&gt;无&lt;/td&gt; &lt;td&gt;新建T2&lt;/td&gt; &lt;/tr&gt; &lt;tr align=&quot;center&quot;&gt; &lt;td rowspan=&quot;2&quot;&gt;SUPPORTS&lt;/td&gt; &lt;td&gt;开启T&lt;/td&gt; &lt;td&gt;加入T&lt;/td&gt; &lt;/tr&gt; &lt;tr align=&quot;center&quot;&gt; &lt;td&gt;无&lt;/td&gt; &lt;td&gt;无&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt; 8.bean的生命周期 bean生命周期：bean从创建到销毁的整体过程 bean生命周期控制：在bean创建后到销毁前做一些事 在BookDaoImpl类中，创建init和destroy方法 1234567891011121314public class BookDaoImpl implements BookDao &#123; public void save() &#123; System.out.println(&quot;BookDao~~~~~&quot;); &#125; public void init()&#123; System.out.println(&quot;init~~~&quot;); &#125; public void destroy()&#123; System.out.println(&quot;destroy~~~&quot;); &#125;&#125; 在Spring配置文件中： init-method和destroy-method属性 12&lt;bean id=&quot;bookDao&quot; class=&quot;com.spring.dao.impl.BookDaoImpl&quot; init-method=&quot;init&quot; destroy-method=&quot;destroy&quot;/&gt; 调用主函数： 123456789public class App &#123; public static void main(String[] args) &#123; //获取ICO容器 ApplicationContext ac = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); //获取bean BookDao bookDao = (BookDao) ac.getBean(&quot;bookDao&quot;); bookDao.save(); &#125;&#125; 123运行结果：init~~~BookDao~~~~~ 控制台并没有输出destroy~~~； 因为销毁函数还没有来得及调用，程序就被杀死了； 所以需要进行手动关闭； 我们调用主函数中的ac中的close()方法，但是ApplicationContext接口中并没有提供close()方法，所以我们要改用ClassPathXmlApplicationContext类。 12345678910public class App &#123; public static void main(String[] args) &#123; //获取ICO容器 ClassPathXmlApplicationContext ac = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); //获取bean BookDao bookDao = (BookDao) ac.getBean(&quot;bookDao&quot;); bookDao.save(); ac.close(); &#125;&#125; 12345运行结果：init~~~BookDao~~~~~destroy~~~ 成功！！！！ 容器还提供另外一种方式关闭容器：设置关闭钩子 调用ac的registerShutdownHook()方法 1234567891011public class App &#123; public static void main(String[] args) &#123; //获取ICO容器 ClassPathXmlApplicationContext ac = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); //获取bean BookDao bookDao = (BookDao) ac.getBean(&quot;bookDao&quot;); bookDao.save(); ac.registerShutdownHook(); &#125;&#125; 1234运行结果：init~~~BookDao~~~~~destroy~~~ close()和registerShutdownHook()的区别 将registerShutdownHook()放到上面： 12345678910public class App &#123; public static void main(String[] args) &#123; //获取ICO容器 ClassPathXmlApplicationContext ac = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); ac.registerShutdownHook(); //获取bean BookDao bookDao = (BookDao) ac.getBean(&quot;bookDao&quot;); bookDao.save(); &#125;&#125; 1234运行成功：init~~~BookDao~~~~~destroy~~~ 将close()放到上面： 12345678910public class App &#123; public static void main(String[] args) &#123; //获取ICO容器 ClassPathXmlApplicationContext ac = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); ac.close(); //获取bean BookDao bookDao = (BookDao) ac.getBean(&quot;bookDao&quot;); bookDao.save(); &#125;&#125; 123456运行结果：init~~~destroy~~~报错：BeanFactory not initialized or already closed - call &#x27;refresh&#x27; before accessing beans via the ApplicationContext BeanFactory没有被初始化或者已经被关闭了 运行失败！！ 或者通过接口的方式实现： BookServiceImpl类实现接口InitializingBean和DisposableBean的方法 1234567891011121314151617181920212223public class BookServiceImpl implements BookService, InitializingBean, DisposableBean &#123; private BookDao bookDao; public void setBookDao(BookDao bookDao) &#123; System.out.println(&quot;BookDao set~~~&quot;); this.bookDao = bookDao; &#125; public void save() &#123; bookDao.save(); &#125; @Override public void destroy() throws Exception &#123; System.out.println(&quot;service destroy~~~~&quot;); &#125; @Override public void afterPropertiesSet() throws Exception &#123; System.out.println(&quot;service init~~~~&quot;); &#125;&#125; 配置文件： 123456&lt;bean id=&quot;bookDao&quot; class=&quot;com.spring.dao.impl.BookDaoImpl&quot; init-method=&quot;init&quot; destroy-method=&quot;destroy&quot;/&gt;&lt;bean id=&quot;bookService&quot; class=&quot;com.spring.service.impl.BookServiceImpl&quot;&gt;&lt;property name=&quot;bookDao&quot; ref=&quot;bookDao&quot;/&gt;&lt;/bean&gt; 主函数运行： 12345678910public class App &#123; public static void main(String[] args) &#123; //获取ICO容器 ClassPathXmlApplicationContext ac = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); //获取bean BookDao bookDao = (BookDao) ac.getBean(&quot;bookDao&quot;); bookDao.save(); ac.registerShutdownHook(); &#125;&#125; 1234567运行结果：init~~~BookDao set~~~service init~~~~BookDao~~~~~service destroy~~~~destroy~~~ BookServiceImpl类中destroy()方法和afterPropertiesSet()方法被调用 并且setBookDao()方法之后才调用的afterPropertiesSet()方法 9.依赖注入方式向一个类传递数据的方式有：set方法、构造方法 9.1 setter注入 引用类型 在bean中定义引用类型属性并提供可访问的set方法 BookServiceImpl类中： 1234567public class BookServiceImpl implements BookService &#123; private BookDao bookDao; //提供相应的set的方法 public void setBookDao(BookDao bookDao) &#123; this.bookDao = bookDao; &#125;&#125; 在配置文件中使用property标签ref属性注入引用类型对象 12345&lt;bean id=&quot;bookDao&quot; class=&quot;com.spring.dao.impl.BookDaoImpl&quot;/&gt;&lt;bean id=&quot;bookService&quot; class=&quot;com.spring.service.impl.BookServiceImpl&quot;&gt; &lt;property name=&quot;bookDao&quot; ref=&quot;bookDao&quot;/&gt;&lt;/bean&gt; 简单类型 在bean中定义引用类型属性并提供可访问的set方法 BookDaoImpl类中： 1234567891011121314public class BookDaoImpl implements BookDao &#123; private String name; private int age; public void setName(String name) &#123; this.name = name; &#125; public void setAge(int age) &#123; this.age = age; &#125; public void save() &#123; System.out.println(&quot;BookDao~~~~~&quot;+&quot;姓名：&quot;+name+&quot;年龄：&quot;+age); &#125;&#125; 配置文件中，在property标签value属性注入简单类型数据 1234&lt;bean id=&quot;bookDao&quot; class=&quot;com.spring.dao.impl.BookDaoImpl&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;DaHuang&quot;/&gt; &lt;property name=&quot;age&quot; value=&quot;18&quot;/&gt;&lt;/bean&gt; 运行主函数： 12345678910public class App &#123; public static void main(String[] args) &#123; //获取ICO容器 ClassPathXmlApplicationContext ac = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); //获取bean BookDao bookDao = (BookDao) ac.getBean(&quot;bookDao&quot;); bookDao.save(); ac.registerShutdownHook(); &#125;&#125; 12运行结果：BookDao~~~~~姓名：DaHuang年龄：18 9.2 构造器注入 引用类型 在bean中定义引用类型属性并提供可访问的构造方法 12345678public class BookServiceImpl implements BookService &#123; private BookDao bookDao; public BookServiceImpl(BookDao bookDao) &#123; System.out.println(&quot;BookServiceImpl构造器运行~~~&quot;); this.bookDao = bookDao; &#125;&#125; 配置文件中，使用constructor-arg标签中的ref属性注入引用类型对象 12345678&lt;bean id=&quot;bookDao&quot; class=&quot;com.spring.dao.impl.BookDaoImpl&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;DaHuang&quot;/&gt; &lt;property name=&quot;age&quot; value=&quot;18&quot;/&gt; &lt;/bean&gt;&lt;bean id=&quot;bookService&quot; class=&quot;com.spring.service.impl.BookServiceImpl&quot;&gt; &lt;constructor-arg name=&quot;bookDao&quot; ref=&quot;bookDao&quot;/&gt;&lt;/bean&gt; 运行主函数： 123456789public class App &#123; public static void main(String[] args) &#123; //获取ICO容器 ClassPathXmlApplicationContext ac = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); //获取bean BookDao bookDao = (BookDao) ac.getBean(&quot;bookDao&quot;); bookDao.save(); &#125;&#125; 12运行结果：BookServiceImpl构造器运行~~~ 简单类型 BookDaoImpl类中： 123456789public class BookDaoImpl implements BookDao &#123; private String name; private int age; public BookDaoImpl(String name, int age) &#123; this.name = name; this.age = age; &#125;&#125; 配置文件中： 1234&lt;bean id=&quot;bookDao&quot; class=&quot;com.spring.dao.impl.BookDaoImpl&quot;&gt; &lt;constructor-arg name=&quot;name&quot; value=&quot;DaHei&quot;/&gt; &lt;constructor-arg name=&quot;age&quot; value=&quot;20&quot;/&gt;&lt;/bean&gt; 如果要更改BookDaoImpl类中的形参名字，还要更改配置文件中的name属性的名字； 存在形参与name属性名不耦合的问题。 constructor-arg标签还有type和index属性 type：形参的数据类型(存在多个同数据类型的形参，无法使用) index：形参的位置顺序 在配置文件中，使用index属性设置按形参位置顺序注入 1234&lt;bean id=&quot;bookDao&quot; class=&quot;com.spring.dao.impl.BookDaoImpl&quot;&gt; &lt;constructor-arg index=&quot;0&quot; value=&quot;DaHei&quot;/&gt; &lt;constructor-arg index=&quot;1&quot; value=&quot;20&quot;/&gt;&lt;/bean&gt; 运行主函数： 123456789public class App &#123; public static void main(String[] args) &#123; //获取ICO容器 ClassPathXmlApplicationContext ac = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); BookDao bookDao = (BookDao) ac.getBean(&quot;bookDao&quot;); bookDao.save(); &#125;&#125; 12运行结果：BookDao~~~~~姓名：DaHei年龄：20 9.3 依赖注入方式的选择 强制依赖使用构造器注入，使用setter注入有概率不注入导致null对象出现。 bean必须要的东西，要用构造器注入。因为构造器必须被执行，必须注入，否则报错 而setter方法可以执行也可以不执行，如果没有进行setter注入，会导致null对象 可选依赖使用setter注入进行，灵活性强。 setter注入可以执行也可以不执行 Spring框架倡导使用构造器。 第三方框架大多采用构造器注入的形式初始化数据，更加严谨 setter注入和构造器注入可以同时使用。 使用构造器完成强制依赖注入，使用setter注入完成可选依赖注入 自己开发的模块推荐使用setter注入 10.依赖自动装配IOC容器根据bean都依赖的资源在容器中自动查找并注入到bean中的过程称为自动装配 自动装配的方式： 按类型(常用) 按名称 按构造方法(不推荐) 不启用自动装配 10.1 按类型需要提供相应的setter方法 123456789public class BookServiceImpl implements BookService &#123; private BookDao bookDao; public void setBookDao(BookDao bookDao) &#123; System.out.println(&quot;BookDao set~~~&quot;); this.bookDao = bookDao; &#125;&#125; 配置文件中，要提前写好bookDao的bean否则无法装配， autowire属性设置为byTpye 通过类型自动装配 1234&lt;bean id=&quot;bookDao&quot; class=&quot;com.spring.dao.impl.BookDaoImpl&quot;/&gt;&lt;bean id=&quot;bookService&quot; class=&quot;com.spring.service.impl.BookServiceImpl&quot; autowire=&quot;byType&quot; /&gt; 主函数： 123456789public class App &#123; public static void main(String[] args) &#123; ClassPathXmlApplicationContext ac = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); BookService bookService = (BookService) ac.getBean(&quot;bookService&quot;); bookService.save(); &#125;&#125; 12运行结果：BookDao set~~~ 如果出现一下这种情况： 12345&lt;bean id=&quot;bookDao1&quot; class=&quot;com.spring.dao.impl.BookDaoImpl&quot;/&gt;&lt;bean id=&quot;bookDao2&quot; class=&quot;com.spring.dao.impl.BookDaoImpl&quot;/&gt;&lt;bean id=&quot;bookService&quot; class=&quot;com.spring.service.impl.BookServiceImpl&quot; autowire=&quot;byType&quot; /&gt; 出现了两个BookDao的bean，导致Spring无法区分了，这时就需要按名称装配 10.2 按名称123456789public class BookServiceImpl implements BookService &#123; private BookDao bookDao; public void setBookDao(BookDao bookDao) &#123; System.out.println(&quot;BookDao set~~~&quot;); this.bookDao = bookDao; &#125;&#125; 配置文件中，autowire属性设置为byName 通过名称自动装配 是通过BookServiceImpl类的变量名bookDao与配置文件的bean中id相同名称的进行绑定 12345&lt;bean id=&quot;bookDao&quot; class=&quot;com.spring.dao.impl.BookDaoImpl&quot;/&gt;&lt;bean id=&quot;bookDao2&quot; class=&quot;com.spring.dao.impl.BookDaoImpl&quot;/&gt;&lt;bean id=&quot;bookService&quot; class=&quot;com.spring.service.impl.BookServiceImpl&quot; autowire=&quot;ByName&quot; /&gt; 10.3 总结 自动装配用于引用类型依赖注入，不能对简单类型进行操作 使用按类型装配byType，必须保障容器中相同类型的bean唯一，推荐使用 使用按名称装配byName，必须保障容器中具有指定名称的bean，变量名要与配置耦合， 不推荐使用 自动装配优先级低于setter注入和构造器注入，同时出现时自动装配配置失效 11.集合注入123456789101112131415161718192021222324252627public class BookDaoImpl implements BookDao &#123; private int[] array; private List&lt;String&gt; list; private Set&lt;String&gt; set; private Map&lt;String, String&gt; map; private Properties properties; public void setArray(int[] array) &#123;this.array = array;&#125; public void setList(List&lt;String&gt; list) &#123;this.list = list;&#125; public void setSet(Set&lt;String&gt; set) &#123;this.set = set;&#125; public void setMap(Map&lt;String, String&gt; map) &#123;this.map = map;&#125; public void setProperties(Properties properties) &#123;this.properties = properties;&#125; public void save() &#123; System.out.println(&quot;BookDaoImpl&#123;&quot; + &quot;\\narray=&quot; + Arrays.toString(array) + &quot;, \\nlist=&quot; + list + &quot;, \\nset=&quot; + set + &quot;, \\nmap=&quot; + map + &quot;, \\nproperties=&quot; + properties + &#x27;&#125;&#x27;); &#125;&#125; 配置文件中： 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;bean id=&quot;bookDao&quot; class=&quot;com.spring.dao.impl.BookDaoImpl&quot;&gt; &lt;property name=&quot;array&quot; &gt; &lt;array&gt; &lt;value&gt;100&lt;/value&gt; &lt;value&gt;200&lt;/value&gt; &lt;value&gt;300&lt;/value&gt; &lt;/array&gt; &lt;/property&gt; &lt;property name=&quot;list&quot; &gt; &lt;list&gt; &lt;value&gt;唱&lt;/value&gt; &lt;value&gt;跳&lt;/value&gt; &lt;value&gt;Rap&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;property name=&quot;set&quot; &gt; &lt;set&gt; &lt;value&gt;唱&lt;/value&gt; &lt;value&gt;跳&lt;/value&gt; &lt;value&gt;Rap&lt;/value&gt; &lt;value&gt;Rap&lt;/value&gt; &lt;/set&gt; &lt;/property&gt; &lt;property name=&quot;map&quot; &gt; &lt;map&gt; &lt;entry key=&quot;county&quot; value=&quot;china&quot;/&gt; &lt;entry key=&quot;province&quot; value=&quot;tianjin&quot;/&gt; &lt;entry key=&quot;city&quot; value=&quot;baodi&quot;/&gt; &lt;/map&gt; &lt;/property&gt; &lt;property name=&quot;properties&quot;&gt; &lt;props&gt; &lt;prop key=&quot;county&quot;&gt;china&lt;/prop&gt; &lt;prop key=&quot;province&quot;&gt;tianjin&lt;/prop&gt; &lt;prop key=&quot;city&quot;&gt;baodi&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt; &lt;/bean&gt; 运行主函数： 12345678public class App &#123; public static void main(String[] args) &#123; ClassPathXmlApplicationContext ac = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); BookDao bookDao = (BookDao) ac.getBean(&quot;bookDao&quot;); bookDao.save(); &#125;&#125; 1234567运行结果：BookDaoImpl&#123;array=[100, 200, 300], list=[唱, 跳, Rap], set=[唱, 跳, Rap], map=&#123;county=china, province=tianjin, city=baodi&#125;, properties=&#123;province=tianjin, city=baodi, county=china&#125;&#125; 12.数据源对象管理在pom.xml导入druid坐标 12345678910&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.2.8&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8.0.28&lt;/version&gt;&lt;/dependency&gt; 配置文件中，管理DruidDataSouurce对象 123456&lt;bean id=&quot;dataSource&quot; class=&quot;com.alibaba.druid.pool.DruidDataSource&quot;&gt; &lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/demo&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;123456&quot;/&gt;&lt;/bean&gt; 运行主函数： 12345678910public class App &#123; public static void main(String[] args) &#123; //获取ICO容器 ClassPathXmlApplicationContext ac = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); DataSource dataSource = (DataSource) ac.getBean(&quot;dataSource&quot;); System.out.println(dataSource); &#125;&#125; 123456789101112运行结果：&#123; CreateTime:&quot;2022-06-24 22:27:03&quot;, ActiveCount:0, PoolingCount:0, CreateCount:0, DestroyCount:0, CloseCount:0, ConnectCount:0, Connections:[ ]&#125; 13.加载properties配置信息在rescource资源包中创建jdbc.properties文件： 1234567jdbc.driver=com.mysql.jdbc.Driverjdbc.url=jdbc:mysql://localhost:3306/demojdbc.username=rootjdbc.password=123456username=dahuangage=18 配置文件中: 在beans标签中开启context命名空间 使用context空间加载properties文件 12345678910111213141516171819202122232425262728293031&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot; http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt; &lt;!-- 1.开启context命名空间 --&gt; &lt;!-- 2.使用context空间加载properties文件 --&gt; &lt;context:property-placeholder location=&quot;jdbc.properties&quot; system-properties-mode=&quot;NEVER&quot;/&gt; &lt;bean id=&quot;dataSource&quot; class=&quot;com.alibaba.druid.pool.DruidDataSource&quot;&gt; &lt;!-- 使用占位符$&#123;&#125;读取properties中的属性 --&gt; &lt;property name=&quot;driverClassName&quot; value=&quot;$&#123;jdbc.driver&#125;&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;$&#123;jdbc.url&#125;&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;$&#123;jdbc.username&#125;&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot;/&gt; &lt;/bean&gt; &lt;bean id=&quot;bookDao&quot; class=&quot;com.spring.dao.impl.BookDaoImpl&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;$&#123;username&#125;&quot;/&gt; &lt;property name=&quot;age&quot; value=&quot;$&#123;age&#125;&quot;/&gt; &lt;/bean&gt;&lt;/beans&gt; 加载properties文件格式： 不加载系统属性： 12&lt;context:property-placeholder location=&quot;jdbc.properties&quot; system-properties-mode=&quot;NEVER&quot;/&gt; 加载多个properties文件： 1&lt;context:property-placeholder location=&quot;jdbc.properties, jdbc2.properties&quot;/&gt; 加载所有properties文件： 1&lt;context:property-placeholder location=&quot;*.properties&quot;/&gt; 加载properties文件标准格式： 1&lt;context:property-placeholder location=&quot;classpath:*.properties&quot;/&gt; 从类路径或jar包中搜索加载properties文件： 1&lt;context:property-placeholder location=&quot;classpath*:*.properties&quot;/&gt; 14.容器14.1 创建容器的几种方式 类路径下的加载配置文件 1ApplicationContext ac = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); 文件系统下加载的配置文件 1ApplicationContext ac = new ClassPathXmlApplicationContext(&quot;E:\\Java_Web\\Spring\\spring_01_IOC\\src\\main\\resources\\applicationContext.xml&quot;); 加载多个配置文件： 1ApplicationContext ac = new ClassPathXmlApplicationContext(&quot;applicationContext1.xml&quot;,&quot;applicationContext2.xml&quot;); 14.2 获取bean的几种方式 使用bean名称获取 1BookDao bookDao = (BookDao) ac.getBean(&quot;bookDao&quot;); 使用bean名称获取并指定类型 1BookDao bookDao = ac.getBean(&quot;bookDao&quot;,BookDao.class); 使用bean类型获取 1BookDao bookDao = ac.getBean(BookDao.class);//对应的容器中只能有一个该类型，唯一 14.3 容器类层次结构使用ctrl+H打开容器类的层次结构图： BeanFactory：是IOC容器的顶层接口，初始化BeanFactory对象时，加载的bean延迟加载 ApplicationContext：是Spring容器的核心接口，初始化时bean立即加载 ​ 提供基础的bean操作相关的方法，通过其他接口扩展其功能 ConfigurableApplicationContext：提供关闭容器功能 ClassPathXmlApplicationContext：常用实现类 14.4 BeanFactory初始化类路径加载配置文件： 12345678public class App &#123; public static void main(String[] args) &#123; Rescoure rescoure = new ClassPathRescoure(&quot;applicationContext.xml&quot;); BeanFactory bf = new XmlBeanFactory(rescoure); BookDao bookDao = bf.getBean(&quot;bookDao&quot;,BookDao.class); bookDao.save(); &#125;&#125; BeanFactory创建完毕后，所有bean均为延迟加载 15.注解开发*15.1 用注释定义bean123456@component(&quot;bookDao&quot;) //等价于&lt;bean id=&quot;bookDao&quot; class=&quot;com.spring.dao.impl.BookDaoImpl&quot;/&gt;public class BookDaoImpl implements BookDao &#123; public void save() &#123; System.out.println(&quot;BookDao~~~~~&quot;); &#125;&#125; 123456@Component //没有写bean名，要通过类型获取beanpublic class BookServiceImpl implements BookService &#123; public void save() &#123; System.out.println(&quot;BookService~~~~&quot;); &#125;&#125; 但是，Spring怎么感知到注释呢？ 配置文件中，需要添加扫描组件： 123456789101112&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot; http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt; &lt;!-- 扫描@component组件 --&gt; &lt;!-- base-package为扫描的位置 --&gt; &lt;context:component-scan base-package=&quot;com.spring&quot;/&gt;&lt;/beans&gt; 主函数： 123456789101112public class App &#123; public static void main(String[] args) &#123; //获取ICO容器 ClassPathXmlApplicationContext ac = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); //获取bean BookDao bookDao = (BookDao) ac.getBean(&quot;bookDao&quot;); bookDao.save(); //因为@component，并没有写bean名，所以要用类型获取bean BookService bookService = ac.getBean(BookService.class); bookService.save(); &#125;&#125; 123运行结果：BookDao~~~~~BookService~~~~ Spring提供@component注解的三个衍生注解 @Repository：用于数据层bean定义(Dao层) ​ 也可以加括号来指定bean名，如：@Repository(“bookDao2”) @Service：用于业务层bean定义(Service层) @Controller：用于表现层bean定义(Controller层) @Service,@Repository不能写在接口上,需要写在接口的实现类上 1234@Repositorypublic class BookDaoImpl implements BookDao &#123; &#125; 1234@Servicepublic class BookServiceImpl implements BookService &#123;&#125; 1234@Controllerpublic class BookController &#123;&#125; 15.2 纯注释开发新建一个SpringConfig类，用来替代配置文件。 其位置：com.spring.config.SpringConfig.java com包 spring包 config包 SpringConfig.java @Configuration ：用于设定当前类为配置类@ComponentScan(&quot;com.spring&quot;) ：用用于设定扫描路径，此注释只能添加一次，多个数据用数组格式 123456//用来替代 &lt;context:component-scan base-package=&quot;com.spring&quot;/&gt;@Configuration //用于设定当前类为配置类@ComponentScan(&quot;com.spring&quot;) //用用于设定扫描路径，此注释只能添加一次，多个数据用数组格式public class SpringConfig &#123; &#125; 主函数： 1234567891011public class AppForAnnotation &#123; public static void main(String[] args) &#123; //改用注释配置初始化容器 ApplicationContext ac = new AnnotationConfigApplicationContext(SpringConfig.class); BookDao bookDao = ac.getBean(BookDao.class); bookDao.save(); BookService bookService = ac.getBean(BookService.class); bookService.save(); &#125;&#125; 123运行结果：BookDao~~~~~BookService~~~~ 15.3 bean管理 作用范围 @Scope(&quot;singleton&quot;)：单例，默认单例 @Scope(&quot;prototype&quot;)：多例 bean生命周期控制 @PostConstruct注解：init @PreDestroy注解：destory 123456789101112@Repository@Scope(&quot;prototype&quot;) //多例public class BookDaoImpl implements BookDao &#123; @PostConstruct public void init()&#123; System.out.println(&quot;init~~~&quot;); &#125; @PreDestroy public void destroy()&#123; System.out.println(&quot;destroy~~~&quot;); &#125;&#125; 15.4 依赖注入1.引用类型 1234567891011@Servicepublic class BookServiceImpl implements BookService &#123; @Autowired private BookDao bookDao; public void save() &#123; System.out.println(&quot;BookService~~~~&quot;); bookDao.save(); &#125;&#125; 主函数： 12345678public class AppForAnnotation &#123; public static void main(String[] args) &#123; ApplicationContext ac = new AnnotationConfigApplicationContext(SpringConfig.class); BookService bookService = ac.getBean(BookService.class); bookService.save(); &#125;&#125; 123运行结果：BookService~~~~ //在创建好BookService的bean,并注入BookDaoBookDao~~~~~ //调用BookDao的方法save(); 123@Repository(&quot;bookDao&quot;)public class BookDaoImpl implements BookDao &#123;&#125; 123@Repository(&quot;bookDao2&quot;)public class BookDaoImpl2 implements BookDao &#123;&#125; 当有多个同类型的bean，使用@Qualifier(&quot;bookDao2&quot;)来指定bean名 并且需要@Autowired和@Qualifier(&quot;bookDao2&quot;)一起使用 1234567891011@Servicepublic class BookServiceImpl implements BookService &#123; @Autowired @Qualifier(&quot;bookDao2&quot;) private BookDao bookDao; public void save() &#123; System.out.println(&quot;BookService~~~~&quot;); bookDao.save(); &#125;&#125; 注意： 自动装配基于反射设计创建对象并暴力反射对应属性为私有属性初始化数据，无需提供setter方法 自动装配建议使用无参构造方法创建对象，如果不提供对应的构造方法，请提供唯一的构造方法 @Qualifier注解无法单独使用，必须配合@Autowired注解使用 2.简单类型 123456789@Repositorypublic class BookDaoImpl implements BookDao &#123; @Value(&quot;dahuang&quot;) private String name; public void save()&#123; System.out.println(&quot;BookDao~~~~~&quot;+&quot;姓名：&quot;+name); &#125;&#125; 主函数： 1234567public class AppForAnnotation &#123; public static void main(String[] args) &#123; ApplicationContext ac = new AnnotationConfigApplicationContext(SpringConfig.class); BookDao bookDao = ac.getBean(BookDao.class); bookDao.save(); &#125;&#125; 12运行结果：BookDao~~~~~姓名：dahaung 但是，我们为什么不直接赋值，为什么要用@Value注解呢？ 我们可以用properties文件，向其传值。 3.读取properties文件 通过创建一个jdbc.properties文件： 1name=dahei 在配置类中新加注解@PropertySource()，括号中指定文件名： 如：@PropertySource(&quot;jdbc.properties&quot;)或者@PropertySource(&quot;classpath:jdbc.properties&quot;) 也可以指定多个文件： 如：@PropertySource(&#123;&quot;jdbc.properties&quot;,&quot;jdbc1.properties&quot;,&quot;jdbc2.properties&quot;&#125;) 12345@Configuration@ComponentScan(&quot;com.spring&quot;)@PropertySource(&quot;jdbc.properties&quot;)public class SpringConfig &#123;&#125; 在BookDaoImpl中将注解改为：@Value(&quot;$&#123;&#125;&quot;)，在&#123;&#125;中填入properties文件中的属性 如：@Value(&quot;$&#123;name&#125;&quot;) 123456789@Repositorypublic class BookDaoImpl implements BookDao &#123; @Value(&quot;$&#123;name&#125;&quot;) private String name; public void save()&#123; System.out.println(&quot;BookDao~~~~~&quot;+&quot;姓名：&quot;+name); &#125;&#125; 15.5 第三方bean管理1.使用独立的配置管理第三方bean 12345678910111213@Configurationpublic class SpringConfig &#123; //定义一个方法获得想要管理的bean @Bean // 表示当前方法返回值是一个bean public DataSource dataSource()&#123; //相关配置 ds.setDriverClassName(&quot;com.mysql.jdbc.Driver&quot;); ds.setUrl(&quot;jdbc:mysql://localhost:3306/demo&quot;); ds.getUsername(&quot;root&quot;); ds.setPassword(&quot;123456&quot;); return ds; &#125;&#125; 但是不建议将独立配置直接写在核心配置类中： 方法一：导入式(建议使用) 在config包创建一个JdbcConfig.java配置类： 12345678910111213public class JdbcConfig &#123; //定义一个方法获得想要管理的bean @Bean // 表示当前方法返回值是一个bean public DataSource dataSource()&#123; DruidDataSource ds = new DruidDataSource(); //相关配置 ds.setDriverClassName(&quot;com.mysql.jdbc.Driver&quot;); ds.setUrl(&quot;jdbc:mysql://localhost:3306/demo&quot;); ds.setUsername(&quot;root&quot;); ds.setPassword(&quot;123456&quot;); return ds; &#125;&#125; 在SpringConfig.java核心配置类中导入： 使用注解@Import()在括号中添加要导入的配置类的类型 如：@Import(JdbcConfig.class) 此注解只能添加一次，导入多个配置类，可以使用数组格式导入 如：@Import(&#123;JdbcConfig.class, XXXConfig.class, XXXConfig.calss&#125;) 12345@Configuration@Import(JdbcConfig.class)public class SpringConfig &#123; &#125; 方式二：扫描式(不建议使用) 注意：使用扫描式需要在独立的配置类加入注解@Configuration 1234567891011121314@Configurationpublic class JdbcConfig &#123; //定义一个方法获得想要管理的bean @Bean // 表示当前方法返回值是一个bean public DataSource dataSource()&#123; DruidDataSource ds = new DruidDataSource(); //相关配置 ds.setDriverClassName(&quot;com.mysql.jdbc.Driver&quot;); ds.setUrl(&quot;jdbc:mysql://localhost:3306/demo&quot;); ds.setUsername(&quot;root&quot;); ds.setPassword(&quot;123456&quot;); return ds; &#125;&#125; 在SpringConfig.java核心配置类中扫描： 使用注解@ComponentScan()在括号中添加要扫描的路径 如：@@ComponentScan(&quot;com.spring.config&quot;) 扫描多个路径，可以使用数组格式导入 如：@Import(&#123;&quot;com.spring.config&quot;,&quot;com.spring.dao&quot;&#125;) 12345@Configuration@ComponentScan(&quot;com.spring.config&quot;)public class SpringConfig &#123; &#125; 2.第三方bean注入资源 简单类型依赖注入(成员变量)： 利用注解@PropertySource(&quot;jdbc.properties&quot;)和@Import(JdbcConfig.class)导入核心主配置文件中 123456@Configuration@ComponentScan(&quot;com.spring&quot;)@PropertySource(&quot;jdbc.properties&quot;)@Import(JdbcConfig.class)public class SpringConfig &#123;&#125; 利用注解@Value(&quot;$&#123;&#125;&quot;)注入数据 12345678910111213141516171819202122public class JdbcConfig &#123; @Value(&quot;$&#123;jdbc.driver&#125;&quot;) private String driver; @Value(&quot;$&#123;jdbc.url&#125;&quot;) private String url; @Value(&quot;$&#123;jdbc.username&#125;&quot;) private String userName; @Value(&quot;$&#123;jdbc.password&#125;&quot;) private String password; //定义一个方法获得想要管理的bean @Bean // 表示当前方法返回值是一个bean public DataSource dataSource()&#123; DruidDataSource ds = new DruidDataSource(); ds.setDriverClassName(driver); ds.setUrl(url); ds.setUsername(userName); ds.setPassword(password); return ds; &#125;&#125; 引入类型依赖注入(方法形参)： 引用类型注入只需要为bean定义的方法设置形参，容器会根据类型自动装配对象 123456789//定义一个方法获得想要管理的bean @Bean // 表示当前方法返回值是一个bean public DataSource dataSource(BookDao bookDao)&#123; System.out.println(&quot;已引用：&quot;+bookDao); DruidDataSource ds = new DruidDataSource(); //对ds进行相关设置 return ds; &#125; 15.6 总结XML配置与注解配置的比较： 功能 XML配置 注解 定义bean bean标签：&gt;id属性&gt;class属性 @Component &gt;@Controller &gt;@Service &gt;@Repository@ComponentScan 设置依赖注入 setter注入(set方法)&gt;引用&#x2F;简单构造器注入(构造方法)&gt;自动装配 @Autowird&gt;@Qualifier@Value 配置第三方bean bean标签&gt;静态工厂&gt;实例工厂&gt;FactoryBean @Bean 作用范围 scope属性 @Scope 生命周期 标准接口&gt;init-method&gt;destory-method @PostConstructor@PreDestroy 16.AOP16.1 AOP简介 AOP(Aspect Oriented Programming)面向切面编程，一种编程范式，指导开发者如何组织程序结构 OOP(Object Oriented Programing)面向对象编程 作用：在不惊动原始设计的基础上为其进行功能增强 Spring理念：无入侵式&#x2F;无侵入式 执行save()方法 运行结果： 打印出一万次的book dao save … 和消耗的时间 执行update()方法没有图中蓝色区域的代码， 但是，运行结果： 仍会打印打印出一万次的book dao update … 和消耗的时间 连接点(JoinPoint)：程序执行过程中的任意位置，粒度为执行方法，抛出异常，设置变量等(代表所有的方法) 在SpringAOP中，理解方法的执行 切入点(Pointcut)：匹配连接点的式子(代表要追加功能的方法) 在SpringAOP中，一个切入点只描述一个具体方法，也可以匹配多个方法 一个具体方法：com.spring.dao包下的BookDao接口中的五星参无返回值的save()方法 匹配多个方法：所有save方法，所有的get开头的方法，所有以Dao结尾的接口中的任意方法，所有带有一个形参的方法 通知(Advice)：在切入点执行的操作，也就是共性功能(代表追加的功能) 在SpringAOP中，功能最终以方法的形式呈现 通知类：定义通知的类 切面(Aspect)：描述通知与切入的对应关系 16.2 AOP入门 案例设定：测试接口执行效率 简化设定：在接口执行当前输出当前的系统时间 开发模式：XML or 注解(此入门案例采用注解的方式) 思路分析： 导入坐标(pom.xml) 制作连接点方法(原始操作，Dao接口与实现类) 制作共性功能(通知类与通知) 定义切入点 绑定切入点与通知关系(切面) pom.xml： 1234567891011&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;5.3.18&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;version&gt;1.9.9.1&lt;/version&gt;&lt;/dependency&gt; 创建一个MyAdivice.java类 其位置：com.spring.aop.MyAdivice.java @Component注解：定义为Spring加载的bean @Aspect注解：把当前类标识为⼀个切⾯供容器读取 @Pointcut(&quot;execution()&quot;)注解：定义切入点，⽅法签名必须是public及void型。 @Before(&quot;pt()&quot;)注解：标识⼀个前置增强⽅法 切入点pt()的定义依托一个不具有实际意义的方法进行，即无参数、无返回值、方法无实际逻辑 1234567891011@Component@Aspectpublic class MyAdvice &#123; @Pointcut(&quot;execution(void com.spring.dao.BookDao.update())&quot;) private void pt()&#123;&#125; @Before(&quot;pt()&quot;) public void method()&#123; System.out.println(System.currentTimeMillis()); &#125;&#125; @EnableAspectJAutoProxy注解：开启AOP代理自动配置 123456@Configuration@ComponentScan(&quot;com.spring&quot;)@EnableAspectJAutoProxypublic class SpringConfig &#123;&#125; 主函数： 1234567public class App &#123; public static void main(String[] args) &#123; ApplicationContext ac = new AnnotationConfigApplicationContext(SpringConfig.class); BookDao bookDao = ac.getBean(BookDao.class); bookDao.update(); &#125;&#125; 123运行结果：1656341601464book dao update~~~ 16.3 AOP工作流程 Spring容器启动 读取所有切面配置中的切入点 初始化bean，判定bean对应的类中的方法是否匹配到任意切入点 匹配失败，创建对象 获取bean，调用方法并执行，完成操作 匹配成功，调用方法并执行，完成操作 获取的bean是代理对象时，根据代理对象的运行模式运行原始方法与增强内容，完成操作 AOP核心本质：代理模式 目标对象(Target)：原始功能去掉共性功能对应的类产生的对象，这种对象是无法直接完成最终工作的 代理(proxy)：目标对象无法直接完成工作，需要进行功能回填，通过原始对象的代理对象实现 代码依旧是入门案例的 但是将主函数修改，打印bookDao的类型： 12345678public class App &#123; public static void main(String[] args) &#123; ApplicationContext ac = new AnnotationConfigApplicationContext(SpringConfig.class); BookDao bookDao = ac.getBean(BookDao.class); System.out.println(bookDao); System.out.println(bookDao.getClass()); &#125;&#125; 123运行结果：com.spring.dao.impl.BookDaoImpl@d23e042class jdk.proxy2.$Proxy20 System.out.println(bookDao)打印出com.spring.dao.impl.BookDaoImpl@d23e042 是因为AOP对BookDao的toString()方法进行了重写 class jdk.proxy2.$Proxy20：最终用的是代理的对象 16.4 AOP切入点表达式切入点：要进行增强的方法 切入点表达式：要进行增强的方法的描述方法 1.语法格式 切入点标准格式：动作关键字(访问修饰符 返回值 包名.接口/类名.方法(参数) 异常名) 12execution(public User com.spring.service.UserService.findById(int))execution(public User com.spring.service.impl.UserServiceImpl.findById(int)) 动作关键字：描述切入点行为动作，如execution表示执行到指定切入点 访问修饰符：public，private等，可以省略 返回值 包名 接口&#x2F;类名：接口名或者类名都可以 方法名 参数 异常名：方法定义中抛出指定异常，可以省略 2.通配符 可以使用通配符描述切入点，快速描述 *：单个独立的任意符号，可以独立出现，也可以作为前缀或者后缀的匹配符出现 1execution(public * com.spring.*.UserService.find*(*)) 解释：匹配com.spring包下的任意包中含有UserService类或接口中所有含有find开头的带有任意一个参数的方法 ..：多个连续的任意符号，可以独立出现，常用于简化包名与参数的书写 1execution(public User com..UserService.findById(..)) 解释：匹配com包中的任意包中的UserService类或接口中的所有名称为findById的方法 +：专用于匹配子类类型 1execution(* *..*Service+.*(..)) 解释：匹配·任意包下的以Service结尾的类或接口的子类中业务层的所有方法 常用写法 1execution(* com.spring.*.*Service.save(..)) 解释：匹配业务层所有的名为save的方法 3.书写技巧 所有代码按照标准规范开发，否则一下技巧全部失效 描述切入点通常描述接口，而不描述实现类 访问控制修饰符针对接口开发均采用public描述(可省略) 返回值类型对应增删改类使用精准类型加速匹配，对于查询类返回值使用*通配符快速描述 包名书写尽量不使用..匹配，效率过低，常用*做单个包描述匹配，或精准匹配 接口名&#x2F;类名书写名称与模块的采用*匹配 如：UserService书写成*Service，绑定业务层接口名 方法名书写以动词进行精准匹配，名词采用*匹配 如：getById书写成getBy*，selectAll书写成selectAll 参数规则较为复杂，根据业务方法灵活调整 通常不使用异常作为匹配规则 16.5 AOP通知类型AOP通知描述了抽取的共性功能，根据共性功能抽取的位置不同，最终运行代码时要将其加入到合理的位置 AOP通知共分为5钟类型 前置通知 1234567891011@Component@Aspectpublic class MyAdvice &#123; @Pointcut(&quot;execution(void com.spring.dao.BookDao.update())&quot;) private void pt()&#123;&#125; @Before(&quot;pt()&quot;) public void method()&#123; System.out.println(&quot;before~~~&quot;); &#125;&#125; 123运行结果：before~~~book dao update~~~ 后置通知 ​ 1234567891011@Component@Aspectpublic class MyAdvice &#123; @Pointcut(&quot;execution(void com.spring.dao.BookDao.update())&quot;) private void pt()&#123;&#125; @Before(&quot;pt()&quot;) public void method()&#123; System.out.println(&quot;after~~~&quot;); &#125;&#125; 123运行结果：book dao update~~~after~~~ 环绕通知(重点) 1.无返回值 1234567891011121314@Component@Aspectpublic class MyAdvice &#123; @Pointcut(&quot;execution(void com.spring.dao.BookDao.update())&quot;) private void pt()&#123;&#125; @Around(&quot;pt()&quot;) public void method(ProceedingJoinPoint pjp) throws Throwable &#123; System.out.println(&quot;before~~~&quot;); //表示对原始操作的调用 pjp.proceed(); System.out.println(&quot;after~~~&quot;); &#125;&#125; 1234运行结果：before~~~book dao update~~~after~~~ 2.有返回值 在BookDaoImpl中新写一个有返回值的select方法 12345678@Repositorypublic class BookDaoImpl implements BookDao &#123; @Override public int select() &#123; System.out.println(&quot;book dao select~~~&quot;); return 100; &#125;&#125; 123456789101112131415@Component@Aspectpublic class MyAdvice &#123; @Pointcut(&quot;execution(void com.spring.dao.BookDao.select())&quot;) private void pt()&#123;&#125; @Around(&quot;pt()&quot;) public Object method(ProceedingJoinPoint pjp) throws Throwable &#123; System.out.println(&quot;before~~~&quot;); //表示对原始操作的调用，并获得返回值 Object ret = pjp.proceed(); System.out.println(&quot;after~~~&quot;); return ret; &#125;&#125; 主函数： 12345678public class App &#123; public static void main(String[] args) &#123; ApplicationContext ac = new AnnotationConfigApplicationContext(SpringConfig.class); BookDao bookDao = ac.getBean(BookDao.class); int num = bookDao.select(); System.out.println(num); &#125;&#125; 12345运行结果：before~~~book dao select~~~after~~~100 并且有无返回值都建议这样的写法： 1234567@Around(&quot;pt()&quot;) public Object method(ProceedingJoinPoint pjp) throws Throwable &#123; System.out.println(&quot;before~~~&quot;); Object ret = pjp.proceed(); System.out.println(&quot;after~~~&quot;); return ret; &#125; @Around注意事项 环绕通知必须依赖形参ProceedingJoinPoint才能实现对原始方法的调用 ,进而实现原始方法调用前后同时添加通知 通知中如果未使用ProceedingJoinPoint对原始方法进行调用将跳过原始方法的执行 对原始方法的调用可以不接收返回值 ,通知方法设置成void即可, 如果接收返回值, 必须设定为Object类型 原始方法的返回值如果 是void类型,通知方法的返回值类型可以设置成void ,也可以设置成Object 由于无法预知原始方法运行后是否会抛出异常 ,因此环绕通知方法必须抛出Throwable对象 返回后通知(了解) 1234567891011@Component@Aspectpublic class MyAdvice &#123; @Pointcut(&quot;execution(int com.spring.dao.BookDao.select())&quot;) private void pt()&#123;&#125; @AfterReturning(&quot;pt()&quot;) public void method()&#123; System.out.println(&quot;afterReturn~~~&quot;); &#125;&#125; 1234运行结果：book dao select~~~afterReturn~~~100 @after和@AfterReturning的区别： 原始方法有异常时： @after也会打印通知的方法 @AfterReturning不会打印通知的方法 抛出异常后通知(了解) 1234567891011@Component@Aspectpublic class MyAdvice &#123; @Pointcut(&quot;execution(int com.spring.dao.BookDao.select())&quot;) private void pt()&#123;&#125; @AfterThrowing(&quot;pt()&quot;) public void method()&#123; System.out.println(&quot;afterThrowing~~~&quot;); &#125;&#125; 123运行结果：book dao select~~~100 @AfterThrowing注解：只有原始方法抛出异常，才会执行通知的方法 16.6 AOP通知获取数据 获取切入点方法的参数 JoinPoint：适用于前置、后置、返回后、抛出异常后通知 ProceedJointPoint：适用于环绕通知 获取切入点方法返回值 返回后通知 环绕通知 获取切入点方法运行异常信息 抛出异常后通知 环绕通知 123456789@Repositorypublic class BookDaoImpl implements BookDao &#123; @Override public int select(int id, String name) &#123; System.out.println(&quot;book dao select~~~&quot;); System.out.println(&quot;id:&quot;+id+&quot; name:&quot;+name); return 100; &#125;&#125; AOP通知获取参数数据 joinPoint对象描述了连接点方法的运行状态，可以获取到原始方法的调用参数 1234567891011121314@Component@Aspectpublic class MyAdvice &#123; @Pointcut(&quot;execution(int com.spring.dao.BookDao.select(..))&quot;) private void pt()&#123;&#125; @Before(&quot;pt()&quot;) public void method(JoinPoint jp)&#123; Object[] args = jp.getArgs(); System.out.println(Arrays.toString(args)); &#125;&#125; 主函数调用select方法： 1234567public class App &#123; public static void main(String[] args) &#123; ApplicationContext ac = new AnnotationConfigApplicationContext(SpringConfig.class); BookDao bookDao = ac.getBean(BookDao.class); bookDao.select(100, &quot;dahuang&quot;); &#125;&#125; 123运行结果：[100, dahuang]book dao select~~~ ProceedingJoinPoint是JoinPoint的子类 12345678@Around(&quot;pt()&quot;) public Object method(ProceedingJoinPoint pjp) throws Throwable &#123; Object[] args = pjp.getArgs(); System.out.println(Arrays.toString(args)); args[0] = 666; Object ret = pjp.proceed(args); return ret; &#125; 1234运行结果：[100, dahuang]book dao select~~~id:666 name:dahuang AOP通知获取返回数据 抛出异常后通知可以获取切入点方法中出现的异常信息，使用形参可以接收对应的异常对象 1234@AfterReturning(value = &quot;pt()&quot;, returning = &quot;ret&quot;)public void method(JoinPoint jp, int ret)&#123; System.out.println(&quot;afterReturn~~~&quot;+ret);&#125; 环绕通知中可以手工书写对原始方法的调用，得到的结果即为原始方法的返回值 12345@Around(&quot;pt()&quot;) public Object method(ProceedingJoinPoint pjp) throws Throwable &#123; Object ret = pjp.proceed(); return ret; &#125; AOP通知获取异常数据(了解) 抛出异常后通知可以获取切入点方法中出现的异常信息，使用形参可以接收对应的异常对象 1234@AfterThrowing(value = &quot;pt()&quot;, throwing = &quot;t&quot;)public void method(JoinPoint jp, Throwable t)&#123; System.out.println(&quot;afterThrowing~~~&quot;+t);&#125; 抛出异常后通知可以获取切入点方法运行的异常信息，使用形参可以接收运行时抛出的异常对象 1234567891011@Around(&quot;pt()&quot;) public Object method(ProceedingJoinPoint pjp) throws Throwable &#123; Object ret = null; try&#123; ret = pjp.proceed(); &#125; catch(Throwable t)&#123; t.printStackTrace(); &#125; return ret; &#125; 16.7 AOP总结1.基本概念： 概念：AOP(Aspect Oriented Programming) 面向切面编程，一种编程范式 作用：在不惊动原始设计的基础上为方法进行功能增强 核心概念 代理(Proxy)：SpringAOP的核心本质是采用代理模式实现的 连接点(JoinPoint )：在SpringAOP中 ,理解为任意方法的执行 切入点( Pointcut )：匹配连接点的式子,也是具有共性功能的方法描述 通知(Advice)：若干个方法的共性功能,在切入点处执行,最终体现为-一个方法 切面( Aspect )：描述通知与切入点的对应关系 目标对象 ( Target )：被代理的原始对象成为目标对象 2.切入点： 切入点表达式标准格式： 动作关键字(访问修饰符 返回值 包名.类&#x2F;接口名.方法名(参数) 异常名) execution(* com.spring.service.*Service.*(..)) 切入点表达式描述通配符： 作用: 用于快速描述,范围描述 *：匹配任意符号(常用) ..：匹配多个连续的任意符号(常用) +：匹配子类类型 切入点表达式书写技巧 按标准规范开发 查询操作的返回值建议使用*匹配 减少使用..的形式描述包 对接口进行描述,使用*表示模块名,例如UserService的匹配描述为*Service 方法名书写保留动词,例如get ,使用*表示名词,例如getById匹配描述为getBy* 参数根据实际情况灵活调整 3.通知类型： 前置通知 后置通知 环绕通知(重点) 环绕通知依赖形参ProceedingJoinPoint才能实现对原始方法的调用 环绕通知可以隔离原始方法的调用执行 环绕通知返回值设置为0bject类型 环绕通知中可以对原始方法调用过程中出现的异常进行处理 返回后通知 抛出异常后通知 4.通知获取数据： 获取切入点方法的参数 JoinPoint：适用于前置、后置、返回后、抛出异常后通知,设置为方法的第一个形参 ProceedJointPoint：适用于环绕通知 获取切入点方法返回值 返回后通知 . 环绕通知 获取切入点方法运行异常信息 抛出异常后通知 环绕通知 17.Spring事务17.1 Spring事务简介事务作用：在数据层保障一系列的数据库操作同成功同失败 Spring事务作用：在数据层或业务层保障一系列的数据库操作同成功同失败 案例：银行转账 需求:实现任意两个账户间转账操作 需求微缩: A账户减钱, B账户加钱 分析: ①数据层提供基础操作, 指定账户减钱( outMoney ) , 指定账户加钱( inMoney ) ②业务层提供转账操作( transfer ) , 调用减钱与加钱的操作 ③提供2个账号和操作金额执行转账操作 ④基于Spring整合MyBatis环境搭建上述操作 JDK版本：8 项目结构： pom.xml 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;5.2.10.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.1.16&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.5.6&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.47&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;5.2.10.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt; &lt;version&gt;1.3.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;5.2.10.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; com.spring.config包下： JdbcConfig 12345678910111213141516171819202122232425262728public class JdbcConfig &#123; @Value(&quot;$&#123;jdbc.driver&#125;&quot;) private String driver; @Value(&quot;$&#123;jdbc.url&#125;&quot;) private String url; @Value(&quot;$&#123;jdbc.username&#125;&quot;) private String userName; @Value(&quot;$&#123;jdbc.password&#125;&quot;) private String password; @Bean public DataSource dataSource()&#123; DruidDataSource ds = new DruidDataSource(); ds.setDriverClassName(driver); ds.setUrl(url); ds.setUsername(userName); ds.setPassword(password); return ds; &#125; //配置事务管理器，mybatis使用的是jdbc事务 @Bean public PlatformTransactionManager transactionManager(DataSource dataSource)&#123; DataSourceTransactionManager transactionManager = new DataSourceTransactionManager(); transactionManager.setDataSource(dataSource); return transactionManager; &#125;&#125; MybatisConfig 1234567891011121314151617public class MybatisConfig &#123; @Bean public SqlSessionFactoryBean sqlSessionFactory(DataSource dataSource)&#123; SqlSessionFactoryBean ssfb = new SqlSessionFactoryBean(); ssfb.setTypeAliasesPackage(&quot;com.itheima.p&quot;); ssfb.setDataSource(dataSource); return ssfb; &#125; @Bean public MapperScannerConfigurer mapperScannerConfigurer()&#123; MapperScannerConfigurer msc = new MapperScannerConfigurer(); msc.setBasePackage(&quot;com.itheima.dao&quot;); return msc; &#125;&#125; 核心配置类：SpringConfig 12345678@Configuration@ComponentScan(&quot;com.itheima&quot;)@PropertySource(&quot;classpath:jdbc.properties&quot;)@Import(&#123;JdbcConfig.class,MybatisConfig.class&#125;)//开启注解式事务驱动@EnableTransactionManagementpublic class SpringConfig &#123;&#125; Account 123456789101112131415161718192021222324252627282930313233343536373839public class Account implements Serializable &#123; private Integer id; private String name; private Double money; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public Double getMoney() &#123; return money; &#125; public void setMoney(Double money) &#123; this.money = money; &#125; @Override public String toString() &#123; return &quot;Account&#123;&quot; + &quot;id=&quot; + id + &quot;, name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &quot;, money=&quot; + money + &#x27;&#125;&#x27;; &#125;&#125; com.spring.dao包下： AccountDao 12345678public interface AccountDao &#123; @Update(&quot;update demo.account set money = money + #&#123;money&#125; where name = #&#123;name&#125;&quot;) void inMoney(@Param(&quot;name&quot;) String name, @Param(&quot;money&quot;) Double money); @Update(&quot;update demo.account set money = money - #&#123;money&#125; where name = #&#123;name&#125;&quot;) void outMoney(@Param(&quot;name&quot;) String name, @Param(&quot;money&quot;) Double money);&#125; AccountService 12345public interface AccountService &#123; //配置当前接口方法具有事务 @Transactional public void transfer(String out,String in ,Double money) ;&#125; AccountServiceImpl 12345678910@Servicepublic class AccountServiceImpl implements AccountService &#123; @Autowired private AccountDao accountDao; public void transfer(String out,String in ,Double money) &#123; accountDao.outMoney(out,money); accountDao.inMoney(in,money); &#125;&#125; 测试类：AccountServiceTest 1234567891011@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(classes = SpringConfig.class)public class AccountServiceTest &#123; @Autowired private AccountService accountService; @Test public void testTransfer() throws IOException &#123; accountService.transfer(&quot;Tom&quot;,&quot;Jerry&quot;,100D); &#125;&#125; 17.2 Spring事务角色事务角色 事务管理员：发起事务方，在Spring中通常代指业务层开启事务的方法 事务协调员：加入事务方，在Spring中通常代指数据层方法，也可以是业务层的方法 17.3 Spring事务属性 属性 作用 示例 readOnly 设置是否为只读事务 readOnly&#x3D;true 只读事务 timeout 设置事务超时时间 timeout&#x3D;-1 永不超时 rollbackFor 设置事务回滚异常(class) rollbackFor&#x3D;{NullPointException.class} rollbackForClassName 设置事务回滚异常(String) 同上字符串格式 noRollbackFor 设置事务不回滚异常(class) norollbackFor&#x3D;{NullPointException.class} noRollbackForClassName 设置事务不回滚异常(String) 同上字符串格式 propagation 设置事务传播行为 ….. 12345678910111213@Servicepublic class AccountServiceImpl implements AccountService &#123; @Autowired private AccountDao accountDao; @Override public void transfer(String out, String in, Double money) throws IOException &#123; accountDao.outMoney(out,money); //添加IOException类型错误 if(true) throw new IOException(); accountDao.inMoney(in,money); &#125;&#125; 运行后，报错，outMoney方法执行了，但inMoney方法没有执行 并不是所有错误类型都会回滚 我们希望transfer方法，调用的事务同失败 在@Transactional注解中的属性rollbackFor添加错误的类型 12345public interface AccountService &#123; @Transactional(rollbackFor = &#123;IOException.class&#125;) void transfer(String out, String in, Double money) throws IOException;&#125; 再次运行后，报错，outMoney和inMoney方法都没有执行 案例：转账业务追加日志 需求:实现任意两个账户间转账操作,并对每次转账操作在数据库进行留痕 需求微缩: A账户减钱, B账户加钱,数据库记录日志 分析: ①:基于转账操作案例添加日志模块,实现数据库中记录日志 ②:业务层转账操作( transfer ) ,调用减钱、加钱与记录日志功能 实现效果预期： ​ 无论转账操作是否成功,均进行转账操作的日志留痕 123456789101112131415161718192021@Servicepublic class AccountServiceImpl implements AccountService &#123; @Autowired private AccountDao accountDao; @Autowired private LogService logService; @Override public void transfer(String out, String in, Double money) throws IOException &#123; try&#123; accountDao.outMoney(out,money); int i = 1/0; accountDao.inMoney(in,money); &#125; finally&#123; logService.log(out,in,money); &#125; &#125;&#125; 运行后，outMoney方法和inMoney方法进行回滚，同时log方法也进行了回滚，未将日志记录到数据库中 存在问题： 日志的记录与转账操作隶属同一个事务，同成功同失败 事务传播行为：事务协调员对事物管理员所携带事务的处理态度 在业务层接口添加Spring事务， @Transactional注解中的propagation属性设置事务传播行为REQIRES_NEW(需要新事务) 123456@Servicepublic interface LogService &#123; //设置为新事务 @Transactional(propagation=Propagation.REQIRES_NEW) public void log(String out, String in, Double money);&#125; 运行后，outMoney方法和inMoney方法进行回滚，事务成功。 log方法执行，将日志记录到数据库中 传播属性 事务管理员 事务协调员 REQUIRED(默认) 开启T 加入T 无 新建T2 REQUIRES_NEW 开启T 新建T2 无 新建T2 SUPPORTS 开启T 加入T 无 无 NOT_SUPPORTED 开启T 无 无 无 MANDATORY 开启T 加入T 无 ERROR NEVER 开启T ERROR 无 无 NESTED 设置savePoint，一旦事务回滚，事务将回滚到savePoint处，交由客户端提交/回滚 ​ 18.结语你竟然看完了(不敢相信！！)，真的人会看吗！真的吗！ゞ◎Д◎ヾ 本人也是初学Spring，笔记中如果有什么遗漏或错误的地方欢迎大佬指正（≧∀≦） 本人QQ：2691936018 备注：Spring 另外关于Spring框架，如果有新的内容需要补充，本人也会进行更新的 本笔记的学习视频：黑马2022最新SSM框架 我们SpringMVC见！！(还是不太相信能有人看╮(╯▽╰)╭)","categories":[{"name":"Java","slug":"Java","permalink":"http://example.com/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"},{"name":"框架","slug":"框架","permalink":"http://example.com/tags/%E6%A1%86%E6%9E%B6/"}]},{"title":"(每日LeetCode)剑指 Offer II 091. 粉刷房子","slug":"每日LeetCode/2022-6/剑指 Offer II 091 粉刷房子","date":"2022-06-25T02:00:00.000Z","updated":"2022-07-08T00:34:56.580Z","comments":true,"path":"2022/06/25/每日LeetCode/2022-6/剑指 Offer II 091 粉刷房子/","link":"","permalink":"http://example.com/2022/06/25/%E6%AF%8F%E6%97%A5LeetCode/2022-6/%E5%89%91%E6%8C%87%20Offer%20II%20091%20%E7%B2%89%E5%88%B7%E6%88%BF%E5%AD%90/","excerpt":"","text":"题目：假如有一排房子，共 n 个，每个房子可以被粉刷成红色、蓝色或者绿色这三种颜色中的一种，你需要粉刷所有的房子并且使其相邻的两个房子颜色不能相同。 当然，因为市场上不同颜色油漆的价格不同，所以房子粉刷成不同颜色的花费成本也是不同的。每个房子粉刷成不同颜色的花费是以一个 n x 3 的正整数矩阵 costs来表示的。 例如，costs[0][0] 表示第 0 号房子粉刷成红色的成本花费；costs[1][2] 表示第 1 号房子粉刷成绿色的花费，以此类推。请计算出粉刷完所有房子最少的花费成本。 示例： 输入: costs &#x3D; [[17,2,17],[16,16,5],[14,3,19]]输出: 10解释: 将 0 号房子粉刷成蓝色，1 号房子粉刷成绿色，2 号房子粉刷成蓝色。 最少花费: 2 + 5 + 3 &#x3D; 10。 1.递归代码(cpp)：12345678910111213141516171819202122232425262728293031class Solution &#123;public: int def(vector&lt;vector&lt;int&gt;&gt;&amp; costs, int pos, int n, vector&lt;vector&lt;int&gt;&gt; flag) &#123; //到达最后，没有房子了，退出 if (pos == n) return 0; int ans = INT_MAX; //依次选择三种颜色 for (int i = 0; i &lt; 3; i++) &#123; int temp = INT_MAX; vector&lt;vector&lt;int&gt;&gt; temp_flag(flag); //粉刷第一个房子，无需看前面房子的颜色，因为前面没有房子。 if (pos == 0) &#123; temp_flag[pos][i] = -1; temp = def(costs, pos + 1, n, temp_flag) + costs[pos][i]; &#125; //粉刷墙，要看前面用了什么颜色 else if (flag[pos - 1][i] != -1) &#123; //将这个房子的颜色标记 temp_flag[pos][i] = -1; temp = def(costs, pos + 1, n, temp_flag) + costs[pos][i]; &#125; //选择花费最少的金额 ans = min(ans, temp); &#125; return ans; &#125; int minCost(vector&lt;vector&lt;int&gt;&gt;&amp; costs) &#123; return def(costs, 0, costs.size(), costs); &#125;&#125;; 采用递归的方法，提交后，结果执行超时。 2.动态规划$$Red[pos][0]&#x3D;\\begin{cases}cost[0][0] &amp; pos &#x3D; 0; \\min(Green[pos+1][1],Blue[pos+1][2]) + costs[pos][0] &amp; pos&gt;0\\end{cases} \\$$ $$Green[pos][1]&#x3D;\\begin{cases}cost[0][1] &amp; pos &#x3D; 0; \\min(Red[pos+1][0],Blue[pos+1][2]) + costs[pos][1] &amp; pos&gt;0\\end{cases} \\$$ $$Blue[pos][2]&#x3D;\\begin{cases}cost[0][2] &amp; pos &#x3D; 0; \\min(Red[pos+1][0],Green[pos+1][1]) + costs[pos][2] &amp; pos&gt;0\\end{cases}$$ 画出动态规划图，以示例为例： costs = [[17,2,17],[16,16,5],[14,3,19]] 颜色\\pos 0 1 2 Red(0) 17 18 21 Green(1) 2 33 10 Blue(2) 17 7 37 $$mincost &#x3D; min(dp[2][0],dp[2][1],dp[2][2])$$ 代码(cpp)：123456789101112131415161718192021class Solution &#123;public: int minCost(vector&lt;vector&lt;int&gt;&gt;&amp; costs) &#123; int n = costs.size(); vector&lt;int&gt; red(n, 0); vector&lt;int&gt; blue(n, 0); vector&lt;int&gt; green(n, 0); // 初始化 red[0] = costs[0][0]; blue[0] = costs[0][1]; green[0] = costs[0][2]; for (int i = 1; i &lt; n; ++i) &#123; red[i] = min(blue[i - 1], green[i - 1]) + costs[i][0]; blue[i] = min(red[i - 1], green[i - 1]) + costs[i][1]; green[i] = min(red[i - 1], blue[i - 1]) + costs[i][2]; &#125; return min(red[n - 1], min(blue[n - 1], green[n - 1])); &#125;&#125;; 复杂度分析 时间复杂度：O(n)，其中 n 是房子个数。需要遍历全部房子一次，由于颜色数量固定是三种，因此对于每个房子计算粉刷房子的最小花费成本的时间是 O(1)，总时间复杂度是 O(n)。 空间复杂度：O(1)。使用空间优化的方法，只需要维护一个长度为 3 的数组，空间复杂度是 O(1)。","categories":[{"name":"每日LeetCode","slug":"每日LeetCode","permalink":"http://example.com/categories/%E6%AF%8F%E6%97%A5LeetCode/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"},{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"(每日LeetCode)515. 在每个树行中找最大值(中等)","slug":"每日LeetCode/2022-6/515 在每个树行中找最大值","date":"2022-06-24T01:04:00.000Z","updated":"2022-07-08T00:35:14.972Z","comments":true,"path":"2022/06/24/每日LeetCode/2022-6/515 在每个树行中找最大值/","link":"","permalink":"http://example.com/2022/06/24/%E6%AF%8F%E6%97%A5LeetCode/2022-6/515%20%E5%9C%A8%E6%AF%8F%E4%B8%AA%E6%A0%91%E8%A1%8C%E4%B8%AD%E6%89%BE%E6%9C%80%E5%A4%A7%E5%80%BC/","excerpt":"","text":"题目：给定一棵二叉树的根节点 root ，请找出该二叉树中每一层的最大值。 示例： 输入: root &#x3D; [1,3,2,5,3,null,9]输出: [1,3,9] 思路：深度优先搜索我们采用树的先序遍历，来进行深度优先搜索，并用pos来记录当前树的高度，就可以通过pos高度来判断是否在同一层，并且是否更新此高度的最大值。 代码(cpp)：123456789101112131415161718192021222324252627class Solution &#123;public: void dfs(TreeNode* root, vector&lt;int&gt;&amp; result, int pos)&#123; //如果该结点为空，则退出 if(root == nullptr) return; if(result.size() == pos)&#123; //数组的大小小于高度，大小需要加1 result.push_back(root-&gt;val); &#125; else&#123; //判断该层的某个结点，与之前记录的比较大小 result[pos] = max(result[pos], root-&gt;val); &#125; //遍历左子树，高度+1 dfs(root-&gt;left, result, pos+1); //遍历右子树，高度+1 dfs(root-&gt;right, result, pos+1); &#125; vector&lt;int&gt; largestValues(TreeNode* root) &#123; vector&lt;int&gt; result; dfs(root, result, 0); return result; &#125;&#125;; 复杂度分析 时间复杂度：O(n)，其中 n 为二叉树节点个数。二叉树的遍历中每个节点会被访问一次且只会被访问一次。 空间复杂度：O(pos)。其中 pos 表示二叉树的高度。递归函数需要栈空间，而栈空间取决于递归的深度，因此空间复杂度等价于二叉树的高度。","categories":[{"name":"每日LeetCode","slug":"每日LeetCode","permalink":"http://example.com/categories/%E6%AF%8F%E6%97%A5LeetCode/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"},{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"(每日LeetCode)30. 串联所有单词的子串","slug":"每日LeetCode/2022-6/30 串联所有单词的子串","date":"2022-06-23T03:53:00.000Z","updated":"2022-07-08T00:35:01.595Z","comments":true,"path":"2022/06/23/每日LeetCode/2022-6/30 串联所有单词的子串/","link":"","permalink":"http://example.com/2022/06/23/%E6%AF%8F%E6%97%A5LeetCode/2022-6/30%20%E4%B8%B2%E8%81%94%E6%89%80%E6%9C%89%E5%8D%95%E8%AF%8D%E7%9A%84%E5%AD%90%E4%B8%B2/","excerpt":"","text":"题目：给定一个字符串s和一些长度相同的单词words。找出s中恰好可以由words中所有单词串联形成的子串的起始位置。 注意子串要与words中的单词完全匹配，中间不能有其他字符，但不需要考虑words中单词串联的顺序。 示例： 输入：s &#x3D; “barfoofoobarthefoobarman”, words &#x3D; [“bar”,”foo”,”the”]输出：[6,9,12] 输出返回字串的第一个字符在s中的位置 第一个字串：barfoofoobarthefoobarman 6 第二个字串：barfoofoobarthefoobarman 9 第三个字符：barfoofoobarthefoobarman 12 思路：滑动窗口 word_len为每个单词的长度，因为每个单词的长度都相同； word_num为words数组中单词的个数； total_len为words数组中所有的单词的总长度； map来记录words数组中每个单词的个数； t_map遍历s时用来记录； 左指针left和右指针right用来当作左右边界； count用来统计已经匹配单词的个数，如果count == word_num，就证明匹配成功； 遍历s时无需一个一个字符的遍历，可以一个一个单词的遍历，right += word_len； 如果截取的单词map中不存在，则之前记录的全部无效，清空t_map和count； 如果某个单词在t_map中的个数大于map中的个数，就需要删除匹配的多余的单词，就需要删除窗口中第一个单词，直到某个单词出现的次数小于map中的个数 代码(cpp)：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364class Solution &#123;public: vector&lt;int&gt; findSubstring(string s, vector&lt;string&gt;&amp; words) &#123; //用来存放结果 vector&lt;int&gt; result; //判断s和words是否为空，如果其中有一个为空，则返回空数组 if(s.empty()||words.empty())&#123; return result; &#125; int word_len = words[0].size(); //一个单词的长度（每个单词长度都相同） int word_num = words.size(); // 单词的总个数 int total_len = word_len*word_num; // 全部单词的长度 //建立单词-&gt;单词个数的映射 unordered_map&lt;string, int&gt; map; //统计每个单词的个数 for(auto &amp;word : words)&#123; //map[key]:返回key值所对应的value值，如果不存在key值，则会使用该key值向当前容器中插入一个新value值为 0 map[word]++; //等价于 map[word] += 1 &#125; for(int i = 0; i&lt; word_len; i++)&#123; //left和right用来表示窗口的左右边界 int left = i; int right = i; //count用来统计已经匹配的单词个数 int count = 0; unordered_map&lt;string, int&gt; t_map; //开始滑动窗口 //right右边界依次累加单词的长度，直到超过s的长度停止循环 while(right + word_len &lt;= s.size())&#123; //substr(pos, n):从第pos的位置开始截取n个字符获取单词 string word = s.substr(right, word_len); right += word_len; //right跳到下一个单词 //count(key):在容器中查找以key键的键值对的个数。如果为0，说明此单词word在words数组中不存在。 if(map.count(word) == 0)&#123; count = 0; //清空之前统计的个数 left = right; //将左指针left移动到右指针right位置上重新开始 t_map.clear(); //之前匹配的单词没用了，清空t_map中的元素 &#125; //如果不为0，说明此单词word在words数组中存在。 else&#123; count++; //统计个数加1 t_map[word]++;// word所对应的个数加1 //t_map中的word对应的个数大于map的word对应的个数，说明匹配到多余的单词了 while(t_map[word]&gt; map[word])&#123; //获取窗口的第一个单词 string t_word = s.substr(left, word_len); //将t_word这个单词对应的个数减1 //并非是那个大于map中个数的单词 t_map[t_word]--; count--; //统计个数减1 left += word_len;//将左指针跳到下一个 &#125; //如果count等于单词的个数说明匹配成功，将左指针位置记录 if(count == word_num)&#123; result.push_back(left); &#125; &#125; &#125; &#125; return result; &#125;&#125;; 复杂度分析 时间复杂度：O(ls×n)，其中 ls 是输入 s 的长度，n 是 words 中每个单词的长度。需要做 n 次滑动窗口，每次需要遍历一次 s。","categories":[{"name":"每日LeetCode","slug":"每日LeetCode","permalink":"http://example.com/categories/%E6%AF%8F%E6%97%A5LeetCode/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"},{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"(每日LeetCode)513. 找树左下角的值","slug":"每日LeetCode/2022-6/513 找树左下角的值","date":"2022-06-22T03:11:00.000Z","updated":"2022-07-08T00:35:09.778Z","comments":true,"path":"2022/06/22/每日LeetCode/2022-6/513 找树左下角的值/","link":"","permalink":"http://example.com/2022/06/22/%E6%AF%8F%E6%97%A5LeetCode/2022-6/513%20%E6%89%BE%E6%A0%91%E5%B7%A6%E4%B8%8B%E8%A7%92%E7%9A%84%E5%80%BC/","excerpt":"","text":"题目：给定一个二叉树的 根节点 root，请找出该二叉树的 最底层 最左边 节点的值。 假设二叉树中至少有一个节点。 示例: 输入: [1,2,3,4,null,5,6,null,null,7]输出: 7 思路：深度优先搜索(DFS)我采用了优先遍历左节点，再遍历右节点，因为只有优先遍历左节点，才会优先记录当前深度左节点的值，所以就没有必要记录当前深度右边的值了。 使用depth记录当前树的深度，current_val为记录的深度current_depth的最左边的值。 进行判断如果depth的深度大于current_depth的深度，将current_val的值设置为当前结点的值，并将current_depth的值设置当前结点深度depth 代码(cpp)：1234567891011121314151617181920212223242526272829class Solution &#123;public: void dfs(TreeNode* root, int depth, int&amp; current_depth, int&amp; current_val) &#123; if (root == nullptr) //如果当前结点为空，则退出 &#123; return; &#125; //优先遍历左节点，深度加1 dfs(root-&gt;left, depth+1, current_depth, current_val); //其次遍历右节点，深度加1 dfs(root-&gt;right, depth+1, current_depth, current_val); //如果当前深度大于记录的深度 if (depth &gt; current_depth) &#123; current_depth = depth; //将当前深度记录到current_depth current_val = root-&gt;val; //将当前结点值记录到current_val &#125; &#125; int findBottomLeftValue(TreeNode* root) &#123; int current_depth = 0; //初始化current_depth int current_val = 0; //初始化current_val //因为有根结点存在，将depth设置为1，而非0 dfs(root, 1, current_depth, current_val); return current_val; &#125;&#125;; 复杂度分析 ​ 时间复杂度：O(n)，其中 n 是二叉树的节点数目。需要遍历 n 个节点。 ​ 空间复杂度：O(n)。递归栈需要占用 O(n) 的空间。","categories":[{"name":"每日LeetCode","slug":"每日LeetCode","permalink":"http://example.com/categories/%E6%AF%8F%E6%97%A5LeetCode/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"},{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]}],"categories":[{"name":"每日LeetCode","slug":"每日LeetCode","permalink":"http://example.com/categories/%E6%AF%8F%E6%97%A5LeetCode/"},{"name":"C++","slug":"C","permalink":"http://example.com/categories/C/"},{"name":"Java","slug":"Java","permalink":"http://example.com/categories/Java/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"},{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"},{"name":"容器","slug":"容器","permalink":"http://example.com/tags/%E5%AE%B9%E5%99%A8/"},{"name":"STL","slug":"STL","permalink":"http://example.com/tags/STL/"},{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"},{"name":"框架","slug":"框架","permalink":"http://example.com/tags/%E6%A1%86%E6%9E%B6/"}]}