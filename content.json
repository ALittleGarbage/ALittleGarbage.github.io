{"meta":{"title":"活着就是为了摸鱼🐟！！！","subtitle":"","description":"一个不起眼的小博客","author":"一个小垃圾","url":"http://example.com","root":"/"},"pages":[{"title":"关于我是谁","date":"2022-06-25T09:46:19.000Z","updated":"2022-06-26T00:50:58.784Z","comments":true,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":""},{"title":"archives","date":"2022-06-25T09:46:11.000Z","updated":"2022-06-25T10:00:28.430Z","comments":true,"path":"archives/index.html","permalink":"http://example.com/archives/index.html","excerpt":"","text":""},{"title":"所有分类","date":"2022-06-25T09:45:03.000Z","updated":"2022-06-25T10:09:55.599Z","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"所有标签","date":"2022-06-25T09:44:36.000Z","updated":"2022-06-25T10:10:32.117Z","comments":true,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"(每日LeetCode)556. 下一个更大元素 III","slug":"每日LeetCode/556 下一个更大元素 III","date":"2022-07-03T04:00:00.000Z","updated":"2022-07-03T04:02:09.035Z","comments":true,"path":"2022/07/03/每日LeetCode/556 下一个更大元素 III/","link":"","permalink":"http://example.com/2022/07/03/%E6%AF%8F%E6%97%A5LeetCode/556%20%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%9B%B4%E5%A4%A7%E5%85%83%E7%B4%A0%20III/","excerpt":"","text":"题目：给你一个正整数 n ，请你找出符合条件的最小整数，其由重新排列 n 中存在的每位数字组成，并且其值大于 n 。如果不存在这样的正整数，则返回 -1 。 注意 ，返回的整数应当是一个 32 位整数 ，如果存在满足题意的答案，但不是 32 位整数 ，同样返回 -1。 示例：示例 1： 输入：n &#x3D; 12324321输出：12331224 示例 2： 输入：n &#x3D; 21输出：-1 思路：以n = 12324321为例 ①.pos1指针从后往前遍历，找到第pos1位置的数比后面的数小的位置，pos1记录位置 1 2 3 2 4 3 2 1 $\\leftarrow\\Uparrow$pos1 2与1比较，2大，pos1向左移 循环直到： 1 2 3 2 4 3 2 1 $\\leftarrow\\Uparrow$pos1 2与4比较，2小，记录pos1的位置 ②.再定义pos2指针，从后往前遍历，找到比pos1位置后面的数中，有比pos1位置的数大的数，用pos2记录位置 1 2 3 2 4 3 2 1 $\\Uparrow$pos1 $\\leftarrow\\Uparrow$pos2 pos1大于pos2，pos2指针左移 循环直到： 1 2 3 2 4 3 2 1 $\\Uparrow$pos1 $\\leftarrow\\Uparrow$pos2 pos1小于pos2，记录指针pos2位置 ③.交换pos1和pos2的位置 1 2 3 3 4 2 2 1 ④.将pos1位置后面的数进行反转 1 2 3 3 1 2 2 4 结果：12331224 代码(cpp)：12345678910111213141516171819202122232425262728class Solution &#123;public: int nextGreaterElement(int n) &#123; //将n转换成字符串 string num = to_string(n); int pos1 = num.size()-2; //从后往前遍历，找到前面的数小于后面的数，前面数的位置 while(pos1 &gt;= 0 &amp;&amp; num[pos1] &gt;= num[pos1+1])&#123; pos1--; &#125; //遍历到字符串第0个位置，还没有小于的数，则不存在 if(pos1 &lt; 0) return -1; int pos2 = num.size()-1; //从后往前遍历，找到有比pos1位置的数小的数，返回pos2位置 while(pos2 &gt; pos1 &amp;&amp; num[pos1] &gt;= num[pos2])&#123; pos2--; &#125; //交换两个位置的数 swap(num[pos1],num[pos2]); //将pos1后面的字符串反转 reverse(num.begin() + pos1 + 1, num.end()); //防止溢出，先将temp转换成long型 long temp = stol(num); //如果超出int的范围，返回-1 if(temp &gt; INT_MAX) return -1; return temp; &#125;&#125;; 复杂度分析： 时间复杂度：O(logn)。 空间复杂度：O(logn)。","categories":[{"name":"每日LeetCode","slug":"每日LeetCode","permalink":"http://example.com/categories/%E6%AF%8F%E6%97%A5LeetCode/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"},{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"(每日LeetCode)871. 最低加油次数","slug":"每日LeetCode/871 最低加油次数","date":"2022-07-02T07:36:00.000Z","updated":"2022-07-02T07:51:59.126Z","comments":true,"path":"2022/07/02/每日LeetCode/871 最低加油次数/","link":"","permalink":"http://example.com/2022/07/02/%E6%AF%8F%E6%97%A5LeetCode/871%20%E6%9C%80%E4%BD%8E%E5%8A%A0%E6%B2%B9%E6%AC%A1%E6%95%B0/","excerpt":"","text":"题目：汽车从起点出发驶向目的地，该目的地位于出发位置东面 target 英里处。 沿途有加油站，每个 station[i] 代表一个加油站，它位于出发位置东面 station[i][0] 英里处，并且有 station[i][1]升汽油。 假设汽车油箱的容量是无限的，其中最初有startFuel升燃料。它每行驶 1 英里就会用掉 1 升汽油。 当汽车到达加油站时，它可能停下来加油，将所有汽油从加油站转移到汽车中。 为了到达目的地，汽车所必要的最低加油次数是多少？如果无法到达目的地，则返回 -1 。 注意：如果汽车到达加油站时剩余燃料为 0，它仍然可以在那里加油。如果汽车到达目的地时剩余燃料为 0，仍然认为它已经到达目的地。 示例：示例1： 输入：target &#x3D; 100, startFuel &#x3D; 1, stations &#x3D; [[10,100]]输出：-1解释：我们无法抵达目的地，甚至无法到达第一个加油站。 示例2： 输入：target &#x3D; 100, startFuel &#x3D; 10, stations &#x3D; [[10,60],[20,30],[30,30],[60,40]]输出：2解释：我们出发时有 10 升燃料。我们开车来到距起点 10 英里处的加油站，消耗 10 升燃料。将汽油从 0 升加到 60 升。然后，我们从 10 英里处的加油站开到 60 英里处的加油站（消耗 50 升燃料），并将汽油从 10 升加到 50 升。然后我们开车抵达目的地。我们沿途在1两个加油站停靠，所以返回 2 。 思路： 一、回溯法代码(cpp)：123456789101112131415161718192021222324252627282930class Solution &#123;public: int def(vector&lt;vector&lt;int&gt;&gt;&amp; stations,int cur_station, int begin, int&amp; end, int oil)&#123; //到达目的地 if(oil+begin &gt;= end) return 0; //油量不够到达目的地 if(cur_station+1 == stations.size() &amp;&amp; oil+begin &lt; end)&#123; return -1; &#125; //油量不够到达下一个加油站 if(cur_station+1 &lt; stations.size() &amp;&amp; oil+begin &lt; stations[cur_station+1][0])&#123; return -1; &#125; int ans = INT_MAX; for(int i = cur_station+1; i &lt; stations.size(); i++)&#123; if(stations[i][0] &lt;= begin+oil)&#123; int temp = def(stations, i, stations[i][0] ,end ,oil+begin-stations[i][0]+stations[i][1]); if(temp != -1 &amp;&amp; ans &gt; temp+1) ans = temp+1; &#125; &#125; if(ans == INT_MAX) ans = -1; return ans; &#125; int minRefuelStops(int target, int startFuel, vector&lt;vector&lt;int&gt;&gt;&amp; stations) &#123; //出发地没有加油站，第一个加油站编号为0，所以初始化为-1 return def(stations, -1, 0, target, startFuel); &#125;&#125;; 运行超时 二、贪心思路：如果不需要加油就往前走，当不够到达下一个加油站或目的地，就从之前走到过的加油站之中选择汽油量最多的加油站进行补充汽油。 以此往复，到达目的地。 如果所有加油站的汽油都被加完，并且没到达目的地，则不可能到达。 代码(cpp)：1234567891011121314151617181920212223242526272829303132class Solution &#123;public: int minRefuelStops(int target, int startFuel, vector&lt;vector&lt;int&gt;&gt;&amp; stations) &#123; priority_queue&lt;int&gt; pq; int count = 0; //初始化加油次数 int begin = 0; //初始化路程 int cur_fuel = startFuel;//初始化车的汽油量 int cur_distance; //表示当前的路程 for (int i = 0; i &lt;= stations.size(); i++) &#123; if(i &lt; stations.size()) cur_distance = stations[i][0]; else cur_distance = target; //(cur_distance - begin)：表示第i-1个加油站到第i个加油站之间的路程，cur_fuel为到第i个加油站时剩余的油量 cur_fuel -= cur_distance - begin; //如果油量为负数，说明需要从第i个加油站，之前的加油站之中选择加油量最多的加油站，进行补充汽油 while (cur_fuel &lt; 0 &amp;&amp; !pq.empty()) &#123; cur_fuel += pq.top();//选择汽油量最多的加油站补充 pq.pop(); count++;//加油次数加1 &#125; //都已经把之前的加油站的汽油都补充了，还是负数说明无法到达下一个加油站或目的地 if (cur_fuel &lt; 0) &#123; return -1; &#125; if (i &lt; stations.size()) &#123; //将第i个加油站的汽油量记录，现在不需要加油，等以后缺油再加 pq.emplace(stations[i][1]); begin = cur_distance;//更新路程 &#125; &#125; return count; &#125;&#125;; 复杂度分析： 时间复杂度：O(nlogn)，其中 n 是数组 stations 的长度。需要遍历数组 stations 一次，每个加油站的汽油量最多添加到优先队列和从优先队列中移除各一次，每次优先队列的操作需要 O(logn) 的时间，因此时间复杂度是 O(nlogn)。 空间复杂度：O(n)，其中 n 是数组 stations 的长度。优先队列需要 O(n) 的空间。","categories":[{"name":"每日LeetCode","slug":"每日LeetCode","permalink":"http://example.com/categories/%E6%AF%8F%E6%97%A5LeetCode/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"},{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"vector容器用法","slug":"C++/vecter容器用法详解","date":"2022-06-30T04:23:10.561Z","updated":"2022-06-30T09:57:01.005Z","comments":true,"path":"2022/06/30/C++/vecter容器用法详解/","link":"","permalink":"http://example.com/2022/06/30/C++/vecter%E5%AE%B9%E5%99%A8%E7%94%A8%E6%B3%95%E8%AF%A6%E8%A7%A3/","excerpt":"","text":"vector是什么？vector是一个能够存放任意类型的动态数组。 vector实现动态增长的原理：vector的原理就是动态数组。当插入新元素的时候，如果空间不足，那么vector会重新申请更大的一块空间，将原空间数据拷贝到新空间，释放旧空间数据，再把新元素插入新申请空间。 需要导入头文件： 12#include&lt;vector&gt;using namespace std; 构造函数： 构造函数 解释 vector() 创建一个空的vector vector(int size) 创建一个vector,元素个数为size，且值均为0(默认为0) vector(int size, T value) 创建一个vector，元素个数为size,且值均为value vector(const vector&amp; v) 另一个vector容器拷贝到这个vector中 vector(iterator begin(), iterator end()) 另一个[begin,end)区间内的数组元素的复制这个vector中 成员函数： 插入函数 解释 void push_back(const T&amp; x) 容器尾部插入一个元素X iterator insert(iterator it,const T&amp; x) 容器中迭代器指向元素的前面插入一个元素x iterator insert(iterator it,int n,const T&amp; x) 容器中迭代器指向元素的前面插入n个相同的元素x iterator insert(iterator it,const_iterator first,const_iterator last) 向量中迭代器指向元素的前面插入另一个相同类型的vector容器的[first,last)间的数据 删除函数 解释 iterator erase(iterator it) 删除容器中迭代器指向的元素 iterator erase(iterator first,iterator last) 删除容器中[first,last)中的元素 void pop_back() 删除容器中最后一个元素 void clear() 清空容器中所有元素 遍历函数 解释 T at(int pos) 返回pos位置的元素(第一个位置为0) T front() 返回首元素 T back() 返回尾元素 iterator begin() 返回vector容器中指向的第一个元素的迭代器 iterator end() 返回vector容器中指向最后一个元素的下一个位置的迭代器 reverse_iterator rbegin() 反向迭代器，指向容器中最后一个元素 reverse_iterator rend() 反向迭代器，指向容器第一个元素前面的位置 大小函数 解释 int size() 返回vector容器中元素的个数 int capacity() 返回当前vector容器所能容纳的最大容量 int max_size() 返回vector容器的最大可允许的容量 void resize(int size) 更改vector容器的元素的个数为size void reserve(int capacity) 更改vector容器的容量为capacity 赋值函数 解释 vector&amp; operator&#x3D; 将右边vector容器的元素拷贝到左边vector容器中 void assign(int n,const T&amp; x) 设置容器中前n个元素的值为x void assign(const_iterator first,const_iterator last) 将另一个vector容器中[first,last)中元素设置成当前vector容器的元素 其他函数 解释 bool empty() 判断向量是否为空，若为空，则返回真 void swap(vector&amp; v) 将两个同类型vector容器的元素互换 vector的遍历 123for(int i = 0; i &lt; v.size(); i++)&#123; cout &lt;&lt; v[i] &lt;&lt; endl;&#125; 123for (int i = 0; i &lt; v.size(); i++)&#123; cout &lt;&lt; v1.at(i) &lt;&lt; endl;&#125; 123for (vector&lt;int&gt;::iterator it = v.begin(); it != v.end(); it++)&#123; cout &lt;&lt; *it &lt;&lt; endl;&#125; 123for (auto it = v.begin(); it != v.end(); it++)&#123; cout &lt;&lt; *it &lt;&lt; endl;&#125;","categories":[{"name":"C++","slug":"C","permalink":"http://example.com/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"},{"name":"容器","slug":"容器","permalink":"http://example.com/tags/%E5%AE%B9%E5%99%A8/"},{"name":"STL","slug":"STL","permalink":"http://example.com/tags/STL/"}]},{"title":"(每日LeetCode)1175. 质数排列","slug":"每日LeetCode/1175 质数排列","date":"2022-06-30T03:09:00.000Z","updated":"2022-07-02T07:52:31.621Z","comments":true,"path":"2022/06/30/每日LeetCode/1175 质数排列/","link":"","permalink":"http://example.com/2022/06/30/%E6%AF%8F%E6%97%A5LeetCode/1175%20%E8%B4%A8%E6%95%B0%E6%8E%92%E5%88%97/","excerpt":"","text":"题目：请你帮忙给从 1 到 n 的数设计排列方案，使得所有的「质数」都应该被放在「质数索引」（索引从 1 开始）上；你需要返回可能的方案总数。由于答案可能会很大，所以请你返回答案 模 mod $10^9$ + 7 之后的结果即可。 示例： 输入：n &#x3D; 5输出：12 解释： 先看质数定义：一个大于1的自然数，除了1和它自身外，不能被其他自然数整除的数叫做质数。(1不是质数) 用红色标记质数： 1 2 3 4 5 题目的意思是将质数和非质数各分一组，进行排序一共有多少种可能： m个数排列m个位置，全排列公式：$A^m_m&#x3D;m!$ $A^3_3$为质数的所有排列次数 $A^2_2$为非质数的所有排列次数 并且每有一个质数的排列组合就有$A^2_2$次非质数的排列： 总数：$A^3_3 \\times A^2_2&#x3D;3! \\times 2!&#x3D;12$ 思路：遍历数组判断是否为质数，记录质数的个数p，非质数个数为n-p 运用公式求出总数：$A^p_p \\times A^{n-p}_{n-p}&#x3D;p! \\times (n-p)!$ 代码(cpp)：123456789101112131415161718192021222324252627282930313233343536373839class Solution &#123;public: int mod = pow(10,9)+7; //判断是否为质数 bool is_prime(int n)&#123; //从2开始 for(int i = 2; i*i &lt;= n;i++)&#123; //模运算为0，不是质数 if(n%i == 0)&#123; return false; &#125; &#125; return true; &#125; //n!运算 Long类型防止溢出 long factorial(int n)&#123; long sum = 1; for(int i = 2; i &lt;= n; i++)&#123; sum *=i; sum = sum%mod; &#125; return sum; &#125; int numPrimeArrangements(int n) &#123; int prime_num = 0; //从2开始，1不是质数 for(int i = 2; i &lt;= n; i++)&#123; if(is_prime(i))&#123; prime_num++; &#125; &#125; //n!*(n-p)! long result = (factorial(prime_num)*factorial(n-prime_num))%mod; return (int)result; &#125;&#125;; 复杂度分析： 时间复杂度：O($n^{3&#x2F;2}$)。求 n 个数中质数个数的时间复杂度为 O($n^{3&#x2F;2}$)，阶乘的时间复杂度为 O(n)，总的时间复杂度为 O($n^{3&#x2F;2}$)。 空间复杂度：O(1)O(1)，只使用了常数空间。","categories":[{"name":"每日LeetCode","slug":"每日LeetCode","permalink":"http://example.com/categories/%E6%AF%8F%E6%97%A5LeetCode/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"},{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"(每日LeetCode)535. TinyURL的加密与解密","slug":"每日LeetCode/535 TinyURL的加密与解密","date":"2022-06-28T23:41:00.000Z","updated":"2022-07-02T07:51:52.081Z","comments":true,"path":"2022/06/29/每日LeetCode/535 TinyURL的加密与解密/","link":"","permalink":"http://example.com/2022/06/29/%E6%AF%8F%E6%97%A5LeetCode/535%20TinyURL%E7%9A%84%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%A7%A3%E5%AF%86/","excerpt":"","text":"题目：TinyURL 是一种 URL 简化服务， 比如：当你输入一个 URL https://leetcode.com/problems/design-tinyurl 时，它将返回一个简化的URL http://tinyurl.com/4e9iAk 。请你设计一个类来加密与解密 TinyURL 。 加密和解密算法如何设计和运作是没有限制的，你只需要保证一个 URL 可以被加密成一个 TinyURL ，并且这个 TinyURL 可以用解密方法恢复成原本的 URL 。 实现 Solution 类： Solution() 初始化 TinyURL 系统对象。String encode(String longUrl) 返回 longUrl 对应的 TinyURL 。String decode(String shortUrl) 返回 shortUrl 原本的 URL 。题目数据保证给定的 shortUrl 是由同一个系统对象加密的。 示例： 输入：url &#x3D; “https://leetcode.com/problems/design-tinyurl“输出：”https://leetcode.com/problems/design-tinyurl“ 解释：Solution obj &#x3D; new Solution();string tiny &#x3D; obj.encode(url); &#x2F;&#x2F; 返回加密后得到的 TinyURL 。string ans &#x3D; obj.decode(tiny); &#x2F;&#x2F; 返回解密后得到的原本的 URL 。 思路：使用自增id作为longUrl的键，存入unordered_map容器中 根据id来获取对应的longUrl 代码(cpp)：1234567891011121314151617181920212223class Solution &#123;private: unordered_map&lt;int, string&gt; map; int id;public: Solution()&#123; id = 0; //初始化id &#125; string encode(string longUrl) &#123; id++; map[id] = longUrl; //http://tinyurl.com/1 return &quot;http://tinyurl.com/&quot;+to_string(id); &#125; string decode(string shortUrl) &#123; //substr(int pos)：获取pos位置起的所有字符串 //stoi(string str)：将string类型的字符串转换成int类型的整数 int t_id = stoi(shortUrl.substr(19)); return map[t_id]; &#125;&#125;; 复杂度分析： 时间复杂度： Encode 函数：O(n)O(n)，其中 n 是字符串 longUrl 的长度。 Decode 函数：O(1)O(1)。我们把 shortUrl 当成有限长度的字符串看待。 空间复杂度： Encode 函数：O(n)O(n)。保存字符串 longUrl 需要 O(n)O(n) 的空间。 Decode 函数：O(1)O(1)。","categories":[{"name":"每日LeetCode","slug":"每日LeetCode","permalink":"http://example.com/categories/%E6%AF%8F%E6%97%A5LeetCode/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"},{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"SpringMVC框架","slug":"Java/SpringMCV框架","date":"2022-06-28T14:02:54.299Z","updated":"2022-07-02T13:43:23.123Z","comments":true,"path":"2022/06/28/Java/SpringMCV框架/","link":"","permalink":"http://example.com/2022/06/28/Java/SpringMCV%E6%A1%86%E6%9E%B6/","excerpt":"","text":"1.初认SpringMVC1.1 SpringMVC简介 SpringMVC技术与Servlet技术功能等同，均属于web层开发技术 SpringMVC是一种基于java实现MVC模型的轻量级Web框架 优点： 使用简单，开发便捷(相比与Servlet) 灵活性强 项目结构： 1.2 SpringMVC入门1.使用SpringMVC技术需要先导入SpringMVC坐标与Servlet 不需要导入spring-context包，spring-webmvc包中包含spring-context包 2.导入Tomcat插件 12345678910111213141516171819202122232425&lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;version&gt;3.1.0&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;!-- 和Tomcat有冲突 --&gt; &lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;5.2.10.RELEASE&lt;/version&gt; &lt;/dependency&gt;&lt;!--Tomcat插件--&gt;&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.tomcat.maven&lt;/groupId&gt; &lt;artifactId&gt;tomcat7-maven-plugin&lt;/artifactId&gt; &lt;version&gt;2.1&lt;/version&gt; &lt;configuration&gt; &lt;port&gt;8888&lt;/port&gt; &lt;!--端口可任意只要没有被占用--&gt; &lt;path&gt;/&lt;/path&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; 3.创建SpringMVC控制器类(等同于Servlet功能) 1234567891011@Controllerpublic class UserController &#123; //设置当前控制器方法的请求路径 @RequestMapping(&quot;/save&quot;) //设置当前控制器方法响应内容为当前返回值，无需解析 @ResponseBody public String save()&#123; System.out.println(&quot;user is saving~~&quot;); return &quot;&#123;&#x27;info&#x27;:&#x27;springmvc&#x27;&#125;&quot;; &#125;&#125; 4.初始化SpringMVC环境(同Spring环境)，设定SpringMVC加载对应的bean 12345//创建SpringMVC的配置文件，加载controller对应的bean@Configuration@ComponentScan(&quot;com.springmvc.controller&quot;)public class SpringMvcConfig &#123;&#125; 5.初始化Servlet容器，加载SpringMVC环境，并设置SpringMVC技术处理的请求 123456789101112131415161718192021//定义一个servlet容器启动的配置类，在里面加载Spring的配置public class ServletContainerInitConfig extends AbstractDispatcherServletInitializer &#123; //加载SpringMVC容器的配置 @Override protected WebApplicationContext createServletApplicationContext() &#123; AnnotationConfigWebApplicationContext acwac = new AnnotationConfigWebApplicationContext(); acwac.register(SpringMvcConfig.class); return acwac; &#125; //设定SpringMVC对应的请求的映射路径 @Override protected String[] getServletMappings() &#123; //设置为/表示拦截所有请求，任意请求都将转入到SpringMVC中进行处理 return new String[]&#123;&quot;/&quot;&#125;; &#125; //加载Spring容器配置，现在不需要 @Override protected WebApplicationContext createRootApplicationContext() &#123; return null; &#125;&#125; 右键找到Run Maven再找到tomcat7:run点击运行，打开浏览器打开http://localhost:8888/save 页面即可出现内容： 1&#123;&#x27;info&#x27;:&#x27;springmvc&#x27;&#125; 此时控制台打印出： 1user is saving~~ 1.3 入门总结 SpringMVC入门程序开发总结(1+N) 一次性工作 创建工程, 设置服务器，加载工程 导入坐标 创建web容器启动类, 加载SpringMVC配置， 并设置SpringMVC请求拦截路径 SpringMVC核心配置类 (设置配置类,扫描controller包, 加载Controller控制器bean) 多次工作 定义处理请求的控制器类 定义处理请求的控制器方法， 并配置映射路径@RequestMapping与返回json数据@ResponseBody 1.4 工作流程入门案例工作流程分析 启动服务器初始化过程 服务器启动, 执行ServletContainersInitConfig类,初始化web容器 执行createServletApplicationContext方法，创建了WebApplicationContext对象 加载SpringMvcConfig配置文件 执行@ComponentScan加载对应的bean 加载UserController, 每个@RequestMapping的名称对应一 个具体的方法 执行getServletMappings方法, 定义所有的请求都通过SpringMVC 单次请求过程 发送请求http:localhost:8888/save web容器发现所有请求都经过SpringMVC, 将请求交给SpringMVC处理 解析请求路径&#x2F;save 由&#x2F;save匹配执行对应的方法save() 执行save() 检测到有@ResponseBody直接将save()方法的返回值作为响应求体返回给请求方 1.5 bean加载控制 com springmvc config controller service dao Controller加载控制业务与业务bean加载控制 SpringMVC相关bean 表现层bean(Controller) Spring控制的bean 业务bean(Service) 功能bean(DataSourse等) SpringMVC相关的bean加载控制 SpringMVC加载的bean对应的包均在com.springnvc.controller包内 Spring相关bean加载控制 Spring加载的bean设定范围为com.springmvc，排除controller包内的bean Spring加载的bean设定范围为精准范围，如：com.springmvc.dao、com.springmvc.service等(常用) 不区分Spring与SpringMVC的环境，加载到同一个环境中 方式一(常用)： 1234@Configuration@ComponentScan(&#123;&quot;com.springmvc.dao&quot;,&quot;com.springmvc.service&quot;&#125;)public class SpringConfig &#123;&#125; 方式二： 123456789@Configuration@ComponentScan(value = &quot;com.springmvc&quot;, excludeFilters = @ComponentScan.Filter( type = FilterType.ANNOTATION, //按照注解排除 classes = Controller.class //需要排除的注解类型 ))public class SpringConfig &#123;&#125; 加载SpringMVC和Spring配置 123456789101112131415161718192021public class ServletContainerInitConfig extends AbstractDispatcherServletInitializer &#123; //加载SpringMVC配置 @Override protected WebApplicationContext createServletApplicationContext() &#123; AnnotationConfigWebApplicationContext acwac = new AnnotationConfigWebApplicationContext(); acwac.register(SpringMvcConfig.class); return acwac; &#125; @Override protected String[] getServletMappings() &#123; return new String[]&#123;&quot;/&quot;&#125;; &#125; //加载SpringMVC配置 @Override protected WebApplicationContext createRootApplicationContext() &#123; AnnotationConfigWebApplicationContext acwac = new AnnotationConfigWebApplicationContext(); acwac.register(SpringConfig.class); return acwac; &#125;&#125; 简化操作(常用)： 1234567891011121314151617public class ServletContainerInitConfig extends AbstractAnnotationConfigDispatcherServletInitializer &#123; @Override protected Class&lt;?&gt;[] getRootConfigClasses() &#123; return new Class[]&#123;SpringConfig.class&#125;; &#125; @Override protected Class&lt;?&gt;[] getServletConfigClasses() &#123; return new Class[]&#123;SpringMvcConfig.class&#125;; &#125; @Override protected String[] getServletMappings() &#123; return new String[]&#123;&quot;/&quot;&#125;; &#125;&#125; 2.请求与响应2.1 3.REST风格4.SSM整合5.拦截器","categories":[{"name":"Java","slug":"Java","permalink":"http://example.com/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"},{"name":"框架","slug":"框架","permalink":"http://example.com/tags/%E6%A1%86%E6%9E%B6/"}]},{"title":"(每日LeetCode)324. 摆动排序 II","slug":"每日LeetCode/324 摆动排序 II","date":"2022-06-28T02:30:00.000Z","updated":"2022-07-03T04:02:56.589Z","comments":true,"path":"2022/06/28/每日LeetCode/324 摆动排序 II/","link":"","permalink":"http://example.com/2022/06/28/%E6%AF%8F%E6%97%A5LeetCode/324%20%E6%91%86%E5%8A%A8%E6%8E%92%E5%BA%8F%20II/","excerpt":"","text":"题目：给你一个整数数组 nums，将它重新排列成 nums[0] &lt; nums[1] &gt; nums[2] &lt; nums[3]... 的顺序。 你可以假设所有输入数组都可以得到满足题目要求的结果。 示例： 输入：nums &#x3D; [1,5,2,4,3,6]输出：[3,6,2,5,1,4] 思路：双指针法将数组nums按从小到大排列： 1 2 3 4 5 6 $\\leftarrow\\Uparrow$left $\\leftarrow\\Uparrow$right 把排序好的数组分成两部分，left指针位于数组中间，right指针位于数组末尾， 将left和right当前位置的元素依次打印后，left和right指针左移，直至结束 输出：[3, 6, 2, 5, 1, 4] 代码(cpp)：123456789101112131415161718192021class Solution &#123;public: void wiggleSort(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); //获取数组的元素个数 int left = n/2-1; //定义左指针 int right = n-1; //定义右指针 vector&lt;int&gt; new_nums(nums); sort(new_nums.begin(),new_nums.end()); //将新数组排序 for(int i=0;i&lt;n;i++)&#123; if(i%2 == 0)&#123; //偶数位置插入left指针的元素，奇数位置插入right指针的元素 nums[i] = a[left]; left--; &#125; else&#123; nums[i] = a[right]; rigth--; &#125; &#125; &#125;&#125;; 复杂度分析： 时间复杂度：O(nlogn)，排序所需的时间复杂度是O(nlogn)，插入O(n)，整体O(nlogn) 空间复杂度：O(n)，需要额外的空间存放排序的元素。","categories":[{"name":"每日LeetCode","slug":"每日LeetCode","permalink":"http://example.com/categories/%E6%AF%8F%E6%97%A5LeetCode/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"},{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"Spring框架","slug":"Java/Spring框架","date":"2022-06-25T09:55:58.239Z","updated":"2022-06-30T06:36:33.319Z","comments":true,"path":"2022/06/25/Java/Spring框架/","link":"","permalink":"http://example.com/2022/06/25/Java/Spring%E6%A1%86%E6%9E%B6/","excerpt":"","text":"1.初识Spring 官网：spring官网 Spring已经发展成了一种开发的生态圈，Spring提供了若干个项目，每个项目用于完成特定的功能 Spring Framework Spring Boot Spring Cloud …. 目前已经发展到Spring 5.0，需要JDK8以上支持 2.Spring Framework架构 Spring Framework是Spring生态圈中最基础的项目，是其他项目的根基 Data Access：数据访问 Data Integeration：数据集成 Web：web开发 AOP：面向切面编程 Aspects：AOP思想实现 Core Container：核心容器 Test：单元测试与集成测试 3.核心概念3.1 项目结构 java包 com包 spring包 dao包 BookDao.java impl包 BookDaoImpl.java service包 BookSerive.java impl包 BookServiceImpl.java App.java主函数 resources包 applicationContext.xml jdbc.properties 3.2 初识IOC和DI12345public class BookDaoImpl implements BookDao &#123; public void save() &#123; System.out.println(&quot;book dao save...&quot;); &#125;&#125; 123456public class BookServiceImpl implements BookService &#123; private BookDao bookDao = new BookDaoImpl; public void save() &#123; bookDao.save(); &#125;&#125; 这是一种很常见的写法。但是这样的写法耦合度太高，耦合度可以简单的理解为：两个类之间的关联程度，耦合度高就代表两个类之间关联程度很高，动其中一个类，就不得不动另外一个类。 所以就需要解耦 123456public class BookServiceImpl implements BookService &#123; private BookDao bookDao;//service:我免费啦！ public void save() &#123; bookDao.save(); &#125;&#125; IOC(Inversion of Control) 控制反转 使用对象时，由以前主动new一个对象转换为由外部提供对象，创建对象的控制权交给了外部，此思想为控制反转。 Spring技术对IOC进行实现 Spring提供一个容器，称为IOC容器，用来当作IOC思想中的**”外部”** IOC容器负责对象的创建、初始化等工作 在IOC容器中被创建或被管理的对象称之为Bean DI(Dependency Injection) 依赖注入 在容器中建立的bean与bean之间的依赖关系的整个过程，称之为依赖注入。 例：service层需要依赖dao层运行，但无需自己new一个dao层，它会自动生成dao层。 目标：充分解耦 使用IOC容器管理bean(IOC思想) 在ICO容器内将依赖关系的bean进行关系绑定(DI思想) 在使用对象时不仅可以从IOC容器中获取，并且也可以获取到bean已经绑定的所有依赖关系 4.IOC入门 pom.xml导入spring的坐标 12345&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;5.3.18&lt;/version&gt;&lt;/dependency&gt; resources目录创建Spring配置文件applicationContext.xml 配置bean bean标签：配置bean id属性：给bean起名字 class属性：给bean定义类型 123&lt;bean id=&quot;bookDao&quot; class=&quot;com.spring.dao.impl.BookDaoImpl&quot;/&gt;&lt;bean id=&quot;bookService&quot; class=&quot;com.spring.service.impl.BookServiceImpl&quot;/&gt; 创建名为启动类App 1234567891011121314151617import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;import com.spring.dao.BookDao;public class App &#123; public static void main(String[] args) &#123; //获取ICO容器 ApplicationContext ac = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); //获取bean BookDao bookDao = (BookDao) ac.getBean(&quot;bookDao&quot;); bookDao.save(); BookService bookService = (BookService) ac.getBean(&quot;bookService&quot;); bookService.save(); &#125;&#125; 5.DI入门 基于IOC管理bean 不能保留Service层中用new创建的对象 通过spring配置文件进行配置Service与Dao的关系 12345678910111213public class BookServiceImpl implements BookService &#123; //删除业务层中用new创建对象的方式 //private BookDao bookDao = new BookDaoImpl(); private BookDao bookDao; //提供相应的set的方法 public void setBookDao(BookDao bookDao) &#123; this.bookDao = bookDao; &#125; public void save() &#123; bookDao.save(); &#125;&#125; 在spring配置文件applicationContext.xml中，配置property property标签：配置当前bean的属性 name属性：配置哪个具体的属性 ref属性：参照spring配置文件中的哪个bean的id 123456&lt;bean id=&quot;bookDao&quot; class=&quot;com.spring.dao.impl.BookDaoImpl&quot;/&gt;&lt;bean id=&quot;bookService&quot; class=&quot;com.spring.service.impl.BookServiceImpl&quot;&gt; &lt;!-- 配置service与dao的关系 --&gt; &lt;property name=&quot;bookDao&quot; ref=&quot;bookDao&quot;/&gt;&lt;/bean&gt; 配置完成后，BookDao无需使用new来手动创建对象，而是通过spring来自动创建 6.bean基础配置6.1 bean别名配置 name属性：可以起多个别名用;分号 空格,逗号分隔 123&lt;bean id=&quot;bookDao&quot; name=&quot;dao Dao&quot; class=&quot;com.spring.dao.impl.BookDaoImpl&quot;/&gt;&lt;bean id=&quot;bookService&quot; name=&quot;Service service&quot; class=&quot;com.spring.service.impl.BookServiceImpl&quot;/&gt; 别名可以用于getBean()方法 1234567891011public class App &#123; public static void main(String[] args) &#123; //获取ICO容器 ApplicationContext ac = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); //获取bean //BookService bookService=(BookService)ac.getBean(&quot;bookService&quot;); //通过别名获取BookService BookService bookService=(BookService)ac.getBean(&quot;Service&quot;); bookService.save(); &#125;&#125; 别名也可以用户ref属性，不建议用别名，建议使用id 123&lt;bean id=&quot;bookService&quot; class=&quot;com.spring.service.impl.BookServiceImpl&quot;&gt; &lt;property name=&quot;bookDao&quot; ref=&quot;Dao&quot;/&gt;&lt;/bean&gt; 6.2 bean的作用范围创建的bean是否为多个对象 123456789101112public class App &#123; public static void main(String[] args) &#123; //获取ICO容器 ApplicationContext ac = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); //获取bean BookDao bookDao1 = (BookDao) ac.getBean(&quot;bookDao&quot;); BookDao bookDao2 = (BookDao) ac.getBean(&quot;bookDao&quot;); System.out.println(bookDao1); System.out.println(bookDao2); &#125;&#125; 123运行结果：com.spring.dao.impl.BookDaoImpl@7219ec67com.spring.dao.impl.BookDaoImpl@7219ec67 结论：两个对象地址相同，spring默认创建的bean是单例的 需要在配置文件的bean标签里添加一个scope属性 scope属性有singleton单例模式和prototype非单例模式 scope属性默认为singleton单例模式 1&lt;bean id=&quot;bookDao&quot; class=&quot;com.spring.dao.impl.BookDaoImpl&quot; scope=&quot;prtotype&quot;/&gt; 123再次运行后，运行结果：com.spring.dao.impl.BookDaoImpl@7219ec67com.spring.dao.impl.BookDaoImpl@45018215 结论：两个对象地址不同，为非单例模式 bean作用范围说明 单例bean的优势 减少了新生成实例的消耗，可以快速获取到bean，更大程度的复用 适合交给容器进行管理的bean 表现层对象，业务层对象，数据层对象，工具对象 不适合交给容器进行管理的bean 封装实体的域对象(存在变量的) 7.bean实例化 bean的本质就是对象，创建bean都需要使用构造方法完成 7.1 构造方法实例化bean(常用) 在BookDaoImpl类中创建构造方法： 123456789101112public class BookDaoImpl implements BookDao &#123; public BookDaoImpl()&#123; System.out.println(&quot;BookDaoImpl构造函数&quot;); &#125; /*private BookDaoImpl()&#123; System.out.println(&quot;BookDaoImpl构造函数&quot;); &#125;*/ public void save() &#123; System.out.println(&quot;BookDao~~~~~&quot;); &#125;&#125; AppForInstanceBook类进行测试： 12345678public class AppForInstanceBook &#123; public static void main(String[] args) &#123; ApplicationContext ac = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); BookDao bookDao = (BookDao) ac.getBean(&quot;bookDao&quot;); bookDao.save(); &#125;&#125; 123运行结果：BookDaoImpl构造函数BookDao~~~~~ 并且BookDaoImpl中的构造方法无论是否私有都可以被调用，这就是反射。 无参构造方法不存在，将会抛出异常 在BookDaoImpl类中构造方法改为有参构造： 123public BookDaoImpl(int i)&#123; System.out.println(&quot;BookDaoImpl构造函数&quot;);&#125; 运行后会报错，同时说明Spring创建bean的时候，调用的是无参构造。 7.2 静态工厂实例化bean(早期实例化bean 了解) 创建一个factory软件包，并在里面创建一个BookDaoFactory类： 123456public class BookDaoFactory &#123; public static BookDao getBookDao()&#123; System.out.println(&quot;factory is running&quot;); return new BookDaoImpl(); &#125;&#125; AppForInstanceBook类运行： 1234567public class AppForInstanceBook &#123; public static void main(String[] args) &#123; BookDao bookDao = BookDaoFactory.getBookDao(); bookDao.save(); &#125;&#125;//运行成功 通过配置文件使用静态工厂实例化bean： Spring配置文件中： factory-method属性：选择工厂里的bean实例方法 12&lt;bean id=&quot;bookDao&quot; class=&quot;com.spring.factory.BookDaoFactory&quot; factory-method=&quot;getBookDao&quot;/&gt; AppForInstanceBook类运行： 12345678public class AppForInstanceBook &#123; public static void main(String[] args) &#123; ApplicationContext ac = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); BookDao bookDao = (BookDao) ac.getBean(&quot;bookDao&quot;); bookDao.save(); &#125;&#125; 1234运行结果：factory is runningBookDaoImpl构造函数BookDao~~~~~ 7.3 实例工厂实例化bean(非静态工厂 了解) BookDaoFactory类中，将方法改为非静态方法 123456public class BookDaoFactory &#123; public BookDao getBookDao()&#123; System.out.println(&quot;factory is running~~~~~&quot;); return new BookDaoImpl(); &#125;&#125; AppForInstanceBook类运行： 1234567public class AppForInstanceBook &#123; public static void main(String[] args) &#123; BookDaoFactory bookDaoFactory = new BookDaoFactory(); BookDao bookDao = bookDaoFactory.getBookDao(); bookDao.save(); &#125;&#125; 1234运行结果：factory is running~~~~~BookDaoImpl构造函数BookDao~~~~~ 通过配置文件使用静态工厂实例化bean： Spring配置文件中： 12345&lt;!-- 先要造出工厂的bean --&gt;&lt;bean id=&quot;bookDaoFactory&quot; class=&quot;com.spring.factory.BookDaoFactory&quot;/&gt;&lt;bean id=&quot;bookDao&quot; factory-bean=&quot;bookDaoFactory&quot; factory-method=&quot;getBookDao&quot; /&gt; AppForInstanceBook类运行： 12345678public class AppForInstanceBook &#123; public static void main(String[] args) &#123; ApplicationContext ac = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); BookDao bookDao = (BookDao) ac.getBean(&quot;bookDao&quot;); bookDao.save(); &#125;&#125; 1234运行结果：factory is running~~~~~BookDaoImpl构造函数BookDao~~~~~ 配置文件中beanbookDaoFactory只是为了配合使用，实际没有意义。 Spring对这种实例化bean方法进行了改良： 4.通过FactoryBean实例化bean(实用) 创建BookDaoFactoryBean类实现接口FactoryBean&lt;T&gt; 123456789101112public class BookDaoFactoryBean implements FactoryBean&lt;BookDao&gt; &#123; //代替原始实例工厂中创建对象的方法 @Override public BookDao getObject() throws Exception &#123; return new BookDaoImpl(); &#125; @Override public Class&lt;?&gt; getObjectType() &#123; return BookDao.class; &#125;&#125; Spring配置文件中： 1&lt;bean id=&quot;bookDao&quot; class=&quot;com.spring.factory.BookDaoFactoryBean&quot;/&gt; AppForInstanceBook类运行： 12345678public class AppForInstanceBook &#123; public static void main(String[] args) &#123; ApplicationContext ac = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); BookDao bookDao = (BookDao) ac.getBean(&quot;bookDao&quot;); bookDao.save(); &#125;&#125; 123运行结果：BookDaoImpl构造函数BookDao~~~~~ 并且BookDaoFactoryBean类中可以重写isSinglenton方法： 12345@Overridepublic boolean isSingleton() &#123; //true：单例； false：多例；默认单例 return true;&#125; 8.bean的生命周期 bean生命周期：bean从创建到销毁的整体过程 bean生命周期控制：在bean创建后到销毁前做一些事 在BookDaoImpl类中，创建init和destroy方法 1234567891011121314public class BookDaoImpl implements BookDao &#123; public void save() &#123; System.out.println(&quot;BookDao~~~~~&quot;); &#125; public void init()&#123; System.out.println(&quot;init~~~&quot;); &#125; public void destroy()&#123; System.out.println(&quot;destroy~~~&quot;); &#125;&#125; 在Spring配置文件中： init-method和destroy-method属性 12&lt;bean id=&quot;bookDao&quot; class=&quot;com.spring.dao.impl.BookDaoImpl&quot; init-method=&quot;init&quot; destroy-method=&quot;destroy&quot;/&gt; 调用主函数： 123456789public class App &#123; public static void main(String[] args) &#123; //获取ICO容器 ApplicationContext ac = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); //获取bean BookDao bookDao = (BookDao) ac.getBean(&quot;bookDao&quot;); bookDao.save(); &#125;&#125; 123运行结果：init~~~BookDao~~~~~ 控制台并没有输出destroy~~~； 因为销毁函数还没有来得及调用，程序就被杀死了； 所以需要进行手动关闭； 我们调用主函数中的ac中的close()方法，但是ApplicationContext接口中并没有提供close()方法，所以我们要改用ClassPathXmlApplicationContext类。 12345678910public class App &#123; public static void main(String[] args) &#123; //获取ICO容器 ClassPathXmlApplicationContext ac = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); //获取bean BookDao bookDao = (BookDao) ac.getBean(&quot;bookDao&quot;); bookDao.save(); ac.close(); &#125;&#125; 12345运行结果：init~~~BookDao~~~~~destroy~~~ 成功！！！！ 容器还提供另外一种方式关闭容器：设置关闭钩子 调用ac的registerShutdownHook()方法 1234567891011public class App &#123; public static void main(String[] args) &#123; //获取ICO容器 ClassPathXmlApplicationContext ac = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); //获取bean BookDao bookDao = (BookDao) ac.getBean(&quot;bookDao&quot;); bookDao.save(); ac.registerShutdownHook(); &#125;&#125; 1234运行结果：init~~~BookDao~~~~~destroy~~~ close()和registerShutdownHook()的区别 将registerShutdownHook()放到上面： 12345678910public class App &#123; public static void main(String[] args) &#123; //获取ICO容器 ClassPathXmlApplicationContext ac = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); ac.registerShutdownHook(); //获取bean BookDao bookDao = (BookDao) ac.getBean(&quot;bookDao&quot;); bookDao.save(); &#125;&#125; 1234运行成功：init~~~BookDao~~~~~destroy~~~ 将close()放到上面： 12345678910public class App &#123; public static void main(String[] args) &#123; //获取ICO容器 ClassPathXmlApplicationContext ac = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); ac.close(); //获取bean BookDao bookDao = (BookDao) ac.getBean(&quot;bookDao&quot;); bookDao.save(); &#125;&#125; 123456运行结果：init~~~destroy~~~报错：BeanFactory not initialized or already closed - call &#x27;refresh&#x27; before accessing beans via the ApplicationContext BeanFactory没有被初始化或者已经被关闭了 运行失败！！ 或者通过接口的方式实现： BookServiceImpl类实现接口InitializingBean和DisposableBean的方法 1234567891011121314151617181920212223public class BookServiceImpl implements BookService, InitializingBean, DisposableBean &#123; private BookDao bookDao; public void setBookDao(BookDao bookDao) &#123; System.out.println(&quot;BookDao set~~~&quot;); this.bookDao = bookDao; &#125; public void save() &#123; bookDao.save(); &#125; @Override public void destroy() throws Exception &#123; System.out.println(&quot;service destroy~~~~&quot;); &#125; @Override public void afterPropertiesSet() throws Exception &#123; System.out.println(&quot;service init~~~~&quot;); &#125;&#125; 配置文件： 123456&lt;bean id=&quot;bookDao&quot; class=&quot;com.spring.dao.impl.BookDaoImpl&quot; init-method=&quot;init&quot; destroy-method=&quot;destroy&quot;/&gt;&lt;bean id=&quot;bookService&quot; class=&quot;com.spring.service.impl.BookServiceImpl&quot;&gt;&lt;property name=&quot;bookDao&quot; ref=&quot;bookDao&quot;/&gt;&lt;/bean&gt; 主函数运行： 12345678910public class App &#123; public static void main(String[] args) &#123; //获取ICO容器 ClassPathXmlApplicationContext ac = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); //获取bean BookDao bookDao = (BookDao) ac.getBean(&quot;bookDao&quot;); bookDao.save(); ac.registerShutdownHook(); &#125;&#125; 1234567运行结果：init~~~BookDao set~~~service init~~~~BookDao~~~~~service destroy~~~~destroy~~~ BookServiceImpl类中destroy()方法和afterPropertiesSet()方法被调用 并且setBookDao()方法之后才调用的afterPropertiesSet()方法 9.依赖注入方式向一个类传递数据的方式有：set方法、构造方法 9.1 setter注入 引用类型 在bean中定义引用类型属性并提供可访问的set方法 BookServiceImpl类中： 1234567public class BookServiceImpl implements BookService &#123; private BookDao bookDao; //提供相应的set的方法 public void setBookDao(BookDao bookDao) &#123; this.bookDao = bookDao; &#125;&#125; 在配置文件中使用property标签ref属性注入引用类型对象 12345&lt;bean id=&quot;bookDao&quot; class=&quot;com.spring.dao.impl.BookDaoImpl&quot;/&gt;&lt;bean id=&quot;bookService&quot; class=&quot;com.spring.service.impl.BookServiceImpl&quot;&gt; &lt;property name=&quot;bookDao&quot; ref=&quot;bookDao&quot;/&gt;&lt;/bean&gt; 简单类型 在bean中定义引用类型属性并提供可访问的set方法 BookDaoImpl类中： 1234567891011121314public class BookDaoImpl implements BookDao &#123; private String name; private int age; public void setName(String name) &#123; this.name = name; &#125; public void setAge(int age) &#123; this.age = age; &#125; public void save() &#123; System.out.println(&quot;BookDao~~~~~&quot;+&quot;姓名：&quot;+name+&quot;年龄：&quot;+age); &#125;&#125; 配置文件中，在property标签value属性注入简单类型数据 1234&lt;bean id=&quot;bookDao&quot; class=&quot;com.spring.dao.impl.BookDaoImpl&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;DaHuang&quot;/&gt; &lt;property name=&quot;age&quot; value=&quot;18&quot;/&gt;&lt;/bean&gt; 运行主函数： 12345678910public class App &#123; public static void main(String[] args) &#123; //获取ICO容器 ClassPathXmlApplicationContext ac = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); //获取bean BookDao bookDao = (BookDao) ac.getBean(&quot;bookDao&quot;); bookDao.save(); ac.registerShutdownHook(); &#125;&#125; 12运行结果：BookDao~~~~~姓名：DaHuang年龄：18 9.2 构造器注入 引用类型 在bean中定义引用类型属性并提供可访问的构造方法 12345678public class BookServiceImpl implements BookService &#123; private BookDao bookDao; public BookServiceImpl(BookDao bookDao) &#123; System.out.println(&quot;BookServiceImpl构造器运行~~~&quot;); this.bookDao = bookDao; &#125;&#125; 配置文件中，使用constructor-arg标签中的ref属性注入引用类型对象 12345678&lt;bean id=&quot;bookDao&quot; class=&quot;com.spring.dao.impl.BookDaoImpl&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;DaHuang&quot;/&gt; &lt;property name=&quot;age&quot; value=&quot;18&quot;/&gt; &lt;/bean&gt;&lt;bean id=&quot;bookService&quot; class=&quot;com.spring.service.impl.BookServiceImpl&quot;&gt; &lt;constructor-arg name=&quot;bookDao&quot; ref=&quot;bookDao&quot;/&gt;&lt;/bean&gt; 运行主函数： 123456789public class App &#123; public static void main(String[] args) &#123; //获取ICO容器 ClassPathXmlApplicationContext ac = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); //获取bean BookDao bookDao = (BookDao) ac.getBean(&quot;bookDao&quot;); bookDao.save(); &#125;&#125; 12运行结果：BookServiceImpl构造器运行~~~ 简单类型 BookDaoImpl类中： 123456789public class BookDaoImpl implements BookDao &#123; private String name; private int age; public BookDaoImpl(String name, int age) &#123; this.name = name; this.age = age; &#125;&#125; 配置文件中： 1234&lt;bean id=&quot;bookDao&quot; class=&quot;com.spring.dao.impl.BookDaoImpl&quot;&gt; &lt;constructor-arg name=&quot;name&quot; value=&quot;DaHei&quot;/&gt; &lt;constructor-arg name=&quot;age&quot; value=&quot;20&quot;/&gt;&lt;/bean&gt; 如果要更改BookDaoImpl类中的形参名字，还要更改配置文件中的name属性的名字； 存在形参与name属性名不耦合的问题。 constructor-arg标签还有type和index属性 type：形参的数据类型(存在多个同数据类型的形参，无法使用) index：形参的位置顺序 在配置文件中，使用index属性设置按形参位置顺序注入 1234&lt;bean id=&quot;bookDao&quot; class=&quot;com.spring.dao.impl.BookDaoImpl&quot;&gt; &lt;constructor-arg index=&quot;0&quot; value=&quot;DaHei&quot;/&gt; &lt;constructor-arg index=&quot;1&quot; value=&quot;20&quot;/&gt;&lt;/bean&gt; 运行主函数： 123456789public class App &#123; public static void main(String[] args) &#123; //获取ICO容器 ClassPathXmlApplicationContext ac = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); BookDao bookDao = (BookDao) ac.getBean(&quot;bookDao&quot;); bookDao.save(); &#125;&#125; 12运行结果：BookDao~~~~~姓名：DaHei年龄：20 9.3 依赖注入方式的选择 强制依赖使用构造器注入，使用setter注入有概率不注入导致null对象出现。 bean必须要的东西，要用构造器注入。因为构造器必须被执行，必须注入，否则报错 而setter方法可以执行也可以不执行，如果没有进行setter注入，会导致null对象 可选依赖使用setter注入进行，灵活性强。 setter注入可以执行也可以不执行 Spring框架倡导使用构造器。 第三方框架大多采用构造器注入的形式初始化数据，更加严谨 setter注入和构造器注入可以同时使用。 使用构造器完成强制依赖注入，使用setter注入完成可选依赖注入 自己开发的模块推荐使用setter注入 10.依赖自动装配IOC容器根据bean都依赖的资源在容器中自动查找并注入到bean中的过程称为自动装配 自动装配的方式： 按类型(常用) 按名称 按构造方法(不推荐) 不启用自动装配 10.1 按类型需要提供相应的setter方法 123456789public class BookServiceImpl implements BookService &#123; private BookDao bookDao; public void setBookDao(BookDao bookDao) &#123; System.out.println(&quot;BookDao set~~~&quot;); this.bookDao = bookDao; &#125;&#125; 配置文件中，要提前写好bookDao的bean否则无法装配， autowire属性设置为byTpye 通过类型自动装配 1234&lt;bean id=&quot;bookDao&quot; class=&quot;com.spring.dao.impl.BookDaoImpl&quot;/&gt;&lt;bean id=&quot;bookService&quot; class=&quot;com.spring.service.impl.BookServiceImpl&quot; autowire=&quot;byType&quot; /&gt; 主函数： 123456789public class App &#123; public static void main(String[] args) &#123; ClassPathXmlApplicationContext ac = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); BookService bookService = (BookService) ac.getBean(&quot;bookService&quot;); bookService.save(); &#125;&#125; 12运行结果：BookDao set~~~ 如果出现一下这种情况： 12345&lt;bean id=&quot;bookDao1&quot; class=&quot;com.spring.dao.impl.BookDaoImpl&quot;/&gt;&lt;bean id=&quot;bookDao2&quot; class=&quot;com.spring.dao.impl.BookDaoImpl&quot;/&gt;&lt;bean id=&quot;bookService&quot; class=&quot;com.spring.service.impl.BookServiceImpl&quot; autowire=&quot;byType&quot; /&gt; 出现了两个BookDao的bean，导致Spring无法区分了，这时就需要按名称装配 10.2 按名称123456789public class BookServiceImpl implements BookService &#123; private BookDao bookDao; public void setBookDao(BookDao bookDao) &#123; System.out.println(&quot;BookDao set~~~&quot;); this.bookDao = bookDao; &#125;&#125; 配置文件中，autowire属性设置为byName 通过名称自动装配 是通过BookServiceImpl类的变量名bookDao与配置文件的bean中id相同名称的进行绑定 12345&lt;bean id=&quot;bookDao&quot; class=&quot;com.spring.dao.impl.BookDaoImpl&quot;/&gt;&lt;bean id=&quot;bookDao2&quot; class=&quot;com.spring.dao.impl.BookDaoImpl&quot;/&gt;&lt;bean id=&quot;bookService&quot; class=&quot;com.spring.service.impl.BookServiceImpl&quot; autowire=&quot;ByName&quot; /&gt; 10.3 总结 自动装配用于引用类型依赖注入，不能对简单类型进行操作 使用按类型装配byType，必须保障容器中相同类型的bean唯一，推荐使用 使用按名称装配byName，必须保障容器中具有指定名称的bean，变量名要与配置耦合， 不推荐使用 自动装配优先级低于setter注入和构造器注入，同时出现时自动装配配置失效 11.集合注入123456789101112131415161718192021222324252627public class BookDaoImpl implements BookDao &#123; private int[] array; private List&lt;String&gt; list; private Set&lt;String&gt; set; private Map&lt;String, String&gt; map; private Properties properties; public void setArray(int[] array) &#123;this.array = array;&#125; public void setList(List&lt;String&gt; list) &#123;this.list = list;&#125; public void setSet(Set&lt;String&gt; set) &#123;this.set = set;&#125; public void setMap(Map&lt;String, String&gt; map) &#123;this.map = map;&#125; public void setProperties(Properties properties) &#123;this.properties = properties;&#125; public void save() &#123; System.out.println(&quot;BookDaoImpl&#123;&quot; + &quot;\\narray=&quot; + Arrays.toString(array) + &quot;, \\nlist=&quot; + list + &quot;, \\nset=&quot; + set + &quot;, \\nmap=&quot; + map + &quot;, \\nproperties=&quot; + properties + &#x27;&#125;&#x27;); &#125;&#125; 配置文件中： 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;bean id=&quot;bookDao&quot; class=&quot;com.spring.dao.impl.BookDaoImpl&quot;&gt; &lt;property name=&quot;array&quot; &gt; &lt;array&gt; &lt;value&gt;100&lt;/value&gt; &lt;value&gt;200&lt;/value&gt; &lt;value&gt;300&lt;/value&gt; &lt;/array&gt; &lt;/property&gt; &lt;property name=&quot;list&quot; &gt; &lt;list&gt; &lt;value&gt;唱&lt;/value&gt; &lt;value&gt;跳&lt;/value&gt; &lt;value&gt;Rap&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;property name=&quot;set&quot; &gt; &lt;set&gt; &lt;value&gt;唱&lt;/value&gt; &lt;value&gt;跳&lt;/value&gt; &lt;value&gt;Rap&lt;/value&gt; &lt;value&gt;Rap&lt;/value&gt; &lt;/set&gt; &lt;/property&gt; &lt;property name=&quot;map&quot; &gt; &lt;map&gt; &lt;entry key=&quot;county&quot; value=&quot;china&quot;/&gt; &lt;entry key=&quot;province&quot; value=&quot;tianjin&quot;/&gt; &lt;entry key=&quot;city&quot; value=&quot;baodi&quot;/&gt; &lt;/map&gt; &lt;/property&gt; &lt;property name=&quot;properties&quot;&gt; &lt;props&gt; &lt;prop key=&quot;county&quot;&gt;china&lt;/prop&gt; &lt;prop key=&quot;province&quot;&gt;tianjin&lt;/prop&gt; &lt;prop key=&quot;city&quot;&gt;baodi&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt; &lt;/bean&gt; 运行主函数： 12345678public class App &#123; public static void main(String[] args) &#123; ClassPathXmlApplicationContext ac = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); BookDao bookDao = (BookDao) ac.getBean(&quot;bookDao&quot;); bookDao.save(); &#125;&#125; 1234567运行结果：BookDaoImpl&#123;array=[100, 200, 300], list=[唱, 跳, Rap], set=[唱, 跳, Rap], map=&#123;county=china, province=tianjin, city=baodi&#125;, properties=&#123;province=tianjin, city=baodi, county=china&#125;&#125; 12.数据源对象管理在pom.xml导入druid坐标 12345678910&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.2.8&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8.0.28&lt;/version&gt;&lt;/dependency&gt; 配置文件中，管理DruidDataSouurce对象 123456&lt;bean id=&quot;dataSource&quot; class=&quot;com.alibaba.druid.pool.DruidDataSource&quot;&gt; &lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/demo&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;123456&quot;/&gt;&lt;/bean&gt; 运行主函数： 12345678910public class App &#123; public static void main(String[] args) &#123; //获取ICO容器 ClassPathXmlApplicationContext ac = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); DataSource dataSource = (DataSource) ac.getBean(&quot;dataSource&quot;); System.out.println(dataSource); &#125;&#125; 123456789101112运行结果：&#123; CreateTime:&quot;2022-06-24 22:27:03&quot;, ActiveCount:0, PoolingCount:0, CreateCount:0, DestroyCount:0, CloseCount:0, ConnectCount:0, Connections:[ ]&#125; 13.加载properties配置信息在rescource资源包中创建jdbc.properties文件： 1234567jdbc.driver=com.mysql.jdbc.Driverjdbc.url=jdbc:mysql://localhost:3306/demojdbc.username=rootjdbc.password=123456username=dahuangage=18 配置文件中: 在beans标签中开启context命名空间 使用context空间加载properties文件 12345678910111213141516171819202122232425262728293031&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot; http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt; &lt;!-- 1.开启context命名空间 --&gt; &lt;!-- 2.使用context空间加载properties文件 --&gt; &lt;context:property-placeholder location=&quot;jdbc.properties&quot; system-properties-mode=&quot;NEVER&quot;/&gt; &lt;bean id=&quot;dataSource&quot; class=&quot;com.alibaba.druid.pool.DruidDataSource&quot;&gt; &lt;!-- 使用占位符$&#123;&#125;读取properties中的属性 --&gt; &lt;property name=&quot;driverClassName&quot; value=&quot;$&#123;jdbc.driver&#125;&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;$&#123;jdbc.url&#125;&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;$&#123;jdbc.username&#125;&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot;/&gt; &lt;/bean&gt; &lt;bean id=&quot;bookDao&quot; class=&quot;com.spring.dao.impl.BookDaoImpl&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;$&#123;username&#125;&quot;/&gt; &lt;property name=&quot;age&quot; value=&quot;$&#123;age&#125;&quot;/&gt; &lt;/bean&gt;&lt;/beans&gt; 加载properties文件格式： 不加载系统属性： 12&lt;context:property-placeholder location=&quot;jdbc.properties&quot; system-properties-mode=&quot;NEVER&quot;/&gt; 加载多个properties文件： 1&lt;context:property-placeholder location=&quot;jdbc.properties, jdbc2.properties&quot;/&gt; 加载所有properties文件： 1&lt;context:property-placeholder location=&quot;*.properties&quot;/&gt; 加载properties文件标准格式： 1&lt;context:property-placeholder location=&quot;classpath:*.properties&quot;/&gt; 从类路径或jar包中搜索加载properties文件： 1&lt;context:property-placeholder location=&quot;classpath*:*.properties&quot;/&gt; 14.容器14.1 创建容器的几种方式 类路径下的加载配置文件 1ApplicationContext ac = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); 文件系统下加载的配置文件 1ApplicationContext ac = new ClassPathXmlApplicationContext(&quot;E:\\Java_Web\\Spring\\spring_01_IOC\\src\\main\\resources\\applicationContext.xml&quot;); 加载多个配置文件： 1ApplicationContext ac = new ClassPathXmlApplicationContext(&quot;applicationContext1.xml&quot;,&quot;applicationContext2.xml&quot;); 14.2 获取bean的几种方式 使用bean名称获取 1BookDao bookDao = (BookDao) ac.getBean(&quot;bookDao&quot;); 使用bean名称获取并指定类型 1BookDao bookDao = ac.getBean(&quot;bookDao&quot;,BookDao.class); 使用bean类型获取 1BookDao bookDao = ac.getBean(BookDao.class);//对应的容器中只能有一个该类型，唯一 14.3 容器类层次结构使用ctrl+H打开容器类的层次结构图： BeanFactory：是IOC容器的顶层接口，初始化BeanFactory对象时，加载的bean延迟加载 ApplicationContext：是Spring容器的核心接口，初始化时bean立即加载 ​ 提供基础的bean操作相关的方法，通过其他接口扩展其功能 ConfigurableApplicationContext：提供关闭容器功能 ClassPathXmlApplicationContext：常用实现类 14.4 BeanFactory初始化类路径加载配置文件： 12345678public class App &#123; public static void main(String[] args) &#123; Rescoure rescoure = new ClassPathRescoure(&quot;applicationContext.xml&quot;); BeanFactory bf = new XmlBeanFactory(rescoure); BookDao bookDao = bf.getBean(&quot;bookDao&quot;,BookDao.class); bookDao.save(); &#125;&#125; BeanFactory创建完毕后，所有bean均为延迟加载 15.注解开发*15.1 用注释定义bean123456@component(&quot;bookDao&quot;) //等价于&lt;bean id=&quot;bookDao&quot; class=&quot;com.spring.dao.impl.BookDaoImpl&quot;/&gt;public class BookDaoImpl implements BookDao &#123; public void save() &#123; System.out.println(&quot;BookDao~~~~~&quot;); &#125;&#125; 123456@Component //没有写bean名，要通过类型获取beanpublic class BookServiceImpl implements BookService &#123; public void save() &#123; System.out.println(&quot;BookService~~~~&quot;); &#125;&#125; 但是，Spring怎么感知到注释呢？ 配置文件中，需要添加扫描组件： 123456789101112&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot; http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt; &lt;!-- 扫描@component组件 --&gt; &lt;!-- base-package为扫描的位置 --&gt; &lt;context:component-scan base-package=&quot;com.spring&quot;/&gt;&lt;/beans&gt; 主函数： 123456789101112public class App &#123; public static void main(String[] args) &#123; //获取ICO容器 ClassPathXmlApplicationContext ac = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); //获取bean BookDao bookDao = (BookDao) ac.getBean(&quot;bookDao&quot;); bookDao.save(); //因为@component，并没有写bean名，所以要用类型获取bean BookService bookService = ac.getBean(BookService.class); bookService.save(); &#125;&#125; 123运行结果：BookDao~~~~~BookService~~~~ Spring提供@component注解的三个衍生注解 @Repository：用于数据层bean定义(Dao层) ​ 也可以加括号来指定bean名，如：@Repository(“bookDao2”) @Service：用于业务层bean定义(Service层) @Controller：用于表现层bean定义(Controller层) @Service,@Repository不能写在接口上,需要写在接口的实现类上 1234@Repositorypublic class BookDaoImpl implements BookDao &#123; &#125; 1234@Servicepublic class BookServiceImpl implements BookService &#123;&#125; 1234@Controllerpublic class BookController &#123;&#125; 15.2 纯注释开发新建一个SpringConfig类，用来替代配置文件。 其位置：com.spring.config.SpringConfig.java com包 spring包 config包 SpringConfig.java @Configuration ：用于设定当前类为配置类@ComponentScan(&quot;com.spring&quot;) ：用用于设定扫描路径，此注释只能添加一次，多个数据用数组格式 123456//用来替代 &lt;context:component-scan base-package=&quot;com.spring&quot;/&gt;@Configuration //用于设定当前类为配置类@ComponentScan(&quot;com.spring&quot;) //用用于设定扫描路径，此注释只能添加一次，多个数据用数组格式public class SpringConfig &#123; &#125; 主函数： 1234567891011public class AppForAnnotation &#123; public static void main(String[] args) &#123; //改用注释配置初始化容器 ApplicationContext ac = new AnnotationConfigApplicationContext(SpringConfig.class); BookDao bookDao = ac.getBean(BookDao.class); bookDao.save(); BookService bookService = ac.getBean(BookService.class); bookService.save(); &#125;&#125; 123运行结果：BookDao~~~~~BookService~~~~ 15.3 bean管理 作用范围 @Scope(&quot;singleton&quot;)：单例，默认单例 @Scope(&quot;prototype&quot;)：多例 bean生命周期控制 @PostConstruct注解：init @PreDestroy注解：destory 123456789101112@Repository@Scope(&quot;prototype&quot;) //多例public class BookDaoImpl implements BookDao &#123; @PostConstruct public void init()&#123; System.out.println(&quot;init~~~&quot;); &#125; @PreDestroy public void destroy()&#123; System.out.println(&quot;destroy~~~&quot;); &#125;&#125; 15.4 依赖注入1.引用类型 1234567891011@Servicepublic class BookServiceImpl implements BookService &#123; @Autowired private BookDao bookDao; public void save() &#123; System.out.println(&quot;BookService~~~~&quot;); bookDao.save(); &#125;&#125; 主函数： 12345678public class AppForAnnotation &#123; public static void main(String[] args) &#123; ApplicationContext ac = new AnnotationConfigApplicationContext(SpringConfig.class); BookService bookService = ac.getBean(BookService.class); bookService.save(); &#125;&#125; 123运行结果：BookService~~~~ //在创建好BookService的bean,并注入BookDaoBookDao~~~~~ //调用BookDao的方法save(); 当有多个同类型的bean，使用@Qualifier(&quot;bookDao2&quot;)来指定bean名 并且需要@Autowired和@Qualifier(&quot;bookDao2&quot;)一起使用 1234567891011@Servicepublic class BookServiceImpl implements BookService &#123; @Autowired @Qualifier(&quot;bookDao2&quot;) private BookDao bookDao; public void save() &#123; System.out.println(&quot;BookService~~~~&quot;); bookDao.save(); &#125;&#125; 注意： 自动装配基于反射设计创建对象并暴力反射对应属性为私有属性初始化数据，无需提供setter方法 自动装配建议使用无参构造方法创建对象，如果不提供对应的构造方法，请提供唯一的构造方法 @Qualifier注解无法单独使用，必须配合@Autowired注解使用 2.简单类型 123456789@Repositorypublic class BookDaoImpl implements BookDao &#123; @Value(&quot;dahuang&quot;) private String name; public void save()&#123; System.out.println(&quot;BookDao~~~~~&quot;+&quot;姓名：&quot;+name); &#125;&#125; 主函数： 1234567public class AppForAnnotation &#123; public static void main(String[] args) &#123; ApplicationContext ac = new AnnotationConfigApplicationContext(SpringConfig.class); BookDao bookDao = ac.getBean(BookDao.class); bookDao.save(); &#125;&#125; 12运行结果：BookDao~~~~~姓名：dahaung 但是，我们为什么不直接赋值，为什么要用@Value注解呢？ 我们可以用properties文件，向其传值。 3.读取properties文件 通过创建一个jdbc.properties文件： 1name=dahei 在配置类中新加注解@PropertySource()，括号中指定文件名： 如：@PropertySource(&quot;jdbc.properties&quot;)或者@PropertySource(&quot;classpath:jdbc.properties&quot;) 也可以指定多个文件： 如：@PropertySource(&#123;&quot;jdbc.properties&quot;,&quot;jdbc1.properties&quot;,&quot;jdbc2.properties&quot;&#125;) 12345@Configuration@ComponentScan(&quot;com.spring&quot;)@PropertySource(&quot;jdbc.properties&quot;)public class SpringConfig &#123;&#125; 在BookDaoImpl中将注解改为：@Value(&quot;$&#123;&#125;&quot;)，在&#123;&#125;中填入properties文件中的属性 如：@Value(&quot;$&#123;name&#125;&quot;) 123456789@Repositorypublic class BookDaoImpl implements BookDao &#123; @Value(&quot;$&#123;name&#125;&quot;) private String name; public void save()&#123; System.out.println(&quot;BookDao~~~~~&quot;+&quot;姓名：&quot;+name); &#125;&#125; 15.5 第三方bean管理1.使用独立的配置管理第三方bean 12345678910111213@Configurationpublic class SpringConfig &#123; //定义一个方法获得想要管理的bean @Bean // 表示当前方法返回值是一个bean public DataSource dataSource()&#123; //相关配置 ds.setDriverClassName(&quot;com.mysql.jdbc.Driver&quot;); ds.setUrl(&quot;jdbc:mysql://localhost:3306/demo&quot;); ds.getUsername(&quot;root&quot;); ds.setPassword(&quot;123456&quot;); return ds; &#125;&#125; 但是不建议将独立配置直接写在核心配置类中： 方法一：导入式(建议使用) 在config包创建一个JdbcConfig.java配置类： 12345678910111213public class JdbcConfig &#123; //定义一个方法获得想要管理的bean @Bean // 表示当前方法返回值是一个bean public DataSource dataSource()&#123; DruidDataSource ds = new DruidDataSource(); //相关配置 ds.setDriverClassName(&quot;com.mysql.jdbc.Driver&quot;); ds.setUrl(&quot;jdbc:mysql://localhost:3306/demo&quot;); ds.setUsername(&quot;root&quot;); ds.setPassword(&quot;123456&quot;); return ds; &#125;&#125; 在SpringConfig.java核心配置类中导入： 使用注解@Import()在括号中添加要导入的配置类的类型 如：@Import(JdbcConfig.class) 此注解只能添加一次，导入多个配置类，可以使用数组格式导入 如：@Import(&#123;JdbcConfig.class, XXXConfig.class, XXXConfig.calss&#125;) 12345@Configuration@Import(JdbcConfig.class)public class SpringConfig &#123; &#125; 方式二：扫描式(不建议使用) 注意：使用扫描式需要在独立的配置类加入注解@Configuration 1234567891011121314@Configurationpublic class JdbcConfig &#123; //定义一个方法获得想要管理的bean @Bean // 表示当前方法返回值是一个bean public DataSource dataSource()&#123; DruidDataSource ds = new DruidDataSource(); //相关配置 ds.setDriverClassName(&quot;com.mysql.jdbc.Driver&quot;); ds.setUrl(&quot;jdbc:mysql://localhost:3306/demo&quot;); ds.setUsername(&quot;root&quot;); ds.setPassword(&quot;123456&quot;); return ds; &#125;&#125; 在SpringConfig.java核心配置类中扫描： 使用注解@ComponentScan()在括号中添加要扫描的路径 如：@@ComponentScan(&quot;com.spring.config&quot;) 扫描多个路径，可以使用数组格式导入 如：@Import(&#123;&quot;com.spring.config&quot;,&quot;com.spring.dao&quot;&#125;) 12345@Configuration@ComponentScan(&quot;com.spring.config&quot;)public class SpringConfig &#123; &#125; 2.第三方bean注入资源 简单类型依赖注入(成员变量)： 利用注解@PropertySource(&quot;jdbc.properties&quot;)和@Import(JdbcConfig.class)导入核心主配置文件中 123456@Configuration@ComponentScan(&quot;com.spring&quot;)@PropertySource(&quot;jdbc.properties&quot;)@Import(JdbcConfig.class)public class SpringConfig &#123;&#125; 利用注解@Value(&quot;$&#123;&#125;&quot;)注入数据 12345678910111213141516171819202122public class JdbcConfig &#123; @Value(&quot;$&#123;jdbc.driver&#125;&quot;) private String driver; @Value(&quot;$&#123;jdbc.url&#125;&quot;) private String url; @Value(&quot;$&#123;jdbc.username&#125;&quot;) private String userName; @Value(&quot;$&#123;jdbc.password&#125;&quot;) private String password; //定义一个方法获得想要管理的bean @Bean // 表示当前方法返回值是一个bean public DataSource dataSource()&#123; DruidDataSource ds = new DruidDataSource(); ds.setDriverClassName(driver); ds.setUrl(url); ds.setUsername(userName); ds.setPassword(password); return ds; &#125;&#125; 引入类型依赖注入(方法形参)： 引用类型注入只需要为bean定义的方法设置形参，容器会根据类型自动装配对象 123456789//定义一个方法获得想要管理的bean @Bean // 表示当前方法返回值是一个bean public DataSource dataSource(BookDao bookDao)&#123; System.out.println(&quot;已引用：&quot;+bookDao); DruidDataSource ds = new DruidDataSource(); //对ds进行相关设置 return ds; &#125; 15.6 总结XML配置与注解配置的比较： 功能 XML配置 注解 定义bean bean标签：&gt;id属性&gt;class属性 @Component &gt;@Controller &gt;@Service &gt;@Repository@ComponentScan 设置依赖注入 setter注入(set方法)&gt;引用&#x2F;简单构造器注入(构造方法)&gt;自动装配 @Autowird&gt;@Qualifier@Value 配置第三方bean bean标签&gt;静态工厂&gt;实例工厂&gt;FactoryBean @Bean 作用范围 scope属性 @Scope 生命周期 标准接口&gt;init-method&gt;destory-method @PostConstructor@PreDestroy 16.AOP16.1 AOP简介 AOP(Aspect Oriented Programming)面向切面编程，一种编程范式，指导开发者如何组织程序结构 OOP(Object Oriented Programing)面向对象编程 作用：在不惊动原始设计的基础上为其进行功能增强 Spring理念：无入侵式&#x2F;无侵入式 执行save()方法 运行结果： 打印出一万次的book dao save … 和消耗的时间 执行update()方法没有图中蓝色区域的代码， 但是，运行结果： 仍会打印打印出一万次的book dao update … 和消耗的时间 连接点(JoinPoint)：程序执行过程中的任意位置，粒度为执行方法，抛出异常，设置变量等(代表所有的方法) 在SpringAOP中，理解方法的执行 切入点(Pointcut)：匹配连接点的式子(代表要追加功能的方法) 在SpringAOP中，一个切入点只描述一个具体方法，也可以匹配多个方法 一个具体方法：com.spring.dao包下的BookDao接口中的五星参无返回值的save()方法 匹配多个方法：所有save方法，所有的get开头的方法，所有以Dao结尾的接口中的任意方法，所有带有一个形参的方法 通知(Advice)：在切入点执行的操作，也就是共性功能(代表追加的功能) 在SpringAOP中，功能最终以方法的形式呈现 通知类：定义通知的类 切面(Aspect)：描述通知与切入的对应关系 16.2 AOP入门 案例设定：测试接口执行效率 简化设定：在接口执行当前输出当前的系统时间 开发模式：XML or 注解(此入门案例采用注解的方式) 思路分析： 导入坐标(pom.xml) 制作连接点方法(原始操作，Dao接口与实现类) 制作共性功能(通知类与通知) 定义切入点 绑定切入点与通知关系(切面) pom.xml： 1234567891011&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;5.3.18&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;version&gt;1.9.9.1&lt;/version&gt;&lt;/dependency&gt; 创建一个MyAdivice.java类 其位置：com.spring.aop.MyAdivice.java @Component注解：定义为Spring加载的bean @Aspect注解：把当前类标识为⼀个切⾯供容器读取 @Pointcut(&quot;execution()&quot;)注解：定义切入点，⽅法签名必须是public及void型。 @Before(&quot;pt()&quot;)注解：标识⼀个前置增强⽅法 切入点pt()的定义依托一个不具有实际意义的方法进行，即无参数、无返回值、方法无实际逻辑 1234567891011@Component@Aspectpublic class MyAdvice &#123; @Pointcut(&quot;execution(void com.spring.dao.BookDao.update())&quot;) private void pt()&#123;&#125; @Before(&quot;pt()&quot;) public void method()&#123; System.out.println(System.currentTimeMillis()); &#125;&#125; @EnableAspectJAutoProxy注解：开启AOP代理自动配置 123456@Configuration@ComponentScan(&quot;com.spring&quot;)@EnableAspectJAutoProxypublic class SpringConfig &#123;&#125; 主函数： 1234567public class App &#123; public static void main(String[] args) &#123; ApplicationContext ac = new AnnotationConfigApplicationContext(SpringConfig.class); BookDao bookDao = ac.getBean(BookDao.class); bookDao.update(); &#125;&#125; 123运行结果：1656341601464book dao update~~~ 16.3 AOP工作流程 Spring容器启动 读取所有切面配置中的切入点 初始化bean，判定bean对应的类中的方法是否匹配到任意切入点 匹配失败，创建对象 获取bean，调用方法并执行，完成操作 匹配成功，调用方法并执行，完成操作 获取的bean是代理对象时，根据代理对象的运行模式运行原始方法与增强内容，完成操作 AOP核心本质：代理模式 目标对象(Target)：原始功能去掉共性功能对应的类产生的对象，这种对象是无法直接完成最终工作的 代理(proxy)：目标对象无法直接完成工作，需要进行功能回填，通过原始对象的代理对象实现 代码依旧是入门案例的 但是将主函数修改，打印bookDao的类型： 12345678public class App &#123; public static void main(String[] args) &#123; ApplicationContext ac = new AnnotationConfigApplicationContext(SpringConfig.class); BookDao bookDao = ac.getBean(BookDao.class); System.out.println(bookDao); System.out.println(bookDao.getClass()); &#125;&#125; 123运行结果：com.spring.dao.impl.BookDaoImpl@d23e042class jdk.proxy2.$Proxy20 System.out.println(bookDao)打印出com.spring.dao.impl.BookDaoImpl@d23e042 是因为AOP对BookDao的toString()方法进行了重写 class jdk.proxy2.$Proxy20：最终用的是代理的对象 16.4 AOP切入点表达式切入点：要进行增强的方法 切入点表达式：要进行增强的方法的描述方法 1.语法格式 切入点标准格式：动作关键字(访问修饰符 返回值 包名.接口/类名.方法(参数) 异常名) 12execution(public User com.spring.service.UserService.findById(int))execution(public User com.spring.service.impl.UserServiceImpl.findById(int)) 动作关键字：描述切入点行为动作，如execution表示执行到指定切入点 访问修饰符：public，private等，可以省略 返回值 包名 接口&#x2F;类名：接口名或者类名都可以 方法名 参数 异常名：方法定义中抛出指定异常，可以省略 2.通配符 可以使用通配符描述切入点，快速描述 *：单个独立的任意符号，可以独立出现，也可以作为前缀或者后缀的匹配符出现 1execution(public * com.spring.*.UserService.find*(*)) 解释：匹配com.spring包下的任意包中含有UserService类或接口中所有含有find开头的带有任意一个参数的方法 ..：多个连续的任意符号，可以独立出现，常用于简化包名与参数的书写 1execution(public User com..UserService.findById(..)) 解释：匹配com包中的任意包中的UserService类或接口中的所有名称为findById的方法 +：专用于匹配子类类型 1execution(* *..*Service+.*(..)) 解释：匹配·任意包下的以Service结尾的类或接口的子类中业务层的所有方法 常用写法 1execution(* com.spring.*.*Service.save(..)) 解释：匹配业务层所有的名为save的方法 3.书写技巧 所有代码按照标准规范开发，否则一下技巧全部失效 描述切入点通常描述接口，而不描述实现类 访问控制修饰符针对接口开发均采用public描述(可省略) 返回值类型对应增删改类使用精准类型加速匹配，对于查询类返回值使用*通配符快速描述 包名书写尽量不使用..匹配，效率过低，常用*做单个包描述匹配，或精准匹配 接口名&#x2F;类名书写名称与模块的采用*匹配 如：UserService书写成*Service，绑定业务层接口名 方法名书写以动词进行精准匹配，名词采用*匹配 如：getById书写成getBy*，selectAll书写成selectAll 参数规则较为复杂，根据业务方法灵活调整 通常不使用异常作为匹配规则 16.5 AOP通知类型AOP通知描述了抽取的共性功能，根据共性功能抽取的位置不同，最终运行代码时要将其加入到合理的位置 AOP通知共分为5钟类型 前置通知 1234567891011@Component@Aspectpublic class MyAdvice &#123; @Pointcut(&quot;execution(void com.spring.dao.BookDao.update())&quot;) private void pt()&#123;&#125; @Before(&quot;pt()&quot;) public void method()&#123; System.out.println(&quot;before~~~&quot;); &#125;&#125; 123运行结果：before~~~book dao update~~~ 后置通知 ​ 1234567891011@Component@Aspectpublic class MyAdvice &#123; @Pointcut(&quot;execution(void com.spring.dao.BookDao.update())&quot;) private void pt()&#123;&#125; @Before(&quot;pt()&quot;) public void method()&#123; System.out.println(&quot;after~~~&quot;); &#125;&#125; 123运行结果：book dao update~~~after~~~ 环绕通知(重点) 1.无返回值 1234567891011121314@Component@Aspectpublic class MyAdvice &#123; @Pointcut(&quot;execution(void com.spring.dao.BookDao.update())&quot;) private void pt()&#123;&#125; @Around(&quot;pt()&quot;) public void method(ProceedingJoinPoint pjp) throws Throwable &#123; System.out.println(&quot;before~~~&quot;); //表示对原始操作的调用 pjp.proceed(); System.out.println(&quot;after~~~&quot;); &#125;&#125; 1234运行结果：before~~~book dao update~~~after~~~ 2.有返回值 在BookDaoImpl中新写一个有返回值的select方法 12345678@Repositorypublic class BookDaoImpl implements BookDao &#123; @Override public int select() &#123; System.out.println(&quot;book dao select~~~&quot;); return 100; &#125;&#125; 123456789101112131415@Component@Aspectpublic class MyAdvice &#123; @Pointcut(&quot;execution(void com.spring.dao.BookDao.select())&quot;) private void pt()&#123;&#125; @Around(&quot;pt()&quot;) public Object method(ProceedingJoinPoint pjp) throws Throwable &#123; System.out.println(&quot;before~~~&quot;); //表示对原始操作的调用，并获得返回值 Object ret = pjp.proceed(); System.out.println(&quot;after~~~&quot;); return ret; &#125;&#125; 主函数： 12345678public class App &#123; public static void main(String[] args) &#123; ApplicationContext ac = new AnnotationConfigApplicationContext(SpringConfig.class); BookDao bookDao = ac.getBean(BookDao.class); int num = bookDao.select(); System.out.println(num); &#125;&#125; 12345运行结果：before~~~book dao select~~~after~~~100 并且有无返回值都建议这样的写法： 1234567@Around(&quot;pt()&quot;) public Object method(ProceedingJoinPoint pjp) throws Throwable &#123; System.out.println(&quot;before~~~&quot;); Object ret = pjp.proceed(); System.out.println(&quot;after~~~&quot;); return ret; &#125; @Around注意事项 环绕通知必须依赖形参ProceedingJoinPoint才能实现对原始方法的调用 ,进而实现原始方法调用前后同时添加通知 通知中如果未使用ProceedingJoinPoint对原始方法进行调用将跳过原始方法的执行 对原始方法的调用可以不接收返回值 ,通知方法设置成void即可, 如果接收返回值, 必须设定为Object类型 原始方法的返回值如果 是void类型,通知方法的返回值类型可以设置成void ,也可以设置成Object 由于无法预知原始方法运行后是否会抛出异常 ,因此环绕通知方法必须抛出Throwable对象 返回后通知(了解) 1234567891011@Component@Aspectpublic class MyAdvice &#123; @Pointcut(&quot;execution(int com.spring.dao.BookDao.select())&quot;) private void pt()&#123;&#125; @AfterReturning(&quot;pt()&quot;) public void method()&#123; System.out.println(&quot;afterReturn~~~&quot;); &#125;&#125; 1234运行结果：book dao select~~~afterReturn~~~100 @after和@AfterReturning的区别： 原始方法有异常时： @after也会打印通知的方法 @AfterReturning不会打印通知的方法 抛出异常后通知(了解) 1234567891011@Component@Aspectpublic class MyAdvice &#123; @Pointcut(&quot;execution(int com.spring.dao.BookDao.select())&quot;) private void pt()&#123;&#125; @AfterThrowing(&quot;pt()&quot;) public void method()&#123; System.out.println(&quot;afterThrowing~~~&quot;); &#125;&#125; 123运行结果：book dao select~~~100 @AfterThrowing注解：只有原始方法抛出异常，才会执行通知的方法 16.6 AOP通知获取数据 获取切入点方法的参数 JoinPoint：适用于前置、后置、返回后、抛出异常后通知 ProceedJointPoint：适用于环绕通知 获取切入点方法返回值 返回后通知 环绕通知 获取切入点方法运行异常信息 抛出异常后通知 环绕通知 123456789@Repositorypublic class BookDaoImpl implements BookDao &#123; @Override public int select(int id, String name) &#123; System.out.println(&quot;book dao select~~~&quot;); System.out.println(&quot;id:&quot;+id+&quot; name:&quot;+name); return 100; &#125;&#125; AOP通知获取参数数据 joinPoint对象描述了连接点方法的运行状态，可以获取到原始方法的调用参数 1234567891011121314@Component@Aspectpublic class MyAdvice &#123; @Pointcut(&quot;execution(int com.spring.dao.BookDao.select(..))&quot;) private void pt()&#123;&#125; @Before(&quot;pt()&quot;) public void method(JoinPoint jp)&#123; Object[] args = jp.getArgs(); System.out.println(Arrays.toString(args)); &#125;&#125; 主函数调用select方法： 1234567public class App &#123; public static void main(String[] args) &#123; ApplicationContext ac = new AnnotationConfigApplicationContext(SpringConfig.class); BookDao bookDao = ac.getBean(BookDao.class); bookDao.select(100, &quot;dahuang&quot;); &#125;&#125; 123运行结果：[100, dahuang]book dao select~~~ ProceedingJoinPoint是JoinPoint的子类 12345678@Around(&quot;pt()&quot;) public Object method(ProceedingJoinPoint pjp) throws Throwable &#123; Object[] args = pjp.getArgs(); System.out.println(Arrays.toString(args)); args[0] = 666; Object ret = pjp.proceed(args); return ret; &#125; 1234运行结果：[100, dahuang]book dao select~~~id:666 name:dahuang AOP通知获取返回数据 抛出异常后通知可以获取切入点方法中出现的异常信息，使用形参可以接收对应的异常对象 1234@AfterReturning(value = &quot;pt()&quot;, returning = &quot;ret&quot;)public void method(JoinPoint jp, int ret)&#123; System.out.println(&quot;afterReturn~~~&quot;+ret);&#125; 环绕通知中可以手工书写对原始方法的调用，得到的结果即为原始方法的返回值 12345@Around(&quot;pt()&quot;) public Object method(ProceedingJoinPoint pjp) throws Throwable &#123; Object ret = pjp.proceed(); return ret; &#125; AOP通知获取异常数据(了解) 抛出异常后通知可以获取切入点方法中出现的异常信息，使用形参可以接收对应的异常对象 1234@AfterThrowing(value = &quot;pt()&quot;, throwing = &quot;t&quot;)public void method(JoinPoint jp, Throwable t)&#123; System.out.println(&quot;afterThrowing~~~&quot;+t);&#125; 抛出异常后通知可以获取切入点方法运行的异常信息，使用形参可以接收运行时抛出的异常对象 1234567891011@Around(&quot;pt()&quot;) public Object method(ProceedingJoinPoint pjp) throws Throwable &#123; Object ret = null; try&#123; ret = pjp.proceed(); &#125; catch(Throwable t)&#123; t.printStackTrace(); &#125; return ret; &#125; 16.7 AOP总结1.基本概念： 概念：AOP(Aspect Oriented Programming) 面向切面编程，一种编程范式 作用：在不惊动原始设计的基础上为方法进行功能增强 核心概念 代理(Proxy)：SpringAOP的核心本质是采用代理模式实现的 连接点(JoinPoint )：在SpringAOP中 ,理解为任意方法的执行 切入点( Pointcut )：匹配连接点的式子,也是具有共性功能的方法描述 通知(Advice)：若干个方法的共性功能,在切入点处执行,最终体现为-一个方法 切面( Aspect )：描述通知与切入点的对应关系 目标对象 ( Target )：被代理的原始对象成为目标对象 2.切入点： 切入点表达式标准格式： 动作关键字(访问修饰符 返回值 包名.类&#x2F;接口名.方法名(参数) 异常名) execution(* com.spring.service.*Service.*(..)) 切入点表达式描述通配符： 作用: 用于快速描述,范围描述 *：匹配任意符号(常用) ..：匹配多个连续的任意符号(常用) +：匹配子类类型 切入点表达式书写技巧 按标准规范开发 查询操作的返回值建议使用*匹配 减少使用..的形式描述包 对接口进行描述,使用*表示模块名,例如UserService的匹配描述为*Service 方法名书写保留动词,例如get ,使用*表示名词,例如getById匹配描述为getBy* 参数根据实际情况灵活调整 3.通知类型： 前置通知 后置通知 环绕通知(重点) 环绕通知依赖形参ProceedingJoinPoint才能实现对原始方法的调用 环绕通知可以隔离原始方法的调用执行 环绕通知返回值设置为0bject类型 环绕通知中可以对原始方法调用过程中出现的异常进行处理 返回后通知 抛出异常后通知 4.通知获取数据： 获取切入点方法的参数 JoinPoint：适用于前置、后置、返回后、抛出异常后通知,设置为方法的第一个形参 ProceedJointPoint：适用于环绕通知 获取切入点方法返回值 返回后通知 . 环绕通知 获取切入点方法运行异常信息 抛出异常后通知 环绕通知 17.Spring事务17.1 Spring事务简介事务作用：在数据层保障一系列的数据库操作同成功同失败 Spring事务作用：在数据层或业务层保障一系列的数据库操作同成功同失败 案例：银行转账 需求:实现任意两个账户间转账操作 需求微缩: A账户减钱, B账户加钱 分析: ①数据层提供基础操作, 指定账户减钱( outMoney ) , 指定账户加钱( inMoney ) ②业务层提供转账操作( transfer ) , 调用减钱与加钱的操作 ③提供2个账号和操作金额执行转账操作 ④基于Spring整合MyBatis环境搭建上述操作 JDK版本：8 项目结构： pom.xml 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;5.2.10.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.1.16&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.5.6&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.47&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;5.2.10.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt; &lt;version&gt;1.3.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;5.2.10.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; com.spring.config包下： JdbcConfig 12345678910111213141516171819202122232425262728public class JdbcConfig &#123; @Value(&quot;$&#123;jdbc.driver&#125;&quot;) private String driver; @Value(&quot;$&#123;jdbc.url&#125;&quot;) private String url; @Value(&quot;$&#123;jdbc.username&#125;&quot;) private String userName; @Value(&quot;$&#123;jdbc.password&#125;&quot;) private String password; @Bean public DataSource dataSource()&#123; DruidDataSource ds = new DruidDataSource(); ds.setDriverClassName(driver); ds.setUrl(url); ds.setUsername(userName); ds.setPassword(password); return ds; &#125; //配置事务管理器，mybatis使用的是jdbc事务 @Bean public PlatformTransactionManager transactionManager(DataSource dataSource)&#123; DataSourceTransactionManager transactionManager = new DataSourceTransactionManager(); transactionManager.setDataSource(dataSource); return transactionManager; &#125;&#125; MybatisConfig 1234567891011121314151617public class MybatisConfig &#123; @Bean public SqlSessionFactoryBean sqlSessionFactory(DataSource dataSource)&#123; SqlSessionFactoryBean ssfb = new SqlSessionFactoryBean(); ssfb.setTypeAliasesPackage(&quot;com.itheima.domain&quot;); ssfb.setDataSource(dataSource); return ssfb; &#125; @Bean public MapperScannerConfigurer mapperScannerConfigurer()&#123; MapperScannerConfigurer msc = new MapperScannerConfigurer(); msc.setBasePackage(&quot;com.itheima.dao&quot;); return msc; &#125;&#125; 核心配置类：SpringConfig 12345678@Configuration@ComponentScan(&quot;com.itheima&quot;)@PropertySource(&quot;classpath:jdbc.properties&quot;)@Import(&#123;JdbcConfig.class,MybatisConfig.class&#125;)//开启注解式事务驱动@EnableTransactionManagementpublic class SpringConfig &#123;&#125; Account 123456789101112131415161718192021222324252627282930313233343536373839public class Account implements Serializable &#123; private Integer id; private String name; private Double money; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public Double getMoney() &#123; return money; &#125; public void setMoney(Double money) &#123; this.money = money; &#125; @Override public String toString() &#123; return &quot;Account&#123;&quot; + &quot;id=&quot; + id + &quot;, name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &quot;, money=&quot; + money + &#x27;&#125;&#x27;; &#125;&#125; com.spring.dao包下： AccountDao 12345678public interface AccountDao &#123; @Update(&quot;update demo.account set money = money + #&#123;money&#125; where name = #&#123;name&#125;&quot;) void inMoney(@Param(&quot;name&quot;) String name, @Param(&quot;money&quot;) Double money); @Update(&quot;update demo.account set money = money - #&#123;money&#125; where name = #&#123;name&#125;&quot;) void outMoney(@Param(&quot;name&quot;) String name, @Param(&quot;money&quot;) Double money);&#125; AccountService 12345public interface AccountService &#123; //配置当前接口方法具有事务 @Transactional public void transfer(String out,String in ,Double money) ;&#125; AccountServiceImpl 12345678910@Servicepublic class AccountServiceImpl implements AccountService &#123; @Autowired private AccountDao accountDao; public void transfer(String out,String in ,Double money) &#123; accountDao.outMoney(out,money); accountDao.inMoney(in,money); &#125;&#125; 测试类：AccountServiceTest 1234567891011@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(classes = SpringConfig.class)public class AccountServiceTest &#123; @Autowired private AccountService accountService; @Test public void testTransfer() throws IOException &#123; accountService.transfer(&quot;Tom&quot;,&quot;Jerry&quot;,100D); &#125;&#125; 17.2 Spring事务角色事务角色 事务管理员：发起事务方，在Spring中通常代指业务层开启事务的方法 事务协调员：加入事务方，在Spring中通常代指数据层方法，也可以是业务层的方法 17.3 Spring事务属性 属性 作用 示例 readOnly 设置是否为只读事务 readOnly&#x3D;true 只读事务 timeout 设置事务超时时间 timeout&#x3D;-1 永不超时 rollbackFor 设置事务回滚异常(class) rollbackFor&#x3D;{NullPointException.class} rollbackForClassName 设置事务回滚异常(String) 同上字符串格式 noRollbackFor 设置事务不回滚异常(class) norollbackFor&#x3D;{NullPointException.class} noRollbackForClassName 设置事务不回滚异常(String) 同上字符串格式 propagation 设置事务传播行为 ….. 12345678910111213@Servicepublic class AccountServiceImpl implements AccountService &#123; @Autowired private AccountDao accountDao; @Override public void transfer(String out, String in, Double money) throws IOException &#123; accountDao.outMoney(out,money); //添加IOException类型错误 if(true) throw new IOException(); accountDao.inMoney(in,money); &#125;&#125; 运行后，报错，outMoney方法执行了，但inMoney方法没有执行 并不是所有错误类型都会回滚 我们希望transfer方法，调用的事务同失败 在@Transactional注解中的属性rollbackFor添加错误的类型 12345public interface AccountService &#123; @Transactional(rollbackFor = &#123;IOException.class&#125;) void transfer(String out, String in, Double money) throws IOException;&#125; 再次运行后，报错，outMoney和inMoney方法都没有执行 案例：转账业务追加日志 需求:实现任意两个账户间转账操作,并对每次转账操作在数据库进行留痕 需求微缩: A账户减钱, B账户加钱,数据库记录日志 分析: ①:基于转账操作案例添加日志模块,实现数据库中记录日志 ②:业务层转账操作( transfer ) ,调用减钱、加钱与记录日志功能 实现效果预期： ​ 无论转账操作是否成功,均进行转账操作的日志留痕 123456789101112131415161718192021@Servicepublic class AccountServiceImpl implements AccountService &#123; @Autowired private AccountDao accountDao; @Autowired private LogService logService; @Override public void transfer(String out, String in, Double money) throws IOException &#123; try&#123; accountDao.outMoney(out,money); int i = 1/0; accountDao.inMoney(in,money); &#125; finally&#123; logService.log(out,in,money); &#125; &#125;&#125; 运行后，outMoney方法和inMoney方法进行回滚，同时log方法也进行了回滚，未将日志记录到数据库中 存在问题： 日志的记录与转账操作隶属同一个事务，同成功同失败 事务传播行为：事务协调员对事物管理员所携带事务的处理态度 在业务层接口添加Spring事务， @Transactional注解中的propagation属性设置事务传播行为REQIRES_NEW(需要新事务) 123456@Servicepublic interface LogService &#123; //设置为新事务 @Transactional(propagation=Propagation.REQIRES_NEW) public void log(String out, String in, Double money);&#125; 运行后，outMoney方法和inMoney方法进行回滚，事务成功。 log方法执行，将日志记录到数据库中 传播属性 事务管理员 事务协调员 REQUIRED(默认) 开启T 加入T 无 新建T2 REQUIRES_NEW 开启T 新建T2 无 新建T2 SUPPORTS 开启T 加入T 无 无 NOT_SUPPORTED 开启T 无 无 无 MANDATORY 开启T 加入T 无 ERROR NEVER 开启T ERROR 无 无 NESTED 设置savePoint，一旦事务回滚，事务将回滚到savePoint处，交由客户端提交/回滚 ​ 18.结语你竟然看完了(不敢相信！！)，真的人会看吗！真的吗！ゞ◎Д◎ヾ 本人也是初学Spring，笔记中如果有什么遗漏或错误的地方欢迎大佬指正（≧∀≦） 本人QQ：2691936018 备注：Spring 另外关于Spring框架，如果有新的内容需要补充，本人也会进行更新的 本笔记的学习视频：黑马2022最新SSM框架 我们SpringMVC见！！(还是不太相信能有人看╮(╯▽╰)╭)","categories":[{"name":"Java","slug":"Java","permalink":"http://example.com/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"},{"name":"框架","slug":"框架","permalink":"http://example.com/tags/%E6%A1%86%E6%9E%B6/"}]},{"title":"(每日LeetCode)剑指 Offer II 091. 粉刷房子","slug":"每日LeetCode/剑指 Offer II 091 粉刷房子","date":"2022-06-25T02:00:00.000Z","updated":"2022-07-02T07:51:12.967Z","comments":true,"path":"2022/06/25/每日LeetCode/剑指 Offer II 091 粉刷房子/","link":"","permalink":"http://example.com/2022/06/25/%E6%AF%8F%E6%97%A5LeetCode/%E5%89%91%E6%8C%87%20Offer%20II%20091%20%E7%B2%89%E5%88%B7%E6%88%BF%E5%AD%90/","excerpt":"","text":"题目：假如有一排房子，共 n 个，每个房子可以被粉刷成红色、蓝色或者绿色这三种颜色中的一种，你需要粉刷所有的房子并且使其相邻的两个房子颜色不能相同。 当然，因为市场上不同颜色油漆的价格不同，所以房子粉刷成不同颜色的花费成本也是不同的。每个房子粉刷成不同颜色的花费是以一个 n x 3 的正整数矩阵 costs来表示的。 例如，costs[0][0] 表示第 0 号房子粉刷成红色的成本花费；costs[1][2] 表示第 1 号房子粉刷成绿色的花费，以此类推。请计算出粉刷完所有房子最少的花费成本。 示例： 输入: costs &#x3D; [[17,2,17],[16,16,5],[14,3,19]]输出: 10解释: 将 0 号房子粉刷成蓝色，1 号房子粉刷成绿色，2 号房子粉刷成蓝色。 最少花费: 2 + 5 + 3 &#x3D; 10。 1.递归代码(cpp)：12345678910111213141516171819202122232425262728293031class Solution &#123;public: int def(vector&lt;vector&lt;int&gt;&gt;&amp; costs, int pos, int n, vector&lt;vector&lt;int&gt;&gt; flag) &#123; //到达最后，没有房子了，退出 if (pos == n) return 0; int ans = INT_MAX; //依次选择三种颜色 for (int i = 0; i &lt; 3; i++) &#123; int temp = INT_MAX; vector&lt;vector&lt;int&gt;&gt; temp_flag(flag); //粉刷第一个房子，无需看前面房子的颜色，因为前面没有房子。 if (pos == 0) &#123; temp_flag[pos][i] = -1; temp = def(costs, pos + 1, n, temp_flag) + costs[pos][i]; &#125; //粉刷墙，要看前面用了什么颜色 else if (flag[pos - 1][i] != -1) &#123; //将这个房子的颜色标记 temp_flag[pos][i] = -1; temp = def(costs, pos + 1, n, temp_flag) + costs[pos][i]; &#125; //选择花费最少的金额 ans = min(ans, temp); &#125; return ans; &#125; int minCost(vector&lt;vector&lt;int&gt;&gt;&amp; costs) &#123; return def(costs, 0, costs.size(), costs); &#125;&#125;; 采用递归的方法，提交后，结果执行超时。 2.动态规划$$Red[pos][0]&#x3D;\\begin{cases}cost[0][0] &amp; pos &#x3D; 0; \\min(Green[pos+1][1],Blue[pos+1][2]) + costs[pos][0] &amp; pos&gt;0\\end{cases} \\$$ $$Green[pos][1]&#x3D;\\begin{cases}cost[0][1] &amp; pos &#x3D; 0; \\min(Red[pos+1][0],Blue[pos+1][2]) + costs[pos][1] &amp; pos&gt;0\\end{cases} \\$$ $$Blue[pos][2]&#x3D;\\begin{cases}cost[0][2] &amp; pos &#x3D; 0; \\min(Red[pos+1][0],Green[pos+1][1]) + costs[pos][2] &amp; pos&gt;0\\end{cases}$$ 画出动态规划图，以示例为例： costs = [[17,2,17],[16,16,5],[14,3,19]] 颜色\\pos 0 1 2 Red(0) 17 18 21 Green(1) 2 33 10 Blue(2) 17 7 37 $$mincost &#x3D; min(dp[2][0],dp[2][1],dp[2][2])$$ 代码(cpp)：123456789101112131415161718192021class Solution &#123;public: int minCost(vector&lt;vector&lt;int&gt;&gt;&amp; costs) &#123; int n = costs.size(); vector&lt;int&gt; red(n, 0); vector&lt;int&gt; blue(n, 0); vector&lt;int&gt; green(n, 0); // 初始化 red[0] = costs[0][0]; blue[0] = costs[0][1]; green[0] = costs[0][2]; for (int i = 1; i &lt; n; ++i) &#123; red[i] = min(blue[i - 1], green[i - 1]) + costs[i][0]; blue[i] = min(red[i - 1], green[i - 1]) + costs[i][1]; green[i] = min(red[i - 1], blue[i - 1]) + costs[i][2]; &#125; return min(red[n - 1], min(blue[n - 1], green[n - 1])); &#125;&#125;; 复杂度分析 时间复杂度：O(n)，其中 n 是房子个数。需要遍历全部房子一次，由于颜色数量固定是三种，因此对于每个房子计算粉刷房子的最小花费成本的时间是 O(1)，总时间复杂度是 O(n)。 空间复杂度：O(1)。使用空间优化的方法，只需要维护一个长度为 3 的数组，空间复杂度是 O(1)。","categories":[{"name":"每日LeetCode","slug":"每日LeetCode","permalink":"http://example.com/categories/%E6%AF%8F%E6%97%A5LeetCode/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"},{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"(每日LeetCode)515. 在每个树行中找最大值(中等)","slug":"每日LeetCode/515 在每个树行中找最大值","date":"2022-06-24T01:04:00.000Z","updated":"2022-07-02T07:51:43.654Z","comments":true,"path":"2022/06/24/每日LeetCode/515 在每个树行中找最大值/","link":"","permalink":"http://example.com/2022/06/24/%E6%AF%8F%E6%97%A5LeetCode/515%20%E5%9C%A8%E6%AF%8F%E4%B8%AA%E6%A0%91%E8%A1%8C%E4%B8%AD%E6%89%BE%E6%9C%80%E5%A4%A7%E5%80%BC/","excerpt":"","text":"题目：给定一棵二叉树的根节点 root ，请找出该二叉树中每一层的最大值。 示例： 输入: root &#x3D; [1,3,2,5,3,null,9]输出: [1,3,9] 思路：深度优先搜索我们采用树的先序遍历，来进行深度优先搜索，并用pos来记录当前树的高度，就可以通过pos高度来判断是否在同一层，并且是否更新此高度的最大值。 代码(cpp)：123456789101112131415161718192021222324252627class Solution &#123;public: void dfs(TreeNode* root, vector&lt;int&gt;&amp; result, int pos)&#123; //如果该结点为空，则退出 if(root == nullptr) return; if(result.size() == pos)&#123; //数组的大小小于高度，大小需要加1 result.push_back(root-&gt;val); &#125; else&#123; //判断该层的某个结点，与之前记录的比较大小 result[pos] = max(result[pos], root-&gt;val); &#125; //遍历左子树，高度+1 dfs(root-&gt;left, result, pos+1); //遍历右子树，高度+1 dfs(root-&gt;right, result, pos+1); &#125; vector&lt;int&gt; largestValues(TreeNode* root) &#123; vector&lt;int&gt; result; dfs(root, result, 0); return result; &#125;&#125;; 复杂度分析 时间复杂度：O(n)，其中 n 为二叉树节点个数。二叉树的遍历中每个节点会被访问一次且只会被访问一次。 空间复杂度：O(pos)。其中 pos 表示二叉树的高度。递归函数需要栈空间，而栈空间取决于递归的深度，因此空间复杂度等价于二叉树的高度。","categories":[{"name":"每日LeetCode","slug":"每日LeetCode","permalink":"http://example.com/categories/%E6%AF%8F%E6%97%A5LeetCode/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"},{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"(每日LeetCode)30. 串联所有单词的子串","slug":"每日LeetCode/30 串联所有单词的子串","date":"2022-06-23T03:53:00.000Z","updated":"2022-07-02T07:51:20.938Z","comments":true,"path":"2022/06/23/每日LeetCode/30 串联所有单词的子串/","link":"","permalink":"http://example.com/2022/06/23/%E6%AF%8F%E6%97%A5LeetCode/30%20%E4%B8%B2%E8%81%94%E6%89%80%E6%9C%89%E5%8D%95%E8%AF%8D%E7%9A%84%E5%AD%90%E4%B8%B2/","excerpt":"","text":"题目：给定一个字符串s和一些长度相同的单词words。找出s中恰好可以由words中所有单词串联形成的子串的起始位置。 注意子串要与words中的单词完全匹配，中间不能有其他字符，但不需要考虑words中单词串联的顺序。 示例： 输入：s &#x3D; “barfoofoobarthefoobarman”, words &#x3D; [“bar”,”foo”,”the”]输出：[6,9,12] 输出返回字串的第一个字符在s中的位置 第一个字串：barfoofoobarthefoobarman 6 第二个字串：barfoofoobarthefoobarman 9 第三个字符：barfoofoobarthefoobarman 12 思路：滑动窗口 word_len为每个单词的长度，因为每个单词的长度都相同； word_num为words数组中单词的个数； total_len为words数组中所有的单词的总长度； map来记录words数组中每个单词的个数； t_map遍历s时用来记录； 左指针left和右指针right用来当作左右边界； count用来统计已经匹配单词的个数，如果count == word_num，就证明匹配成功； 遍历s时无需一个一个字符的遍历，可以一个一个单词的遍历，right += word_len； 如果截取的单词map中不存在，则之前记录的全部无效，清空t_map和count； 如果某个单词在t_map中的个数大于map中的个数，就需要删除匹配的多余的单词，就需要删除窗口中第一个单词，直到某个单词出现的次数小于map中的个数 代码(cpp)：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364class Solution &#123;public: vector&lt;int&gt; findSubstring(string s, vector&lt;string&gt;&amp; words) &#123; //用来存放结果 vector&lt;int&gt; result; //判断s和words是否为空，如果其中有一个为空，则返回空数组 if(s.empty()||words.empty())&#123; return result; &#125; int word_len = words[0].size(); //一个单词的长度（每个单词长度都相同） int word_num = words.size(); // 单词的总个数 int total_len = word_len*word_num; // 全部单词的长度 //建立单词-&gt;单词个数的映射 unordered_map&lt;string, int&gt; map; //统计每个单词的个数 for(auto &amp;word : words)&#123; //map[key]:返回key值所对应的value值，如果不存在key值，则会使用该key值向当前容器中插入一个新value值为 0 map[word]++; //等价于 map[word] += 1 &#125; for(int i = 0; i&lt; word_len; i++)&#123; //left和right用来表示窗口的左右边界 int left = i; int right = i; //count用来统计已经匹配的单词个数 int count = 0; unordered_map&lt;string, int&gt; t_map; //开始滑动窗口 //right右边界依次累加单词的长度，直到超过s的长度停止循环 while(right + word_len &lt;= s.size())&#123; //substr(pos, n):从第pos的位置开始截取n个字符获取单词 string word = s.substr(right, word_len); right += word_len; //right跳到下一个单词 //count(key):在容器中查找以key键的键值对的个数。如果为0，说明此单词word在words数组中不存在。 if(map.count(word) == 0)&#123; count = 0; //清空之前统计的个数 left = right; //将左指针left移动到右指针right位置上重新开始 t_map.clear(); //之前匹配的单词没用了，清空t_map中的元素 &#125; //如果不为0，说明此单词word在words数组中存在。 else&#123; count++; //统计个数加1 t_map[word]++;// word所对应的个数加1 //t_map中的word对应的个数大于map的word对应的个数，说明匹配到多余的单词了 while(t_map[word]&gt; map[word])&#123; //获取窗口的第一个单词 string t_word = s.substr(left, word_len); //将t_word这个单词对应的个数减1 //并非是那个大于map中个数的单词 t_map[t_word]--; count--; //统计个数减1 left += word_len;//将左指针跳到下一个 &#125; //如果count等于单词的个数说明匹配成功，将左指针位置记录 if(count == word_num)&#123; result.push_back(left); &#125; &#125; &#125; &#125; return result; &#125;&#125;; 复杂度分析 时间复杂度：O(ls×n)，其中 ls 是输入 s 的长度，n 是 words 中每个单词的长度。需要做 n 次滑动窗口，每次需要遍历一次 s。","categories":[{"name":"每日LeetCode","slug":"每日LeetCode","permalink":"http://example.com/categories/%E6%AF%8F%E6%97%A5LeetCode/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"},{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"(每日LeetCode)513. 找树左下角的值","slug":"每日LeetCode/513 找树左下角的值","date":"2022-06-22T03:11:00.000Z","updated":"2022-07-02T07:51:35.945Z","comments":true,"path":"2022/06/22/每日LeetCode/513 找树左下角的值/","link":"","permalink":"http://example.com/2022/06/22/%E6%AF%8F%E6%97%A5LeetCode/513%20%E6%89%BE%E6%A0%91%E5%B7%A6%E4%B8%8B%E8%A7%92%E7%9A%84%E5%80%BC/","excerpt":"","text":"题目：给定一个二叉树的 根节点 root，请找出该二叉树的 最底层 最左边 节点的值。 假设二叉树中至少有一个节点。 示例: 输入: [1,2,3,4,null,5,6,null,null,7]输出: 7 思路：深度优先搜索(DFS)我采用了优先遍历左节点，再遍历右节点，因为只有优先遍历左节点，才会优先记录当前深度左节点的值，所以就没有必要记录当前深度右边的值了。 使用depth记录当前树的深度，current_val为记录的深度current_depth的最左边的值。 进行判断如果depth的深度大于current_depth的深度，将current_val的值设置为当前结点的值，并将current_depth的值设置当前结点深度depth 代码(cpp)：1234567891011121314151617181920212223242526272829class Solution &#123;public: void dfs(TreeNode* root, int depth, int&amp; current_depth, int&amp; current_val) &#123; if (root == nullptr) //如果当前结点为空，则退出 &#123; return; &#125; //优先遍历左节点，深度加1 dfs(root-&gt;left, depth+1, current_depth, current_val); //其次遍历右节点，深度加1 dfs(root-&gt;right, depth+1, current_depth, current_val); //如果当前深度大于记录的深度 if (depth &gt; current_depth) &#123; current_depth = depth; //将当前深度记录到current_depth current_val = root-&gt;val; //将当前结点值记录到current_val &#125; &#125; int findBottomLeftValue(TreeNode* root) &#123; int current_depth = 0; //初始化current_depth int current_val = 0; //初始化current_val //因为有根结点存在，将depth设置为1，而非0 dfs(root, 1, current_depth, current_val); return current_val; &#125;&#125;; 复杂度分析 ​ 时间复杂度：O(n)，其中 n 是二叉树的节点数目。需要遍历 n 个节点。 ​ 空间复杂度：O(n)。递归栈需要占用 O(n) 的空间。","categories":[{"name":"每日LeetCode","slug":"每日LeetCode","permalink":"http://example.com/categories/%E6%AF%8F%E6%97%A5LeetCode/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"},{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]}],"categories":[{"name":"每日LeetCode","slug":"每日LeetCode","permalink":"http://example.com/categories/%E6%AF%8F%E6%97%A5LeetCode/"},{"name":"C++","slug":"C","permalink":"http://example.com/categories/C/"},{"name":"Java","slug":"Java","permalink":"http://example.com/categories/Java/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"},{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"},{"name":"容器","slug":"容器","permalink":"http://example.com/tags/%E5%AE%B9%E5%99%A8/"},{"name":"STL","slug":"STL","permalink":"http://example.com/tags/STL/"},{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"},{"name":"框架","slug":"框架","permalink":"http://example.com/tags/%E6%A1%86%E6%9E%B6/"}]}